        console.log('ğŸš€ Solar Explorer v2.1 ë¡œë“œë¨');
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        
        window.THREE = THREE;  // â˜… ë§ì›ê²½ ëª¨ë“œì—ì„œ ì‚¬ìš©
        window.GLTFLoader = GLTFLoader;  // â˜… ë©€í‹°í”Œë ˆì´ì–´ì—ì„œ ì‚¬ìš©
        window.DRACOLoader = DRACOLoader;  // â˜… Draco ì••ì¶• ëª¨ë¸ ì§€ì›
        window.CSS2DObject = CSS2DObject;  // â˜… ë©€í‹°í”Œë ˆì´ì–´ ë‹‰ë„¤ì„ ë¼ë²¨
        
        // â˜…â˜…â˜… ì‹œë„¤ë§ˆí‹± ì¸íŠ¸ë¡œ ì‹œìŠ¤í…œ â˜…â˜…â˜…
        (function initIntro() {
            const canvas = document.getElementById('intro-canvas');
            const overlay = document.getElementById('intro-overlay');
            
            if (!canvas || !overlay) return;
            
            // DOM ìš”ì†Œë“¤
            const letterboxTop = document.querySelector('.letterbox-top');
            const letterboxBottom = document.querySelector('.letterbox-bottom');
            const lensFlare = document.getElementById('lens-flare');
            const studioLogo = document.getElementById('studio-logo');
            const mainTitle = document.getElementById('main-title');
            const titleChars = document.querySelectorAll('.title-text .char');
            const titleLines = document.querySelectorAll('.title-line');
            const titleTagline = document.querySelector('.title-tagline');
            const loader = document.getElementById('intro-loader');
            const loaderProgress = document.querySelector('.loader-progress');
            const percentText = document.getElementById('intro-percent');
            const startDiv = document.getElementById('intro-start');
            const startBtn = document.getElementById('intro-start-btn');
            const skipBtn = document.getElementById('intro-skip');
            
            // Three.js ì„¤ì •
            const introScene = new THREE.Scene();
            const introCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 3000);
            const introRenderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
            introRenderer.setSize(window.innerWidth, window.innerHeight);
            introRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            introCamera.position.z = 500;
            
            // ë³„ í•„ë“œ (ì€í•˜ìˆ˜ ëŠë‚Œ)
            const starCount = 5000;
            const starGeometry = new THREE.BufferGeometry();
            const starPositions = new Float32Array(starCount * 3);
            const starColors = new Float32Array(starCount * 3);
            
            for (let i = 0; i < starCount; i++) {
                const i3 = i * 3;
                const radius = Math.random() * 1500 + 100;
                const theta = Math.random() * Math.PI * 2;
                const phi = (Math.random() - 0.5) * Math.PI * 0.5;
                
                starPositions[i3] = radius * Math.cos(theta) * Math.cos(phi);
                starPositions[i3 + 1] = radius * Math.sin(phi) * 0.3;
                starPositions[i3 + 2] = radius * Math.sin(theta) * Math.cos(phi);
                
                const brightness = Math.random() * 0.5 + 0.5;
                const colorType = Math.random();
                if (colorType < 0.6) {
                    starColors[i3] = brightness;
                    starColors[i3 + 1] = brightness;
                    starColors[i3 + 2] = brightness;
                } else if (colorType < 0.8) {
                    starColors[i3] = brightness * 0.7;
                    starColors[i3 + 1] = brightness * 0.85;
                    starColors[i3 + 2] = brightness;
                } else {
                    starColors[i3] = brightness;
                    starColors[i3 + 1] = brightness * 0.8;
                    starColors[i3 + 2] = brightness * 0.6;
                }
            }
            
            starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
            starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
            
            const starMaterial = new THREE.PointsMaterial({
                size: 2,
                vertexColors: true,
                transparent: true,
                opacity: 0,
                blending: THREE.AdditiveBlending
            });
            
            const stars = new THREE.Points(starGeometry, starMaterial);
            introScene.add(stars);
            
            // ì„±ìš´ íš¨ê³¼ (ë°°ê²½)
            const nebulaTexture = createNebulaTexture();
            const nebulaMaterial = new THREE.SpriteMaterial({
                map: nebulaTexture,
                transparent: true,
                opacity: 0,
                blending: THREE.AdditiveBlending
            });
            const nebula = new THREE.Sprite(nebulaMaterial);
            nebula.scale.set(2000, 1000, 1);
            nebula.position.z = -800;
            introScene.add(nebula);
            
            function createNebulaTexture() {
                const size = 512;
                const canvas2d = document.createElement('canvas');
                canvas2d.width = size;
                canvas2d.height = size;
                const ctx = canvas2d.getContext('2d');
                
                const gradient = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
                gradient.addColorStop(0, 'rgba(0, 100, 150, 0.3)');
                gradient.addColorStop(0.3, 'rgba(50, 0, 100, 0.2)');
                gradient.addColorStop(0.6, 'rgba(0, 50, 80, 0.1)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, size, size);
                
                return new THREE.CanvasTexture(canvas2d);
            }
            
            // ìƒíƒœ ë³€ìˆ˜
            let phase = 0;
            let time = 0;
            let progress = 0;
            let introComplete = false;
            let charIndex = 0;
            let cameraTargetZ = 500;
            
            // ì‹œë„¤ë§ˆí‹± ì‹œí€€ìŠ¤
            const sequence = [
                { time: 0, action: 'fadeInStars' },
                { time: 1, action: 'showLetterbox' },
                { time: 1.5, action: 'showStudioLogo' },
                { time: 4, action: 'hideStudioLogo' },
                { time: 5, action: 'showMainTitle' },
                { time: 5.5, action: 'typeTitle' },
                { time: 8, action: 'showLoader' },
                { time: 8, action: 'startLoading' }
            ];
            
            let currentSequenceIndex = 0;
            
            // ì¸íŠ¸ë¡œ ì‚¬ìš´ë“œ
            function playWhoosh() {
                try {
                    const ctx = new (window.AudioContext || window.webkitAudioContext)();
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(200, ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(50, ctx.currentTime + 0.5);
                    gain.gain.setValueAtTime(0.1, ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.5);
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.start();
                    osc.stop(ctx.currentTime + 0.5);
                } catch(e) {}
            }
            
            // ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„
            function animate() {
                if (introComplete) return;
                requestAnimationFrame(animate);
                
                time += 0.016;
                
                // ì‹œí€€ìŠ¤ ì‹¤í–‰
                while (currentSequenceIndex < sequence.length && time >= sequence[currentSequenceIndex].time) {
                    executeAction(sequence[currentSequenceIndex].action);
                    currentSequenceIndex++;
                }
                
                // ë³„ íšŒì „ & í˜ì´ë“œ
                stars.rotation.y += 0.0003;
                stars.rotation.x = Math.sin(time * 0.1) * 0.02;
                
                // ì¹´ë©”ë¼ ë¶€ë“œëŸ¬ìš´ ì´ë™
                introCamera.position.z += (cameraTargetZ - introCamera.position.z) * 0.02;
                
                // ì„±ìš´ ì›€ì§ì„
                nebula.position.x = Math.sin(time * 0.1) * 50;
                nebula.position.y = Math.cos(time * 0.15) * 30;
                
                introRenderer.render(introScene, introCamera);
            }
            
            function executeAction(action) {
                switch(action) {
                    case 'fadeInStars':
                        gsapTo(starMaterial, 'opacity', 1, 2);
                        gsapTo(nebulaMaterial, 'opacity', 0.5, 3);
                        break;
                    case 'showLetterbox':
                        letterboxTop.classList.add('active');
                        letterboxBottom.classList.add('active');
                        lensFlare.classList.add('active');
                        break;
                    case 'showStudioLogo':
                        studioLogo.classList.add('visible');
                        playWhoosh();
                        break;
                    case 'hideStudioLogo':
                        studioLogo.classList.add('fadeout');
                        cameraTargetZ = 300;
                        break;
                    case 'showMainTitle':
                        mainTitle.classList.add('visible');
                        titleLines.forEach(line => line.classList.add('expand'));
                        playWhoosh();
                        break;
                    case 'typeTitle':
                        typeNextChar();
                        break;
                    case 'showLoader':
                        loader.classList.add('visible');
                        break;
                    case 'startLoading':
                        startLoadingAnimation();
                        break;
                }
            }
            
            // ê°„ë‹¨í•œ íŠ¸ìœˆ í•¨ìˆ˜
            function gsapTo(obj, prop, target, duration) {
                const start = obj[prop];
                const startTime = time;
                function update() {
                    if (introComplete) return;
                    const elapsed = time - startTime;
                    const t = Math.min(elapsed / duration, 1);
                    obj[prop] = start + (target - start) * easeOutCubic(t);
                    if (t < 1) requestAnimationFrame(update);
                }
                update();
            }
            
            function easeOutCubic(t) {
                return 1 - Math.pow(1 - t, 3);
            }
            
            // íƒ€ì´í•‘ íš¨ê³¼
            function typeNextChar() {
                if (charIndex < titleChars.length) {
                    titleChars[charIndex].classList.add('visible');
                    charIndex++;
                    setTimeout(typeNextChar, 80);
                } else {
                    titleTagline.classList.add('visible');
                }
            }
            
            // ë¡œë”© ì• ë‹ˆë©”ì´ì…˜
            function startLoadingAnimation() {
                function updateProgress() {
                    if (introComplete) return;
                    progress = Math.min(progress + 1.5, 100);
                    const offset = 283 - (283 * progress / 100);
                    loaderProgress.style.strokeDashoffset = offset;
                    percentText.textContent = Math.floor(progress);
                    
                    if (progress >= 100) {
                        loader.style.display = 'none';
                        startDiv.classList.add('visible');
                    } else {
                        setTimeout(updateProgress, 50);
                    }
                }
                updateProgress();
            }
            
            // ì¸íŠ¸ë¡œ ì¢…ë£Œ
            function endIntro() {
                introComplete = true;
                overlay.classList.add('fade-out');
                
                const mainMenu = document.getElementById('mode-select-overlay');
                if (mainMenu) mainMenu.style.display = 'flex';
                
                setTimeout(() => {
                    overlay.style.display = 'none';
                    introRenderer.dispose();
                    starGeometry.dispose();
                    starMaterial.dispose();
                }, 1500);
            }
            
            // ì´ë²¤íŠ¸
            startBtn.addEventListener('click', endIntro);
            startBtn.addEventListener('touchend', (e) => { e.preventDefault(); endIntro(); });
            skipBtn.addEventListener('click', endIntro);
            
            // ë¦¬ì‚¬ì´ì¦ˆ
            window.addEventListener('resize', () => {
                if (introComplete) return;
                introCamera.aspect = window.innerWidth / window.innerHeight;
                introCamera.updateProjectionMatrix();
                introRenderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // SVG ê·¸ë¼ë°ì´ì…˜ ì¶”ê°€
            const svgNS = "http://www.w3.org/2000/svg";
            const defs = document.createElementNS(svgNS, 'defs');
            const gradient = document.createElementNS(svgNS, 'linearGradient');
            gradient.setAttribute('id', 'loader-gradient');
            gradient.innerHTML = '<stop offset="0%" stop-color="#00ffff"/><stop offset="50%" stop-color="#00ff88"/><stop offset="100%" stop-color="#00ffff"/>';
            defs.appendChild(gradient);
            document.querySelector('.loader-ring').appendChild(defs);
            
            // ì‹œì‘
            animate();
        })();

        // ===== ë‹¤êµ­ì–´ ì‹œìŠ¤í…œ =====
        let currentLang = 'en';  // ê¸°ë³¸ ì–¸ì–´: ì˜ì–´
        window.currentLang = currentLang;  // ì „ì—­ìœ¼ë¡œ ë…¸ì¶œ
        
        const translations = {
            ko: {
                // ì„¤ì •
                settings: "âš™ï¸ ì„¤ì •", sound: "ğŸ”Š ì†Œë¦¬", graphics: "ğŸ¨ ê·¸ë˜í”½", language: "ğŸŒ ì–¸ì–´",
                graphicsLow: "ë‚®ìŒ", graphicsMedium: "ì¤‘ê°„", graphicsHigh: "ë†’ìŒ",
                // íƒ‘ë°”
                distExp: "ê±°ë¦¬: ì²´í—˜", distReal: "ê±°ë¦¬: ì‹¤ì œ (50x)",
                station: "ğŸ›°ï¸ ì •ê±°ì¥", catalog: "ğŸ“– ë„ê°", fullscreen: "â›¶ ì „ì²´í™”ë©´", windowMode: "â›¶ ì°½ëª¨ë“œ",
                fine: "ì •ë°€(0~2x)", fast: "ê³ ì†(1~100x)",
                // ë„¤ë¹„ê²Œì´ì…˜
                bodyList: "ì²œì²´ ëª©ë¡", catalogTitle: "ğŸŒŒ ì²œì²´ ë„ê° (í´ë¦­í•˜ì—¬ ìƒì„±)",
                // ìš°ì£¼ì„ 
                boardShip: "ğŸš€ ìš°ì£¼ì„  íƒ‘ìŠ¹", selectShip: "ğŸš€ ìš°ì£¼ì„  ì„ íƒ",
                maxSpeed: "ìµœëŒ€ ì†ë„", accelStat: "ê°€ì†ë ¥", turnRate: "ì„ íšŒë ¥", fuel: "ì—°ë£Œ",
                launch: "ì¶œê²©", cancel: "âœ• ì·¨ì†Œ",
                // ì¡°ì¢…
                accel: "ê°€ì†", reverse: "ì—­ì¶”ì§„", thrust: "ì¶”ì§„", emergencyReverse: "ğŸ”¥<br>ê¸´ê¸‰ì—­ì¶”ì§„",
                auto: "ğŸ¤– ìë™", orbitEntry: "ğŸŒ ê¶¤ë„ì§„ì…", orbitExit: "ğŸŒ ê¶¤ë„ ì´íƒˆ",
                interior: "ğŸšª ì„ ë‚´", emergency: "ğŸ†˜ ê¸´ê¸‰íƒˆì¶œ", disembark: "ğŸŒŒ ìš°ì£¼ ëª¨ë“œ",
                none: "ì—†ìŒ", viewAll: "ğŸ”­ ì „ì²´ ë³´ê¸°", unknown: "ë¯¸ìƒ",
                // ìƒíƒœ
                status: "ìƒíƒœ", statusNominal: "ì •ìƒ", statusAuto: "ìë™ìš´í•­ì¤‘", statusLowFuel: "ì—°ë£Œë¶€ì¡±",
                statusCruising: "ìˆœí•­ì¤‘", statusOrbiting: "ê¶¤ë„ìš´í•­", statusBraking: "ê¸´ê¸‰ì œë™",
                // ê¶¤ë„
                orbitLock: "ğŸŒ ê¶¤ë„ ì¡°ì„ ê³ ì •", stableOrbit: "ì•ˆì • ê¶¤ë„",
                orbitPromptMsg: "ê¶¤ë„ ì¡°ì„ ê³ ì •í•˜ì‹œê² ìŠµë‹ˆê¹Œ?<br>í–‰ì„±ì„ ë°”ë¼ë³´ë©° ìì—°ìŠ¤ëŸ½ê²Œ ê¶¤ë„ë¥¼ ëŒê²Œ ë©ë‹ˆë‹¤.",
                confirmOrbit: "âœ“ ê¶¤ë„ ê³ ì •",
                // ë©”ì‹œì§€
                msgExpMode: "ì²´í—˜ ëª¨ë“œ: ê´€ì°°í•˜ê¸° ì‰¬ìš´ ê±°ë¦¬ì…ë‹ˆë‹¤.",
                msgRealMode: "ì‹¤ì œ ëª¨ë“œ: íƒœì–‘ê³„ ì¶•ì†ŒíŒ! í–‰ì„±ë“¤ì´ ë©€ë¦¬ ë–¨ì–´ì§‘ë‹ˆë‹¤.",
                msgOrbitEntering: "ê¶¤ë„ ì§„ì… ì¤‘... ì„ ë‚´ ì´ë™ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.",
                msgOrbitStable: "ì•ˆì • ê¶¤ë„ ë„ë‹¬!",
                msgOrbitExit: "ê¶¤ë„ ì´íƒˆ! ìˆ˜ë™ ì¡°ì¢…ìœ¼ë¡œ ì „í™˜í•©ë‹ˆë‹¤.",
                msgNeedAuto: "âš ï¸ ìë™í•­ë²• ë˜ëŠ” ê¶¤ë„ ìš´í–‰ ëª¨ë“œì—ì„œë§Œ ì„ ë‚´ë¡œ ì´ë™í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
                // ë¡œê·¸ì¸
                login: "ë¡œê·¸ì¸", register: "íšŒì›ê°€ì…", logout: "ë¡œê·¸ì•„ì›ƒ", username: "ì•„ì´ë””", password: "ë¹„ë°€ë²ˆí˜¸",
                welcome: "í™˜ì˜í•©ë‹ˆë‹¤", guest: "ê²ŒìŠ¤íŠ¸", loginFirst: "ë¨¼ì € ë¡œê·¸ì¸í•˜ì„¸ìš”",
                // ìŠ¤í˜ì´ìŠ¤ì½”ì¸
                spaceCoin: "ìŠ¤í˜ì´ìŠ¤ì½”ì¸", price: "ê°€ê²©", buy: "êµ¬ë§¤", owned: "ë³´ìœ ì¤‘", freeShip: "ê¸°ë³¸ ì§€ê¸‰",
                notEnoughCoins: "ì½”ì¸ì´ ë¶€ì¡±í•©ë‹ˆë‹¤!", alreadyOwned: "ì´ë¯¸ ë³´ìœ  ì¤‘ì…ë‹ˆë‹¤!",
                purchased: "êµ¬ë§¤ ì™„ë£Œ!", reward: "ë³´ìƒ",
                // ë¬´ì¥
                armory: "âš”ï¸ ë¬´ì¥", armorySystem: "âš”ï¸ ë¬´ì¥ ì‹œìŠ¤í…œ",
                // ìš°ì£¼ì„ 
                shipParked: "ìš°ì£¼ì„  ì£¼ì°¨ë¨", reboard: "ì¬íƒ‘ìŠ¹", goToStation: "ì •ê±°ì¥ìœ¼ë¡œ",
                upgradeAtStation: "ì •ê±°ì¥ì—ì„œ ì—…ê·¸ë ˆì´ë“œ",
                // ì²˜ë¶„
                sellShipTitle: "í•¨ì„  ì²˜ë¶„", currentShip: "í˜„ì¬ í•¨ì„ ", sellPrice: "ì²˜ë¶„ ê°€ê²© (50%)",
                sellAndBoard: "ì²˜ë¶„ í›„ íƒ‘ìŠ¹", sellMessage: "ìƒˆ ìš°ì£¼ì„ ì„ íƒ‘ìŠ¹í•˜ë ¤ë©´ ê¸°ì¡´ í•¨ì„ ì„ ì²˜ë¶„í•´ì•¼ í•©ë‹ˆë‹¤.",
                // HUD
                target: "ëª©í‘œ", distance: "ê±°ë¦¬", eta: "ë„ì°©ì˜ˆì •", speed: "ì†ë„",
                // HUD ê²½ê³ 
                lowFuel: "âš ï¸ ì—°ë£Œ ë¶€ì¡±!", escapeBoosterReady: "âš¡ ê¸´ê¸‰íƒˆì¶œ ì¤€ë¹„ë¨",
                collisionWarning: "âš ï¸ ì¶©ëŒ ê²½ê³ !", hullDamage: "âš ï¸ ì„ ì²´ ì†ìƒ!",
                autoDecel: "ğŸ”» ìë™ ê°ì†", emergencyReverseWarn: "ğŸš¨ ê¸´ê¸‰ ì—­ì¶”ì§„!",
                gravityCapture: "âš ï¸ ì¤‘ë ¥ í¬ì°©! íƒˆì¶œ í•„ìš”!",
                targetLabel: "ëª©í‘œ", autopilotLabel: "ìë™í•­ë²•", off: "êº¼ì§", on: "ì¼œì§",
                // ì²œì²´ ì´ë¦„
                galacticCenter: "ì€í•˜ ì¤‘ì‹¬", sun: "íƒœì–‘", mercury: "ìˆ˜ì„±", venus: "ê¸ˆì„±", earth: "ì§€êµ¬",
                mars: "í™”ì„±", jupiter: "ëª©ì„±", saturn: "í† ì„±", uranus: "ì²œì™•ì„±", neptune: "í•´ì™•ì„±",
                moon: "ë‹¬", phobos: "í¬ë³´ìŠ¤", deimos: "ë°ì´ëª¨ìŠ¤", io: "ì´ì˜¤", europa: "ìœ ë¡œíŒŒ",
                ganymede: "ê°€ë‹ˆë©”ë°", callisto: "ì¹¼ë¦¬ìŠ¤í† ", titan: "íƒ€ì´íƒ„", enceladus: "ì—”ì…€ë¼ë‘ìŠ¤",
                titania: "í‹°íƒ€ë‹ˆì•„", oberon: "ì˜¤ë² ë¡ ", triton: "íŠ¸ë¦¬í†¤",
                // ì •ê±°ì¥
                fuelDepotAlpha: "ì—°ë£Œì •ê±°ì¥ ì•ŒíŒŒ", fuelDepotBeta: "ì—°ë£Œì •ê±°ì¥ ë² íƒ€",
                fuelDepotGamma: "ì—°ë£Œì •ê±°ì¥ ê°ë§ˆ", fuelDepotDelta: "ì—°ë£Œì •ê±°ì¥ ë¸íƒ€",
                issStation: "ISS ìš°ì£¼ì •ê±°ì¥", venusPlatform: "ë¹„ë„ˆìŠ¤ í”Œë«í¼", marsStation: "ë§ˆìŠ¤ ìŠ¤í…Œì´ì…˜",
                jupiterOutpost: "ì£¼í”¼í„° ì•„ì›ƒí¬ìŠ¤íŠ¸", saturnBase: "ìƒˆí„´ ë² ì´ìŠ¤",
                uranusRelay: "ìš°ë¼ë…¸ìŠ¤ ë¦´ë ˆì´", neptuneTerminal: "ë„µíŠ  í„°ë¯¸ë„",
                // ë©”ì¸ ë©”ë‰´
                singlePlay: "ì‹±ê¸€ í”Œë ˆì´", multiPlay: "ë©€í‹° í”Œë ˆì´", loginBtn: "ë¡œê·¸ì¸", settings: "ì„¤ì •",
                singleDesc: "ììœ ë¡œìš´ ìš°ì£¼ íƒí—˜ â€¢ ì²œì²´ ìƒì„± â€¢ ë¬´ì œí•œ",
                multiDesc: "ì‹¤ì‹œê°„ ì±„íŒ… â€¢ ê³µë™ íƒí—˜ â€¢ ê²½ìŸ",
                loginDesc: "ê³„ì • ì—°ë™ â€¢ ì§„í–‰ ì €ì¥ â€¢ ë­í‚¹",
                // ë¯¸ì…˜
                missionBoard: "ë¯¸ì…˜ ë³´ë“œ", missionActive: "ì§„í–‰ ì¤‘", missionAvailable: "ìˆ˜ë½ ê°€ëŠ¥", missionCompleted: "ì™„ë£Œ",
                // ë“œë¡­ë‹¤ìš´ ë©”ë‰´
                myProfile: "ğŸ‘¤ ë‚´ í”„ë¡œí•„", dropdownMissions: "ğŸ“‹ ë¯¸ì…˜ ë³´ë“œ", dropdownSettings: "âš™ï¸ ì„¤ì •", dropdownLogout: "ğŸšª ë¡œê·¸ì•„ì›ƒ",
                // ì²œì²´ ì •ë³´
                bodyRadius: "ë°˜ì§€ë¦„", bodyMass: "ì§ˆëŸ‰", bodyDistance: "ê±°ë¦¬", bodyRotation: "ìì „ ì†ë„",
                bodySurfaceGravity: "í‘œë©´ ì¤‘ë ¥", bodyOrbitalSpeed: "ê³µì „ ì†ë„", bodyMoons: "ìœ„ì„± ìˆ˜", bodyRings: "ê³ ë¦¬",
                bodyDetailBtn: "ğŸ“– ìƒì„¸ë³´ê¸°", bodyFocusBtn: "ğŸ¯ ì¶”ì í•˜ê¸°", bodyNavBtn: "ğŸ§­ í•­ë²• ëª©í‘œ ì„¤ì •",
                bodyBasicInfo: "ğŸ“Š ê¸°ë³¸ ì •ë³´", bodyOrbitInfo: "ğŸ›°ï¸ ê¶¤ë„ ì •ë³´", bodyDescription: "ğŸ“ ì„¤ëª…",
                // ì²œì²´ ì •ë³´ ëª¨ë‹¬
                infoBasicInfo: "ê¸°ë³¸ ì •ë³´", infoType: "ìœ í˜•", infoOrbit: "ê³µì „", infoGravity: "ì¤‘ë ¥", infoTemp: "ê¸°ì˜¨",
                terraformingStatus: "í…Œë¼í¬ë° ìƒíƒœ", infrastructure: "ì¸í”„ë¼",
                unexplored: "ë¯¸íƒì‚¬", unknownValue: "ì•Œ ìˆ˜ ì—†ìŒ", days: "ì¼",
                infraSpaceport: "ìš°ì£¼í•­", infraFuel: "ì—°ë£Œ", infraRepair: "ìˆ˜ë¦¬", infraShop: "ìƒì ", infraResearch: "ì—°êµ¬", infraMining: "ì±„êµ´",
                // ê´‘ê³  ë³´ìƒ
                adRewardsTitle: "ğŸ ê´‘ê³  ë³´ìƒ", watchAd: "ğŸ“º ê´‘ê³  ë³´ê¸°", close: "ë‹«ê¸°",
                adBoosterTitle: "ğŸš€ 2ë°° ë¶€ìŠ¤í„°", adBoosterDesc: "ê°€ì† ë° ìµœëŒ€ ì†ë„ 2ë°° (5ë¶„)",
                adEscapeTitle: "âš¡ ê¸´ê¸‰ íƒˆì¶œ", adEscapeDesc: "ë¬´ë£Œ ê¸´ê¸‰íƒˆì¶œ 1íšŒ (10ë¶„)",
                adExploreTitle: "ğŸ”­ ë‘˜ëŸ¬ë³´ê¸° ëª¨ë“œ", adExploreDesc: "ììœ  ì¹´ë©”ë¼ íƒí—˜ (3ë¶„, ëˆ„ì ê°€ëŠ¥)",
                // ì²œì²´ ìƒì„±
                dragToSetVelocity: "ğŸ‘† í™”ì‚´í‘œ ëì„ ë“œë˜ê·¸í•˜ì—¬ ë°©í–¥ê³¼ ì†ë„ë¥¼ ì„¤ì •í•˜ì„¸ìš”",
                // ì¸ì¦ UI
                email: "ì´ë©”ì¼", emailAddress: "ì´ë©”ì¼ ì£¼ì†Œ", passwordConfirm: "ë¹„ë°€ë²ˆí˜¸ í™•ì¸",
                nickname: "ë‹‰ë„¤ì„", nicknameDesc: "(ê²Œì„ì—ì„œ í‘œì‹œ)", emailRequired: "(ì¸ì¦ í•„ìˆ˜)",
                emailVerifyNote: "â€» ì‹¤ì œ ì´ë©”ì¼ ì£¼ì†Œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”. ì¸ì¦ ë©”ì¼ì´ ë°œì†¡ë©ë‹ˆë‹¤.",
                guestStart: "ê²ŒìŠ¤íŠ¸ë¡œ ì‹œì‘ (ì €ì¥ ì•ˆë¨)", backToLogin: "â† ë¡œê·¸ì¸ìœ¼ë¡œ ëŒì•„ê°€ê¸°",
                findPassword: "ë¹„ë°€ë²ˆí˜¸ ì°¾ê¸°", findId: "ì•„ì´ë”” ì°¾ê¸°", resetPassword: "ë¹„ë°€ë²ˆí˜¸ ì¬ì„¤ì •",
                enterEmailForId: "ê°€ì… ì‹œ ë“±ë¡í•œ ì´ë©”ì¼ì„ ì…ë ¥í•˜ì„¸ìš”",
                enterIdAndEmail: "ì•„ì´ë””ì™€ ê°€ì… ì‹œ ë“±ë¡í•œ ì´ë©”ì¼ì„ ì…ë ¥í•˜ì„¸ìš”",
                newPasswordSet: "ìƒˆ ë¹„ë°€ë²ˆí˜¸ê°€ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤", changePasswordAfterLogin: "ë¡œê·¸ì¸ í›„ ë¹„ë°€ë²ˆí˜¸ë¥¼ ë³€ê²½í•˜ì„¸ìš”",
                privacyPolicy: "ê°œì¸ì •ë³´ ì²˜ë¦¬ë°©ì¹¨", termsOfService: "ì´ìš©ì•½ê´€", agreeToTerms: "ì— ë™ì˜í•©ë‹ˆë‹¤",
                // ì¡°ì¢… UI
                currentCoords: "í˜„ì¬ ì¢Œí‘œ", navTargetSelect: "ğŸ¯ í•­ë²• ëª©í‘œ ì„ íƒ...",
                telescope: "ë§ì›ê²½", telescopeMode: "ğŸ”­ ë§ì›ê²½ ëª¨ë“œ", zoomLevel: "ì¤Œ",
                exitToCorridor: "[E] ë³µë„ë¡œ ë‚˜ê°€ê¸°", docking: "ë„í‚¹ ì¤‘...", docked: "ë„í‚¹ë¨",
                launching: "ë°œì§„ ì¤‘...", selectFromList: "ëª©ë¡ì—ì„œ í•­ëª©ì„ ì„ íƒí•˜ì„¸ìš”",
                warp: "ì›Œí”„", accelerating: "ğŸš€ ê°€ì† ì¤‘...", cruising: "âœˆï¸ ìˆœí•­ ì¤‘...",
                decelerating: "ğŸ”» ê°ì† ì¤‘...", arrived: "âœ… ë„ì°©", orbitTransfer: "ğŸ”„ ê¶¤ë„ ì „ì´",
                stableOrbitReached: "ğŸŒ ì•ˆì • ê¶¤ë„", targetPrefix: "ëª©í‘œ: ", orbitSuffix: " ê¶¤ë„",
                statusNormal: "ì •ìƒ", save: "ì €ì¥", load: "ë¶ˆëŸ¬ì˜¤ê¸°", enterMessage: "ë©”ì‹œì§€ ì…ë ¥...",
                enterQuestion: "ì§ˆë¬¸ì„ ì…ë ¥í•˜ì„¸ìš”...", selectChannel: "ğŸ“¡ ì±„ë„ì„ ì„ íƒí•˜ì„¸ìš”",
                andromeda: "ì•ˆë“œë¡œë©”ë‹¤ì€í•˜", notVisitedYet: "âš ï¸ ì•„ì§ ë°©ë¬¸í•˜ì§€ ì•Šì€ ìœ„ì„±ì…ë‹ˆë‹¤. ì§ì ‘ ë¹„í–‰í•˜ì—¬ ë°©ë¬¸í•˜ì„¸ìš”!",
                selectStation: "ğŸ›¸ ìš°ì£¼ì •ê±°ì¥ ì„ íƒ", selectWeapon: "ë¬´ê¸° ì„ íƒ", selectWeaponDesc: "ë¬´ê¸°ë¥¼ ì„ íƒí•˜ì„¸ìš”",
                // ì±„íŒ…
                ariaTab: "ğŸ¤– ARIA", chatTab: "ğŸ’¬ ì±„íŒ…", ariaPlaceholder: "ARIAì—ê²Œ ì§ˆë¬¸...",
                chatNotConnected: "ì±„íŒ… ì—°ê²° ì•ˆë¨", systemInit: "ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ. ì•ˆì „í•œ ë¹„í–‰ ë˜ì„¸ìš”, íŒŒì¼ëŸ¿.",
                // ì¡°ì¢… ëª¨ë“œ
                pilotMode: "ğŸ® ì¡°ì¢… ëª¨ë“œ", spaceMode: "ğŸŒŒ ìš°ì£¼ ëª¨ë“œ",
                // ì¶”ê°€ UI í…ìŠ¤íŠ¸
                overwrite: "ë®ì–´ì“°ê¸°", delete: "ì‚­ì œ", chatConnected: "ì±„íŒ… ì—°ê²°ë¨",
                radioConnecting: "ğŸ“¡ ì—°ê²° ì¤‘...", radioConnectionFailed: "âš ï¸ ì—°ê²° ì‹¤íŒ¨ - ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”",
                radioPlaybackFailed: "âš ï¸ ì¬ìƒ ì‹¤íŒ¨ - ë‹¤ë¥¸ ì±„ë„ì„ ì„ íƒí•˜ì„¸ìš”", playing: "ì¬ìƒ ì¤‘...",
                orbitalStations: "ğŸ“ ê¶¤ë„ ì •ê±°ì¥", fuelDepots: "â›½ ì—°ë£Œ ë³´ê¸‰ì†Œ", refueling: "â›½ ì—°ë£Œ ì¶©ì „ ì¤‘...",
                selectArmor: "ë°©ì–´êµ¬ ì„ íƒ", specialAbility: "íŠ¹ìˆ˜ëŠ¥ë ¥", warpAbility: "ì›Œí”„",
                etaLabel: "ETA", user: "ì‚¬ìš©ì",
                // ë¡œê·¸ì¸/íšŒì›ê°€ì… ì—ëŸ¬
                enterEmailPassword: "ì´ë©”ì¼ê³¼ ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”",
                passwordsNotMatch: "ë¹„ë°€ë²ˆí˜¸ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤",
                enterNickname: "ë‹‰ë„¤ì„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”",
                enterEmailRequired: "ì´ë©”ì¼ì„ ì…ë ¥í•´ì£¼ì„¸ìš” (ì¸ì¦ í•„ìš”)",
                invalidEmailFormat: "ì˜¬ë°”ë¥¸ ì´ë©”ì¼ í˜•ì‹ì„ ì…ë ¥í•´ì£¼ì„¸ìš”",
                agreePrivacy: "ê°œì¸ì •ë³´ì²˜ë¦¬ë°©ì¹¨ì— ë™ì˜í•´ì£¼ì„¸ìš”",
                agreeTerms: "ì´ìš©ì•½ê´€ì— ë™ì˜í•´ì£¼ì„¸ìš”",
                confirmLogout: "ì •ë§ ë¡œê·¸ì•„ì›ƒ í•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
                // ì•„ì´ë””/ë¹„ë°€ë²ˆí˜¸ ì°¾ê¸°
                enterRegisteredEmail: "ê°€ì…í•  ë•Œ ë“±ë¡í•œ ì´ë©”ì¼ì„ ì…ë ¥í•˜ì„¸ìš”",
                foundId: "ì°¾ì€ ì•„ì´ë””",
                findIdBtn: "ì•„ì´ë”” ì°¾ê¸°",
                backToLoginBtn: "â† ë¡œê·¸ì¸ìœ¼ë¡œ ëŒì•„ê°€ê¸°",
                enterIdAndEmailDesc: "ì•„ì´ë””ì™€ ë“±ë¡ëœ ì´ë©”ì¼ì„ ì…ë ¥í•˜ì„¸ìš”",
                newPasswordSetMsg: "ìƒˆ ë¹„ë°€ë²ˆí˜¸ê°€ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤",
                changePasswordNote: "ë¡œê·¸ì¸ í›„ ë¹„ë°€ë²ˆí˜¸ë¥¼ ë³€ê²½í•´ì£¼ì„¸ìš”",
                resetPasswordBtn: "ë¹„ë°€ë²ˆí˜¸ ì¬ì„¤ì •",
                // ì†Œë¦¬
                soundOnOff: "ì†Œë¦¬ ì¼œê¸°/ë„ê¸°",
                // ë¼ë””ì˜¤
                spaceStation: "ìš°ì£¼ ì •ê±°ì¥",
                radio: "ğŸ“» ë¼ë””ì˜¤", radioShort: "ğŸ“»",
                // orbit
                orbitSuffixText: " ê¶¤ë„",
                // ì¶”ê°€ ì—ëŸ¬/ìƒíƒœ ë©”ì‹œì§€
                on: "ì¼œì§", off: "êº¼ì§",
                connectingServer: "ì„œë²„ ì—°ê²° ì¤‘... ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”",
                emailAlreadyRegistered: "ì´ë¯¸ ë“±ë¡ëœ ì´ë©”ì¼ì…ë‹ˆë‹¤",
                enterValidEmail: "ì˜¬ë°”ë¥¸ ì´ë©”ì¼ ì£¼ì†Œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”",
                registrationComplete: "íšŒì›ê°€ì… ì™„ë£Œ! ë¡œê·¸ì¸í•´ì£¼ì„¸ìš”",
                serverConnectionFailed: "ì„œë²„ ì—°ê²° ì‹¤íŒ¨: ",
                enterEmailExample: "ì´ë©”ì¼ ì£¼ì†Œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš” (ì˜ˆ: user@example.com)",
                invalidEmailOrPassword: "ì´ë©”ì¼ ë˜ëŠ” ë¹„ë°€ë²ˆí˜¸ê°€ í‹€ë ¸ìŠµë‹ˆë‹¤",
                loginFailed: "ë¡œê·¸ì¸ ì‹¤íŒ¨: ",
                stop: "â¹ï¸ ì •ì§€",
                // SSIL
                ssilTrainingProgram: "SSIL í›ˆë ¨ í”„ë¡œê·¸ë¨",
                ssilSubtitle: "Solar System Integrated Logistics",
                mission: "ë¯¸ì…˜", missionDesc: "ì„¤ëª…",
                totalReward: "ì´ ë³´ìƒ", coins: "ì½”ì¸",
                ssilWorkOrder: "SSIL ì—…ë¬´ ì§€ì‹œì„œ",
                urgentDelivery: "ê¸´ê¸‰ ë°°ë‹¬ ìš”ì²­",
                missionComplete: "ğŸ¯ ë¯¸ì…˜ ì™„ë£Œ!",
                confirm: "í™•ì¸",
                // ë§ì›ê²½
                telescopeExit: "âœ• ë§ì›ê²½ ì¢…ë£Œ",
                mouseDrag: "ğŸ–±ï¸ ë§ˆìš°ìŠ¤ ë“œë˜ê·¸: ì‹œì  ì´ë™",
                wheelZoom: "ğŸ”„ íœ  ìŠ¤í¬ë¡¤: ì¤Œ ì¡°ì ˆ",
                escExit: "ESC: ë§ì›ê²½ ì¢…ë£Œ",
                telescopeControls: "ğŸ“– ì¡°ì‘ë²•",
                zoomLabel: "ì¤Œ", maxZoomLabel: "ìµœëŒ€", targetNone: "íƒ€ê²Ÿ: ì—†ìŒ",
                defaultTelescope: "ê¸°ë³¸ ë§ì›ê²½",
                // ìš°ì£¼ ê°€ì´ë“œ
                spaceKnowledgeGuide: "ğŸ›¸ ìš°ì£¼ ì§€ì‹ ê°€ì´ë“œ",
                // UI ì„¤ì •
                uiSettings: "ğŸ›ï¸ UI ì„¤ì •",
                uiReposition: "ğŸ”§ UI ì¬ë°°ì¹˜ ëª¨ë“œ",
                uiDragToMove: "ì¬ë°°ì¹˜ ëª¨ë“œì—ì„œ UIë¥¼ ë“œë˜ê·¸í•˜ì—¬ ì´ë™",
                saveSlots: "ğŸ’¾ ì €ì¥ ìŠ¬ë¡¯",
                resetDefault: "ğŸ”„ ê¸°ë³¸ê°’ìœ¼ë¡œ ë¦¬ì…‹",
                done: "âœ“ ì™„ë£Œ",
                // ìƒì 
                equipmentShopPreparing: "ì¥ë¹„ ìƒì  ì¤€ë¹„ì¤‘...",
                consumablesShopPreparing: "ì†Œëª¨í’ˆ ìƒì  ì¤€ë¹„ì¤‘...",
                // ëª¨ë°”ì¼ íƒ­
                control: "ì¡°ì¢…", statusTab: "ìƒíƒœ", radioTab: "ë¼ë””ì˜¤", chatTab2: "ì±„íŒ…", ariaTab2: "ARIA",
                // ì´ë©”ì¼ ì¸ì¦
                emailVerificationRequired: "ì´ë©”ì¼ ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤.<br><small>ë©”ì¼í•¨ì„ í™•ì¸í•´ì£¼ì„¸ìš” (ìŠ¤íŒ¸í•¨ë„ í™•ì¸)</small>",
                // ë¯¸ì…˜ ê´€ë ¨
                accept: "âœ“ ìˆ˜ë½", decline: "âœ• ê±°ì ˆ", later: "ë‚˜ì¤‘ì—",
                // ì¤‘ë ¥ ê²½ê³ 
                gravityWarning: "ìœ¼ë¡œ", turnLeft: "ì¢Œì¸¡", turnRight: "ìš°ì¸¡", avoidText: "íšŒí”¼",
                escapeVelocity: "í•„ìš” ì†ë„", currentVelocity: "í˜„ì¬ ì†ë„", deficit: "ë¶€ì¡±",
                // ë„í‚¹/ì •ê±°ì¥
                docking: "ë„í‚¹", refuelMenu: "â›½ ì—°ë£Œ ë³´ì¶©", refuelingProgress: "â›½ ì—°ë£Œ ë³´ê¸‰ ì¤‘...",
                goToStationBtn: "ì´ë™",
                // ë©”ì‹œì§€
                message: "ë©”ì‹œì§€",
                // AI
                aiInitMessage: "ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ. ì•ˆì „í•œ ë¹„í–‰ ë˜ì„¸ìš”, íŒŒì¼ëŸ¿.",
                aiWelcome: "ì•ˆë…•í•˜ì„¸ìš”! ì²œì²´ë¼ë¦¬ ì¶©ëŒí•˜ë©´ í¡ìˆ˜ë˜ë©°, ì§ˆëŸ‰ì´ 100ì„ ë„˜ìœ¼ë©´ ë³„(í•­ì„±)ì´ ë©ë‹ˆë‹¤.",
                unidentifiedSignal: "ë¯¸í™•ì¸ ì‹ í˜¸", online: "â— ì˜¨ë¼ì¸",
                // ìš°ì£¼ì„ 
                shuttle: "ì…”í‹€", shuttleDesc: "ê¸°ë³¸í˜• ì™•ë³µì„ ",
                // ì„ ë‚´
                researchLab: "ğŸšª ì—°êµ¬ì‹¤", approachedDoor: "ë¬¸ì— ì ‘ê·¼í–ˆìŠµë‹ˆë‹¤", enterDoor: "ì…ì¥ [E]",
                // ì±„íŒ…
                send: "ì „ì†¡",
                // ë¼ë””ì˜¤
                spaceRadio: "ğŸ›¸ ìš°ì£¼ ë¼ë””ì˜¤",
                // ë¬´ì¥
                damage: "ë°ë¯¸ì§€", fireRate: "ì—°ì‚¬ì†ë„", range: "ì‚¬ê±°ë¦¬", energy: "ì—ë„ˆì§€",
                tier: "í‹°ì–´", defense: "ë°©ì–´ë ¥", hpBonus: "HP ë³´ë„ˆìŠ¤", weightFactor: "ì¤‘ëŸ‰ ê³„ìˆ˜",
                owned: "ë³´ìœ ì¤‘", ownedMark: "âœ“ ë³´ìœ ", locked: "ì¥ì°© ë¶ˆê°€",
                // ì¶”ê°€
                noEscapeTicket: "íƒˆì¶œê¶Œ ì—†ìŒ", chargeComplete: "âœ… ì¶©ì „ ì™„ë£Œ", minutes: "ë¶„",
                afterburnerOff: "ì• í”„í„°ë²„ë„ˆ í•´ì œ", orbitEntryCanceled: "ê¶¤ë„ ì§„ì… ì·¨ì†Œ. í˜„ì¬ ìœ„ì¹˜ì—ì„œ ì •ì§€.",
                trackingMode: "ì¶”ì  ëª¨ë“œ", observatory: "ğŸ”­ ì „ë§ëŒ€", undock: "ğŸš€ ë„í‚¹í•´ì œ",
                // ì¶©ëŒ/ì¶”ë½
                crashWarning: "ì¶”ë½ ìœ„í—˜!", hullDestroyed: "ì„ ì²´ íŒŒê´´!",
                // íšŒì „ ì•ˆë‚´
                rotateScreen: "í™”ë©´ì„ ê°€ë¡œë¡œ íšŒì „í•´ì£¼ì„¸ìš”",
                rotateScreenSub: "ì¡°ì¢… ëª¨ë“œëŠ” ê°€ë¡œ í™”ë©´ì—ì„œë§Œ ì§€ì›ë©ë‹ˆë‹¤",
                // ì €ì¥ëœ ìš°ì£¼ì„ 
                savedShipFound: "ì €ì¥ëœ ìš°ì£¼ì„  ë°œê²¬!",
                fuelPercent: "â›½ ì—°ë£Œ",
                restoreShip: "ì´ ìœ„ì¹˜ì—ì„œ íƒ‘ìŠ¹",
                newShipStart: "ì •ê±°ì¥ì—ì„œ ìƒˆë¡œ ì‹œì‘",
                // ì ‘ì†ì
                playersOnline: "ğŸŸ¢ ì ‘ì†ì",
                playersCount: "ëª…",
                // ê´‘ê³ 
                activated: "âœ… í™œì„±í™”ë¨", watchAdBtn: "ğŸ“º ê´‘ê³  ë³´ê¸°",
                // êµ¬ë§¤ í™•ì¸
                confirmPurchase: "ì„(ë¥¼) êµ¬ë§¤í•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
                coinsUnit: "ì½”ì¸",
                // ì´ˆê¸°í™”
                confirmResetSolar: "íƒœì–‘ê³„ë¥¼ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
                resetSolarDesc: "ëª¨ë“  ì¶”ê°€ëœ ì²œì²´ê°€ ì‚­ì œë˜ê³  ì›ë˜ ìƒíƒœë¡œ ë³µì›ë©ë‹ˆë‹¤.",
                resetSolarSystem: "ğŸ”„ íƒœì–‘ê³„ ì´ˆê¸°í™”",
                // ì¸ì¦ ê´€ë ¨
                noAuthInfo: "ì¸ì¦ ì •ë³´ ì—†ìŒ. ë‹¤ì‹œ ë¡œê·¸ì¸í•´ì£¼ì„¸ìš”.",
                verifying: "í™•ì¸ ì¤‘...",
                emailPending: "âŒ ì´ë©”ì¼ ì¸ì¦ ëŒ€ê¸° ì¤‘. ë©”ì¼í•¨ì„ í™•ì¸í•´ì£¼ì„¸ìš”.",
                loginFailedMsg: "âŒ ë¡œê·¸ì¸ ì‹¤íŒ¨: ",
                verified: "âœ… ì¸ì¦ ì™„ë£Œ! ë¡œê·¸ì¸ ì¤‘...",
                serverError: "âŒ ì„œë²„ ì˜¤ë¥˜: ",
                emailNotFound: "ì´ë©”ì¼ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
                sendingEmail: "ë©”ì¼ ë°œì†¡ ì¤‘...",
                resendFailed: "âŒ ì¬ë°œì†¡ ì‹¤íŒ¨: ",
                resendSuccess: "âœ… ì¸ì¦ ë©”ì¼ì„ ë‹¤ì‹œ ë³´ëƒˆìŠµë‹ˆë‹¤. ë©”ì¼í•¨ì„ í™•ì¸í•´ì£¼ì„¸ìš”.",
                // ë‹«ê¸°
                closeBtn: "âœ• ë‹«ê¸°"
            },
            en: {
                // Settings
                settings: "âš™ï¸ Settings", sound: "ğŸ”Š Sound", graphics: "ğŸ¨ Graphics", language: "ğŸŒ Language",
                graphicsLow: "Low", graphicsMedium: "Medium", graphicsHigh: "High",
                distExp: "Dist: Experience", distReal: "Dist: Real (50x)",
                station: "ğŸ›°ï¸ Station", catalog: "ğŸ“– Catalog", fullscreen: "â›¶ Fullscreen", windowMode: "â›¶ Window",
                fine: "Fine(0~2x)", fast: "Fast(1~100x)",
                bodyList: "Celestial Bodies", catalogTitle: "ğŸŒŒ Celestial Catalog (Click to spawn)",
                boardShip: "ğŸš€ Board Ship", selectShip: "ğŸš€ Select Ship",
                maxSpeed: "Max Speed", accelStat: "Acceleration", turnRate: "Turn Rate", fuel: "Fuel",
                launch: "Launch", cancel: "âœ• Cancel",
                accel: "Accel", reverse: "Reverse", thrust: "Thrust", emergencyReverse: "ğŸ”¥<br>E-Reverse",
                auto: "ğŸ¤– Auto", orbitEntry: "ğŸŒ Orbit", orbitExit: "ğŸŒ Exit Orbit",
                interior: "ğŸšª Interior", emergency: "ğŸ†˜ Escape", disembark: "âœ• Exit",
                none: "None", viewAll: "ğŸ”­ View All", unknown: "Unknown",
                status: "STATUS", statusNominal: "NOMINAL", statusAuto: "AUTO", statusLowFuel: "LOW FUEL",
                statusCruising: "CRUISING", statusOrbiting: "ORBITING", statusBraking: "BRAKING",
                orbitLock: "ğŸŒ Tidal Lock Orbit", stableOrbit: "Stable Orbit",
                orbitPromptMsg: "Enter tidal locked orbit?<br>Ship will naturally orbit while facing the planet.",
                confirmOrbit: "âœ“ Lock Orbit",
                msgExpMode: "Experience mode: Easy viewing distance.",
                msgRealMode: "Real mode: Scale solar system! Planets are far apart.",
                msgOrbitEntering: "Entering orbit... Interior access enabled.",
                msgOrbitStable: "Stable orbit achieved!",
                msgOrbitExit: "Left orbit! Manual control enabled.",
                msgNeedAuto: "âš ï¸ Interior access requires autopilot or orbit mode.",
                login: "Login", register: "Register", logout: "Logout", username: "Username", password: "Password",
                welcome: "Welcome", guest: "Guest", loginFirst: "Please login first",
                spaceCoin: "SpaceCoin", price: "Price", buy: "Buy", owned: "Owned", freeShip: "Starter",
                notEnoughCoins: "Not enough coins!", alreadyOwned: "Already owned!",
                purchased: "Purchased!", reward: "Reward",
                // Armory
                armory: "âš”ï¸ Armory", armorySystem: "âš”ï¸ Armory System",
                shipParked: "Ship parked", reboard: "Reboard", goToStation: "Go to Station",
                upgradeAtStation: "Upgrade at Station",
                sellShipTitle: "Sell Ship", currentShip: "Current Ship", sellPrice: "Sell Price (50%)",
                sellAndBoard: "Sell & Board", sellMessage: "You must sell your current ship to board a new one.",
                target: "Target", distance: "Distance", eta: "ETA", speed: "Speed",
                // HUD Warnings
                lowFuel: "âš ï¸ Low Fuel!", escapeBoosterReady: "âš¡ Escape Booster Ready",
                collisionWarning: "âš ï¸ Collision Warning!", hullDamage: "âš ï¸ Hull Damage!",
                autoDecel: "ğŸ”» Auto Deceleration", emergencyReverseWarn: "ğŸš¨ Emergency Reverse!",
                gravityCapture: "âš ï¸ Gravity Capture! Escape Required!",
                targetLabel: "TARGET", autopilotLabel: "AUTOPILOT", off: "OFF", on: "ON",
                // Celestial Bodies
                galacticCenter: "Galactic Center", sun: "Sun", mercury: "Mercury", venus: "Venus", earth: "Earth",
                mars: "Mars", jupiter: "Jupiter", saturn: "Saturn", uranus: "Uranus", neptune: "Neptune",
                moon: "Moon", phobos: "Phobos", deimos: "Deimos", io: "Io", europa: "Europa",
                ganymede: "Ganymede", callisto: "Callisto", titan: "Titan", enceladus: "Enceladus",
                titania: "Titania", oberon: "Oberon", triton: "Triton",
                // Stations
                fuelDepotAlpha: "Fuel Depot Alpha", fuelDepotBeta: "Fuel Depot Beta",
                fuelDepotGamma: "Fuel Depot Gamma", fuelDepotDelta: "Fuel Depot Delta",
                issStation: "ISS Space Station", venusPlatform: "Venus Platform", marsStation: "Mars Station",
                jupiterOutpost: "Jupiter Outpost", saturnBase: "Saturn Base",
                uranusRelay: "Uranus Relay", neptuneTerminal: "Neptune Terminal",
                // Main Menu
                singlePlay: "Single Play", multiPlay: "Multiplayer", loginBtn: "Login", settings: "Settings",
                singleDesc: "Free space exploration â€¢ Create celestial bodies â€¢ Unlimited",
                multiDesc: "Real-time chat â€¢ Co-op exploration â€¢ Competition",
                loginDesc: "Account sync â€¢ Save progress â€¢ Rankings",
                // Missions
                missionBoard: "Mission Board", missionActive: "Active", missionAvailable: "Available", missionCompleted: "Completed",
                // Dropdown Menu
                myProfile: "ğŸ‘¤ My Profile", dropdownMissions: "ğŸ“‹ Mission Board", dropdownSettings: "âš™ï¸ Settings", dropdownLogout: "ğŸšª Logout",
                // Body Info
                bodyRadius: "Radius", bodyMass: "Mass", bodyDistance: "Distance", bodyRotation: "Rotation",
                bodySurfaceGravity: "Surface Gravity", bodyOrbitalSpeed: "Orbital Speed", bodyMoons: "Moons", bodyRings: "Rings",
                bodyDetailBtn: "ğŸ“– Details", bodyFocusBtn: "ğŸ¯ Track", bodyNavBtn: "ğŸ§­ Set Nav Target",
                bodyBasicInfo: "ğŸ“Š Basic Info", bodyOrbitInfo: "ğŸ›°ï¸ Orbital Info", bodyDescription: "ğŸ“ Description",
                // Info modal
                infoBasicInfo: "Basic Info", infoType: "Type", infoOrbit: "Orbit", infoGravity: "Gravity", infoTemp: "Temp",
                terraformingStatus: "Terraforming Status", infrastructure: "Infrastructure",
                unexplored: "Unexplored", unknownValue: "Unknown", days: "days",
                infraSpaceport: "Spaceport", infraFuel: "Fuel", infraRepair: "Repair", infraShop: "Shop", infraResearch: "Research", infraMining: "Mining",
                // Ad Rewards
                adRewardsTitle: "ğŸ Ad Rewards", watchAd: "ğŸ“º Watch Ad", close: "Close",
                adBoosterTitle: "ğŸš€ 2x Booster", adBoosterDesc: "2x acceleration & max speed (5 min)",
                adEscapeTitle: "âš¡ Emergency Escape", adEscapeDesc: "Free emergency escape x1 (10 min)",
                adExploreTitle: "ğŸ”­ Explore Mode", adExploreDesc: "Free camera exploration (3 min, stackable)",
                // Body Creation
                dragToSetVelocity: "ğŸ‘† Drag the arrow tip to set direction and speed",
                // Auth UI
                email: "Email", emailAddress: "Email Address", passwordConfirm: "Confirm Password",
                nickname: "Nickname", nicknameDesc: "(Displayed in game)", emailRequired: "(Verification required)",
                emailVerifyNote: "â€» Please enter a valid email. Verification email will be sent.",
                guestStart: "Start as Guest (Not saved)", backToLogin: "â† Back to Login",
                findPassword: "Find Password", findId: "Find ID", resetPassword: "Reset Password",
                enterEmailForId: "Enter email registered during signup",
                enterIdAndEmail: "Enter your ID and registered email",
                newPasswordSet: "New password has been set", changePasswordAfterLogin: "Please change your password after login",
                privacyPolicy: "Privacy Policy", termsOfService: "Terms of Service", agreeToTerms: "I agree to",
                // Pilot UI
                currentCoords: "Current Coordinates", navTargetSelect: "ğŸ¯ Select Navigation Target...",
                telescope: "Telescope", telescopeMode: "ğŸ”­ Telescope Mode", zoomLevel: "Zoom",
                exitToCorridor: "[E] Exit to Corridor", docking: "Docking...", docked: "Docked",
                launching: "Launching...", selectFromList: "Select an item from the list",
                warp: "Warp", accelerating: "ğŸš€ Accelerating...", cruising: "âœˆï¸ Cruising...",
                decelerating: "ğŸ”» Decelerating...", arrived: "âœ… Arrived", orbitTransfer: "ğŸ”„ Orbit Transfer",
                stableOrbitReached: "ğŸŒ Stable Orbit", targetPrefix: "Target: ", orbitSuffix: " Orbit",
                statusNormal: "Normal", save: "Save", load: "Load", enterMessage: "Enter message...",
                enterQuestion: "Enter your question...", selectChannel: "ğŸ“¡ Select a channel",
                andromeda: "Andromeda Galaxy", notVisitedYet: "âš ï¸ Not visited yet. Fly there directly!",
                selectStation: "ğŸ›¸ Select Station", selectWeapon: "Select Weapon", selectWeaponDesc: "Select a weapon",
                // Chat
                ariaTab: "ğŸ¤– ARIA", chatTab: "ğŸ’¬ Chat", ariaPlaceholder: "Ask ARIA...",
                chatNotConnected: "Not connected to chat", systemInit: "System initialized. Fly safe, pilot.",
                // Pilot Mode
                pilotMode: "ğŸ® Pilot Mode", spaceMode: "ğŸŒŒ Space Mode",
                // Additional UI text
                overwrite: "Overwrite", delete: "Delete", chatConnected: "Chat connected",
                radioConnecting: "ğŸ“¡ Connecting...", radioConnectionFailed: "âš ï¸ Connection failed - Please retry",
                radioPlaybackFailed: "âš ï¸ Playback failed - Select another channel", playing: "Playing...",
                orbitalStations: "ğŸ“ Orbital Stations", fuelDepots: "â›½ Fuel Depots", refueling: "â›½ Refueling...",
                selectArmor: "Select Armor", specialAbility: "Special", warpAbility: "Warp",
                etaLabel: "ETA", user: "User",
                // Login/Register errors
                enterEmailPassword: "Please enter email and password",
                passwordsNotMatch: "Passwords do not match",
                enterNickname: "Please enter a nickname",
                enterEmailRequired: "Please enter email (verification required)",
                invalidEmailFormat: "Please enter a valid email format",
                agreePrivacy: "Please agree to the Privacy Policy",
                agreeTerms: "Please agree to the Terms of Service",
                confirmLogout: "Are you sure you want to logout?",
                // Find ID/Password
                enterRegisteredEmail: "Enter the email you registered with",
                foundId: "Found ID",
                findIdBtn: "Find ID",
                backToLoginBtn: "â† Back to Login",
                enterIdAndEmailDesc: "Enter your ID and registered email",
                newPasswordSetMsg: "New password has been set",
                changePasswordNote: "Please change your password after login",
                resetPasswordBtn: "Reset Password",
                // Sound
                soundOnOff: "Sound ON/OFF",
                // Radio
                spaceStation: "Space Station",
                radio: "ğŸ“» Radio", radioShort: "ğŸ“»",
                // orbit
                orbitSuffixText: " Orbit",
                // Additional error/status messages
                on: "ON", off: "OFF",
                connectingServer: "Connecting to server... Please try again",
                emailAlreadyRegistered: "Email already registered",
                enterValidEmail: "Please enter a valid email address",
                registrationComplete: "Registration complete! Please login",
                serverConnectionFailed: "Server connection failed: ",
                enterEmailExample: "Please enter email address (e.g. user@example.com)",
                invalidEmailOrPassword: "Invalid email or password",
                loginFailed: "Login failed: ",
                stop: "â¹ï¸ Stop",
                // SSIL
                ssilTrainingProgram: "SSIL Training Program",
                ssilSubtitle: "Solar System Integrated Logistics",
                mission: "Mission", missionDesc: "Description",
                totalReward: "Total Reward", coins: "Coins",
                ssilWorkOrder: "SSIL Work Order",
                urgentDelivery: "Urgent Delivery Request",
                missionComplete: "ğŸ¯ Mission Complete!",
                confirm: "Confirm",
                // Telescope
                telescopeExit: "âœ• Exit Telescope",
                mouseDrag: "ğŸ–±ï¸ Mouse drag: Pan view",
                wheelZoom: "ğŸ”„ Scroll wheel: Zoom",
                escExit: "ESC: Exit Telescope",
                // Space Guide
                spaceKnowledgeGuide: "ğŸ›¸ Space Knowledge Guide",
                // UI Settings
                uiSettings: "ğŸ›ï¸ UI Settings",
                uiReposition: "ğŸ”§ UI Reposition Mode",
                // Shop
                equipmentShopPreparing: "Equipment shop preparing...",
                consumablesShopPreparing: "Consumables shop preparing...",
                // Mobile tabs
                control: "Control", statusTab: "Status", radioTab: "Radio", chatTab2: "Chat", ariaTab2: "ARIA",
                // Email verification
                emailVerificationRequired: "Email verification required.<br><small>Please check your mailbox (also spam folder)</small>",
                // Telescope extended
                telescopeControls: "ğŸ“– Controls",
                zoomLabel: "Zoom", maxZoomLabel: "Max", targetNone: "Target: None",
                defaultTelescope: "Default Telescope",
                // UI Settings extended
                uiDragToMove: "Drag UI to move in reposition mode",
                saveSlots: "ğŸ’¾ Save Slots",
                resetDefault: "ğŸ”„ Reset to Default",
                done: "âœ“ Done",
                // Mission related
                accept: "âœ“ Accept", decline: "âœ• Decline", later: "Later",
                // Gravity warning
                gravityWarning: " to", turnLeft: "Left", turnRight: "Right", avoidText: "avoid",
                escapeVelocity: "Escape velocity", currentVelocity: "Current velocity", deficit: "Deficit",
                // Docking/Station
                docking: "Dock", refuelMenu: "â›½ Refuel", refuelingProgress: "â›½ Refueling...",
                goToStationBtn: "Go",
                // Message
                message: "Message",
                // AI
                aiInitMessage: "System initialized. Fly safe, pilot.",
                aiWelcome: "Hello! When celestial bodies collide, they merge. If mass exceeds 100, it becomes a star.",
                unidentifiedSignal: "Unidentified Signal", online: "â— Online",
                // Spaceship
                shuttle: "Shuttle", shuttleDesc: "Basic shuttle craft",
                // Interior
                researchLab: "ğŸšª Research Lab", approachedDoor: "Approached door", enterDoor: "Enter [E]",
                // Chat
                send: "Send",
                // Radio
                spaceRadio: "ğŸ›¸ Space Radio",
                // Armory
                damage: "Damage", fireRate: "Fire Rate", range: "Range", energy: "Energy",
                tier: "Tier", defense: "Defense", hpBonus: "HP Bonus", weightFactor: "Weight",
                owned: "Owned", ownedMark: "âœ“ Owned", locked: "Locked",
                // Additional
                noEscapeTicket: "No Escape Ticket", chargeComplete: "âœ… Charged", minutes: "min",
                afterburnerOff: "Afterburner disabled", orbitEntryCanceled: "Orbit entry canceled. Stopped at current position.",
                trackingMode: "Tracking Mode", observatory: "ğŸ”­ Observatory", undock: "ğŸš€ Undock",
                // Crash
                crashWarning: "Crash Warning!", hullDestroyed: "Hull Destroyed!",
                // Rotate screen
                rotateScreen: "Please rotate to landscape",
                rotateScreenSub: "Pilot mode only supports landscape orientation",
                // Saved ship
                savedShipFound: "Saved ship found!",
                fuelPercent: "â›½ Fuel",
                restoreShip: "Board at this location",
                newShipStart: "Start fresh at station",
                // Players online
                playersOnline: "ğŸŸ¢ Online",
                playersCount: "players",
                // Ad
                activated: "âœ… Activated", watchAdBtn: "ğŸ“º Watch Ad",
                // Purchase confirm
                confirmPurchase: "Do you want to purchase?",
                coinsUnit: "coins",
                // Reset
                confirmResetSolar: "Reset the solar system?",
                resetSolarDesc: "All added celestial bodies will be deleted and restored to original state.",
                resetSolarSystem: "ğŸ”„ Reset Solar System",
                // Auth related
                noAuthInfo: "No auth info. Please login again.",
                verifying: "Verifying...",
                emailPending: "âŒ Email verification pending. Please check your inbox.",
                loginFailedMsg: "âŒ Login failed: ",
                verified: "âœ… Verified! Logging in...",
                serverError: "âŒ Server error: ",
                emailNotFound: "Email information not found.",
                sendingEmail: "Sending email...",
                resendFailed: "âŒ Resend failed: ",
                resendSuccess: "âœ… Verification email sent. Please check your mailbox.",
                // Close
                closeBtn: "âœ• Close"
            },
            ja: {
                distExp: "è·é›¢: ä½“é¨“", distReal: "è·é›¢: å®Ÿéš› (50x)",
                station: "ğŸ›°ï¸ ã‚¹ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³", catalog: "ğŸ“– å›³é‘‘", fullscreen: "â›¶ å…¨ç”»é¢", windowMode: "â›¶ ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦",
                fine: "ç²¾å¯†(0~2x)", fast: "é«˜é€Ÿ(1~100x)",
                bodyList: "å¤©ä½“ãƒªã‚¹ãƒˆ", catalogTitle: "ğŸŒŒ å¤©ä½“å›³é‘‘ (ã‚¯ãƒªãƒƒã‚¯ã§ç”Ÿæˆ)",
                boardShip: "ğŸš€ å®‡å®™èˆ¹æ­ä¹—", selectShip: "ğŸš€ å®‡å®™èˆ¹é¸æŠ",
                maxSpeed: "æœ€é«˜é€Ÿåº¦", accelStat: "åŠ é€ŸåŠ›", turnRate: "æ—‹å›åŠ›", fuel: "ç‡ƒæ–™",
                launch: "å‡ºæ’ƒ", cancel: "âœ• ã‚­ãƒ£ãƒ³ã‚»ãƒ«",
                accel: "åŠ é€Ÿ", reverse: "é€†å™´å°„", thrust: "æ¨é€²", emergencyBrake: "ğŸ”¥<br>ç·Šæ€¥åˆ¶å‹•",
                auto: "ğŸ¤– è‡ªå‹•", orbitEntry: "ğŸŒ è»Œé“çªå…¥", orbitExit: "ğŸŒ è»Œé“é›¢è„±",
                interior: "ğŸšª èˆ¹å†…", emergency: "ğŸ†˜ ç·Šæ€¥è„±å‡º", disembark: "âœ• ä¸‹èˆ¹",
                none: "ãªã—", viewAll: "ğŸ”­ å…¨ä½“è¡¨ç¤º",
                status: "çŠ¶æ…‹", statusNominal: "æ­£å¸¸", statusAuto: "è‡ªå‹•èˆªè¡Œä¸­", statusLowFuel: "ç‡ƒæ–™ä¸è¶³",
                statusCruising: "å·¡èˆªä¸­", statusOrbiting: "è»Œé“é‹è¡Œ", statusBraking: "ç·Šæ€¥åˆ¶å‹•",
                orbitLock: "ğŸŒ æ½®æ±å›ºå®šè»Œé“", stableOrbit: "å®‰å®šè»Œé“",
                orbitPromptMsg: "æ½®æ±å›ºå®šè»Œé“ã«å…¥ã‚Šã¾ã™ã‹ï¼Ÿ<br>æƒ‘æ˜Ÿã‚’è¦‹ãªãŒã‚‰è‡ªç„¶ã«å‘¨å›ã—ã¾ã™ã€‚",
                confirmOrbit: "âœ“ è»Œé“å›ºå®š",
                msgExpMode: "ä½“é¨“ãƒ¢ãƒ¼ãƒ‰ï¼šè¦³å¯Ÿã—ã‚„ã™ã„è·é›¢ã§ã™ã€‚",
                msgRealMode: "å®Ÿéš›ãƒ¢ãƒ¼ãƒ‰ï¼šå¤ªé™½ç³»ç¸®å°ç‰ˆï¼æƒ‘æ˜ŸãŒé ããªã‚Šã¾ã™ã€‚",
                msgOrbitEntering: "è»Œé“çªå…¥ä¸­... èˆ¹å†…ç§»å‹•ãŒå¯èƒ½ã§ã™ã€‚",
                msgOrbitStable: "å®‰å®šè»Œé“åˆ°é”ï¼",
                msgOrbitExit: "è»Œé“é›¢è„±ï¼æ‰‹å‹•æ“ç¸¦ã«åˆ‡ã‚Šæ›¿ãˆã¾ã™ã€‚",
                msgNeedAuto: "âš ï¸ èˆ¹å†…ç§»å‹•ã¯è‡ªå‹•èˆªæ³•ã¾ãŸã¯è»Œé“ãƒ¢ãƒ¼ãƒ‰ã§ã®ã¿å¯èƒ½ã§ã™ã€‚",
                login: "ãƒ­ã‚°ã‚¤ãƒ³", register: "ç™»éŒ²", logout: "ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ", username: "ãƒ¦ãƒ¼ã‚¶ãƒ¼å", password: "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰",
                welcome: "ã‚ˆã†ã“ã", guest: "ã‚²ã‚¹ãƒˆ", loginFirst: "å…ˆã«ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ãã ã•ã„",
                spaceCoin: "ã‚¹ãƒšãƒ¼ã‚¹ã‚³ã‚¤ãƒ³", price: "ä¾¡æ ¼", buy: "è³¼å…¥", owned: "æ‰€æŒ", freeShip: "åˆæœŸ",
                notEnoughCoins: "ã‚³ã‚¤ãƒ³ãŒè¶³ã‚Šã¾ã›ã‚“ï¼", alreadyOwned: "æ—¢ã«æ‰€æŒã—ã¦ã„ã¾ã™ï¼",
                purchased: "è³¼å…¥å®Œäº†ï¼", reward: "å ±é…¬",
                shipParked: "å®‡å®™èˆ¹é§æ©Ÿä¸­", reboard: "å†æ­ä¹—", goToStation: "ã‚¹ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã¸",
                upgradeAtStation: "ã‚¹ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã§ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰",
                sellShipTitle: "è‰¦èˆ¹å£²å´", currentShip: "ç¾åœ¨ã®è‰¦èˆ¹", sellPrice: "å£²å´ä¾¡æ ¼ (50%)",
                sellAndBoard: "å£²å´ã—ã¦æ­ä¹—", sellMessage: "æ–°ã—ã„å®‡å®™èˆ¹ã«ä¹—ã‚‹ã«ã¯ç¾åœ¨ã®è‰¦èˆ¹ã‚’å£²å´ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚",
                target: "ç›®æ¨™", distance: "è·é›¢", eta: "åˆ°ç€äºˆå®š", speed: "é€Ÿåº¦",
                // å¤©ä½“å
                galacticCenter: "éŠ€æ²³ä¸­å¿ƒ", sun: "å¤ªé™½", mercury: "æ°´æ˜Ÿ", venus: "é‡‘æ˜Ÿ", earth: "åœ°çƒ",
                mars: "ç«æ˜Ÿ", jupiter: "æœ¨æ˜Ÿ", saturn: "åœŸæ˜Ÿ", uranus: "å¤©ç‹æ˜Ÿ", neptune: "æµ·ç‹æ˜Ÿ",
                moon: "æœˆ", phobos: "ãƒ•ã‚©ãƒœã‚¹", deimos: "ãƒ€ã‚¤ãƒ¢ã‚¹", io: "ã‚¤ã‚ª", europa: "ã‚¨ã‚¦ãƒ­ãƒ‘",
                ganymede: "ã‚¬ãƒ‹ãƒ¡ãƒ‡", callisto: "ã‚«ãƒªã‚¹ãƒˆ", titan: "ã‚¿ã‚¤ã‚¿ãƒ³", enceladus: "ã‚¨ãƒ³ã‚±ãƒ©ãƒ‰ã‚¥ã‚¹",
                titania: "ãƒã‚¿ãƒ‹ã‚¢", oberon: "ã‚ªãƒ™ãƒ­ãƒ³", triton: "ãƒˆãƒªãƒˆãƒ³",
                // ã‚¹ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³
                fuelDepotAlpha: "ç‡ƒæ–™è£œçµ¦æ‰€ã‚¢ãƒ«ãƒ•ã‚¡", fuelDepotBeta: "ç‡ƒæ–™è£œçµ¦æ‰€ãƒ™ãƒ¼ã‚¿",
                fuelDepotGamma: "ç‡ƒæ–™è£œçµ¦æ‰€ã‚¬ãƒ³ãƒ", fuelDepotDelta: "ç‡ƒæ–™è£œçµ¦æ‰€ãƒ‡ãƒ«ã‚¿",
                issStation: "ISSå®‡å®™ã‚¹ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³", venusPlatform: "ãƒ´ã‚£ãƒ¼ãƒŠã‚¹ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ", marsStation: "ãƒãƒ¼ã‚ºã‚¹ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³",
                jupiterOutpost: "ã‚¸ãƒ¥ãƒ”ã‚¿ãƒ¼å‰å“¨åŸºåœ°", saturnBase: "ã‚µã‚¿ãƒ¼ãƒ³ãƒ™ãƒ¼ã‚¹",
                uranusRelay: "ã‚¦ãƒ©ãƒã‚¹ãƒªãƒ¬ãƒ¼", neptuneTerminal: "ãƒãƒ—ãƒãƒ¥ãƒ¼ãƒ³ã‚¿ãƒ¼ãƒŸãƒŠãƒ«",
                // ãƒ¡ã‚¤ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼
                singlePlay: "ã‚·ãƒ³ã‚°ãƒ«ãƒ—ãƒ¬ã‚¤", multiPlay: "ãƒãƒ«ãƒãƒ—ãƒ¬ã‚¤", loginBtn: "ãƒ­ã‚°ã‚¤ãƒ³", settings: "è¨­å®š",
                singleDesc: "è‡ªç”±ãªå®‡å®™æ¢æ¤œ â€¢ å¤©ä½“ç”Ÿæˆ â€¢ ç„¡åˆ¶é™",
                multiDesc: "ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒãƒ£ãƒƒãƒˆ â€¢ å…±åŒæ¢æ¤œ â€¢ ç«¶äº‰",
                loginDesc: "ã‚¢ã‚«ã‚¦ãƒ³ãƒˆé€£æº â€¢ é€²è¡Œä¿å­˜ â€¢ ãƒ©ãƒ³ã‚­ãƒ³ã‚°",
                // ãƒŸãƒƒã‚·ãƒ§ãƒ³
                missionBoard: "ãƒŸãƒƒã‚·ãƒ§ãƒ³ãƒœãƒ¼ãƒ‰", missionActive: "é€²è¡Œä¸­", missionAvailable: "å—è«¾å¯èƒ½", missionCompleted: "å®Œäº†",
                // ãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼
                myProfile: "ğŸ‘¤ ãƒã‚¤ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«", dropdownMissions: "ğŸ“‹ ãƒŸãƒƒã‚·ãƒ§ãƒ³ãƒœãƒ¼ãƒ‰", dropdownSettings: "âš™ï¸ è¨­å®š", dropdownLogout: "ğŸšª ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ",
                // å¤©ä½“æƒ…å ±
                bodyRadius: "åŠå¾„", bodyMass: "è³ªé‡", bodyDistance: "è·é›¢", bodyRotation: "è‡ªè»¢é€Ÿåº¦",
                bodySurfaceGravity: "è¡¨é¢é‡åŠ›", bodyOrbitalSpeed: "å…¬è»¢é€Ÿåº¦", bodyMoons: "è¡›æ˜Ÿæ•°", bodyRings: "ãƒªãƒ³ã‚°",
                bodyDetailBtn: "ğŸ“– è©³ç´°", bodyFocusBtn: "ğŸ¯ è¿½è·¡", bodyNavBtn: "ğŸ§­ èˆªæ³•ç›®æ¨™è¨­å®š",
                bodyBasicInfo: "ğŸ“Š åŸºæœ¬æƒ…å ±", bodyOrbitInfo: "ğŸ›°ï¸ è»Œé“æƒ…å ±", bodyDescription: "ğŸ“ èª¬æ˜",
                // åºƒå‘Šå ±é…¬
                adRewardsTitle: "ğŸ åºƒå‘Šå ±é…¬", watchAd: "ğŸ“º åºƒå‘Šã‚’è¦‹ã‚‹", close: "é–‰ã˜ã‚‹",
                adBoosterTitle: "ğŸš€ 2å€ãƒ–ãƒ¼ã‚¹ã‚¿ãƒ¼", adBoosterDesc: "åŠ é€Ÿã¨æœ€å¤§é€Ÿåº¦2å€ (5åˆ†)",
                adEscapeTitle: "âš¡ ç·Šæ€¥è„±å‡º", adEscapeDesc: "ç„¡æ–™ç·Šæ€¥è„±å‡º1å› (10åˆ†)",
                adExploreTitle: "ğŸ”­ æ¢ç´¢ãƒ¢ãƒ¼ãƒ‰", adExploreDesc: "ãƒ•ãƒªãƒ¼ã‚«ãƒ¡ãƒ©æ¢ç´¢ (3åˆ†ã€ç´¯ç©å¯èƒ½)",
                // å¤©ä½“ç”Ÿæˆ
                dragToSetVelocity: "ğŸ‘† çŸ¢å°ã®å…ˆç«¯ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦æ–¹å‘ã¨é€Ÿåº¦ã‚’è¨­å®š",
                // è¿½åŠ UIãƒ†ã‚­ã‚¹ãƒˆ
                overwrite: "ä¸Šæ›¸ã", delete: "å‰Šé™¤", chatConnected: "ãƒãƒ£ãƒƒãƒˆæ¥ç¶šæ¸ˆã¿",
                radioConnecting: "ğŸ“¡ æ¥ç¶šä¸­...", radioConnectionFailed: "âš ï¸ æ¥ç¶šå¤±æ•— - å†è©¦è¡Œã—ã¦ãã ã•ã„",
                radioPlaybackFailed: "âš ï¸ å†ç”Ÿå¤±æ•— - åˆ¥ã®ãƒãƒ£ãƒ³ãƒãƒ«ã‚’é¸æŠ", playing: "å†ç”Ÿä¸­...",
                orbitalStations: "ğŸ“ è»Œé“ã‚¹ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³", fuelDepots: "â›½ ç‡ƒæ–™è£œçµ¦æ‰€", refueling: "â›½ ç‡ƒæ–™è£œçµ¦ä¸­...",
                selectArmor: "ã‚¢ãƒ¼ãƒãƒ¼é¸æŠ", specialAbility: "ç‰¹æ®Šèƒ½åŠ›", warpAbility: "ãƒ¯ãƒ¼ãƒ—",
                etaLabel: "ETA", user: "ãƒ¦ãƒ¼ã‚¶ãƒ¼",
                // ãƒ­ã‚°ã‚¤ãƒ³/ç™»éŒ²ã‚¨ãƒ©ãƒ¼
                enterEmailPassword: "ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã¨ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„",
                passwordsNotMatch: "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒä¸€è‡´ã—ã¾ã›ã‚“",
                enterNickname: "ãƒ‹ãƒƒã‚¯ãƒãƒ¼ãƒ ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„",
                enterEmailRequired: "ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆèªè¨¼å¿…è¦ï¼‰",
                invalidEmailFormat: "æœ‰åŠ¹ãªãƒ¡ãƒ¼ãƒ«å½¢å¼ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„",
                agreePrivacy: "ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ãƒãƒªã‚·ãƒ¼ã«åŒæ„ã—ã¦ãã ã•ã„",
                agreeTerms: "åˆ©ç”¨è¦ç´„ã«åŒæ„ã—ã¦ãã ã•ã„",
                confirmLogout: "ãƒ­ã‚°ã‚¢ã‚¦ãƒˆã—ã¾ã™ã‹ï¼Ÿ",
                // ID/ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰æ¤œç´¢
                enterRegisteredEmail: "ç™»éŒ²æ™‚ã®ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å…¥åŠ›",
                foundId: "è¦‹ã¤ã‹ã£ãŸID",
                findIdBtn: "IDæ¤œç´¢",
                backToLoginBtn: "â† ãƒ­ã‚°ã‚¤ãƒ³ã«æˆ»ã‚‹",
                enterIdAndEmailDesc: "IDã¨ç™»éŒ²ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å…¥åŠ›",
                newPasswordSetMsg: "æ–°ã—ã„ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒè¨­å®šã•ã‚Œã¾ã—ãŸ",
                changePasswordNote: "ãƒ­ã‚°ã‚¤ãƒ³å¾Œã«ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å¤‰æ›´ã—ã¦ãã ã•ã„",
                resetPasswordBtn: "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆ",
                // ã‚µã‚¦ãƒ³ãƒ‰
                soundOnOff: "ã‚µã‚¦ãƒ³ãƒ‰ ON/OFF",
                // ãƒ©ã‚¸ã‚ª
                spaceStation: "å®‡å®™ã‚¹ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³",
                radio: "ğŸ“» ãƒ©ã‚¸ã‚ª", radioShort: "ğŸ“»",
                // è»Œé“
                orbitSuffixText: " è»Œé“",
                // è¿½åŠ ã‚¨ãƒ©ãƒ¼/ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                on: "ON", off: "OFF",
                connectingServer: "ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šä¸­... ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„",
                emailAlreadyRegistered: "æ—¢ã«ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã§ã™",
                enterValidEmail: "æœ‰åŠ¹ãªãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„",
                registrationComplete: "ç™»éŒ²å®Œäº†ï¼ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ãã ã•ã„",
                serverConnectionFailed: "ã‚µãƒ¼ãƒãƒ¼æ¥ç¶šå¤±æ•—: ",
                enterEmailExample: "ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ (ä¾‹: user@example.com)",
                invalidEmailOrPassword: "ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã¾ãŸã¯ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“",
                loginFailed: "ãƒ­ã‚°ã‚¤ãƒ³å¤±æ•—: ",
                stop: "â¹ï¸ åœæ­¢",
                // è¨­å®š
                settings: "âš™ï¸ è¨­å®š", sound: "ğŸ”Š ã‚µã‚¦ãƒ³ãƒ‰", graphics: "ğŸ¨ ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯", language: "ğŸŒ è¨€èª",
                graphicsLow: "ä½", graphicsMedium: "ä¸­", graphicsHigh: "é«˜",
                // å¤©ä½“æƒ…å ±ãƒ¢ãƒ¼ãƒ€ãƒ«
                infoBasicInfo: "åŸºæœ¬æƒ…å ±", infoType: "ã‚¿ã‚¤ãƒ—", infoOrbit: "å…¬è»¢", infoGravity: "é‡åŠ›", infoTemp: "æ°—æ¸©",
                terraformingStatus: "ãƒ†ãƒ©ãƒ•ã‚©ãƒ¼ãƒŸãƒ³ã‚°çŠ¶æ…‹", infrastructure: "ã‚¤ãƒ³ãƒ•ãƒ©",
                unexplored: "æœªæ¢æŸ»", unknownValue: "ä¸æ˜", days: "æ—¥",
                infraSpaceport: "å®‡å®™æ¸¯", infraFuel: "ç‡ƒæ–™", infraRepair: "ä¿®ç†", infraShop: "ã‚·ãƒ§ãƒƒãƒ—", infraResearch: "ç ”ç©¶", infraMining: "æ¡æ˜",
                // ãƒŸãƒƒã‚·ãƒ§ãƒ³é–¢é€£
                accept: "âœ“ å—è«¾", decline: "âœ• æ‹’å¦", later: "å¾Œã§",
                // ãƒ‰ãƒƒã‚­ãƒ³ã‚°
                docking: "ãƒ‰ãƒƒã‚­ãƒ³ã‚°", refuelMenu: "â›½ ç‡ƒæ–™è£œçµ¦", refuelingProgress: "â›½ ç‡ƒæ–™è£œçµ¦ä¸­...",
                goToStationBtn: "ç§»å‹•",
                // è¡çª/å¢œè½
                crashWarning: "å¢œè½å±é™º!", hullDestroyed: "èˆ¹ä½“ç ´å£Š!",
                // ç”»é¢å›è»¢
                rotateScreen: "ç”»é¢ã‚’æ¨ªå‘ãã«ã—ã¦ãã ã•ã„",
                rotateScreenSub: "æ“ç¸¦ãƒ¢ãƒ¼ãƒ‰ã¯æ¨ªç”»é¢ã®ã¿å¯¾å¿œã—ã¦ã„ã¾ã™",
                // ä¿å­˜ã•ã‚ŒãŸå®‡å®™èˆ¹
                savedShipFound: "ä¿å­˜ã•ã‚ŒãŸå®‡å®™èˆ¹ã‚’ç™ºè¦‹!",
                fuelPercent: "â›½ ç‡ƒæ–™",
                restoreShip: "ã“ã®ä½ç½®ã‹ã‚‰æ­ä¹—",
                newShipStart: "ã‚¹ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã‹ã‚‰æ–°è¦é–‹å§‹",
                // æ¥ç¶šè€…
                playersOnline: "ğŸŸ¢ ã‚ªãƒ³ãƒ©ã‚¤ãƒ³",
                playersCount: "äºº",
                // åºƒå‘Š
                activated: "âœ… æœ‰åŠ¹åŒ–æ¸ˆã¿", watchAdBtn: "ğŸ“º åºƒå‘Šã‚’è¦‹ã‚‹",
                // è³¼å…¥ç¢ºèª
                confirmPurchase: "è³¼å…¥ã—ã¾ã™ã‹?",
                coinsUnit: "ã‚³ã‚¤ãƒ³",
                // ãƒªã‚»ãƒƒãƒˆ
                confirmResetSolar: "å¤ªé™½ç³»ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹?",
                resetSolarDesc: "è¿½åŠ ã•ã‚ŒãŸå¤©ä½“ãŒã™ã¹ã¦å‰Šé™¤ã•ã‚Œã€å…ƒã®çŠ¶æ…‹ã«å¾©å…ƒã•ã‚Œã¾ã™ã€‚",
                resetSolarSystem: "ğŸ”„ å¤ªé™½ç³»ãƒªã‚»ãƒƒãƒˆ",
                // èªè¨¼é–¢é€£
                noAuthInfo: "èªè¨¼æƒ…å ±ãŒã‚ã‚Šã¾ã›ã‚“ã€‚å†åº¦ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ãã ã•ã„ã€‚",
                verifying: "ç¢ºèªä¸­...",
                emailPending: "âŒ ãƒ¡ãƒ¼ãƒ«èªè¨¼å¾…ã¡ã€‚å—ä¿¡ãƒˆãƒ¬ã‚¤ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚",
                loginFailedMsg: "âŒ ãƒ­ã‚°ã‚¤ãƒ³å¤±æ•—: ",
                verified: "âœ… èªè¨¼å®Œäº†! ãƒ­ã‚°ã‚¤ãƒ³ä¸­...",
                serverError: "âŒ ã‚µãƒ¼ãƒãƒ¼ã‚¨ãƒ©ãƒ¼: ",
                emailNotFound: "ãƒ¡ãƒ¼ãƒ«æƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚",
                sendingEmail: "ãƒ¡ãƒ¼ãƒ«é€ä¿¡ä¸­...",
                resendFailed: "âŒ å†é€ä¿¡å¤±æ•—: ",
                resendSuccess: "âœ… èªè¨¼ãƒ¡ãƒ¼ãƒ«ã‚’å†é€ä¿¡ã—ã¾ã—ãŸã€‚å—ä¿¡ãƒˆãƒ¬ã‚¤ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚",
                // é–‰ã˜ã‚‹
                closeBtn: "âœ• é–‰ã˜ã‚‹",
                // æ­¦è£…
                damage: "ãƒ€ãƒ¡ãƒ¼ã‚¸", fireRate: "ç™ºå°„é€Ÿåº¦", range: "å°„ç¨‹", energy: "ã‚¨ãƒãƒ«ã‚®ãƒ¼",
                tier: "ãƒ†ã‚£ã‚¢", defense: "é˜²å¾¡", hpBonus: "HPãƒœãƒ¼ãƒŠã‚¹", weightFactor: "é‡é‡",
                owned: "æ‰€æŒä¸­", ownedMark: "âœ“ æ‰€æŒ", locked: "ãƒ­ãƒƒã‚¯",
                // è¿½åŠ 
                noEscapeTicket: "è„±å‡ºåˆ¸ãªã—", chargeComplete: "âœ… å……é›»å®Œäº†", minutes: "åˆ†",
                trackingMode: "è¿½è·¡ãƒ¢ãƒ¼ãƒ‰", observatory: "ğŸ”­ å±•æœ›å°", undock: "ğŸš€ åˆ‡é›¢",
            },
            zh: {
                distExp: "è·ç¦»: ä½“éªŒ", distReal: "è·ç¦»: å®é™… (50x)",
                station: "ğŸ›°ï¸ ç©ºé—´ç«™", catalog: "ğŸ“– å›¾é‰´", fullscreen: "â›¶ å…¨å±", windowMode: "â›¶ çª—å£",
                fine: "ç²¾å¯†(0~2x)", fast: "é«˜é€Ÿ(1~100x)",
                bodyList: "å¤©ä½“åˆ—è¡¨", catalogTitle: "ğŸŒŒ å¤©ä½“å›¾é‰´ (ç‚¹å‡»ç”Ÿæˆ)",
                boardShip: "ğŸš€ ç™»èˆ¹", selectShip: "ğŸš€ é€‰æ‹©é£èˆ¹",
                maxSpeed: "æœ€é«˜é€Ÿåº¦", accelStat: "åŠ é€ŸåŠ›", turnRate: "è½¬å‘åŠ›", fuel: "ç‡ƒæ–™",
                launch: "å‡ºå‡»", cancel: "âœ• å–æ¶ˆ",
                accel: "åŠ é€Ÿ", reverse: "åæ¨", thrust: "æ¨è¿›", emergencyBrake: "ğŸ”¥<br>ç´§æ€¥åˆ¶åŠ¨",
                auto: "ğŸ¤– è‡ªåŠ¨", orbitEntry: "ğŸŒ å…¥è½¨", orbitExit: "ğŸŒ è„±è½¨",
                interior: "ğŸšª èˆ±å†…", emergency: "ğŸ†˜ ç´§æ€¥é€ƒç”Ÿ", disembark: "âœ• ä¸‹èˆ¹",
                none: "æ— ", viewAll: "ğŸ”­ å…¨æ™¯",
                status: "çŠ¶æ€", statusNominal: "æ­£å¸¸", statusAuto: "è‡ªåŠ¨èˆªè¡Œ", statusLowFuel: "ç‡ƒæ–™ä¸è¶³",
                statusCruising: "å·¡èˆªä¸­", statusOrbiting: "è½¨é“è¿è¡Œ", statusBraking: "ç´§æ€¥åˆ¶åŠ¨",
                orbitLock: "ğŸŒ æ½®æ±é”å®šè½¨é“", stableOrbit: "ç¨³å®šè½¨é“",
                orbitPromptMsg: "è¿›å…¥æ½®æ±é”å®šè½¨é“ï¼Ÿ<br>é£èˆ¹å°†é¢å‘è¡Œæ˜Ÿè‡ªç„¶ç¯ç»•ã€‚",
                confirmOrbit: "âœ“ é”å®šè½¨é“",
                msgExpMode: "ä½“éªŒæ¨¡å¼ï¼šä¾¿äºè§‚å¯Ÿçš„è·ç¦»ã€‚",
                msgRealMode: "å®é™…æ¨¡å¼ï¼šå¤ªé˜³ç³»ç¼©å°ç‰ˆï¼è¡Œæ˜Ÿé—´è·ç¦»å¾ˆè¿œã€‚",
                msgOrbitEntering: "æ­£åœ¨å…¥è½¨... å¯è¿›å…¥èˆ±å†…ã€‚",
                msgOrbitStable: "å·²åˆ°è¾¾ç¨³å®šè½¨é“ï¼",
                msgOrbitExit: "å·²è„±ç¦»è½¨é“ï¼åˆ‡æ¢åˆ°æ‰‹åŠ¨æ§åˆ¶ã€‚",
                msgNeedAuto: "âš ï¸ ä»…åœ¨è‡ªåŠ¨é©¾é©¶æˆ–è½¨é“æ¨¡å¼ä¸‹å¯è¿›å…¥èˆ±å†…ã€‚",
                login: "ç™»å½•", register: "æ³¨å†Œ", logout: "ç™»å‡º", username: "ç”¨æˆ·å", password: "å¯†ç ",
                welcome: "æ¬¢è¿", guest: "æ¸¸å®¢", loginFirst: "è¯·å…ˆç™»å½•",
                spaceCoin: "å¤ªç©ºå¸", price: "ä»·æ ¼", buy: "è´­ä¹°", owned: "å·²æ‹¥æœ‰", freeShip: "åˆå§‹",
                notEnoughCoins: "é‡‘å¸ä¸è¶³ï¼", alreadyOwned: "å·²æ‹¥æœ‰ï¼",
                purchased: "è´­ä¹°æˆåŠŸï¼", reward: "å¥–åŠ±",
                shipParked: "é£èˆ¹åœæ”¾ä¸­", reboard: "é‡æ–°ç™»èˆ¹", goToStation: "å‰å¾€ç©ºé—´ç«™",
                upgradeAtStation: "åœ¨ç©ºé—´ç«™å‡çº§",
                sellShipTitle: "å‡ºå”®é£èˆ¹", currentShip: "å½“å‰é£èˆ¹", sellPrice: "å‡ºå”®ä»·æ ¼ (50%)",
                sellAndBoard: "å‡ºå”®å¹¶ç™»èˆ¹", sellMessage: "ç™»ä¸Šæ–°é£èˆ¹å‰éœ€è¦å‡ºå”®å½“å‰é£èˆ¹ã€‚",
                target: "ç›®æ ‡", distance: "è·ç¦»", eta: "é¢„è®¡åˆ°è¾¾", speed: "é€Ÿåº¦",
                // å¤©ä½“åç§°
                galacticCenter: "é“¶æ²³ä¸­å¿ƒ", sun: "å¤ªé˜³", mercury: "æ°´æ˜Ÿ", venus: "é‡‘æ˜Ÿ", earth: "åœ°çƒ",
                mars: "ç«æ˜Ÿ", jupiter: "æœ¨æ˜Ÿ", saturn: "åœŸæ˜Ÿ", uranus: "å¤©ç‹æ˜Ÿ", neptune: "æµ·ç‹æ˜Ÿ",
                moon: "æœˆçƒ", phobos: "ç«å«ä¸€", deimos: "ç«å«äºŒ", io: "æœ¨å«ä¸€", europa: "æœ¨å«äºŒ",
                ganymede: "æœ¨å«ä¸‰", callisto: "æœ¨å«å››", titan: "åœŸå«å…­", enceladus: "åœŸå«äºŒ",
                titania: "å¤©å«ä¸‰", oberon: "å¤©å«å››", triton: "æµ·å«ä¸€",
                // ç©ºé—´ç«™
                fuelDepotAlpha: "åŠ æ²¹ç«™é˜¿å°”æ³•", fuelDepotBeta: "åŠ æ²¹ç«™è´å¡”",
                fuelDepotGamma: "åŠ æ²¹ç«™ä¼½é©¬", fuelDepotDelta: "åŠ æ²¹ç«™å¾·å°”å¡”",
                issStation: "å›½é™…ç©ºé—´ç«™", venusPlatform: "é‡‘æ˜Ÿå¹³å°", marsStation: "ç«æ˜Ÿç«™",
                jupiterOutpost: "æœ¨æ˜Ÿå‰å“¨", saturnBase: "åœŸæ˜ŸåŸºåœ°",
                uranusRelay: "å¤©ç‹æ˜Ÿä¸­ç»§ç«™", neptuneTerminal: "æµ·ç‹æ˜Ÿç»ˆç«¯",
                // ä¸»èœå•
                singlePlay: "å•äººæ¸¸æˆ", multiPlay: "å¤šäººæ¸¸æˆ", loginBtn: "ç™»å½•", settings: "è®¾ç½®",
                singleDesc: "è‡ªç”±å¤ªç©ºæ¢ç´¢ â€¢ åˆ›å»ºå¤©ä½“ â€¢ æ— é™åˆ¶",
                multiDesc: "å®æ—¶èŠå¤© â€¢ åˆä½œæ¢ç´¢ â€¢ ç«äº‰",
                loginDesc: "è´¦å·åŒæ­¥ â€¢ ä¿å­˜è¿›åº¦ â€¢ æ’è¡Œæ¦œ",
                // ä»»åŠ¡
                missionBoard: "ä»»åŠ¡æ¿", missionActive: "è¿›è¡Œä¸­", missionAvailable: "å¯æ¥å—", missionCompleted: "å·²å®Œæˆ",
                // ä¸‹æ‹‰èœå•
                myProfile: "ğŸ‘¤ æˆ‘çš„èµ„æ–™", dropdownMissions: "ğŸ“‹ ä»»åŠ¡æ¿", dropdownSettings: "âš™ï¸ è®¾ç½®", dropdownLogout: "ğŸšª é€€å‡ºç™»å½•",
                // è®¾ç½®
                sound: "ğŸ”Š å£°éŸ³", graphics: "ğŸ¨ å›¾å½¢", language: "ğŸŒ è¯­è¨€",
                graphicsLow: "ä½", graphicsMedium: "ä¸­", graphicsHigh: "é«˜",
                // å¤©ä½“ä¿¡æ¯æ¨¡æ€
                infoBasicInfo: "åŸºæœ¬ä¿¡æ¯", infoType: "ç±»å‹", infoOrbit: "å…¬è½¬", infoGravity: "é‡åŠ›", infoTemp: "æ¸©åº¦",
                terraformingStatus: "æ”¹é€ çŠ¶æ€", infrastructure: "åŸºç¡€è®¾æ–½",
                unexplored: "æœªæ¢ç´¢", unknownValue: "æœªçŸ¥", days: "å¤©",
                infraSpaceport: "å¤ªç©ºæ¸¯", infraFuel: "ç‡ƒæ–™", infraRepair: "ç»´ä¿®", infraShop: "å•†åº—", infraResearch: "ç ”ç©¶", infraMining: "é‡‡çŸ¿",
                // ä»»åŠ¡ç›¸å…³
                accept: "âœ“ æ¥å—", decline: "âœ• æ‹’ç»", later: "ç¨å",
                // å¯¹æ¥
                docking: "å¯¹æ¥", refuelMenu: "â›½ åŠ æ²¹", refuelingProgress: "â›½ åŠ æ²¹ä¸­...",
                goToStationBtn: "å‰å¾€",
                // ç¢°æ’
                crashWarning: "å æ¯å±é™©!", hullDestroyed: "èˆ¹ä½“æ¯å!",
                // å±å¹•æ—‹è½¬
                rotateScreen: "è¯·å°†å±å¹•æ¨ªå‘",
                rotateScreenSub: "é©¾é©¶æ¨¡å¼ä»…æ”¯æŒæ¨ªå±",
                // ä¿å­˜çš„é£èˆ¹
                savedShipFound: "å‘ç°ä¿å­˜çš„é£èˆ¹!",
                fuelPercent: "â›½ ç‡ƒæ–™",
                restoreShip: "ä»æ­¤ä½ç½®ç™»èˆ¹",
                newShipStart: "ä»ç©ºé—´ç«™é‡æ–°å¼€å§‹",
                // åœ¨çº¿äººæ•°
                playersOnline: "ğŸŸ¢ åœ¨çº¿",
                playersCount: "äºº",
                // å¹¿å‘Š
                activated: "âœ… å·²æ¿€æ´»", watchAdBtn: "ğŸ“º çœ‹å¹¿å‘Š",
                // è´­ä¹°ç¡®è®¤
                confirmPurchase: "ç¡®å®šè´­ä¹°å—?",
                coinsUnit: "é‡‘å¸",
                // é‡ç½®
                confirmResetSolar: "é‡ç½®å¤ªé˜³ç³»å—?",
                resetSolarDesc: "æ‰€æœ‰æ·»åŠ çš„å¤©ä½“å°†è¢«åˆ é™¤å¹¶æ¢å¤åŸå§‹çŠ¶æ€ã€‚",
                resetSolarSystem: "ğŸ”„ é‡ç½®å¤ªé˜³ç³»",
                // è®¤è¯ç›¸å…³
                noAuthInfo: "æ— è®¤è¯ä¿¡æ¯ï¼Œè¯·é‡æ–°ç™»å½•ã€‚",
                verifying: "éªŒè¯ä¸­...",
                emailPending: "âŒ é‚®ç®±éªŒè¯ä¸­ï¼Œè¯·æ£€æŸ¥æ”¶ä»¶ç®±ã€‚",
                loginFailedMsg: "âŒ ç™»å½•å¤±è´¥: ",
                verified: "âœ… éªŒè¯æˆåŠŸ! ç™»å½•ä¸­...",
                serverError: "âŒ æœåŠ¡å™¨é”™è¯¯: ",
                emailNotFound: "æœªæ‰¾åˆ°é‚®ç®±ä¿¡æ¯ã€‚",
                sendingEmail: "å‘é€é‚®ä»¶ä¸­...",
                resendFailed: "âŒ é‡å‘å¤±è´¥: ",
                resendSuccess: "âœ… éªŒè¯é‚®ä»¶å·²é‡å‘ï¼Œè¯·æ£€æŸ¥æ”¶ä»¶ç®±ã€‚",
                // å…³é—­
                closeBtn: "âœ• å…³é—­",
                // æ­¦è£…
                damage: "ä¼¤å®³", fireRate: "å°„é€Ÿ", range: "å°„ç¨‹", energy: "èƒ½é‡",
                tier: "ç­‰çº§", defense: "é˜²å¾¡", hpBonus: "HPåŠ æˆ", weightFactor: "é‡é‡",
                owned: "å·²æ‹¥æœ‰", ownedMark: "âœ“ æ‹¥æœ‰", locked: "é”å®š",
                // è¿½åŠ 
                noEscapeTicket: "æ— é€ƒç”Ÿç¥¨", chargeComplete: "âœ… å……ç”µå®Œæˆ", minutes: "åˆ†é’Ÿ",
                trackingMode: "è¿½è¸ªæ¨¡å¼", observatory: "ğŸ”­ è§‚æ™¯å°", undock: "ğŸš€ è„±ç¦»",
            },
            fr: {
                distExp: "Dist: ExpÃ©rience", distReal: "Dist: RÃ©el (50x)",
                station: "ğŸ›°ï¸ Station", catalog: "ğŸ“– Catalogue", fullscreen: "â›¶ Plein Ã©cran", windowMode: "â›¶ FenÃªtre",
                fine: "Fin(0~2x)", fast: "Rapide(1~100x)",
                bodyList: "Corps cÃ©lestes", catalogTitle: "ğŸŒŒ Catalogue cÃ©leste (Cliquer pour crÃ©er)",
                boardShip: "ğŸš€ Embarquer", selectShip: "ğŸš€ Choisir vaisseau",
                maxSpeed: "Vitesse max", accelStat: "AccÃ©lÃ©ration", turnRate: "Virage", fuel: "Carburant",
                launch: "Lancer", cancel: "âœ• Annuler",
                accel: "AccÃ©l", reverse: "RÃ©tro", thrust: "PoussÃ©e", emergencyBrake: "ğŸ”¥<br>Frein Urg",
                auto: "ğŸ¤– Auto", orbitEntry: "ğŸŒ Orbite", orbitExit: "ğŸŒ Quitter orbite",
                interior: "ğŸšª IntÃ©rieur", emergency: "ğŸ†˜ Ã‰vasion", disembark: "âœ• Sortir",
                none: "Aucun", viewAll: "ğŸ”­ Vue globale",
                status: "Ã‰TAT", statusNominal: "NORMAL", statusAuto: "AUTO", statusLowFuel: "CARBURANT BAS",
                statusCruising: "CROISIÃˆRE", statusOrbiting: "EN ORBITE", statusBraking: "FREINAGE",
                orbitLock: "ğŸŒ Orbite verrouillÃ©e", stableOrbit: "Orbite stable",
                orbitPromptMsg: "Entrer en orbite verrouillÃ©e?<br>Le vaisseau orbite naturellement face Ã  la planÃ¨te.",
                confirmOrbit: "âœ“ Verrouiller",
                msgExpMode: "Mode expÃ©rience: Distance facile Ã  observer.",
                msgRealMode: "Mode rÃ©el: SystÃ¨me solaire Ã  l'Ã©chelle! Les planÃ¨tes sont Ã©loignÃ©es.",
                msgOrbitEntering: "EntrÃ©e en orbite... AccÃ¨s intÃ©rieur activÃ©.",
                msgOrbitStable: "Orbite stable atteinte!",
                msgOrbitExit: "Orbite quittÃ©e! ContrÃ´le manuel activÃ©.",
                msgNeedAuto: "âš ï¸ AccÃ¨s intÃ©rieur uniquement en pilote auto ou orbite.",
                login: "Connexion", register: "Inscription", logout: "DÃ©connexion", username: "Identifiant", password: "Mot de passe",
                welcome: "Bienvenue", guest: "InvitÃ©", loginFirst: "Connectez-vous d'abord",
                spaceCoin: "SpaceCoin", price: "Prix", buy: "Acheter", owned: "PossÃ©dÃ©", freeShip: "Gratuit",
                notEnoughCoins: "Pas assez de piÃ¨ces!", alreadyOwned: "DÃ©jÃ  possÃ©dÃ©!",
                purchased: "AchetÃ©!", reward: "RÃ©compense",
                shipParked: "Vaisseau garÃ©", reboard: "Remonter", goToStation: "Aller Ã  la Station",
                upgradeAtStation: "AmÃ©liorer Ã  la Station",
                sellShipTitle: "Vendre Vaisseau", currentShip: "Vaisseau actuel", sellPrice: "Prix de vente (50%)",
                sellAndBoard: "Vendre et Embarquer", sellMessage: "Vous devez vendre votre vaisseau actuel pour en embarquer un nouveau.",
                target: "Cible", distance: "Distance", eta: "ArrivÃ©e", speed: "Vitesse",
                // Corps cÃ©lestes
                galacticCenter: "Centre Galactique", sun: "Soleil", mercury: "Mercure", venus: "VÃ©nus", earth: "Terre",
                mars: "Mars", jupiter: "Jupiter", saturn: "Saturne", uranus: "Uranus", neptune: "Neptune",
                moon: "Lune", phobos: "Phobos", deimos: "DÃ©imos", io: "Io", europa: "Europe",
                ganymede: "GanymÃ¨de", callisto: "Callisto", titan: "Titan", enceladus: "Encelade",
                titania: "Titania", oberon: "ObÃ©ron", triton: "Triton",
                // Stations
                fuelDepotAlpha: "DÃ©pÃ´t Alpha", fuelDepotBeta: "DÃ©pÃ´t BÃªta",
                fuelDepotGamma: "DÃ©pÃ´t Gamma", fuelDepotDelta: "DÃ©pÃ´t Delta",
                issStation: "Station ISS", venusPlatform: "Plateforme VÃ©nus", marsStation: "Station Mars",
                jupiterOutpost: "Avant-poste Jupiter", saturnBase: "Base Saturne",
                uranusRelay: "Relais Uranus", neptuneTerminal: "Terminal Neptune",
                // Menu principal
                singlePlay: "Solo", multiPlay: "Multijoueur", loginBtn: "Connexion", settings: "ParamÃ¨tres",
                singleDesc: "Exploration libre â€¢ CrÃ©ation â€¢ IllimitÃ©",
                multiDesc: "Chat en direct â€¢ Co-op â€¢ CompÃ©tition",
                loginDesc: "Sync compte â€¢ Sauvegarde â€¢ Classement",
                // Missions
                missionBoard: "Tableau de missions", missionActive: "En cours", missionAvailable: "Disponible", missionCompleted: "TerminÃ©",
                // Menu dÃ©roulant
                myProfile: "ğŸ‘¤ Mon profil", dropdownMissions: "ğŸ“‹ Missions", dropdownSettings: "âš™ï¸ ParamÃ¨tres", dropdownLogout: "ğŸšª DÃ©connexion",
                // ParamÃ¨tres
                sound: "ğŸ”Š Son", graphics: "ğŸ¨ Graphiques", language: "ğŸŒ Langue",
                graphicsLow: "Bas", graphicsMedium: "Moyen", graphicsHigh: "Haut",
                // Modal info cÃ©leste
                infoBasicInfo: "Info de base", infoType: "Type", infoOrbit: "Orbite", infoGravity: "GravitÃ©", infoTemp: "Temp",
                terraformingStatus: "Ã‰tat terraformation", infrastructure: "Infrastructure",
                unexplored: "Non explorÃ©", unknownValue: "Inconnu", days: "jours",
                infraSpaceport: "Spatioport", infraFuel: "Carburant", infraRepair: "RÃ©paration", infraShop: "Boutique", infraResearch: "Recherche", infraMining: "Minage",
                // Mission
                accept: "âœ“ Accepter", decline: "âœ• Refuser", later: "Plus tard",
                // Amarrage
                docking: "Amarrage", refuelMenu: "â›½ Ravitailler", refuelingProgress: "â›½ Ravitaillement...",
                goToStationBtn: "Aller",
                // Collision
                crashWarning: "Danger de crash!", hullDestroyed: "Coque dÃ©truite!",
                // Rotation Ã©cran
                rotateScreen: "Tournez l'Ã©cran en mode paysage",
                rotateScreenSub: "Le mode pilotage ne supporte que le mode paysage",
                // Vaisseau sauvegardÃ©
                savedShipFound: "Vaisseau sauvegardÃ© trouvÃ©!",
                fuelPercent: "â›½ Carburant",
                restoreShip: "Embarquer ici",
                newShipStart: "Repartir de la station",
                // Joueurs en ligne
                playersOnline: "ğŸŸ¢ En ligne",
                playersCount: "joueurs",
                // Pub
                activated: "âœ… ActivÃ©", watchAdBtn: "ğŸ“º Voir la pub",
                // Confirmation achat
                confirmPurchase: "Acheter?",
                coinsUnit: "piÃ¨ces",
                // Reset
                confirmResetSolar: "RÃ©initialiser le systÃ¨me solaire?",
                resetSolarDesc: "Tous les corps ajoutÃ©s seront supprimÃ©s.",
                resetSolarSystem: "ğŸ”„ RÃ©initialiser systÃ¨me solaire",
                // Auth
                noAuthInfo: "Pas d'info auth. Reconnectez-vous.",
                verifying: "VÃ©rification...",
                emailPending: "âŒ VÃ©rification email en attente.",
                loginFailedMsg: "âŒ Ã‰chec connexion: ",
                verified: "âœ… VÃ©rifiÃ©! Connexion...",
                serverError: "âŒ Erreur serveur: ",
                emailNotFound: "Email non trouvÃ©.",
                sendingEmail: "Envoi email...",
                resendFailed: "âŒ Ã‰chec renvoi: ",
                resendSuccess: "âœ… Email de vÃ©rification renvoyÃ©.",
                // Fermer
                closeBtn: "âœ• Fermer",
                // Armement
                damage: "DÃ©gÃ¢ts", fireRate: "Cadence", range: "PortÃ©e", energy: "Ã‰nergie",
                tier: "Niveau", defense: "DÃ©fense", hpBonus: "Bonus HP", weightFactor: "Poids",
                owned: "PossÃ©dÃ©", ownedMark: "âœ“ PossÃ©dÃ©", locked: "VerrouillÃ©",
                // SupplÃ©mentaire
                noEscapeTicket: "Pas de billet", chargeComplete: "âœ… ChargÃ©", minutes: "min",
                trackingMode: "Mode suivi", observatory: "ğŸ”­ Observatoire", undock: "ğŸš€ DÃ©samarrer",
            },
            la: {
                distExp: "Dist: Experientia", distReal: "Dist: Verum (50x)",
                station: "ğŸ›°ï¸ Statio", catalog: "ğŸ“– Catalogus", fullscreen: "â›¶ Plenus", windowMode: "â›¶ Fenestra",
                fine: "Subtilis(0~2x)", fast: "Velox(1~100x)",
                bodyList: "Corpora Caelestia", catalogTitle: "ğŸŒŒ Catalogus Caelestis (Preme ad creandum)",
                boardShip: "ğŸš€ Ascende Navem", selectShip: "ğŸš€ Elige Navem",
                maxSpeed: "Velocitas Max", accelStat: "Acceleratio", turnRate: "Conversio", fuel: "Combustibile",
                launch: "Emitte", cancel: "âœ• Abnega",
                accel: "Accel", reverse: "Retro", thrust: "Impulsus", emergencyBrake: "ğŸ”¥<br>Frena",
                auto: "ğŸ¤– Auto", orbitEntry: "ğŸŒ Orbita", orbitExit: "ğŸŒ Exi Orbita",
                interior: "ğŸšª Interior", emergency: "ğŸ†˜ Fuga", disembark: "âœ• Descende",
                none: "Nullus", viewAll: "ğŸ”­ Omnia Vide",
                status: "STATUS", statusNominal: "BONUS", statusAuto: "AUTO", statusLowFuel: "PARUM",
                statusCruising: "NAVIGANS", statusOrbiting: "ORBITANS", statusBraking: "FRENANS",
                orbitLock: "ğŸŒ Orbita Fixa", stableOrbit: "Orbita Stabilis",
                orbitPromptMsg: "Intrare orbitam fixam?<br>Navis naturaliter orbitat versus planetam.",
                confirmOrbit: "âœ“ Fige Orbitam",
                msgExpMode: "Modus Experientiae: Distantia facilis ad observandum.",
                msgRealMode: "Modus Verus: Systema Solare! Planetae longe sunt.",
                msgOrbitEntering: "Intrans orbitam... Accessus interior activatus.",
                msgOrbitStable: "Orbita stabilis attacta!",
                msgOrbitExit: "Orbita relicta! Imperium manuale activatum.",
                msgNeedAuto: "âš ï¸ Accessus interior solum in autopilota vel orbita.",
                // ë¡œê·¸ì¸
                login: "Intra", register: "Inscribe", logout: "Exi", username: "Nomen", password: "Signum",
                welcome: "Salve", guest: "Hospes", loginFirst: "Prius inscribe",
                // ìŠ¤í˜ì´ìŠ¤ì½”ì¸
                spaceCoin: "Nummus Spatialis", price: "Pretium", buy: "Eme", owned: "Possessum", freeShip: "Gratis",
                notEnoughCoins: "Pecunia insufficiens!", alreadyOwned: "Iam possides!",
                purchased: "Emptum!", reward: "Praemium",
                // ìš°ì£¼ì„ 
                shipParked: "Navis relicta", reboard: "Reascende", goToStation: "I ad stationem",
                upgradeAtStation: "Ad stationem meliora",
                sellShipTitle: "Vende Navem", currentShip: "Navis praesens", sellPrice: "Pretium venditionis (50%)",
                sellAndBoard: "Vende et Ascende", sellMessage: "Navem praesentem vendere debes ut novam ascendas.",
                // HUD
                target: "Scopus", distance: "Distantia", eta: "Tempus", speed: "Velocitas",
                // Corpora Caelestia
                galacticCenter: "Centrum Galaxiae", sun: "Sol", mercury: "Mercurius", venus: "Venus", earth: "Terra",
                mars: "Mars", jupiter: "Iuppiter", saturn: "Saturnus", uranus: "Uranus", neptune: "Neptunus",
                moon: "Luna", phobos: "Phobos", deimos: "Deimos", io: "Io", europa: "Europa",
                ganymede: "Ganymedes", callisto: "Callisto", titan: "Titan", enceladus: "Enceladus",
                titania: "Titania", oberon: "Oberon", triton: "Triton",
                // Stationes
                fuelDepotAlpha: "Statio Alpha", fuelDepotBeta: "Statio Beta",
                fuelDepotGamma: "Statio Gamma", fuelDepotDelta: "Statio Delta",
                issStation: "Statio ISS", venusPlatform: "Suggestus Veneris", marsStation: "Statio Martis",
                jupiterOutpost: "Praesidium Iovis", saturnBase: "Basis Saturni",
                uranusRelay: "Transmissio Urani", neptuneTerminal: "Terminus Neptuni",
                // Menu Principale
                singlePlay: "Solus", multiPlay: "Multi", loginBtn: "Intra", settings: "Optiones",
                singleDesc: "Exploratio libera â€¢ Creatio â€¢ Infinitum",
                multiDesc: "Colloquium â€¢ Cooperatio â€¢ Certamen",
                loginDesc: "Sync â€¢ Servo â€¢ Ordo",
                // Missiones
                missionBoard: "Tabula Missionum", missionActive: "Activum", missionAvailable: "Praesto", missionCompleted: "Perfectum",
                // Menu
                myProfile: "ğŸ‘¤ Profilo Meum", dropdownMissions: "ğŸ“‹ Missiones", dropdownSettings: "âš™ï¸ Optiones", dropdownLogout: "ğŸšª Exitus",
                // Optiones
                sound: "ğŸ”Š Sonus", graphics: "ğŸ¨ Graphica", language: "ğŸŒ Lingua",
                graphicsLow: "Infimus", graphicsMedium: "Medius", graphicsHigh: "Summus",
                // Info corporum
                infoBasicInfo: "Info Prima", infoType: "Genus", infoOrbit: "Orbita", infoGravity: "Gravitas", infoTemp: "Temperies",
                terraformingStatus: "Status Terraformationis", infrastructure: "Infrastructura",
                unexplored: "Inexplorata", unknownValue: "Ignotum", days: "dies",
                infraSpaceport: "Portus", infraFuel: "Combustibile", infraRepair: "Reparatio", infraShop: "Taberna", infraResearch: "Investigatio", infraMining: "Fodienda",
                // Missiones
                accept: "âœ“ Accipe", decline: "âœ• Recusa", later: "Postea",
                // Iunctio
                docking: "Iunctio", refuelMenu: "â›½ Refice", refuelingProgress: "â›½ Reficiens...",
                goToStationBtn: "Vade",
                // Collisio
                crashWarning: "Periculum ruinae!", hullDestroyed: "Alveus destructus!",
                // Rota
                rotateScreen: "Verte in latus",
                rotateScreenSub: "Modus gubernandi solum horizontalis",
                // Navis servata
                savedShipFound: "Navis servata inventa!",
                fuelPercent: "â›½ Combustibile",
                restoreShip: "Ascende hic",
                newShipStart: "Initium novum a statione",
                // Connexi
                playersOnline: "ğŸŸ¢ Connexi",
                playersCount: "",
                // Nuntius
                activated: "âœ… Activum", watchAdBtn: "ğŸ“º Vide",
                // Emptio
                confirmPurchase: "Emere vis?",
                coinsUnit: "nummi",
                // Reset
                confirmResetSolar: "Renovare systema solare?",
                resetSolarDesc: "Omnia corpora addita delebuntur.",
                resetSolarSystem: "ğŸ”„ Renova systema solare",
                // Auth
                noAuthInfo: "Nulla info. Iterum intra.",
                verifying: "Verificans...",
                emailPending: "âŒ Epistula pendente.",
                loginFailedMsg: "âŒ Intratio defecit: ",
                verified: "âœ… Verificatum! Intrans...",
                serverError: "âŒ Error servientis: ",
                emailNotFound: "Epistula non inventa.",
                sendingEmail: "Mittens epistulam...",
                resendFailed: "âŒ Remissio defecit: ",
                resendSuccess: "âœ… Epistula remissa.",
                // Claude
                closeBtn: "âœ• Claude",
                // Arma
                damage: "Damnum", fireRate: "Celeritas", range: "Spatium", energy: "Energia",
                tier: "Gradus", defense: "Defensio", hpBonus: "HP Bonus", weightFactor: "Pondus",
                owned: "Possessum", ownedMark: "âœ“ Possessum", locked: "Clausum",
                // Addendum
                noEscapeTicket: "Nulla tessera", chargeComplete: "âœ… Paratum", minutes: "min",
                trackingMode: "Modus sequendi", observatory: "ğŸ”­ Speculatorium", undock: "ğŸš€ Dissolve",
            }
        };
        window.translations = translations;  // ì „ì—­ìœ¼ë¡œ ë…¸ì¶œ
        
        // ìš°ì£¼ì„  ì´ë¦„ ë‹¤êµ­ì–´ ì§€ì› í•¨ìˆ˜
        function getShipName(ship) {
            const langMap = { ko: 'name', en: 'nameEn', ja: 'nameJa', zh: 'nameZh', fr: 'nameFr', la: 'nameLa' };
            return ship[langMap[currentLang]] || ship.nameEn || ship.name;
        }
        
        function t(key) {
            const lang = window.currentLang || currentLang;
            return translations[lang][key] || translations['en'][key] || key;
        }
        window.t = t;  // ì „ì—­ìœ¼ë¡œ ë…¸ì¶œ
        
        // â˜…â˜…â˜… ì²œì²´ ì´ë¦„ ë²ˆì—­ í•¨ìˆ˜ â˜…â˜…â˜…
        const bodyNameMap = {
            'ì€í•˜ ì¤‘ì‹¬': 'galacticCenter', 'íƒœì–‘': 'sun', 'ìˆ˜ì„±': 'mercury', 'ê¸ˆì„±': 'venus', 'ì§€êµ¬': 'earth',
            'í™”ì„±': 'mars', 'ëª©ì„±': 'jupiter', 'í† ì„±': 'saturn', 'ì²œì™•ì„±': 'uranus', 'í•´ì™•ì„±': 'neptune',
            'ë‹¬': 'moon', 'í¬ë³´ìŠ¤': 'phobos', 'ë°ì´ëª¨ìŠ¤': 'deimos', 'ì´ì˜¤': 'io', 'ìœ ë¡œíŒŒ': 'europa',
            'ê°€ë‹ˆë©”ë°': 'ganymede', 'ì¹¼ë¦¬ìŠ¤í† ': 'callisto', 'íƒ€ì´íƒ„': 'titan', 'ì—”ì…€ë¼ë‘ìŠ¤': 'enceladus',
            'í‹°íƒ€ë‹ˆì•„': 'titania', 'ì˜¤ë² ë¡ ': 'oberon', 'íŠ¸ë¦¬í†¤': 'triton',
            'ì—°ë£Œì •ê±°ì¥ ì•ŒíŒŒ': 'fuelDepotAlpha', 'ì—°ë£Œì •ê±°ì¥ ë² íƒ€': 'fuelDepotBeta',
            'ì—°ë£Œì •ê±°ì¥ ê°ë§ˆ': 'fuelDepotGamma', 'ì—°ë£Œì •ê±°ì¥ ë¸íƒ€': 'fuelDepotDelta',
            'ISS ìš°ì£¼ì •ê±°ì¥': 'issStation', 'ë¹„ë„ˆìŠ¤ í”Œë«í¼': 'venusPlatform', 'ë§ˆìŠ¤ ìŠ¤í…Œì´ì…˜': 'marsStation',
            'ì£¼í”¼í„° ì•„ì›ƒí¬ìŠ¤íŠ¸': 'jupiterOutpost', 'ìƒˆí„´ ë² ì´ìŠ¤': 'saturnBase',
            'ìš°ë¼ë…¸ìŠ¤ ë¦´ë ˆì´': 'uranusRelay', 'ë„µíŠ  í„°ë¯¸ë„': 'neptuneTerminal',
            'ì•ˆë“œë¡œë©”ë‹¤ì€í•˜': 'andromeda'
        };
        
        function translateBodyName(koreanName) {
            const lang = window.currentLang || currentLang;
            const key = bodyNameMap[koreanName];
            if (key && translations[lang][key]) {
                return translations[lang][key];
            }
            return koreanName;  // ë²ˆì—­ ì—†ìœ¼ë©´ ì›ë³¸ ë°˜í™˜
        }
        window.translateBodyName = translateBodyName;  // ì „ì—­ìœ¼ë¡œ ë…¸ì¶œ
        
        function setLanguage(lang) {
            currentLang = lang;
            window.currentLang = lang;  // ì „ì—­ ë³€ìˆ˜ë„ ì—…ë°ì´íŠ¸
            localStorage.setItem('milkyway-lang', lang);
            
            // data-i18n ì†ì„±ì´ ìˆëŠ” ëª¨ë“  ìš”ì†Œ ì—…ë°ì´íŠ¸
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                if (translations[lang][key]) {
                    el.innerHTML = translations[lang][key];
                }
            });
            
            // placeholder ì—…ë°ì´íŠ¸
            document.querySelectorAll('[data-placeholder-i18n]').forEach(el => {
                const key = el.getAttribute('data-placeholder-i18n');
                if (translations[lang][key]) {
                    el.placeholder = translations[lang][key];
                }
            });
            
            // â˜…â˜…â˜… title ì†ì„± ì—…ë°ì´íŠ¸ â˜…â˜…â˜…
            document.querySelectorAll('[data-i18n-title]').forEach(el => {
                const key = el.getAttribute('data-i18n-title');
                if (translations[lang][key]) {
                    el.title = translations[lang][key];
                }
            });
            
            // â˜…â˜…â˜… 3D ì²œì²´ ë¼ë²¨ ì—…ë°ì´íŠ¸ â˜…â˜…â˜…
            document.querySelectorAll('.label[data-body-name]').forEach(el => {
                const originalName = el.dataset.bodyName;
                if (originalName) {
                    el.textContent = translateBodyName(originalName);
                }
            });
            
            // â˜…â˜…â˜… galaxy-label ì—…ë°ì´íŠ¸ (ì€í•˜ ì¤‘ì‹¬, ì•ˆë“œë¡œë©”ë‹¤) â˜…â˜…â˜…
            document.querySelectorAll('.galaxy-label[data-body-name]').forEach(el => {
                const originalName = el.dataset.bodyName;
                if (originalName) {
                    el.textContent = translateBodyName(originalName);
                }
            });
            
            // ë™ì  ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸
            const scaleBtn = document.getElementById('btn-scale-mode');
            if (scaleBtn) {
                const isReal = CONFIG && CONFIG.distScale > 1.0;
                scaleBtn.textContent = t(isReal ? 'distReal' : 'distExp');
            }
            
            const fullscreenBtn = document.getElementById('btn-fullscreen');
            if (fullscreenBtn) {
                const isFullscreen = !!document.fullscreenElement;
                fullscreenBtn.textContent = t(isFullscreen ? 'windowMode' : 'fullscreen');
            }
            
            // â˜…â˜…â˜… ì„¤ì • ëª¨ë‹¬ ì–¸ì–´ ì„ íƒ ë™ê¸°í™” â˜…â˜…â˜…
            const settingsLang = document.getElementById('settings-language');
            if (settingsLang) settingsLang.value = lang;
            
            // HUD ì—…ë°ì´íŠ¸
            updateHUDLanguage();
            
            // â˜…â˜…â˜… ë„¤ë¹„ê²Œì´ì…˜ ì²œì²´ ëª©ë¡ ì—…ë°ì´íŠ¸ â˜…â˜…â˜…
            updateNavList();
            
            // â˜…â˜…â˜… ë¯¸ì…˜ ë³´ë“œ ë¦¬ë Œë”ë§ â˜…â˜…â˜…
            if (typeof MissionSystem !== 'undefined' && MissionSystem.render) {
                MissionSystem.render();
            }
        }
        
        function updateHUDLanguage() {
            // ì¡°ì¢…ì„ HUD ë¼ë²¨ ì—…ë°ì´íŠ¸ëŠ” ë™ì ìœ¼ë¡œ ì²˜ë¦¬
        }

        // ===== ìœ ì € ì‹œìŠ¤í…œ (Supabase í†µí•©) =====
        let currentUser = null;
        
        // ì£¼ì°¨ëœ ìš°ì£¼ì„  ì •ë³´
        let parkedShip = null;  // { position, rotation, type, fuel }
        let parkedShipMesh = null;  // ì”¬ì— í‘œì‹œë˜ëŠ” ì£¼ì°¨ëœ ìš°ì£¼ì„  ë©”ì‹œ
        
        // â˜… í†µí•© ë¡œê·¸ì¸ ì²´í¬ í•¨ìˆ˜
        function isUserLoggedIn() {
            return !!(window.mpUser || window.mpUserId);
        }
        
        // â˜… í˜„ì¬ ì‚¬ìš©ì ì •ë³´ ê°€ì ¸ì˜¤ê¸°
        function getCurrentUserInfo() {
            if (window.mpUser) {
                return {
                    username: window.mpUser.username,
                    nickname: window.mpUser.nickname,
                    coins: window.mpUser.coins || 0,
                    unlockedShips: window.mpUser.unlockedShips || ['shuttle'],
                    currentShip: window.mpUser.currentShip || 'shuttle'
                };
            }
            return null;
        }
        
        // ê¸°ì¡´ loginUser í•¨ìˆ˜ëŠ” ì‚¬ìš©í•˜ì§€ ì•ŠìŒ (Supabaseë¡œ ëŒ€ì²´ë¨)
        function loginUser() {
            console.log('âš ï¸ ê¸°ì¡´ loginUserëŠ” ë¹„í™œì„±í™”ë¨. Supabase ë¡œê·¸ì¸ ì‚¬ìš©');
            // êµ¬ë²„ì „ ëª¨ë‹¬ ë‹«ê¸°
            var loginModal = document.getElementById('login-modal');
            console.log('login-modal:', loginModal);
            if (loginModal) loginModal.classList.remove('open');
            // Supabase ë¡œê·¸ì¸ ì°½ ë„ìš°ê¸°
            var authOverlay = document.getElementById('auth-overlay');
            console.log('auth-overlay:', authOverlay);
            if (authOverlay) {
                authOverlay.style.display = 'flex';
                console.log('âœ… auth-overlay í‘œì‹œë¨');
                // íšŒì›ê°€ì… íƒ­ìœ¼ë¡œ ì „í™˜
                if (typeof showRegisterTab === 'function') {
                    showRegisterTab();
                }
            } else {
                console.error('âŒ auth-overlayë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ');
            }
            return false;
        }
        
        // â˜… ì•„ì´ë””/ë¹„ë°€ë²ˆí˜¸ ì°¾ê¸° (Supabaseì—ì„œëŠ” ì´ë©”ì¼ë¡œ ì²˜ë¦¬)
        function findUserId(email) {
            showMsg('Please use email password reset in Supabase.');
        }
        
        function findUserPassword(username, email) {
            showMsg('Please use email password reset in Supabase.');
        }
        
        // â˜… ë¡œê·¸ì¸ í¼ ì´ˆê¸°í™” ë° í‘œì‹œ
        function showLoginForm() {
            document.getElementById('login-form').style.display = 'block';
            document.getElementById('find-id-form').style.display = 'none';
            document.getElementById('find-pw-form').style.display = 'none';
            document.querySelector('.login-tabs').style.display = 'flex';
            document.getElementById('login-title').innerHTML = 'ğŸ” <span data-i18n="login">Login</span>';
            
            // â˜… ì•½ê´€ ì„¹ì…˜ ìˆ¨ê¹€ ë° ì²´í¬ í•´ì œ
            document.getElementById('terms-agree-section').style.display = 'none';
            const agreePrivacy = document.getElementById('agree-privacy');
            const agreeTerms = document.getElementById('agree-terms');
            if (agreePrivacy) agreePrivacy.checked = false;
            if (agreeTerms) agreeTerms.checked = false;
            
            // ì…ë ¥ í•„ë“œ ì´ˆê¸°í™”
            document.getElementById('find-id-email').value = '';
            document.getElementById('find-pw-username').value = '';
            document.getElementById('find-pw-email').value = '';
            document.getElementById('find-id-result').style.display = 'none';
            document.getElementById('find-pw-result').style.display = 'none';
            document.getElementById('find-id-error').textContent = '';
            document.getElementById('find-pw-error').textContent = '';
        }
        
        // â˜… ì•„ì´ë”” ì°¾ê¸° í¼ í‘œì‹œ
        function showFindIdForm() {
            document.getElementById('login-form').style.display = 'none';
            document.getElementById('find-id-form').style.display = 'block';
            document.getElementById('find-pw-form').style.display = 'none';
            document.querySelector('.login-tabs').style.display = 'none';
            document.getElementById('login-title').innerHTML = 'ğŸ” ' + t('findId');
        }
        
        // â˜… ë¹„ë°€ë²ˆí˜¸ ì°¾ê¸° í¼ í‘œì‹œ
        function showFindPwForm() {
            document.getElementById('login-form').style.display = 'none';
            document.getElementById('find-id-form').style.display = 'none';
            document.getElementById('find-pw-form').style.display = 'block';
            document.querySelector('.login-tabs').style.display = 'none';
            document.getElementById('login-title').innerHTML = 'ğŸ”‘ ' + t('findPassword');
        }
        
        function logoutUser() {
            // â˜… Supabase ë¡œê·¸ì•„ì›ƒ
            if (typeof supabase !== 'undefined' && supabase) {
                supabase.auth.signOut().then(function() {
                    console.log('Supabase ë¡œê·¸ì•„ì›ƒ ì™„ë£Œ');
                }).catch(function(e) {
                    console.log('Supabase ë¡œê·¸ì•„ì›ƒ ì˜¤ë¥˜:', e);
                });
            }
            
            // ë¡œì»¬ ìƒíƒœ ì´ˆê¸°í™”
            currentUser = null;
            window.mpUser = null;
            window.mpUserId = null;
            window.mpNickname = null;
            window.currentUser = null;
            
            localStorage.removeItem('milkyway-currentUser');
            localStorage.removeItem('solar_user');
            
            parkedShip = null;
            savedShipState = null;  // ìš°ì£¼ì„  ìƒíƒœë„ ì´ˆê¸°í™”
            
            updateUserUI();
            showMsg('Logged out!');
            
            // í˜ì´ì§€ ìƒˆë¡œê³ ì¹¨ (ê¹”ë”í•œ ìƒíƒœë¡œ)
            setTimeout(() => {
                location.reload();
            }, 500);
        }
        window.logoutUser = logoutUser;  // ì „ì—­ ë…¸ì¶œ
        
        // â˜… ë¡œê·¸ì•„ì›ƒ í™•ì¸ í•¨ìˆ˜
        function confirmLogout() {
            if (confirm(t('confirmLogout'))) {
                logoutUser();
            }
        }
        window.confirmLogout = confirmLogout;
        
        function updateUserUI() {
            const loginBtn = document.getElementById('btn-login');
            const loginMainBtn = document.getElementById('btn-login-main');  // â˜… ë©”ì¸ ë©”ë‰´ ë¡œê·¸ì¸ ë²„íŠ¼
            const userInfo = document.getElementById('user-info');
            const userCoins = document.getElementById('user-coins');
            const userName = document.getElementById('user-name');
            const coinAmount = document.getElementById('coin-amount');
            const logoutBtn = document.getElementById('btn-logout');
            const profilePanel = document.getElementById('user-profile-panel');
            
            // Supabase ë¡œê·¸ì¸ ìƒíƒœ í™•ì¸
            const isLoggedIn = window.mpUser || window.mpUserId;
            const isMultiMode = window.gameMode === 'multi';
            
            console.log('updateUserUI í˜¸ì¶œë¨, ë¡œê·¸ì¸ìƒíƒœ:', isLoggedIn, 'mpUser:', !!window.mpUser, 'mpUserId:', window.mpUserId);
            
            if (isLoggedIn) {
                // ë¡œê·¸ì¸ ë²„íŠ¼ ìˆ¨ê¸°ê¸°
                if (loginBtn) {
                    loginBtn.style.display = 'none';
                    loginBtn.style.visibility = 'hidden';
                }
                // â˜… ë©”ì¸ ë©”ë‰´ ë¡œê·¸ì¸ ë²„íŠ¼ë„ ìˆ¨ê¸°ê¸°
                if (loginMainBtn) {
                    loginMainBtn.style.display = 'none';
                }
                
                // â˜…â˜…â˜… ë©€í‹°ëª¨ë“œ: í”„ë¡œí•„ íŒ¨ë„ í‘œì‹œ â˜…â˜…â˜…
                if (isMultiMode && profilePanel) {
                    profilePanel.style.display = 'flex';
                    if (userInfo) userInfo.style.display = 'none';
                    if (userCoins) userCoins.style.display = 'none';
                    
                    // í”„ë¡œí•„ ì •ë³´ ì—…ë°ì´íŠ¸
                    const profileName = document.getElementById('profile-name');
                    const profileCoins = document.getElementById('profile-coins');
                    const profileLevel = document.getElementById('profile-level');
                    const profileExpFill = document.getElementById('profile-exp-fill');
                    const profileAvatar = document.getElementById('profile-avatar');
                    
                    if (window.mpUser) {
                        if (profileName) profileName.textContent = window.mpUser.nickname || window.mpUser.username || t('user');
                        if (profileCoins) profileCoins.textContent = (window.mpUser.coins || 0).toLocaleString();
                        
                        // ë ˆë²¨ ê³„ì‚° (ê²½í—˜ì¹˜ ê¸°ë°˜)
                        const exp = window.mpUser.exp || 0;
                        const level = Math.floor(Math.sqrt(exp / 100)) + 1;
                        const expForCurrentLevel = Math.pow(level - 1, 2) * 100;
                        const expForNextLevel = Math.pow(level, 2) * 100;
                        const expProgress = ((exp - expForCurrentLevel) / (expForNextLevel - expForCurrentLevel)) * 100;
                        
                        if (profileLevel) profileLevel.textContent = level;
                        if (profileExpFill) profileExpFill.style.width = Math.min(100, expProgress) + '%';
                        
                        window.userLevel = level;  // ì „ì—­ ë ˆë²¨ ì €ì¥
                        
                        // ì•„ë°”íƒ€ (í”„ë¡œí•„ ì´ë¯¸ì§€ê°€ ìˆìœ¼ë©´ í‘œì‹œ)
                        if (profileAvatar) {
                            if (window.mpUser.avatar_url) {
                                profileAvatar.innerHTML = `<img src="${window.mpUser.avatar_url}" alt="avatar">`;
                            } else {
                                profileAvatar.innerHTML = 'ğŸ‘¤';
                            }
                        }
                    } else if (window.mpNickname) {
                        // ê²ŒìŠ¤íŠ¸
                        if (profileName) profileName.textContent = window.mpNickname;
                        if (profileCoins) profileCoins.textContent = '0';
                        if (profileLevel) profileLevel.textContent = '1';
                    }
                } else {
                    // ì‹±ê¸€ëª¨ë“œ: ê¸°ì¡´ UI í‘œì‹œ
                    if (profilePanel) profilePanel.style.display = 'none';
                    if (userInfo) {
                        userInfo.style.display = 'flex';
                        userInfo.style.visibility = 'visible';
                    }
                    if (userCoins) userCoins.style.display = 'block';
                    if (logoutBtn) {
                        logoutBtn.style.display = 'inline-block';
                        logoutBtn.style.visibility = 'visible';
                    }
                    
                    if (window.mpUser) {
                        if (userName) userName.textContent = window.mpUser.nickname || window.mpUser.username;
                        if (coinAmount) coinAmount.textContent = (window.mpUser.coins || 0).toLocaleString();
                    } else if (window.mpNickname) {
                        if (userName) userName.textContent = window.mpNickname;
                    }
                }
                
                // ì£¼ì°¨ëœ ìš°ì£¼ì„  ë³µì›
                if (window.mpUser && window.mpUser.parkedShip) {
                    parkedShip = window.mpUser.parkedShip;
                }
            } else {
                // ë¡œê·¸ì•„ì›ƒ ìƒíƒœ
                if (loginBtn) {
                    loginBtn.style.display = 'block';
                    loginBtn.style.visibility = 'visible';
                }
                // â˜… ë©”ì¸ ë©”ë‰´ ë¡œê·¸ì¸ ë²„íŠ¼ ë‹¤ì‹œ í‘œì‹œ
                if (loginMainBtn) {
                    loginMainBtn.style.display = 'flex';
                }
                if (profilePanel) profilePanel.style.display = 'none';
                if (userInfo) {
                    userInfo.style.display = 'none';
                    userInfo.style.visibility = 'hidden';
                }
                if (userCoins) userCoins.style.display = 'none';
                if (logoutBtn) {
                    logoutBtn.style.display = 'none';
                }
            }
        }
        
        // â˜…â˜…â˜… ê²½í—˜ì¹˜ ì¶”ê°€ í•¨ìˆ˜ â˜…â˜…â˜…
        function addExp(amount) {
            if (window.mpUser && window.supabaseClient) {
                window.mpUser.exp = (window.mpUser.exp || 0) + amount;
                window.supabaseClient
                    .from('profiles')
                    .update({ exp: window.mpUser.exp })
                    .eq('id', window.mpUserId)
                    .then(function() {
                        updateUserUI();
                    })
                    .catch(function(e) {
                        console.warn('ê²½í—˜ì¹˜ ì €ì¥ ì‹¤íŒ¨:', e);
                    });
            }
        }
        window.addExp = addExp;

        // â˜…â˜…â˜… í”„ë¡œí•„ ëª¨ë‹¬ í•¨ìˆ˜ë“¤ â˜…â˜…â˜…
        function openProfileModal() {
            const modal = document.getElementById('profile-edit-modal');
            if (!modal) return;

            // ì‚¬ìš©ì ì •ë³´ ì±„ìš°ê¸°
            if (window.mpUser) {
                // ë‹‰ë„¤ì„
                const nicknameInput = document.getElementById('profile-nickname-input');
                if (nicknameInput) {
                    nicknameInput.value = window.mpUser.nickname || window.mpUser.username || '';
                }

                // ì•„ë°”íƒ€
                const modalAvatar = document.getElementById('modal-avatar');
                if (modalAvatar) {
                    if (window.mpUser.avatar_url) {
                        modalAvatar.innerHTML = '<img src="' + window.mpUser.avatar_url + '" alt="avatar">';
                    } else {
                        modalAvatar.innerHTML = 'ğŸ‘¤';
                    }
                }

                // ì´ë©”ì¼
                const emailEl = document.getElementById('modal-email');
                if (emailEl) {
                    emailEl.textContent = window.mpUser.email || '-';
                }

                // ê°€ì…ì¼
                const createdEl = document.getElementById('modal-created-at');
                if (createdEl && window.mpUser.created_at) {
                    const date = new Date(window.mpUser.created_at);
                    createdEl.textContent = date.toLocaleDateString('ko-KR');
                }

                // ìŠ¤íƒ¯
                const coinsEl = document.getElementById('modal-coins');
                if (coinsEl) coinsEl.textContent = (window.mpUser.coins || 0).toLocaleString();

                const expEl = document.getElementById('modal-exp');
                if (expEl) expEl.textContent = (window.mpUser.exp || 0).toLocaleString();

                const levelEl = document.getElementById('modal-level');
                if (levelEl) {
                    const exp = window.mpUser.exp || 0;
                    const level = Math.floor(Math.sqrt(exp / 100)) + 1;
                    levelEl.textContent = level;
                }
            }

            // ìƒíƒœ ì´ˆê¸°í™”
            const statusEl = document.getElementById('profile-save-status');
            if (statusEl) {
                statusEl.textContent = '';
                statusEl.className = '';
            }

            modal.classList.add('active');
        }
        window.openProfileModal = openProfileModal;

        function closeProfileModal() {
            const modal = document.getElementById('profile-edit-modal');
            if (modal) {
                modal.classList.remove('active');
            }
        }
        window.closeProfileModal = closeProfileModal;

        async function saveNickname() {
            const nicknameInput = document.getElementById('profile-nickname-input');
            const statusEl = document.getElementById('profile-save-status');
            const saveBtn = document.getElementById('save-nickname-btn');

            if (!nicknameInput || !window.mpUser || !window.supabaseClient) {
                if (statusEl) {
                    statusEl.textContent = 'ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤';
                    statusEl.className = 'error';
                }
                return;
            }

            const newNickname = nicknameInput.value.trim();

            // ìœ íš¨ì„± ê²€ì‚¬
            if (newNickname.length < 2 || newNickname.length > 20) {
                if (statusEl) {
                    statusEl.textContent = 'ë‹‰ë„¤ì„ì€ 2~20ìì—¬ì•¼ í•©ë‹ˆë‹¤';
                    statusEl.className = 'error';
                }
                return;
            }

            // íŠ¹ìˆ˜ë¬¸ì ê²€ì‚¬ (í•œê¸€, ì˜ë¬¸, ìˆ«ì, ì–¸ë”ìŠ¤ì½”ì–´ë§Œ í—ˆìš©)
            if (!/^[ê°€-í£a-zA-Z0-9_]+$/.test(newNickname)) {
                if (statusEl) {
                    statusEl.textContent = 'íŠ¹ìˆ˜ë¬¸ìëŠ” ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤';
                    statusEl.className = 'error';
                }
                return;
            }

            // ë²„íŠ¼ ë¹„í™œì„±í™”
            if (saveBtn) saveBtn.disabled = true;
            if (statusEl) {
                statusEl.textContent = 'ì €ì¥ ì¤‘...';
                statusEl.className = '';
            }

            try {
                const { error } = await window.supabaseClient
                    .from('profiles')
                    .update({ nickname: newNickname })
                    .eq('id', window.mpUserId);

                if (error) throw error;

                // ë¡œì»¬ ë°ì´í„° ì—…ë°ì´íŠ¸
                window.mpUser.nickname = newNickname;
                window.mpNickname = newNickname;

                // UI ì—…ë°ì´íŠ¸
                updateUserUI();
                if (typeof updateCockpitProfile === 'function') updateCockpitProfile();

                if (statusEl) {
                    statusEl.textContent = 'âœ“ ë‹‰ë„¤ì„ì´ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤';
                    statusEl.className = 'success';
                }

                // ë©€í‹°í”Œë ˆì´ì–´ ë‹‰ë„¤ì„ë„ ì—…ë°ì´íŠ¸
                if (typeof mpSendPositionUpdate === 'function') {
                    // ë‹¤ìŒ ìœ„ì¹˜ ì—…ë°ì´íŠ¸ ì‹œ ìƒˆ ë‹‰ë„¤ì„ ì „ì†¡ë¨
                }

                console.log('ë‹‰ë„¤ì„ ë³€ê²½ë¨:', newNickname);
            } catch (e) {
                console.error('ë‹‰ë„¤ì„ ì €ì¥ ì‹¤íŒ¨:', e);
                if (statusEl) {
                    statusEl.textContent = 'ì €ì¥ ì‹¤íŒ¨: ' + (e.message || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜');
                    statusEl.className = 'error';
                }
            } finally {
                if (saveBtn) saveBtn.disabled = false;
            }
        }
        window.saveNickname = saveNickname;

        // í”„ë¡œí•„ ëª¨ë‹¬ ì˜¤ë²„ë ˆì´ í´ë¦­ ì‹œ ë‹«ê¸°
        document.addEventListener('click', function(e) {
            if (e.target.id === 'profile-edit-modal') {
                closeProfileModal();
            }
        });

        function getUserCoins() {
            // Supabase ë¡œê·¸ì¸ ìƒíƒœë©´ mpUser ì‚¬ìš©
            if (window.mpUser && window.mpUser.coins !== undefined) {
                return window.mpUser.coins;
            }
            return 0;
        }
        
        function addCoins(amount) {
            // Supabase ë¡œê·¸ì¸ ìƒíƒœ
            if (window.mpUser && window.supabaseClient) {
                window.mpUser.coins = (window.mpUser.coins || 0) + amount;
                window.supabaseClient
                    .from('profiles')
                    .update({ coins: window.mpUser.coins })
                    .eq('id', window.mpUserId)
                    .then(function() {})
                    .catch(function(e) {
                        console.warn('ì½”ì¸ ì €ì¥ ì‹¤íŒ¨:', e);
                    });
                updateUserUI();
                if (typeof updateCockpitProfile === 'function') updateCockpitProfile();
            }
        }
        
        function spendCoins(amount) {
            // Supabase ë¡œê·¸ì¸ ìƒíƒœ
            if (window.mpUser && window.supabaseClient) {
                if ((window.mpUser.coins || 0) >= amount) {
                    window.mpUser.coins -= amount;
                    window.supabaseClient
                        .from('profiles')
                        .update({ coins: window.mpUser.coins })
                        .eq('id', window.mpUserId)
                        .then(function() {})
                        .catch(function(e) {
                            console.warn('ì½”ì¸ ì €ì¥ ì‹¤íŒ¨:', e);
                        });
                    updateUserUI();
                    if (typeof updateCockpitProfile === 'function') updateCockpitProfile();
                    return true;
                }
            }
            return false;
        }
        
        function ownsShip(shipId) {
            // Supabase ë¡œê·¸ì¸ ìƒíƒœ
            if (window.mpUser && window.mpUser.unlockedShips) {
                return window.mpUser.unlockedShips.includes(shipId);
            }
            // ë¹„ë¡œê·¸ì¸ ì‹œ ê¸°ë³¸ 4ê°œ ìš°ì£¼ì„ ë§Œ ì‚¬ìš© ê°€ëŠ¥
            return ['shuttle', 'scout', 'interceptor', 'freighter'].includes(shipId);
        }
        
        function buyShip(shipId) {
            if (!window.mpUser) {
                showMsg(t('loginFirst'));
                return false;
            }
            
            var ship = SHIP_TYPES.find(function(s) { return s.id === shipId; });
            if (!ship) return false;
            
            if (ownsShip(shipId)) {
                showMsg(t('alreadyOwned'));
                return false;
            }
            
            if (!spendCoins(ship.price)) {
                showMsg(t('notEnoughCoins'));
                return false;
            }
            
            // Supabaseì— ì €ì¥
            if (window.mpUser && window.supabaseClient) {
                window.mpUser.unlockedShips = window.mpUser.unlockedShips || ['shuttle'];
                window.mpUser.unlockedShips.push(shipId);
                window.supabaseClient
                    .from('profiles')
                    .update({ unlocked_ships: window.mpUser.unlockedShips })
                    .eq('id', window.mpUserId)
                    .then(function() {})
                    .catch(function(e) {
                        console.warn('ìš°ì£¼ì„  ì €ì¥ ì‹¤íŒ¨:', e);
                    });
            }
            
            showMsg('âœ… ' + t('purchased') + ' ' + getShipName(ship) + '!');
            return true;
        }
        
        // ìš°ì£¼ì„  ì£¼ì°¨ (í•˜ì„  ì‹œ)
        function parkShip() {
            if (!playerShip || !playerShip.mesh) return;
            
            parkedShip = {
                position: playerShip.mesh.position.clone(),
                rotation: playerShip.mesh.rotation.clone(),
                quaternion: playerShip.mesh.quaternion.clone(),
                type: currentShipType.id,
                fuel: playerShip.fuel,
                hull: playerShip.hull,
                speed: playerShip.speed
            };
            
            // Supabaseì— ì €ì¥
            if (window.mpUser && window.supabaseClient) {
                window.supabaseClient
                    .from('profiles')
                    .update({ 
                        parked_ship: {
                            type: parkedShip.type,
                            fuel: parkedShip.fuel,
                            hull: parkedShip.hull,
                            position: { x: parkedShip.position.x, y: parkedShip.position.y, z: parkedShip.position.z },
                            rotation: { x: parkedShip.rotation.x, y: parkedShip.rotation.y, z: parkedShip.rotation.z }
                        }
                    })
                    .eq('id', window.mpUserId)
                    .then(function() {})
                    .catch(function(e) {
                        console.warn('ì£¼ì°¨ ì •ë³´ ì €ì¥ ì‹¤íŒ¨:', e);
                    });
            }
        }
        
        // ì£¼ì°¨ëœ ìš°ì£¼ì„ ì— ì¬íƒ‘ìŠ¹
        function reboardParkedShip() {
            if (!parkedShip) return false;
            return true;  // ì¬íƒ‘ìŠ¹ ê°€ëŠ¥
        }

        // 1. Constants & Globals
        const CONFIG = {
            G: 0.1,
            timeScale: 0.1,
            subSteps: 10,
            softening: 1.0,
            trailLength: 300,
            distScale: 1.0
        };

        const STAR_THRESHOLD = 100;
        const API_BASE = '/api';  // Vercel API
        const API_URL = 'data.json';  // fallback
        const ASSET_PATH = 'uploads/';  // fallback
        const SUPABASE_STORAGE = 'https://sfirzuqngdbpwvdoyero.supabase.co/storage/v1/object/public/assets/';  // Supabase Storage

        const TEXTURES = {
            SUN: { map: '2k_sun.jpg' }, MERCURY: { map: '2k_mercury.jpg' }, VENUS: { map: '2k_venus_atmosphere.jpg' },
            EARTH: { map: '2k_earth_daymap.jpg' }, MARS: { map: '2k_mars.jpg' }, JUPITER: { map: '2k_jupiter.jpg' },
            SATURN: { map: '2k_saturn.jpg' }, URANUS: { map: '2k_uranus.jpg' }, NEPTUNE: { map: '2k_neptune.jpg' }, MOON: { map: '2k_moon.jpg' }
        };

        // â˜… Supabase Storageì— ì—…ë¡œë“œëœ íŒŒì¼ëª… ë§¤í•‘ (assets/ ë£¨íŠ¸ì— ìˆìŒ)
        const SUPABASE_TEXTURES = {
            'earth': 'earth_1765901958.jpeg',
            'mars': 'mars_1765902547.jpg',
            'venus': 'venus_1765902007.jpg',
            'saturn': 'saturn_1765902576.jpg',
            'saturn_ring': 'saturn_ring_1765903886.png',
            'uranus': 'uranus_1765903664.jpg',
            'neptune': 'neptune_1765907700.jpeg',
            'moon': 'moon_1765907677.jpg',
            'mercury': 'mercury_1765902026.jpg',
            'jupiter': 'jupiter_1765902587.jpg'
        };

        // â˜… í…ìŠ¤ì²˜ URL ê°€ì ¸ì˜¤ê¸° í•¨ìˆ˜
        function getTextureUrl(filename) {
            // Supabase Storageì—ì„œ ì°¾ê¸°
            const baseName = filename.toLowerCase().replace(/\.(jpg|jpeg|png)$/i, '').replace(/^2k_/, '').replace(/_.*$/, '');
            if (SUPABASE_TEXTURES[baseName]) {
                return SUPABASE_STORAGE + SUPABASE_TEXTURES[baseName];
            }
            // uploads/ ê²½ë¡œë©´ Supabaseì—ì„œ íŒŒì¼ëª…ë§Œ ì¶”ì¶œí•´ì„œ ì‹œë„
            if (filename.startsWith('uploads/')) {
                const justFilename = filename.replace('uploads/', '').replace('ships/', '');
                return SUPABASE_STORAGE + justFilename;
            }
            // httpë¡œ ì‹œì‘í•˜ë©´ ê·¸ëŒ€ë¡œ
            if (filename.startsWith('http')) {
                return filename;
            }
            // ê¸°ë³¸: Supabase Storage (ë£¨íŠ¸)
            return SUPABASE_STORAGE + filename;
        }

        let scene, camera, renderer, labelRenderer, controls;
        let bodies = [];
        let satellites = []; 
        let particles = [];
        let focusedBody = null;
        let isPlacing = false;
        let ghostMesh = null;
        let spawnData = null;
        let dragStartPos = null;  // ë“œë˜ê·¸ ì‹œì‘ ìœ„ì¹˜
        let dragLine = null;      // ë“œë˜ê·¸ ë°©í–¥ í‘œì‹œ ì„ 
        let isDraggingBody = false;  // ì²œì²´ ë“œë˜ê·¸ ì¤‘
        
        // â˜…â˜…â˜… 2ë‹¨ê³„ ì²œì²´ ìƒì„± ì‹œìŠ¤í…œ (ëª¨ë°”ì¼ìš©) â˜…â˜…â˜…
        let pendingBody = null;        // 1ë‹¨ê³„ì—ì„œ ë°°ì¹˜ëœ ëŒ€ê¸° ì¤‘ì¸ ì²œì²´
        let pendingBodyMesh = null;    // ëŒ€ê¸° ì¤‘ì¸ ì²œì²´ ë©”ì‰¬
        let isPendingDrag = false;     // 2ë‹¨ê³„ ë“œë˜ê·¸ ì¤‘
        let pendingDragStart = null;   // 2ë‹¨ê³„ ë“œë˜ê·¸ ì‹œì‘ì 
        let velocityArrow = null;      // ì†ë„ ë°©í–¥ í™”ì‚´í‘œ
        let velocityLine = null;       // ì†ë„ ë°©í–¥ ì„ 
        
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
        const textureLoader = new THREE.TextureLoader();
        
        // â˜…â˜…â˜… ì¼ì‹/ì›”ì‹ ê·¸ë¦¼ì ì‹œìŠ¤í…œ â˜…â˜…â˜…
        const EclipseSystem = {
            // ê·¸ë¦¼ì ì˜¤ë²„ë ˆì´ ë©”ì‰¬ë“¤
            shadowOverlays: new Map(),
            
            // ì¼ì‹ ì²´í¬: occluderê°€ targetê³¼ sun ì‚¬ì´ì— ìˆëŠ”ì§€
            checkEclipse: function(target, occluder, sun) {
                if (!target || !occluder || !sun) return null;
                if (!target.mesh || !occluder.mesh || !sun.mesh) return null;
                
                const sunPos = sun.mesh.position;
                const targetPos = target.mesh.position;
                const occluderPos = occluder.mesh.position;
                
                // íƒ€ê²Ÿì—ì„œ íƒœì–‘ìœ¼ë¡œì˜ ë°©í–¥
                const toSun = new THREE.Vector3().subVectors(sunPos, targetPos).normalize();
                
                // íƒ€ê²Ÿì—ì„œ ê°€ë¦¼ì²´ê¹Œì§€ì˜ ë²¡í„°
                const toOccluder = new THREE.Vector3().subVectors(occluderPos, targetPos);
                
                // ê°€ë¦¼ì²´ê°€ íƒœì–‘ ë°©í–¥ì— ìˆëŠ”ì§€ í™•ì¸ (ë‚´ì  > 0)
                const dotProduct = toOccluder.dot(toSun);
                if (dotProduct <= 0) return null;  // ê°€ë¦¼ì²´ê°€ íƒœì–‘ ë°˜ëŒ€ìª½ì— ìˆìŒ
                
                // íƒœì–‘-íƒ€ê²Ÿ ì„ ì— ëŒ€í•œ ê°€ë¦¼ì²´ì˜ ìˆ˜ì§ ê±°ë¦¬
                const projection = toSun.clone().multiplyScalar(dotProduct);
                const perpendicular = new THREE.Vector3().subVectors(toOccluder, projection);
                const perpDist = perpendicular.length();
                
                // ê°€ë¦¼ì²´ê¹Œì§€ì˜ ê±°ë¦¬
                const occluderDist = toOccluder.length();
                
                // íƒœì–‘ê¹Œì§€ì˜ ê±°ë¦¬
                const sunDist = new THREE.Vector3().subVectors(sunPos, targetPos).length();
                
                // ê°€ë¦¼ì²´ê°€ íƒœì–‘ë³´ë‹¤ ê°€ê¹Œì›Œì•¼ í•¨
                if (occluderDist >= sunDist) return null;
                
                // ê° í¬ê¸° ê³„ì‚° (ë¼ë””ì•ˆ)
                const occluderRadius = occluder.radius || 0.5;
                const targetRadius = target.radius || 1;
                const sunRadius = sun.radius || 10;
                
                // ê°€ë¦¼ì²´ì˜ ê° í¬ê¸° (íƒ€ê²Ÿì—ì„œ ë³¸)
                const occluderAngularSize = Math.atan2(occluderRadius, occluderDist);
                
                // íƒœì–‘ì˜ ê° í¬ê¸° (íƒ€ê²Ÿì—ì„œ ë³¸)
                const sunAngularSize = Math.atan2(sunRadius, sunDist);
                
                // ìˆ˜ì§ ê±°ë¦¬ì˜ ê°ë„
                const perpAngularDist = Math.atan2(perpDist, occluderDist);
                
                // ê·¸ë¦¼ì ê°•ë„ ê³„ì‚°
                // ê°€ë¦¼ì²´ê°€ íƒœì–‘ì„ ì–¼ë§ˆë‚˜ ê°€ë¦¬ëŠ”ì§€
                if (perpAngularDist > occluderAngularSize + sunAngularSize) {
                    return null;  // ì™„ì „íˆ ë²—ì–´ë‚¨
                }
                
                let shadowIntensity = 0;
                if (perpAngularDist < Math.abs(occluderAngularSize - sunAngularSize)) {
                    // ì™„ì „ ì¼ì‹ (ë³¸ì˜) ë˜ëŠ” ê¸ˆí™˜ì¼ì‹
                    if (occluderAngularSize >= sunAngularSize) {
                        shadowIntensity = 1.0;  // ê°œê¸°ì¼ì‹
                    } else {
                        shadowIntensity = (occluderAngularSize / sunAngularSize) * (occluderAngularSize / sunAngularSize);  // ê¸ˆí™˜ì¼ì‹
                    }
                } else {
                    // ë¶€ë¶„ ì¼ì‹ (ë°˜ì˜) - ê°•ë„ ì¦ê°€
                    const overlap = (occluderAngularSize + sunAngularSize - perpAngularDist) / (2 * sunAngularSize);
                    shadowIntensity = Math.max(0, Math.min(1, overlap * 1.5));  // 0.7 â†’ 1.5
                }
                
                return {
                    intensity: shadowIntensity,
                    direction: toSun.clone().negate(),
                    occluderName: occluder.name
                };
            },
            
            // ê·¸ë¦¼ì ì˜¤ë²„ë ˆì´ ìƒì„±
            createShadowOverlay: function(body) {
                if (!body || !body.mesh) return null;
                
                const radius = body.radius * (body.visualScale || 1) * 1.005;
                const geo = new THREE.SphereGeometry(radius, 64, 64);
                const mat = new THREE.ShaderMaterial({
                    uniforms: {
                        shadowDirection: { value: new THREE.Vector3(1, 0, 0) },
                        shadowIntensity: { value: 0.0 },
                        shadowSoftness: { value: 0.15 },
                        shadowSize: { value: 0.5 }
                    },
                    vertexShader: `
                        varying vec3 vNormal;
                        varying vec3 vWorldPosition;
                        
                        void main() {
                            vNormal = normalize(normalMatrix * normal);
                            vec4 worldPos = modelMatrix * vec4(position, 1.0);
                            vWorldPosition = worldPos.xyz;
                            gl_Position = projectionMatrix * viewMatrix * worldPos;
                        }
                    `,
                    fragmentShader: `
                        uniform vec3 shadowDirection;
                        uniform float shadowIntensity;
                        uniform float shadowSoftness;
                        uniform float shadowSize;
                        
                        varying vec3 vNormal;
                        varying vec3 vWorldPosition;
                        
                        void main() {
                            vec3 normal = normalize(vNormal);
                            vec3 lightDir = normalize(-shadowDirection);
                            
                            // íƒœì–‘ì„ í–¥í•˜ëŠ” ë©´ì—ë§Œ ê·¸ë¦¼ì ì ìš©
                            float facing = dot(normal, lightDir);
                            
                            // ê·¸ë¦¼ì ì˜ì—­ ê³„ì‚° (ë¶€ë“œëŸ¬ìš´ ì—£ì§€)
                            float shadowMask = smoothstep(-shadowSoftness, shadowSoftness * 2.0, facing);
                            
                            // ê·¸ë¦¼ì ê°•ë„ (5ë°° ì¦ê°€)
                            float shadow = shadowMask * shadowIntensity * 5.0;
                            shadow = min(shadow, 1.0);  // ìµœëŒ€ 1.0ìœ¼ë¡œ í´ë¨í”„
                            
                            // ê·¸ë¦¼ì ìƒ‰ìƒ (ë” ì–´ë‘ìš´ ìƒ‰)
                            vec3 shadowColor = vec3(0.0, 0.0, 0.0);
                            
                            // ê°€ì¥ìë¦¬ ë¶€ë“œëŸ½ê²Œ
                            float edgeFade = 1.0 - smoothstep(0.7, 1.0, abs(facing));
                            shadow *= (1.0 - edgeFade * 0.2);
                            
                            gl_FragColor = vec4(shadowColor, shadow * 0.95);
                        }
                    `,
                    transparent: true,
                    side: THREE.FrontSide,
                    depthWrite: false,
                    blending: THREE.MultiplyBlending
                });
                
                const overlay = new THREE.Mesh(geo, mat);
                overlay.renderOrder = 10;
                overlay.name = 'eclipseShadow';
                body.mesh.add(overlay);
                
                return overlay;
            },
            
            // ë§¤ í”„ë ˆì„ ì—…ë°ì´íŠ¸
            update: function() {
                const sun = bodies.find(b => b.name === 'íƒœì–‘' || b.name === 'Sun');
                if (!sun) return;
                
                // ì¼ì‹ ì•Œë¦¼ ì¿¨ë‹¤ìš´
                if (!this.lastEclipseAlert) this.lastEclipseAlert = {};
                const now = Date.now();
                
                // ëª¨ë“  í–‰ì„±ì— ëŒ€í•´ ì¼ì‹ ì²´í¬
                bodies.forEach(target => {
                    if (target === sun || target.type === 'star' || target.type === 'blackhole') return;
                    
                    // ê·¸ë¦¼ì ì˜¤ë²„ë ˆì´ ìƒì„± (ìµœì´ˆ 1íšŒ)
                    if (!this.shadowOverlays.has(target.name)) {
                        const overlay = this.createShadowOverlay(target);
                        if (overlay) {
                            this.shadowOverlays.set(target.name, overlay);
                        }
                    }
                    
                    const overlay = this.shadowOverlays.get(target.name);
                    if (!overlay) return;
                    
                    // ëª¨ë“  ìœ„ì„±(ë‹¬)ì— ëŒ€í•´ ì¼ì‹ ì²´í¬
                    let maxEclipse = null;
                    
                    satellites.forEach(sat => {
                        if (sat.isSpaceStation) return;  // ìš°ì£¼ì •ê±°ì¥ ì œì™¸
                        
                        const satBody = {
                            mesh: sat.mesh,
                            radius: sat.radius || 0.3,
                            name: sat.name
                        };
                        
                        const eclipse = this.checkEclipse(target, satBody, sun);
                        if (eclipse && (!maxEclipse || eclipse.intensity > maxEclipse.intensity)) {
                            maxEclipse = eclipse;
                        }
                    });
                    
                    // ë‹¤ë¥¸ í–‰ì„±ì— ì˜í•œ ì¼ì‹ë„ ì²´í¬
                    bodies.forEach(occluder => {
                        if (occluder === target || occluder === sun) return;
                        if (occluder.type === 'star' || occluder.type === 'blackhole') return;
                        
                        const eclipse = this.checkEclipse(target, occluder, sun);
                        if (eclipse && (!maxEclipse || eclipse.intensity > maxEclipse.intensity)) {
                            maxEclipse = eclipse;
                        }
                    });
                    
                    // ê·¸ë¦¼ì ì ìš©
                    if (maxEclipse && maxEclipse.intensity > 0.01) {
                        overlay.material.uniforms.shadowIntensity.value = maxEclipse.intensity;
                        overlay.material.uniforms.shadowDirection.value.copy(maxEclipse.direction);
                        overlay.visible = true;
                    } else {
                        overlay.visible = false;
                        overlay.material.uniforms.shadowIntensity.value = 0;
                    }
                });
                
                // ìœ„ì„±(ë‹¬)ì— ëŒ€í•´ì„œë„ ì¼ì‹ ì²´í¬ (ì›”ì‹ = ì§€êµ¬ ê·¸ë¦¼ìì— ë‹¬ì´ ë“¤ì–´ê°)
                satellites.forEach(sat => {
                    if (sat.isSpaceStation) return;
                    
                    // ë‹¬ ê·¸ë¦¼ì ì˜¤ë²„ë ˆì´ ìƒì„±
                    const satKey = 'sat_' + sat.name;
                    if (!this.shadowOverlays.has(satKey)) {
                        const satBody = {
                            mesh: sat.mesh,
                            radius: sat.radius || 0.3,
                            visualScale: 1
                        };
                        const overlay = this.createShadowOverlay(satBody);
                        if (overlay) {
                            this.shadowOverlays.set(satKey, overlay);
                        }
                    }
                    
                    const overlay = this.shadowOverlays.get(satKey);
                    if (!overlay) return;
                    
                    // ëª¨í–‰ì„±ì— ì˜í•œ ì›”ì‹ ì²´í¬
                    const satBody = {
                        mesh: sat.mesh,
                        radius: sat.radius || 0.3,
                        name: sat.name
                    };
                    
                    const eclipse = this.checkEclipse(satBody, sat.parentBody, sun);
                    
                    if (eclipse && eclipse.intensity > 0.01) {
                        overlay.material.uniforms.shadowIntensity.value = eclipse.intensity;
                        overlay.material.uniforms.shadowDirection.value.copy(eclipse.direction);
                        overlay.visible = true;
                    } else {
                        overlay.visible = false;
                        overlay.material.uniforms.shadowIntensity.value = 0;
                    }
                });
            }
        };
        
        window.EclipseSystem = EclipseSystem;

        // ===== ìš°ì£¼ì„  ì¡°ì¢… ì‹œìŠ¤í…œ ë³€ìˆ˜ =====
        
        // 10ì¢… ìš°ì£¼ì„  íƒ€ì… ì •ì˜ (ìŠ¤í™ 5ë°° ì ìš©)
        const SHIP_TYPES = [
            {
                id: 'shuttle',
                name: 'ì…”í‹€',
                nameEn: 'Shuttle',
                nameJa: 'ã‚·ãƒ£ãƒˆãƒ«',
                nameZh: 'ç©¿æ¢­æœº',
                nameFr: 'Navette',
                nameLa: 'Navicula',
                tier: 1,
                maxSpeed: 375,  // 75 * 5
                acceleration: 40.0,
                turnSpeed: 0.125,
                maxFuel: 25,
                maxHull: 80,
                capacity: 50,  // ì ì¬ëŸ‰
                size: 'small',
                color: 0x888888,
                accentColor: 0xcccccc,
                special: null,
                description: 'ê¸°ë³¸í˜• ì™•ë³µì„ . ì•ˆì •ì ì¸ ì„±ëŠ¥.',
                descEn: 'Basic shuttle. Stable performance.',
                descJa: 'åŸºæœ¬ã‚·ãƒ£ãƒˆãƒ«ã€‚å®‰å®šã—ãŸæ€§èƒ½ã€‚',
                descZh: 'åŸºç¡€ç©¿æ¢­æœºã€‚ç¨³å®šçš„æ€§èƒ½ã€‚',
                descFr: 'Navette de base. Performance stable.',
                descLa: 'Navis fundamentalis. Stabilis.',
                price: 500,
                unlocked: true,
                image: '',
                model: 'https://sfirzuqngdbpwvdoyero.supabase.co/storage/v1/object/public/assets/ships/shuttle_model_1767450908791.glb'
            },
            {
                id: 'scout',
                name: 'íƒì‚¬ì •',
                nameEn: 'Scout',
                nameJa: 'åµå¯Ÿæ©Ÿ',
                nameZh: 'ä¾¦å¯Ÿèˆ¹',
                nameFr: 'Ã‰claireur',
                nameLa: 'Explorator',
                tier: 1,
                maxSpeed: 450,  // 90 * 5
                acceleration: 50.0,
                turnSpeed: 0.15,
                maxFuel: 30,
                maxHull: 70,
                capacity: 60,  // ì ì¬ëŸ‰
                size: 'small',
                color: 0x4a90d9,
                accentColor: 0x7ec8e3,
                special: 'scan',
                specialDesc: 'ìŠ¤ìº” ë²”ìœ„ +50%',
                description: 'ì¥ê±°ë¦¬ íƒì‚¬ìš©. ë„“ì€ ì„¼ì„œ ë²”ìœ„.',
                descEn: 'Long-range scout. Wide sensor range.',
                descJa: 'é•·è·é›¢åµå¯Ÿç”¨ã€‚åºƒã„ã‚»ãƒ³ã‚µãƒ¼ç¯„å›²ã€‚',
                descZh: 'è¿œç¨‹ä¾¦å¯Ÿç”¨ã€‚å®½å¹¿çš„ä¼ æ„Ÿå™¨èŒƒå›´ã€‚',
                descFr: 'Ã‰claireur longue portÃ©e. Large zone de capteur.',
                descLa: 'Explorator longinquus. Latus sensus.',
                price: 1000,
                unlocked: true,
                model: 'https://sfirzuqngdbpwvdoyero.supabase.co/storage/v1/object/public/assets/ships/explorer_model_1766457987.glb'
            },
            {
                id: 'interceptor',
                name: 'ì¸í„°ì…‰í„°',
                nameEn: 'Interceptor',
                nameJa: 'ã‚¤ãƒ³ã‚¿ãƒ¼ã‚»ãƒ—ã‚¿ãƒ¼',
                nameZh: 'æ‹¦æˆªæœº',
                nameFr: 'Intercepteur',
                nameLa: 'Interceptor',
                tier: 2,
                maxSpeed: 875,  // 175 * 5
                acceleration: 100.0,
                turnSpeed: 0.2,
                maxFuel: 20,
                maxHull: 60,
                capacity: 70,  // ì ì¬ëŸ‰
                size: 'small',
                color: 0xe74c3c,
                accentColor: 0xff6b6b,
                special: 'boost',
                specialDesc: 'ê¸´ê¸‰ë¶€ìŠ¤íŠ¸ (3ì´ˆê°„ ì†ë„ 2ë°°)',
                specialCooldown: 30,
                description: 'ê³ ì† ìš”ê²©ê¸°. ë¹ ë¥¸ ê°€ì†ê³¼ ì„ íšŒ.',
                descEn: 'High-speed interceptor. Fast acceleration.',
                descJa: 'é«˜é€Ÿè¿æ’ƒæ©Ÿã€‚ç´ æ—©ã„åŠ é€Ÿã¨æ—‹å›ã€‚',
                descZh: 'é«˜é€Ÿæ‹¦æˆªæœºã€‚å¿«é€ŸåŠ é€Ÿå’Œè½¬å‘ã€‚',
                descFr: 'Intercepteur haute vitesse. AccÃ©lÃ©ration rapide.',
                descLa: 'Velox interceptor. Celer acceleratio.',
                price: 2000,
                unlocked: true,
                model: 'https://sfirzuqngdbpwvdoyero.supabase.co/storage/v1/object/public/assets/ships/interceptor_model_1765905786.glb'
            },
            {
                id: 'freighter',
                name: 'í™”ë¬¼ì„ ',
                nameEn: 'Freighter',
                nameJa: 'è²¨ç‰©èˆ¹',
                nameZh: 'è´§èˆ¹',
                nameFr: 'Cargo',
                nameLa: 'Oneraria',
                tier: 2,
                maxSpeed: 300,  // 60 * 5
                acceleration: 30.0,
                turnSpeed: 0.075,
                maxFuel: 75,
                maxHull: 150,
                capacity: 200,  // ì ì¬ëŸ‰ (í™”ë¬¼ì„ ì€ í¬ê²Œ)
                size: 'large',
                color: 0x8b4513,
                accentColor: 0xcd853f,
                special: 'fuelEfficiency',
                specialDesc: 'ì—°ë£Œ íš¨ìœ¨ +30%',
                description: 'ëŒ€í˜• í™”ë¬¼ì„ . ëŠë¦¬ì§€ë§Œ ì—°ë£Œê°€ í’ë¶€.',
                descEn: 'Large freighter. Slow but fuel-rich.',
                descJa: 'å¤§å‹è²¨ç‰©èˆ¹ã€‚é…ã„ãŒç‡ƒæ–™è±Šå¯Œã€‚',
                descZh: 'å¤§å‹è´§èˆ¹ã€‚é€Ÿåº¦æ…¢ä½†ç‡ƒæ–™å……è¶³ã€‚',
                descFr: 'Grand cargo. Lent mais carburant abondant.',
                descLa: 'Magna oneraria. Lenta sed combustibile.',
                price: 4000,
                unlocked: true,
                model: 'https://sfirzuqngdbpwvdoyero.supabase.co/storage/v1/object/public/assets/ships/freighter_model_1765906618.glb'
            },
            {
                id: 'corvette',
                name: 'ì½”ë¥´ë²³',
                nameEn: 'Corvette',
                nameJa: 'ã‚³ãƒ«ãƒ™ãƒƒãƒˆ',
                nameZh: 'æŠ¤å«èˆ°',
                nameFr: 'Corvette',
                nameLa: 'Corbita',
                tier: 3,
                maxSpeed: 700,  // 140 * 5
                acceleration: 70.0,
                turnSpeed: 0.15,
                maxFuel: 40,
                maxHull: 120,
                capacity: 120,  // ì ì¬ëŸ‰
                size: 'medium',
                color: 0x2ecc71,
                accentColor: 0x58d68d,
                special: 'shield',
                specialDesc: 'ì‰´ë“œ ì¥ì°© (ì¶©ëŒ 1íšŒ ë°©ì–´)',
                description: 'ë‹¤ëª©ì  í˜¸ìœ„í•¨. ê· í˜• ì¡íŒ ì„±ëŠ¥.',
                descEn: 'Multi-purpose corvette. Balanced stats.',
                descJa: 'å¤šç›®çš„ã‚³ãƒ«ãƒ™ãƒƒãƒˆã€‚ãƒãƒ©ãƒ³ã‚¹ã®å–ã‚ŒãŸæ€§èƒ½ã€‚',
                descZh: 'å¤šåŠŸèƒ½æŠ¤å«èˆ°ã€‚å‡è¡¡çš„æ€§èƒ½ã€‚',
                descFr: 'Corvette polyvalente. Stats Ã©quilibrÃ©es.',
                descLa: 'Navis multiplex. Aequilibrata.',
                price: 8000,
                unlocked: false
            },
            {
                id: 'racer',
                name: 'ë ˆì´ì„œ',
                nameEn: 'Racer',
                nameJa: 'ãƒ¬ãƒ¼ã‚µãƒ¼',
                nameZh: 'èµ›è½¦',
                nameFr: 'Coureur',
                nameLa: 'Cursor',
                tier: 3,
                maxSpeed: 1125,  // 225 * 5
                acceleration: 120.0,
                turnSpeed: 0.25,
                maxFuel: 15,
                maxHull: 50,
                capacity: 60,  // ì ì¬ëŸ‰ (ë ˆì´ì„œëŠ” ì‘ê²Œ)
                size: 'small',
                color: 0xf39c12,
                accentColor: 0xf7dc6f,
                special: 'afterburner',
                specialDesc: 'ì• í”„í„°ë²„ë„ˆ (ì—°ë£Œ 3ë°°ë¡œ ì†ë„ 1.5ë°°)',
                description: 'ê·¹í•œì˜ ì†ë„. ì—°ë£Œ ê´€ë¦¬ í•„ìˆ˜.',
                descEn: 'Extreme speed. Fuel management required.',
                descJa: 'æ¥µé™ã®é€Ÿåº¦ã€‚ç‡ƒæ–™ç®¡ç†å¿…é ˆã€‚',
                descZh: 'æé™é€Ÿåº¦ã€‚ç‡ƒæ–™ç®¡ç†å¿…éœ€ã€‚',
                descFr: 'Vitesse extrÃªme. Gestion carburant requise.',
                descLa: 'Velocitas extrema. Combustibile curandum.',
                price: 12000,
                unlocked: false
            },
            {
                id: 'frigate',
                name: 'í”„ë¦¬ê¹ƒ',
                nameEn: 'Frigate',
                nameJa: 'ãƒ•ãƒªã‚²ãƒ¼ãƒˆ',
                nameZh: 'æŠ¤å«èˆ°',
                nameFr: 'FrÃ©gate',
                nameLa: 'Fregata',
                tier: 4,
                maxSpeed: 800,  // 160 * 5
                acceleration: 80.0,
                turnSpeed: 0.125,
                maxFuel: 60,
                maxHull: 140,
                capacity: 150,  // ì ì¬ëŸ‰
                size: 'medium',
                color: 0x9b59b6,
                accentColor: 0xbb8fce,
                special: 'autoRepair',
                specialDesc: 'ìë™ ìˆ˜ë¦¬ (10ì´ˆë‹¹ ì—°ë£Œ 1% íšŒë³µ)',
                description: 'ì¤‘í˜• í˜¸ìœ„í•¨. ì¥ê±°ë¦¬ ì„ë¬´ì— ì í•©.',
                descEn: 'Medium frigate. Good for long missions.',
                descJa: 'ä¸­å‹ãƒ•ãƒªã‚²ãƒ¼ãƒˆã€‚é•·è·é›¢ä»»å‹™ã«æœ€é©ã€‚',
                descZh: 'ä¸­å‹æŠ¤å«èˆ°ã€‚é€‚åˆé•¿é€”ä»»åŠ¡ã€‚',
                descFr: 'FrÃ©gate moyenne. IdÃ©ale missions longues.',
                descLa: 'Navis media. Ad longinqua apta.',
                price: 20000,
                unlocked: false
            },
            {
                id: 'cruiser',
                name: 'í¬ë£¨ì €',
                nameEn: 'Cruiser',
                nameJa: 'ã‚¯ãƒ«ãƒ¼ã‚¶ãƒ¼',
                nameZh: 'å·¡æ´‹èˆ°',
                nameFr: 'Croiseur',
                nameLa: 'Cruciator',
                tier: 4,
                maxSpeed: 625,  // 125 * 5
                acceleration: 60.0,
                turnSpeed: 0.1,
                maxFuel: 100,
                maxHull: 180,
                capacity: 180,  // ì ì¬ëŸ‰
                size: 'large',
                color: 0x3498db,
                accentColor: 0x85c1e9,
                special: 'warp',
                specialDesc: 'ì›Œí”„ ë“œë¼ì´ë¸Œ (ëª©í‘œë¡œ ì¦‰ì‹œ ì´ë™)',
                specialCooldown: 60,
                description: 'ëŒ€í˜• ìˆœì–‘í•¨. ì›Œí”„ ê¸°ëŠ¥ íƒ‘ì¬.',
                descEn: 'Large cruiser. Warp drive equipped.',
                descJa: 'å¤§å‹å·¡æ´‹è‰¦ã€‚ãƒ¯ãƒ¼ãƒ—ãƒ‰ãƒ©ã‚¤ãƒ–æ­è¼‰ã€‚',
                descZh: 'å¤§å‹å·¡æ´‹èˆ°ã€‚é…å¤‡æ›²é€Ÿå¼•æ“ã€‚',
                descFr: 'Grand croiseur. Moteur warp Ã©quipÃ©.',
                descLa: 'Magna navis. Propulsio warpi.',
                price: 35000,
                unlocked: false
            },
            {
                id: 'battleship',
                name: 'ë°°í‹€ì‹­',
                nameEn: 'Battleship',
                nameJa: 'ãƒãƒˆãƒ«ã‚·ãƒƒãƒ—',
                nameZh: 'æˆ˜èˆ°',
                nameFr: 'CuirassÃ©',
                nameLa: 'Navis Bellica',
                tier: 5,
                maxSpeed: 550,  // 110 * 5
                acceleration: 50.0,
                turnSpeed: 0.075,
                maxFuel: 150,
                maxHull: 250,
                capacity: 250,  // ì ì¬ëŸ‰
                size: 'huge',
                color: 0x1a5276,
                accentColor: 0x2980b9,
                special: 'gravityResist',
                specialDesc: 'ì¤‘ë ¥ ì €í•­ (ì¤‘ë ¥ ì˜í–¥ 50% ê°ì†Œ)',
                description: 'ì´ˆëŒ€í˜• ì „í•¨. ì¤‘ë ¥ì— ê°•í•˜ë‹¤.',
                descEn: 'Super-large battleship. Gravity resistant.',
                descJa: 'è¶…å¤§å‹æˆ¦è‰¦ã€‚é‡åŠ›ã«å¼·ã„ã€‚',
                descZh: 'è¶…å¤§å‹æˆ˜èˆ°ã€‚æŠ—é‡åŠ›èƒ½åŠ›å¼ºã€‚',
                descFr: 'Super cuirassÃ©. RÃ©sistant Ã  la gravitÃ©.',
                descLa: 'Navis maxima. Gravitas resistens.',
                price: 60000,
                unlocked: false
            },
            {
                id: 'flagship',
                name: 'í”Œë˜ê·¸ì‹­',
                nameEn: 'Flagship',
                nameJa: 'ãƒ•ãƒ©ãƒƒã‚°ã‚·ãƒƒãƒ—',
                nameZh: 'æ——èˆ°',
                nameFr: 'Vaisseau Amiral',
                nameLa: 'Navis Praetoria',
                tier: 5,
                maxSpeed: 1000,  // 200 * 5
                acceleration: 90.0,
                turnSpeed: 0.15,
                maxFuel: 250,
                maxHull: 300,
                capacity: 300,  // ì ì¬ëŸ‰ (ìµœëŒ€)
                size: 'huge',
                color: 0xd4af37,
                accentColor: 0xffd700,
                special: 'allInOne',
                specialDesc: 'ì „ ê¸°ëŠ¥ í†µí•©',
                description: 'ìµœê³ ê¸‰ ê¸°í•¨. ëª¨ë“  ëŠ¥ë ¥ ë³´ìœ .',
                descEn: 'Ultimate flagship. All abilities included.',
                descJa: 'æœ€é«˜ç´šæ——è‰¦ã€‚å…¨èƒ½åŠ›æ­è¼‰ã€‚',
                descZh: 'é¡¶çº§æ——èˆ°ã€‚æ‹¥æœ‰æ‰€æœ‰èƒ½åŠ›ã€‚',
                descFr: 'Vaisseau amiral ultime. Toutes capacitÃ©s.',
                descLa: 'Optima navis. Omnes facultates.',
                price: 100000,
                unlocked: false
            }
        ];

        // ì „ì—­ ë…¸ì¶œ (ë©€í‹°í”Œë ˆì´ì–´ì—ì„œ ì‚¬ìš©)
        window.SHIP_TYPES = SHIP_TYPES;

        // â˜… ë¬´ê¸° ì‹œìŠ¤í…œ (30ì¢…) - weight ì¶”ê°€ (ì ì¬ëŸ‰ ì‹œìŠ¤í…œ)
        const WEAPONS = [
            // Tier 1 - ê¸°ë³¸ ë¬´ê¸° (ì…”í‹€~íƒì‚¬ì •) - weight: 5~8
            { id: 'laser_basic', name: 'ê¸°ë³¸ ë ˆì´ì €', tier: 1, damage: 10, fireRate: 2.0, range: 500, energy: 5, weight: 5, price: 200, desc: 'ê°€ì¥ ê¸°ë³¸ì ì¸ ë ˆì´ì € ë¬´ê¸°' },
            { id: 'laser_dual', name: 'ë“€ì–¼ ë ˆì´ì €', tier: 1, damage: 18, fireRate: 1.8, range: 500, energy: 8, weight: 7, price: 400, desc: 'ë‘ ì¤„ê¸° ë ˆì´ì € ë™ì‹œ ë°œì‚¬' },
            { id: 'machinegun', name: 'ìš°ì£¼ ê¸°ê´€ì´', tier: 1, damage: 5, fireRate: 8.0, range: 300, energy: 2, weight: 6, price: 350, desc: 'ë¹ ë¥¸ ì—°ì‚¬ ì†ë„ì˜ ì‹¤íƒ„ ë¬´ê¸°' },
            { id: 'flare_launcher', name: 'í”Œë ˆì–´ ëŸ°ì²˜', tier: 1, damage: 15, fireRate: 1.0, range: 200, energy: 10, weight: 8, price: 300, desc: 'ë¯¸ì‚¬ì¼ êµë€ìš© í”Œë ˆì–´' },

            // Tier 2 - ì¤‘ê¸‰ ë¬´ê¸° (ì¸í„°ì…‰í„°~í™”ë¬¼ì„ ) - weight: 10~18
            { id: 'laser_triple', name: 'íŠ¸ë¦¬í”Œ ë ˆì´ì €', tier: 2, damage: 25, fireRate: 1.5, range: 600, energy: 12, weight: 12, price: 800, desc: 'ì„¸ ì¤„ê¸° ë ˆì´ì € ë™ì‹œ ë°œì‚¬' },
            { id: 'pulse_laser', name: 'í„ìŠ¤ ë ˆì´ì €', tier: 2, damage: 30, fireRate: 3.0, range: 450, energy: 15, weight: 10, price: 1000, desc: 'ê³ ì† í„ìŠ¤ ì—ë„ˆì§€íƒ„' },
            { id: 'missile_basic', name: 'ê¸°ë³¸ ë¯¸ì‚¬ì¼', tier: 2, damage: 50, fireRate: 0.5, range: 1000, energy: 20, weight: 18, price: 1200, desc: 'ìœ ë„ ê¸°ëŠ¥ ì—†ëŠ” ì§ì„  ë¯¸ì‚¬ì¼' },
            { id: 'gatling', name: 'ê°œí‹€ë§ê±´', tier: 2, damage: 8, fireRate: 12.0, range: 350, energy: 3, weight: 15, price: 1500, desc: 'ì´ˆê³ ì† íšŒì „ ê¸°ê´€í¬' },
            { id: 'shotgun', name: 'ìŠ¤í˜ì´ìŠ¤ ì‚°íƒ„ì´', tier: 2, damage: 40, fireRate: 0.8, range: 150, energy: 18, weight: 14, price: 900, desc: 'ê·¼ê±°ë¦¬ ê´‘ì—­ í”¼í•´' },

            // Tier 3 - ê³ ê¸‰ ë¬´ê¸° (ì½”ë¥´ë²³~ë ˆì´ì„œ) - weight: 15~28
            { id: 'beam_laser', name: 'ë¹” ë ˆì´ì €', tier: 3, damage: 45, fireRate: 0.1, range: 800, energy: 25, weight: 18, price: 3000, desc: 'ì§€ì† ì¡°ì‚¬í˜• ê³ ì¶œë ¥ ë¹”' },
            { id: 'plasma_cannon', name: 'í”Œë¼ì¦ˆë§ˆ ìºë…¼', tier: 3, damage: 60, fireRate: 1.0, range: 600, energy: 30, weight: 22, price: 3500, desc: 'ê³ ì˜¨ í”Œë¼ì¦ˆë§ˆ ë°œì‚¬' },
            { id: 'ion_cannon', name: 'ì´ì˜¨ ìºë…¼', tier: 3, damage: 35, fireRate: 1.5, range: 700, energy: 22, weight: 16, price: 2800, desc: 'ì  ì‹œìŠ¤í…œ ë§ˆë¹„ íš¨ê³¼' },
            { id: 'homing_missile', name: 'í˜¸ë° ë¯¸ì‚¬ì¼', tier: 3, damage: 70, fireRate: 0.4, range: 1500, energy: 35, weight: 25, price: 4000, desc: 'ì—´ì¶”ì  ìœ ë„ ë¯¸ì‚¬ì¼' },
            { id: 'sniper_cannon', name: 'ìŠ¤ë‚˜ì´í¼ ìºë…¼', tier: 3, damage: 100, fireRate: 0.3, range: 2000, energy: 40, weight: 28, price: 4500, desc: 'ì´ˆì¥ê±°ë¦¬ ì •ë°€ ì‚¬ê²©' },
            { id: 'emp_missile', name: 'EMP ë¯¸ì‚¬ì¼', tier: 3, damage: 20, fireRate: 0.3, range: 800, energy: 45, weight: 20, price: 5000, desc: 'ì „ìê¸° í„ìŠ¤ë¡œ ì‹œìŠ¤í…œ ë§ˆë¹„' },

            // Tier 4 - ì „í•¨ê¸‰ ë¬´ê¸° (í”„ë¦¬ê¹ƒ~í¬ë£¨ì €) - weight: 25~45
            { id: 'railgun', name: 'ë ˆì¼ê±´', tier: 4, damage: 150, fireRate: 0.2, range: 2500, energy: 60, weight: 40, price: 8000, desc: 'ì „ìê¸° ê°€ì† ê´€í†µíƒ„' },
            { id: 'gauss_cannon', name: 'ê°€ìš°ìŠ¤ ìºë…¼', tier: 4, damage: 120, fireRate: 0.4, range: 1800, energy: 50, weight: 35, price: 7000, desc: 'ìê¸°ì¥ ê°€ì† ì¤‘ê¸ˆì†íƒ„' },
            { id: 'torpedo', name: 'ê´‘ì ì–´ë¢°', tier: 4, damage: 200, fireRate: 0.15, range: 3000, energy: 80, weight: 45, price: 10000, desc: 'ëŒ€í˜• í•¨ì„ ìš© ì¤‘ì–´ë¢°' },
            { id: 'cluster_missile', name: 'í´ëŸ¬ìŠ¤í„° ë¯¸ì‚¬ì¼', tier: 4, damage: 30, fireRate: 0.5, range: 1200, energy: 55, weight: 38, price: 9000, desc: 'ë¶„ì‚° íƒ„ë‘ 8ë°œ ë™ì‹œ í­ë°œ' },
            { id: 'tesla_coil', name: 'í…ŒìŠ¬ë¼ ì½”ì¼', tier: 4, damage: 80, fireRate: 2.0, range: 400, energy: 45, weight: 30, price: 8500, desc: 'ì—°ì‡„ ì „ê¸° ë°©ì „' },
            { id: 'disruptor', name: 'ë””ìŠ¤ëŸ½í„°', tier: 4, damage: 90, fireRate: 0.8, range: 600, energy: 55, weight: 28, price: 9500, desc: 'ì‹¤ë“œ íŠ¹í™” íŒŒê´´ ë¬´ê¸°' },

            // Tier 5 - ìµœì¢…ë³‘ê¸° (ë°°í‹€ì‹­~í”Œë˜ê·¸ì‹­) - weight: 40~80
            { id: 'antimatter_cannon', name: 'ë°˜ë¬¼ì§ˆ ìºë…¼', tier: 5, damage: 300, fireRate: 0.1, range: 2000, energy: 100, weight: 60, price: 25000, desc: 'ë°˜ë¬¼ì§ˆ í­ë°œë¡œ ê´‘ì—­ í”¼í•´' },
            { id: 'quantum_cannon', name: 'ì–‘ì ìºë…¼', tier: 5, damage: 250, fireRate: 0.15, range: 2500, energy: 90, weight: 55, price: 22000, desc: 'ì–‘ì ë¶ˆí™•ì •ì„± ê´€í†µ' },
            { id: 'nuke_missile', name: 'í•µ ë¯¸ì‚¬ì¼', tier: 5, damage: 500, fireRate: 0.05, range: 5000, energy: 150, weight: 80, price: 30000, desc: 'ì „ìˆ  í•µíƒ„ë‘ ë¯¸ì‚¬ì¼' },
            { id: 'gravity_well', name: 'ì¤‘ë ¥ì¥ ë°œìƒê¸°', tier: 5, damage: 50, fireRate: 0.2, range: 1000, energy: 120, weight: 50, price: 28000, desc: 'ì¤‘ë ¥ì¥ìœ¼ë¡œ ì  ì†ë°•' },
            { id: 'mine_layer', name: 'í€€í…€ ë§ˆì¸', tier: 5, damage: 180, fireRate: 0.3, range: 100, energy: 70, weight: 42, price: 20000, desc: 'ê³µê°„ì— ê¸°ë¢° ì„¤ì¹˜' },
            { id: 'singularity_launcher', name: 'íŠ¹ì´ì  ë°œì‚¬ê¸°', tier: 5, damage: 400, fireRate: 0.08, range: 1500, energy: 130, weight: 70, price: 35000, desc: 'ë¯¸ë‹ˆ ë¸”ë™í™€ ìƒì„±' },
            { id: 'darkmatter_beam', name: 'ì•”í‘ë¬¼ì§ˆ ë¹”', tier: 5, damage: 350, fireRate: 0.1, range: 3000, energy: 110, weight: 65, price: 32000, desc: 'ì•”í‘ë¬¼ì§ˆ ì—ë„ˆì§€ ë°©ì¶œ' },
            { id: 'tachyon_beam', name: 'íƒ€í‚¤ì˜¨ ë¹”', tier: 5, damage: 280, fireRate: 0.2, range: 4000, energy: 95, weight: 48, price: 28000, desc: 'ì´ˆê´‘ì† ì…ì ë¹”' },
            { id: 'omega_cannon', name: 'ì˜¤ë©”ê°€ ìºë…¼', tier: 5, damage: 1000, fireRate: 0.02, range: 3500, energy: 200, weight: 75, price: 50000, desc: 'ìµœì¢… ë³‘ê¸°, í–‰ì„±ê¸‰ íŒŒê´´ë ¥' }
        ];
        
        // â˜… ì¥ê°‘ ì‹œìŠ¤í…œ (5ë‹¨ê³„)
        const ARMORS = [
            { 
                id: 'steel_armor', 
                name: 'ê°•ì²  í•©ê¸ˆ ì¥ê°‘', 
                tier: 1, 
                defense: 50, 
                hpBonus: 100, 
                weight: 1.0,
                price: 500, 
                desc: 'ê¸°ë³¸ì ì¸ ê°•ì²  í•©ê¸ˆ ì¥ê°‘íŒ',
                effect: null
            },
            { 
                id: 'titanium_armor', 
                name: 'ê°•í™” í‹°íƒ€ëŠ„ ì¥ê°‘', 
                tier: 2, 
                defense: 100, 
                hpBonus: 200, 
                weight: 0.9,
                price: 2000, 
                desc: 'ê²½ëŸ‰ ê³ ê°•ë„ í‹°íƒ€ëŠ„ ë³µí•©ì¬',
                effect: 'ì´ë™ì†ë„ ê°ì†Œ 10% ê°ë©´'
            },
            { 
                id: 'nanocarbon_armor', 
                name: 'ë‚˜ë…¸ì¹´ë³¸ ë³µí•© ì¥ê°‘', 
                tier: 3, 
                defense: 180, 
                hpBonus: 350, 
                weight: 0.7,
                price: 8000, 
                desc: 'ë‚˜ë…¸ íƒ„ì†Œì„¬ìœ  ìê°€ìˆ˜ë³µ ì¥ê°‘',
                effect: '5ì´ˆë‹¹ HP 1% ìë™ íšŒë³µ'
            },
            { 
                id: 'energy_shield', 
                name: 'ì—ë„ˆì§€ ì‹¤ë“œ', 
                tier: 4, 
                defense: 280, 
                hpBonus: 500, 
                weight: 0.5,
                price: 20000, 
                desc: 'ì—ë„ˆì§€ ì—­ì¥ ë°©ì–´ë§‰',
                effect: 'ì—ë„ˆì§€ ë¬´ê¸° í”¼í•´ 30% ê°ì†Œ'
            },
            { 
                id: 'quantum_barrier', 
                name: 'ì–‘ì ë¶„í•´ ë°©ì–´ë²½', 
                tier: 5, 
                defense: 500, 
                hpBonus: 1000, 
                weight: 0.3,
                price: 50000, 
                desc: 'ì–‘ì ì–½í˜ì„ ì´ìš©í•œ ë¬¼ì§ˆ ë¶„í•´ ë°©ì–´ë²½. ì ‘ì´‰í•˜ëŠ” ëª¨ë“  ë¬¼ì²´ë¥¼ ì–‘ì ìˆ˜ì¤€ì—ì„œ ë¶„í•´í•˜ì—¬ ë¬´íš¨í™”',
                effect: 'í”¼í•´ì˜ 20%ë¥¼ ì ì—ê²Œ ë°˜ì‚¬, ì¼ì • í™•ë¥ ë¡œ í”¼í•´ ì™„ì „ ë¬´íš¨í™”'
            }
        ];
        
        // â˜… ìš°ì£¼ì„ ë³„ ë¬´ê¸°/ì¥ê°‘ ìŠ¬ë¡¯ ì„¤ì •
        const SHIP_COMBAT_STATS = {
            shuttle:     { weaponSlots: 1, armorSlots: 1, maxWeaponTier: 1, maxArmorTier: 2, hp: 100 },
            scout:       { weaponSlots: 1, armorSlots: 1, maxWeaponTier: 2, maxArmorTier: 2, hp: 80 },
            interceptor: { weaponSlots: 2, armorSlots: 1, maxWeaponTier: 3, maxArmorTier: 2, hp: 120 },
            freighter:   { weaponSlots: 1, armorSlots: 3, maxWeaponTier: 2, maxArmorTier: 3, hp: 300 },
            corvette:    { weaponSlots: 3, armorSlots: 2, maxWeaponTier: 3, maxArmorTier: 3, hp: 200 },
            racer:       { weaponSlots: 2, armorSlots: 1, maxWeaponTier: 3, maxArmorTier: 2, hp: 90 },
            frigate:     { weaponSlots: 4, armorSlots: 3, maxWeaponTier: 4, maxArmorTier: 4, hp: 350 },
            cruiser:     { weaponSlots: 5, armorSlots: 4, maxWeaponTier: 4, maxArmorTier: 4, hp: 500 },
            battleship:  { weaponSlots: 8, armorSlots: 5, maxWeaponTier: 5, maxArmorTier: 5, hp: 800 },
            flagship:    { weaponSlots: 10, armorSlots: 5, maxWeaponTier: 5, maxArmorTier: 5, hp: 1000 }
        };
        
        // â˜… ë¬´ê¸° ì•„ì´ì½˜ ë§¤í•‘
        const WEAPON_ICONS = {
            laser_basic: 'ğŸ”«', laser_dual: 'ğŸ”«', laser_triple: 'ğŸ”«', beam_laser: 'âš¡',
            pulse_laser: 'ğŸ’¥', machinegun: 'ğŸ”§', gatling: 'âš™ï¸', shotgun: 'ğŸ’£',
            flare_launcher: 'ğŸ†', missile_basic: 'ğŸš€', homing_missile: 'ğŸ¯', emp_missile: 'âš¡',
            cluster_missile: 'ğŸ’¢', plasma_cannon: 'ğŸ”¥', ion_cannon: 'âš¡', sniper_cannon: 'ğŸ¯',
            railgun: 'âš¡', gauss_cannon: 'ğŸ§²', torpedo: 'ğŸŸ', tesla_coil: 'âš¡',
            disruptor: 'ğŸ’«', antimatter_cannon: 'â˜¢ï¸', quantum_cannon: 'ğŸ”®', nuke_missile: 'â˜¢ï¸',
            gravity_well: 'ğŸŒ€', mine_layer: 'ğŸ’£', singularity_launcher: 'ğŸ•³ï¸',
            darkmatter_beam: 'ğŸŒ‘', tachyon_beam: 'âœ¨', omega_cannon: 'ğŸ’€'
        };
        
        const ARMOR_ICONS = {
            steel_armor: 'ğŸ›¡ï¸', titanium_armor: 'ğŸ”°', nanocarbon_armor: 'ğŸ”·',
            energy_shield: 'ğŸ’ ', quantum_barrier: 'ğŸŒŸ'
        };
        
        // â˜… í”Œë ˆì´ì–´ ë¬´ì¥ ì¸ë²¤í† ë¦¬
        // â˜… ë©€í‹°ëª¨ë“œ: ì„œë²„ ì €ì¥, ì‹±ê¸€ëª¨ë“œ: localStorage
        let playerArmory = JSON.parse(localStorage.getItem('milkyway-armory') || '{}');
        let armoryLoaded = false;  // ì„œë²„ì—ì„œ ë¡œë“œ ì™„ë£Œ ì—¬ë¶€

        // â˜… ë¬´ê¸°ê³  ì„œë²„ì—ì„œ ë¡œë“œ (ë©€í‹°ëª¨ë“œ ì´ˆê¸°í™”ìš©)
        async function loadArmoryFromServer() {
            if (window.gameMode !== 'multi') return;
            try {
                const serverData = await GameDataManager.load('armory', 'milkyway-armory');
                if (serverData) {
                    playerArmory = serverData;
                    console.log('âœ… ë¬´ê¸°ê³  ì„œë²„ì—ì„œ ë¡œë“œë¨');
                }
                armoryLoaded = true;
            } catch (e) {
                console.warn('ë¬´ê¸°ê³  ì„œë²„ ë¡œë“œ ì‹¤íŒ¨:', e);
            }
        }

        function saveArmory() {
            // â˜… GameDataManagerë¥¼ í†µí•´ ì €ì¥ (ë©€í‹°: ì„œë²„, ì‹±ê¸€: ë¡œì»¬)
            GameDataManager.save('armory', playerArmory, 'milkyway-armory');
        }

        function getPlayerArmory() {
            // mpUser ë˜ëŠ” mpUserId ì‚¬ìš©
            const oderId = window.mpUserId || (window.mpUser && window.mpUser.username);
            if (!oderId) return { ownedWeapons: [], ownedArmors: [], equipped: {} };
            if (!playerArmory[oderId]) {
                playerArmory[oderId] = {
                    ownedWeapons: ['laser_basic'],  // ê¸°ë³¸ ë¬´ê¸° ì§€ê¸‰
                    ownedArmors: [],
                    equipped: {}  // shipId: { weapons: [], armor: null }
                };
                saveArmory();
            }
            return playerArmory[oderId];
        }
        
        function ownsWeapon(weaponId) {
            return getPlayerArmory().ownedWeapons.includes(weaponId);
        }
        
        function ownsArmor(armorId) {
            return getPlayerArmory().ownedArmors.includes(armorId);
        }
        
        function buyWeapon(weaponId) {
            const weapon = WEAPONS.find(w => w.id === weaponId);
            const userId = window.mpUserId || (window.mpUser && window.mpUser.username);
            if (!weapon || !userId) return false;
            if (ownsWeapon(weaponId)) return false;
            if (!spendCoins(weapon.price)) return false;
            getPlayerArmory().ownedWeapons.push(weaponId);
            saveArmory();
            return true;
        }
        
        function buyArmor(armorId) {
            const armor = ARMORS.find(a => a.id === armorId);
            const userId = window.mpUserId || (window.mpUser && window.mpUser.username);
            if (!armor || !userId) return false;
            if (ownsArmor(armorId)) return false;
            if (!spendCoins(armor.price)) return false;
            getPlayerArmory().ownedArmors.push(armorId);
            saveArmory();
            return true;
        }
        
        function getEquipped(shipId) {
            const armory = getPlayerArmory();
            if (!armory.equipped[shipId]) {
                armory.equipped[shipId] = { weapons: [], armor: null };
            }
            return armory.equipped[shipId];
        }
        
        function equipWeapon(shipId, weaponId, slotIndex) {
            const ship = SHIP_TYPES.find(s => s.id === shipId);
            const weapon = WEAPONS.find(w => w.id === weaponId);
            const combatStats = SHIP_COMBAT_STATS[shipId];
            if (!ship || !weapon || !combatStats) return false;
            if (weapon.tier > combatStats.maxWeaponTier) return false;
            if (slotIndex >= combatStats.weaponSlots) return false;
            if (!ownsWeapon(weaponId)) return false;

            // â˜…â˜…â˜… ì ì¬ëŸ‰ ì²´í¬ â˜…â˜…â˜…
            const equipped = getEquipped(shipId);
            const currentSlotWeapon = equipped.weapons[slotIndex];
            let removedWeight = 0;
            if (currentSlotWeapon) {
                const oldWeapon = WEAPONS.find(w => w.id === currentSlotWeapon);
                if (oldWeapon) removedWeight = oldWeapon.weight || 0;
            }
            const newWeight = weapon.weight || 0;
            const currentWeight = getEquippedWeight(shipId);
            const maxCapacity = ship.capacity || 100;
            if ((currentWeight - removedWeight + newWeight) > maxCapacity) {
                return { success: false, reason: 'capacity' };  // ì ì¬ëŸ‰ ì´ˆê³¼
            }

            equipped.weapons[slotIndex] = weaponId;
            saveArmory();
            return true;
        }

        function equipArmor(shipId, armorId) {
            const ship = SHIP_TYPES.find(s => s.id === shipId);
            const armor = ARMORS.find(a => a.id === armorId);
            const combatStats = SHIP_COMBAT_STATS[shipId];
            if (!ship || !armor || !combatStats) return false;
            if (armor.tier > combatStats.maxArmorTier) return false;
            if (!ownsArmor(armorId)) return false;

            // â˜…â˜…â˜… ì ì¬ëŸ‰ ì²´í¬ â˜…â˜…â˜…
            const equipped = getEquipped(shipId);
            const baseArmorWeight = 30;
            let removedWeight = 0;
            if (equipped.armor) {
                const oldArmor = ARMORS.find(a => a.id === equipped.armor);
                if (oldArmor) removedWeight = baseArmorWeight * (oldArmor.weight || 1);
            }
            const newWeight = baseArmorWeight * (armor.weight || 1);
            const currentWeight = getEquippedWeight(shipId);
            const maxCapacity = ship.capacity || 100;
            if ((currentWeight - removedWeight + newWeight) > maxCapacity) {
                return { success: false, reason: 'capacity' };  // ì ì¬ëŸ‰ ì´ˆê³¼
            }

            equipped.armor = armorId;
            saveArmory();
            return true;
        }
        
        function unequipWeapon(shipId, slotIndex) {
            const equipped = getEquipped(shipId);
            equipped.weapons[slotIndex] = null;
            saveArmory();
        }
        
        function unequipArmor(shipId) {
            const equipped = getEquipped(shipId);
            equipped.armor = null;
            saveArmory();
        }

        // â˜…â˜…â˜… ì ì¬ëŸ‰ ê³„ì‚° í•¨ìˆ˜ â˜…â˜…â˜…
        function getEquippedWeight(shipId) {
            const equipped = getEquipped(shipId);
            let totalWeight = 0;

            // ë¬´ê¸° ë¬´ê²Œ í•©ì‚°
            if (equipped.weapons) {
                equipped.weapons.forEach(weaponId => {
                    if (weaponId) {
                        const weapon = WEAPONS.find(w => w.id === weaponId);
                        if (weapon) totalWeight += weapon.weight || 0;
                    }
                });
            }

            // ì¥ê°‘ ë¬´ê²Œ í•©ì‚° (weightê°€ ê³„ìˆ˜ì¸ ê²½ìš° ê¸°ë³¸ ë¬´ê²Œ 20ìœ¼ë¡œ ê³„ì‚°)
            if (equipped.armor) {
                const armor = ARMORS.find(a => a.id === equipped.armor);
                if (armor) {
                    // armor.weightê°€ 1.0, 0.9 ë“± ê³„ìˆ˜ì¸ ê²½ìš° ê¸°ë³¸ ë¬´ê²Œ * ê³„ìˆ˜ë¡œ ê³„ì‚°
                    const baseArmorWeight = 30;  // ê¸°ë³¸ ì¥ê°‘ ë¬´ê²Œ
                    totalWeight += baseArmorWeight * (armor.weight || 1);
                }
            }

            return totalWeight;
        }

        // ì ì¬ëŸ‰ ì´ˆê³¼ ì²´í¬ í•¨ìˆ˜
        function canEquipWeight(shipId, additionalWeight) {
            const ship = SHIP_TYPES.find(s => s.id === shipId);
            if (!ship) return false;

            const currentWeight = getEquippedWeight(shipId);
            const maxCapacity = ship.capacity || 100;

            return (currentWeight + additionalWeight) <= maxCapacity;
        }

        // í˜„ì¬ ìš°ì£¼ì„  ì„¤ì • (ì„ íƒëœ ìš°ì£¼ì„  íƒ€ì…ì—ì„œ ê°€ì ¸ì˜´)
        let currentShipType = SHIP_TYPES[0];  // ê¸°ë³¸: ì…”í‹€
        window.currentShipType = currentShipType;  // â˜… ì „ì—­ ë…¸ì¶œ
        let selectedShipIndex = 0;
        
        // íŠ¹ìˆ˜ëŠ¥ë ¥ ìƒíƒœ
        let shipAbility = {
            cooldown: 0,
            shieldActive: false,
            afterburnerActive: false,
            warpReady: true
        };
        
        // ê±°ë¦¬ ëª¨ë“œ ì €ì¥ìš©
        let savedDistScale = 1.0;
        
        const SHIP_CONFIG = {
            get maxSpeed() { return currentShipType.maxSpeed; },
            get acceleration() { return currentShipType.acceleration; },
            get deceleration() { return currentShipType.acceleration * 0.6; },
            get reverseThrust() { return currentShipType.acceleration * 2.5; },
            get turnSpeed() { return currentShipType.turnSpeed; },
            get maxFuel() { return currentShipType.maxFuel; },
            get maxHull() { return currentShipType.maxHull || 100; },  // â˜… ë‚´êµ¬ë„ ì¶”ê°€
            fuelConsumption: 5.0,  // 100ë°° ì¦ê°€ (0.05 â†’ 5.0)
            reverseFuelMult: 5,
            emergencyBrakeFuelMult: 3,
            gravityWarningThreshold: 0.3,
            orbitAltitudeMultiplier: 2.5
        };
        
        let playerShip = null;
        let savedShipState = null;  // ìš°ì£¼ì„  ìœ„ì¹˜/ë°©í–¥ ì €ì¥ìš©
        let dockedShipMesh = null;
        let isPilotMode = false;
        let isInteriorMode = false;
        let isObservatoryMode = false;
        let shipTargetBody = null;
        let autopilot = { engaged: false, phase: 'idle' };
        const shipInputs = { pitch: 0, yaw: 0, throttle: 0, brake: false, emergencyReverse: false };
        window.shipInputs = shipInputs;  // â˜… ì „ì—­ìœ¼ë¡œ ë…¸ì¶œ (ëª¨ë°”ì¼ ë²„íŠ¼ìš©)
        let joystickActive = false, joystickCenter = { x: 0, y: 0 };
        let currentETA = 0;
        let isGravityWarning = false;
        let beepInterval = null;
        
        // â˜… engineConfig ë¶ˆê½ƒ ê·¸ë£¹ (ì „ì—­)
        var configuredThrustFlames = null;
        var configuredReverseFlames = null;
        var hasEngineConfig = false;
        let audioContext = null;

        // â˜…â˜…â˜… ë¬´ê¸° ë°œì‚¬ ì‹œìŠ¤í…œ â˜…â˜…â˜…
        const weaponSystem = {
            projectiles: [],        // ë°œì‚¬ëœ íˆ¬ì‚¬ì²´ë“¤
            beams: [],              // ë¹” ë ˆì´ì €ë“¤
            lastFireTime: 0,        // ë§ˆì§€ë§‰ ë°œì‚¬ ì‹œê°„
            isFiring: false,        // ë°œì‚¬ ë²„íŠ¼ ëˆ„ë¥´ëŠ” ì¤‘
            fireRate: 0.15,         // ë°œì‚¬ ê°„ê²© (ì´ˆ)
            projectileSpeed: 500,   // íˆ¬ì‚¬ì²´ ì†ë„
            projectileRange: 1000,  // íˆ¬ì‚¬ì²´ ì‚¬ê±°ë¦¬
            damage: 15,             // ê¸°ë³¸ ë°ë¯¸ì§€
            maxProjectiles: 50      // ìµœëŒ€ íˆ¬ì‚¬ì²´ ìˆ˜
        };

        // â˜…â˜…â˜… ìš°ì£¼ì •ê±°ì¥ ë°˜ê²© ì‹œìŠ¤í…œ â˜…â˜…â˜…
        const stationDefense = {
            beams: [],              // ë°˜ê²© ë¹”ë“¤
            lastFireTime: {},       // ì •ê±°ì¥ë³„ ë§ˆì§€ë§‰ ë°œì‚¬ ì‹œê°„
            fireRate: 2.0,          // ë°˜ê²© ê°„ê²© (ì´ˆ)
            beamDuration: 0.5,      // ë¹” ì§€ì† ì‹œê°„ (ì´ˆ)
            damage: 10,             // ë°˜ê²© ë°ë¯¸ì§€
            range: 200              // ë°˜ê²© ì‚¬ê±°ë¦¬
        };

        // â˜… ë„í‚¹ í•´ì œ ì—°ì¶œ ì‹œìŠ¤í…œ
        let undockingState = {
            active: false,
            phase: 'idle',  // 'idle', 'undocking', 'complete'
            startTime: 0,
            duration: 8000,  // â˜… 8ì´ˆ ì—°ì¶œ (ì†ë„ ì ˆë°˜ìœ¼ë¡œ ê°ì†Œ)
            startPos: null,
            targetDist: 2,   // â˜… ì •ê±°ì¥ì—ì„œ ì´íƒˆ ê±°ë¦¬ (ë” ì¤„ì„)
            stationPos: null,
            undockDirection: null  // â˜… ì§€êµ¬ ë°˜ëŒ€ ë°©í–¥ ì €ì¥
        };
        
        // â˜… ê¸´ê¸‰ ì—­ì¶”ì§„ ì‹œìŠ¤í…œ
        let emergencyBrakeActive = false;
        const EMERGENCY_BRAKE_FUEL_MULT = 5;  // ì—°ë£Œ 5ë°° ì†Œëª¨
        const EMERGENCY_BRAKE_POWER_MULT = 3;  // ì—­ì¶”ì§„ íš¨ìœ¨ 3ë°°
        
        // â˜…â˜…â˜… AI ë¶€ì¡°ì¢…ì‚¬ ì‹œìŠ¤í…œ (ARIA) â˜…â˜…â˜…
        const aiCopilot = {
            isTyping: false,
            typeSpeed: 60,  // ms per character (ëŠë¦¬ê²Œ)
            lastWarningTime: 0,
            lastBodyCheck: null,
            missionActive: null,
            commEvent: null,
            audioCtx: null,
            warningCooldowns: {
                fuel: 0,
                speed: 0,
                collision: 0,
                gravity: 0
            }
        };
        
        // AI ë¯¸ì…˜ í…œí”Œë¦¿
        const AI_MISSIONS = [
            { id: 'explore', type: 'explore', title: 'íƒì‚¬ ë¯¸ì…˜', desc: '{target} ê·¼ì²˜ë¥¼ íƒì‚¬í•˜ì„¸ìš”.', reward: 200, targets: ['í™”ì„±', 'ëª©ì„±', 'í† ì„±', 'ì²œì™•ì„±'] },
            { id: 'speed', type: 'speed', title: 'ì†ë„ ë„ì „', desc: '{speed}km/s ì´ìƒ ë„ë‹¬í•˜ì„¸ìš”.', reward: 150, speeds: [50, 75, 100] },
            { id: 'orbit', type: 'orbit', title: 'ê¶¤ë„ ì§„ì…', desc: '{target} ê¶¤ë„ì— ì§„ì…í•˜ì„¸ìš”.', reward: 300, targets: ['ì§€êµ¬', 'í™”ì„±', 'ëª©ì„±'] },
            { id: 'fuel', type: 'fuel', title: 'ì—°ë£Œ íš¨ìœ¨', desc: 'ì—°ë£Œ {fuel}% ì´ìƒ ìœ ì§€í•˜ë©° {target}ê¹Œì§€ ë¹„í–‰', reward: 250, fuels: [50, 70], targets: ['í™”ì„±', 'ê¸ˆì„±'] },
            { id: 'distance', type: 'distance', title: 'ì¥ê±°ë¦¬ ë¹„í–‰', desc: '{distance}AU ì´ìƒ ë¹„í–‰í•˜ì„¸ìš”.', reward: 500, distances: [5, 10, 20] }
        ];
        
        // AI êµì‹  ì´ë²¤íŠ¸ í…œí”Œë¦¿
        const AI_COMM_EVENTS = [
            {
                id: 'alien_friendly',
                portrait: 'ğŸ‘½',
                name: 'ì™¸ê³„ íƒì‚¬ì„ ',
                message: 'í‰í™”ë¡œìš´ ì¸ì‚¬ë¥¼ ì „í•©ë‹ˆë‹¤, ì§€êµ¬ì¸. ìš°ë¦¬ëŠ” íƒì‚¬ ëª©ì ìœ¼ë¡œ ì´ êµ¬ì—­ì„ ì§€ë‚˜ê³  ìˆìŠµë‹ˆë‹¤. ì •ë³´ë¥¼ êµí™˜í•˜ì‹œê² ìŠµë‹ˆê¹Œ?',
                choices: [
                    { text: 'ğŸ“¡ ì •ë³´ êµí™˜ ìˆ˜ë½', action: 'accept', result: { coins: 100, message: 'ìœ ìš©í•œ í•­ë¡œ ì •ë³´ë¥¼ ì–»ì—ˆìŠµë‹ˆë‹¤! +100 ì½”ì¸' } },
                    { text: 'ğŸ‘‹ ì •ì¤‘íˆ ê±°ì ˆ', action: 'decline', result: { message: 'ì™¸ê³„ íƒì‚¬ì„ ì´ í‰í™”ë¡­ê²Œ ë– ë‚¬ìŠµë‹ˆë‹¤.' } }
                ]
            },
            {
                id: 'pirate',
                portrait: 'ğŸ´â€â˜ ï¸',
                name: 'ìš°ì£¼ í•´ì ',
                message: 'ë©ˆì¶°ë¼! í™”ë¬¼ì„ ë‚´ë†“ìœ¼ë©´ ì‚´ë ¤ì£¼ì§€. ì €í•­í•˜ë©´... ì•Œê² ì§€?',
                choices: [
                    { text: 'ğŸ’° ì½”ì¸ 50ê°œ ì§€ë¶ˆ', action: 'pay', cost: 50, result: { message: 'í•´ì ì´ ì½”ì¸ì„ ë°›ê³  ë– ë‚¬ìŠµë‹ˆë‹¤.' } },
                    { text: 'ğŸš€ ë„ì£¼ ì‹œë„', action: 'flee', result: { damage: 10, message: 'ë„ì£¼ ì¤‘ ì„ ì²´ì— ê²½ë¯¸í•œ ì†ìƒ! -10% ì—°ë£Œ' } },
                    { text: 'âš”ï¸ ì „íˆ¬ ì¤€ë¹„', action: 'fight', result: { coins: 150, damage: 20, message: 'í•´ì ì„ ê²©í‡´í–ˆìŠµë‹ˆë‹¤! +150 ì½”ì¸, -20% ì—°ë£Œ' } }
                ]
            },
            {
                id: 'station_hail',
                portrait: 'ğŸ›°ï¸',
                name: 'ìš°ì£¼ ì •ê±°ì¥ ê´€ì œ',
                message: 'ë¯¸í™•ì¸ ì„ ë°•, ì‹ë³„ ì½”ë“œë¥¼ ì „ì†¡í•˜ì„¸ìš”. ë„í‚¹ í—ˆê°€ê°€ í•„ìš”í•©ë‹ˆë‹¤.',
                choices: [
                    { text: 'ğŸ“‹ ì‹ë³„ ì½”ë“œ ì „ì†¡', action: 'identify', result: { message: 'ë„í‚¹ í—ˆê°€ê°€ ìŠ¹ì¸ë˜ì—ˆìŠµë‹ˆë‹¤. ì•ˆì „í•œ ë¹„í–‰ ë˜ì„¸ìš”.' } },
                    { text: 'ğŸ”„ ë¬´ì‹œí•˜ê³  ì§€ë‚˜ê°', action: 'ignore', result: { message: 'ê´€ì œì†Œì—ì„œ ê²½ê³ ë¥¼ ë³´ë‚´ì§€ë§Œ ì¶”ì ì€ ì—†ìŠµë‹ˆë‹¤.' } }
                ]
            },
            {
                id: 'distress',
                portrait: 'ğŸ†˜',
                name: 'ì¡°ë‚œ ì‹ í˜¸',
                message: 'ë©”ì´ë°ì´! ë©”ì´ë°ì´! ì—”ì§„ ê³ ì¥ìœ¼ë¡œ í‘œë¥˜ ì¤‘ì…ë‹ˆë‹¤. ì—°ë£Œë¥¼ ë‚˜ëˆ ì£¼ì‹¤ ìˆ˜ ìˆìŠµë‹ˆê¹Œ?',
                choices: [
                    { text: 'â›½ ì—°ë£Œ 20% ì œê³µ', action: 'help', cost_fuel: 20, result: { coins: 200, message: 'ê°ì‚¬í•©ë‹ˆë‹¤! ë³´ìƒìœ¼ë¡œ ì½”ì¸ì„ ë“œë¦½ë‹ˆë‹¤. +200 ì½”ì¸' } },
                    { text: 'ğŸ“¡ êµ¬ì¡°ëŒ€ì— ì—°ë½', action: 'contact', result: { message: 'ê·¼ì²˜ ì •ê±°ì¥ì— êµ¬ì¡° ìš”ì²­ì„ ì „ë‹¬í–ˆìŠµë‹ˆë‹¤.' } },
                    { text: 'ğŸ˜” ë„ìš¸ ìˆ˜ ì—†ìŒ', action: 'decline', result: { message: 'ì•ˆíƒ€ê¹ì§€ë§Œ ì§€ë‚˜ì¹©ë‹ˆë‹¤.' } }
                ]
            },
            {
                id: 'trader',
                portrait: 'ğŸ›¸',
                name: 'ìš°ì£¼ ìƒì¸',
                message: 'ì—¬í–‰ìì—¬! í¬ê·€í•œ ë¬¼í’ˆì´ ìˆì†Œ. 100 ì½”ì¸ì— í–‰ìš´ì˜ ë¶€ì ì„... êµ¬ë§¤í•˜ë©´ ì¢‹ì€ ì¼ì´ ìƒê¸¸ ê±°ìš”!',
                choices: [
                    { text: 'ğŸ’ 100 ì½”ì¸ ì§€ë¶ˆ', action: 'buy', cost: 100, result: { coins: 300, message: 'í–‰ìš´ì˜ ë¶€ì ì´ ë¹›ë‚¬ìŠµë‹ˆë‹¤! ìˆ¨ê²¨ì§„ ë³´ë¬¼ ë°œê²¬! +300 ì½”ì¸' } },
                    { text: 'ğŸ™… ì‚¬ì–‘í•©ë‹ˆë‹¤', action: 'decline', result: { message: 'ìƒì¸ì´ ì•„ì‰¬ì›Œí•˜ë©° ë– ë‚¬ìŠµë‹ˆë‹¤.' } }
                ]
            }
        ];
        
        // â˜…â˜…â˜… SSIL ë¯¸ì…˜ ì‹œìŠ¤í…œ â˜…â˜…â˜…
        const SSIL_TRAINING_MISSIONS = [
            { id: 'explore', type: 'explore', title: 'íƒì‚¬ ë¯¸ì…˜', desc: 'ğŸš€ í™”ì„±ì— ê°€ê¹Œì´ ê°€ë³´ì„¸ìš”! (ê±°ë¦¬ 50 ì´ë‚´)', reward: 200, target: 'í™”ì„±', targetDist: 50 },
            { id: 'speed', type: 'speed', title: 'ì†ë„ ë„ì „', desc: 'âš¡ ìš°ì£¼ì„  ì†ë„ë¥¼ 50km/sê¹Œì§€ ì˜¬ë ¤ë³´ì„¸ìš”!', reward: 150, targetSpeed: 50 },
            { id: 'orbit', type: 'orbit', title: 'ê¶¤ë„ ì§„ì…', desc: 'ğŸŒ ì§€êµ¬ ê¶¤ë„ì— ë“¤ì–´ê°€ì„¸ìš” (ë„ì°© í›„ ê¶¤ë„ ë²„íŠ¼)', reward: 300, target: 'ì§€êµ¬' },
            { id: 'fuel', type: 'fuel', title: 'ì—°ë£Œ íš¨ìœ¨', desc: 'â›½ ì—°ë£Œ 50% ì´ìƒ ë‚¨ê¸°ê³  í™”ì„±ê¹Œì§€ ê°€ì„¸ìš”!', reward: 250, minFuel: 50, target: 'í™”ì„±' },
            { id: 'distance', type: 'distance', title: 'ì¥ê±°ë¦¬ ë¹„í–‰', desc: 'ğŸŒŒ íƒœì–‘ì—ì„œ 5AU ì´ìƒ ë©€ë¦¬ ê°€ë³´ì„¸ìš”! (ëª©ì„± ê·¼ì²˜)', reward: 500, targetDistance: 5 }
        ];
        
        // ì¼ì¼ ë¯¸ì…˜ í…œí”Œë¦¿ (ê° 10ê°œì”©)
        const DAILY_MISSION_TEMPLATES = {
            delivery: [
                { title: 'í™”ì„± ê¸´ê¸‰ ë°°ë‹¬', desc: 'í™”ì„± ì •ê±°ì¥ìœ¼ë¡œ ê¸´ê¸‰ ë¬¼ì ë°°ë‹¬', target: 'í™”ì„±', reward: 300 },
                { title: 'ëª©ì„± ë³´ê¸‰ ì„ë¬´', desc: 'ëª©ì„± ì •ê±°ì¥ì— ì—°ë£Œ ë³´ê¸‰í’ˆ ì „ë‹¬', target: 'ëª©ì„±', reward: 450 },
                { title: 'í† ì„± ì—°êµ¬ ì¥ë¹„', desc: 'í† ì„± ì—°êµ¬ì†Œì— ì¥ë¹„ ë°°ì†¡', target: 'í† ì„±', reward: 500 },
                { title: 'ê¸ˆì„± ì˜ì•½í’ˆ ìˆ˜ì†¡', desc: 'ê¸ˆì„± ê¸°ì§€ì— ì˜ì•½í’ˆ ê¸´ê¸‰ ìˆ˜ì†¡', target: 'ê¸ˆì„±', reward: 350 },
                { title: 'ì²œì™•ì„± íƒì‚¬ ì¥ë¹„', desc: 'ì²œì™•ì„± ì „ì´ˆê¸°ì§€ì— íƒì‚¬ ì¥ë¹„ ë°°ë‹¬', target: 'ì²œì™•ì„±', reward: 600 },
                { title: 'í•´ì™•ì„± ì‹ëŸ‰ ë³´ê¸‰', desc: 'í•´ì™•ì„± ì •ê±°ì¥ì— ì‹ëŸ‰ ë³´ê¸‰', target: 'í•´ì™•ì„±', reward: 700 },
                { title: 'ìˆ˜ì„± ëƒ‰ê° ì¥ì¹˜', desc: 'ìˆ˜ì„± ê¸°ì§€ì— ëƒ‰ê° ì¥ì¹˜ ë°°ì†¡', target: 'ìˆ˜ì„±', reward: 400 },
                { title: 'ISS ë¶€í’ˆ ìˆ˜ì†¡', desc: 'ISSì— êµì²´ ë¶€í’ˆ ì „ë‹¬', target: 'ISS', reward: 200 },
                { title: 'ë‹¬ ê¸°ì§€ ë¬¼ì', desc: 'ë‹¬ ê¸°ì§€ì— ìƒí™œ ë¬¼ì ë°°ì†¡', target: 'ë‹¬', reward: 250 },
                { title: 'ì™¸ê³½ ì „ì´ˆê¸°ì§€', desc: 'ì¹´ì´í¼ ë²¨íŠ¸ ì „ì´ˆê¸°ì§€ì— ë¬¼ì ìˆ˜ì†¡', target: 'í•´ì™•ì„±', reward: 800 }
            ],
            stationTour: [
                { title: 'ë‚´í–‰ì„± ìˆœíšŒ', desc: 'ìˆ˜ì„±, ê¸ˆì„±, í™”ì„± ì •ê±°ì¥ ë°©ë¬¸', targets: ['ìˆ˜ì„±', 'ê¸ˆì„±', 'í™”ì„±'], reward: 400 },
                { title: 'ì™¸í–‰ì„± íƒë°©', desc: 'ëª©ì„±, í† ì„±, ì²œì™•ì„± ì •ê±°ì¥ ë°©ë¬¸', targets: ['ëª©ì„±', 'í† ì„±', 'ì²œì™•ì„±'], reward: 550 },
                { title: 'ê°€ìŠ¤ í–‰ì„± íˆ¬ì–´', desc: 'ëª©ì„±, í† ì„± ì •ê±°ì¥ ìˆœíšŒ', targets: ['ëª©ì„±', 'í† ì„±'], reward: 450 },
                { title: 'ì–¼ìŒ í–‰ì„± íƒí—˜', desc: 'ì²œì™•ì„±, í•´ì™•ì„± ì •ê±°ì¥ ë°©ë¬¸', targets: ['ì²œì™•ì„±', 'í•´ì™•ì„±'], reward: 650 },
                { title: 'ì§€êµ¬ê¶Œ ìˆœì°°', desc: 'ISSì™€ ë‹¬ ê¸°ì§€ ì ê²€', targets: ['ì§€êµ¬', 'ë‹¬'], reward: 300 },
                { title: 'íƒœì–‘ê³„ ì¼ì£¼', desc: 'ëª¨ë“  í–‰ì„± ì •ê±°ì¥ ë°©ë¬¸', targets: ['ìˆ˜ì„±', 'ê¸ˆì„±', 'í™”ì„±', 'ëª©ì„±', 'í† ì„±'], reward: 800 },
                { title: 'ì•”ì„ í–‰ì„± íˆ¬ì–´', desc: 'ìˆ˜ì„±, ê¸ˆì„±, í™”ì„± íƒë°©', targets: ['ìˆ˜ì„±', 'ê¸ˆì„±', 'í™”ì„±'], reward: 400 },
                { title: 'ê±°ëŒ€ í–‰ì„± ìˆœë¡€', desc: 'ëª©ì„±, í† ì„± ì •ê±°ì¥ ë°©ë¬¸', targets: ['ëª©ì„±', 'í† ì„±'], reward: 500 },
                { title: 'ë¨¼ ìš°ì£¼ ì—¬í–‰', desc: 'ì²œì™•ì„±, í•´ì™•ì„±ê¹Œì§€ ì™•ë³µ', targets: ['ì²œì™•ì„±', 'í•´ì™•ì„±'], reward: 700 },
                { title: 'ì‹ ì… ìˆœì°°', desc: 'ì§€êµ¬, í™”ì„± ì •ê±°ì¥ ì ê²€', targets: ['ì§€êµ¬', 'í™”ì„±'], reward: 350 }
            ],
            timeAttack: [
                { title: 'í™”ì„± ê¸‰í–‰', desc: 'ì§€êµ¬â†’í™”ì„± 15ë¶„ ë‚´ ë„ì°©', target: 'í™”ì„±', timeLimit: 900, reward: 350 },
                { title: 'ëª©ì„± íŠ¹ê¸‰', desc: 'ì§€êµ¬â†’ëª©ì„± 20ë¶„ ë‚´ ë„ì°©', target: 'ëª©ì„±', timeLimit: 1200, reward: 450 },
                { title: 'ê¸ˆì„± ìŠ¤í”„ë¦°íŠ¸', desc: 'ì§€êµ¬â†’ê¸ˆì„± 10ë¶„ ë‚´ ë„ì°©', target: 'ê¸ˆì„±', timeLimit: 600, reward: 300 },
                { title: 'í† ì„± ë ˆì´ìŠ¤', desc: 'ì§€êµ¬â†’í† ì„± 25ë¶„ ë‚´ ë„ì°©', target: 'í† ì„±', timeLimit: 1500, reward: 500 },
                { title: 'ìˆ˜ì„± ë„ì „', desc: 'ì§€êµ¬â†’ìˆ˜ì„± 12ë¶„ ë‚´ ë„ì°©', target: 'ìˆ˜ì„±', timeLimit: 720, reward: 350 },
                { title: 'ì²œì™•ì„± ë§ˆë¼í†¤', desc: 'ì§€êµ¬â†’ì²œì™•ì„± 30ë¶„ ë‚´ ë„ì°©', target: 'ì²œì™•ì„±', timeLimit: 1800, reward: 600 },
                { title: 'í•´ì™•ì„± ìš¸íŠ¸ë¼', desc: 'ì§€êµ¬â†’í•´ì™•ì„± 40ë¶„ ë‚´ ë„ì°©', target: 'í•´ì™•ì„±', timeLimit: 2400, reward: 750 },
                { title: 'ë‹¬ ìŠ¤í”„ë¦°íŠ¸', desc: 'ì§€êµ¬â†’ë‹¬ 5ë¶„ ë‚´ ë„ì°©', target: 'ë‹¬', timeLimit: 300, reward: 200 },
                { title: 'ISS ë„í‚¹', desc: 'ISSì— 3ë¶„ ë‚´ ë„í‚¹', target: 'ISS', timeLimit: 180, reward: 250 },
                { title: 'ì™•ë³µ ì±Œë¦°ì§€', desc: 'í™”ì„± ì™•ë³µ 30ë¶„', target: 'í™”ì„±', timeLimit: 1800, reward: 500 }
            ],
            exploration: [
                { title: 'í™”ì„± í‘œë©´ ìŠ¤ìº”', desc: 'í™”ì„± ê·¼ì ‘ ë¹„í–‰ìœ¼ë¡œ í‘œë©´ ìŠ¤ìº”', target: 'í™”ì„±', scanDist: 30, reward: 250 },
                { title: 'ëª©ì„± ëŒ€ê¸° ê´€ì¸¡', desc: 'ëª©ì„± ëŒ€ê¸°ê¶Œ ê·¼ì ‘ ê´€ì¸¡', target: 'ëª©ì„±', scanDist: 50, reward: 350 },
                { title: 'í† ì„± ê³ ë¦¬ íƒì‚¬', desc: 'í† ì„± ê³ ë¦¬ ê·¼ì ‘ ë¹„í–‰', target: 'í† ì„±', scanDist: 60, reward: 400 },
                { title: 'ê¸ˆì„± êµ¬ë¦„ ê´€ì¸¡', desc: 'ê¸ˆì„± ëŒ€ê¸° ìƒì¸µë¶€ ê´€ì¸¡', target: 'ê¸ˆì„±', scanDist: 25, reward: 300 },
                { title: 'ìˆ˜ì„± ë¶„í™”êµ¬ ì¡°ì‚¬', desc: 'ìˆ˜ì„± ë¶„í™”êµ¬ ê·¼ì ‘ ì´¬ì˜', target: 'ìˆ˜ì„±', scanDist: 20, reward: 350 },
                { title: 'ì²œì™•ì„± ìê¸°ì¥', desc: 'ì²œì™•ì„± ìê¸°ì¥ ì¸¡ì •', target: 'ì²œì™•ì„±', scanDist: 40, reward: 450 },
                { title: 'í•´ì™•ì„± í­í’ ê´€ì¸¡', desc: 'í•´ì™•ì„± ëŒ€í‘ì  ê´€ì¸¡', target: 'í•´ì™•ì„±', scanDist: 50, reward: 500 },
                { title: 'íƒœì–‘ í”Œë ˆì–´ ê´€ì¸¡', desc: 'íƒœì–‘ ì•ˆì „ê±°ë¦¬ ì ‘ê·¼', target: 'íƒœì–‘', scanDist: 100, reward: 400 },
                { title: 'ì†Œí–‰ì„±ëŒ€ íƒì‚¬', desc: 'í™”ì„±-ëª©ì„± ì‚¬ì´ ì†Œí–‰ì„±ëŒ€ íƒì‚¬', target: 'í™”ì„±', scanDist: 100, reward: 350 },
                { title: 'í˜œì„± ì¶”ì ', desc: 'íƒœì–‘ê³„ ì™¸ê³½ í˜œì„± ì¶”ì ', target: 'í•´ì™•ì„±', scanDist: 80, reward: 550 }
            ],
            precision: [
                { title: 'ì •ë°€ ë„í‚¹ A', desc: 'ISSì— 1km/s ì´í•˜ë¡œ ë„í‚¹', target: 'ISS', maxSpeed: 1, reward: 200 },
                { title: 'ì •ë°€ ë„í‚¹ B', desc: 'í™”ì„± ì •ê±°ì¥ì— 0.5km/s ì´í•˜ë¡œ ë„í‚¹', target: 'í™”ì„±', maxSpeed: 0.5, reward: 300 },
                { title: 'ì™„ë²½í•œ ì°©ë¥™', desc: 'ëª©ì„± ì •ê±°ì¥ì— 0.1km/s ì´í•˜ë¡œ ë„í‚¹', target: 'ëª©ì„±', maxSpeed: 0.1, reward: 450 },
                { title: 'ë¶€ë“œëŸ¬ìš´ ì ‘ê·¼', desc: 'í† ì„± ì •ê±°ì¥ì— 0.3km/s ì´í•˜ë¡œ ë„í‚¹', target: 'í† ì„±', maxSpeed: 0.3, reward: 400 },
                { title: 'ê¸ˆì„± ì •ë°€ ì§„ì…', desc: 'ê¸ˆì„± ì •ê±°ì¥ì— 0.5km/s ì´í•˜ë¡œ ë„í‚¹', target: 'ê¸ˆì„±', maxSpeed: 0.5, reward: 350 },
                { title: 'ì²œì™•ì„± ì—°ì°©ë¥™', desc: 'ì²œì™•ì„± ì •ê±°ì¥ì— 0.2km/s ì´í•˜ë¡œ ë„í‚¹', target: 'ì²œì™•ì„±', maxSpeed: 0.2, reward: 500 },
                { title: 'í•´ì™•ì„± ë§ˆìŠ¤í„°', desc: 'í•´ì™•ì„± ì •ê±°ì¥ì— 0.1km/s ì´í•˜ë¡œ ë„í‚¹', target: 'í•´ì™•ì„±', maxSpeed: 0.1, reward: 600 },
                { title: 'ìˆ˜ì„± ì ‘ê·¼ ì£¼ì˜', desc: 'ìˆ˜ì„± ì •ê±°ì¥ì— 0.5km/s ì´í•˜ë¡œ ë„í‚¹', target: 'ìˆ˜ì„±', maxSpeed: 0.5, reward: 350 },
                { title: 'ë‹¬ ì°©ë¥™ ì—°ìŠµ', desc: 'ë‹¬ì— 0.3km/s ì´í•˜ë¡œ ì ‘ê·¼', target: 'ë‹¬', maxSpeed: 0.3, reward: 250 },
                { title: 'ì œë¡œ ì„íŒ©íŠ¸', desc: 'ì–´ëŠ ì •ê±°ì¥ì´ë“  0.05km/s ì´í•˜ë¡œ ë„í‚¹', target: 'any', maxSpeed: 0.05, reward: 700 }
            ],
            economy: [
                { title: 'ì—°ë£Œ ì ˆì•½ A', desc: 'í™”ì„±ê¹Œì§€ ì—°ë£Œ 80% ì´ìƒ ìœ ì§€', target: 'í™”ì„±', minFuel: 80, reward: 300 },
                { title: 'ì—°ë£Œ ì ˆì•½ B', desc: 'ëª©ì„±ê¹Œì§€ ì—°ë£Œ 60% ì´ìƒ ìœ ì§€', target: 'ëª©ì„±', minFuel: 60, reward: 400 },
                { title: 'ê·¹í•œ ì ˆì•½', desc: 'í† ì„±ê¹Œì§€ ì—°ë£Œ 50% ì´ìƒ ìœ ì§€', target: 'í† ì„±', minFuel: 50, reward: 500 },
                { title: 'íš¨ìœ¨ì˜ ë‹¬ì¸', desc: 'ì²œì™•ì„±ê¹Œì§€ ì—°ë£Œ 40% ì´ìƒ ìœ ì§€', target: 'ì²œì™•ì„±', minFuel: 40, reward: 600 },
                { title: 'ì—ì½” íŒŒì¼ëŸ¿', desc: 'ê¸ˆì„±ê¹Œì§€ ì—°ë£Œ 90% ì´ìƒ ìœ ì§€', target: 'ê¸ˆì„±', minFuel: 90, reward: 350 },
                { title: 'ì ˆì•½ ë§ˆìŠ¤í„°', desc: 'í•´ì™•ì„±ê¹Œì§€ ì—°ë£Œ 30% ì´ìƒ ìœ ì§€', target: 'í•´ì™•ì„±', minFuel: 30, reward: 700 },
                { title: 'ê·¼ê±°ë¦¬ íš¨ìœ¨', desc: 'ë‹¬ê¹Œì§€ ì—°ë£Œ 95% ì´ìƒ ìœ ì§€', target: 'ë‹¬', minFuel: 95, reward: 250 },
                { title: 'ìˆ˜ì„± ì±Œë¦°ì§€', desc: 'ìˆ˜ì„±ê¹Œì§€ ì—°ë£Œ 70% ì´ìƒ ìœ ì§€', target: 'ìˆ˜ì„±', minFuel: 70, reward: 400 },
                { title: 'ISS ì ˆì•½ ë¹„í–‰', desc: 'ISSê¹Œì§€ ì—°ë£Œ 98% ì´ìƒ ìœ ì§€', target: 'ISS', minFuel: 98, reward: 200 },
                { title: 'ì´ˆì ˆì•½ ë„ì „', desc: 'í™”ì„± ì™•ë³µ ì—°ë£Œ 40% ì´ìƒ ìœ ì§€', target: 'í™”ì„±', minFuel: 40, reward: 550 }
            ],
            returnHome: [
                { title: 'í™”ì„± ê·€í™˜', desc: 'í™”ì„±ì—ì„œ ì§€êµ¬ë¡œ ë¬´ì‚¬ ê·€í™˜', from: 'í™”ì„±', to: 'ì§€êµ¬', reward: 350 },
                { title: 'ëª©ì„± ê·€í™˜', desc: 'ëª©ì„±ì—ì„œ ì§€êµ¬ë¡œ ë¬´ì‚¬ ê·€í™˜', from: 'ëª©ì„±', to: 'ì§€êµ¬', reward: 450 },
                { title: 'í† ì„± ê·€í™˜', desc: 'í† ì„±ì—ì„œ ì§€êµ¬ë¡œ ë¬´ì‚¬ ê·€í™˜', from: 'í† ì„±', to: 'ì§€êµ¬', reward: 500 },
                { title: 'ì²œì™•ì„± ê·€í™˜', desc: 'ì²œì™•ì„±ì—ì„œ ì§€êµ¬ë¡œ ë¬´ì‚¬ ê·€í™˜', from: 'ì²œì™•ì„±', to: 'ì§€êµ¬', reward: 600 },
                { title: 'í•´ì™•ì„± ê·€í™˜', desc: 'í•´ì™•ì„±ì—ì„œ ì§€êµ¬ë¡œ ë¬´ì‚¬ ê·€í™˜', from: 'í•´ì™•ì„±', to: 'ì§€êµ¬', reward: 700 },
                { title: 'ê¸ˆì„± ê·€í™˜', desc: 'ê¸ˆì„±ì—ì„œ ì§€êµ¬ë¡œ ë¬´ì‚¬ ê·€í™˜', from: 'ê¸ˆì„±', to: 'ì§€êµ¬', reward: 300 },
                { title: 'ìˆ˜ì„± ê·€í™˜', desc: 'ìˆ˜ì„±ì—ì„œ ì§€êµ¬ë¡œ ë¬´ì‚¬ ê·€í™˜', from: 'ìˆ˜ì„±', to: 'ì§€êµ¬', reward: 400 },
                { title: 'ë‹¬ ê·€í™˜', desc: 'ë‹¬ì—ì„œ ì§€êµ¬ë¡œ ë¬´ì‚¬ ê·€í™˜', from: 'ë‹¬', to: 'ì§€êµ¬', reward: 200 },
                { title: 'ì™¸ê³½ ê·€í™˜', desc: 'ì¹´ì´í¼ ë²¨íŠ¸ì—ì„œ ê·€í™˜', from: 'í•´ì™•ì„±', to: 'ì§€êµ¬', reward: 800 },
                { title: 'íƒì‚¬ ê·€í™˜', desc: 'ì•„ë¬´ ì™¸í–‰ì„±ì—ì„œ ì§€êµ¬ë¡œ ê·€í™˜', from: 'any_outer', to: 'ì§€êµ¬', reward: 400 }
            ],
            speed: [
                { title: 'ì†ë„ì˜ ì‹ ', desc: '100km/s ë‹¬ì„±', targetSpeed: 100, reward: 300 },
                { title: 'ì´ˆê³ ì† ë¹„í–‰', desc: '150km/s ë‹¬ì„±', targetSpeed: 150, reward: 400 },
                { title: 'ìŒì† ëŒíŒŒ', desc: '200km/s ë‹¬ì„±', targetSpeed: 200, reward: 500 },
                { title: 'ê´‘ì†ì˜ 1%', desc: '300km/s ë‹¬ì„±', targetSpeed: 300, reward: 600 },
                { title: 'ê·¹ì´ˆìŒì†', desc: '75km/s ë‹¬ì„±', targetSpeed: 75, reward: 250 },
                { title: 'ìˆœí•­ ì†ë„', desc: '50km/s ìœ ì§€ 30ì´ˆ', targetSpeed: 50, duration: 30, reward: 200 },
                { title: 'ê³ ì† ìˆœí•­', desc: '100km/s ìœ ì§€ 60ì´ˆ', targetSpeed: 100, duration: 60, reward: 350 },
                { title: 'ì•ˆì • ë¹„í–‰', desc: '150km/s ìœ ì§€ 30ì´ˆ', targetSpeed: 150, duration: 30, reward: 450 },
                { title: 'ì›Œí”„ ì¤€ë¹„', desc: '250km/s ë‹¬ì„±', targetSpeed: 250, reward: 550 },
                { title: 'ìµœê³  ì†ë„', desc: 'í˜„ì¬ ìš°ì£¼ì„  ìµœê³  ì†ë„ ë‹¬ì„±', targetSpeed: 'max', reward: 400 }
            ],
            distance: [
                { title: '1AU ë¹„í–‰', desc: 'íƒœì–‘ì—ì„œ 1AU ê±°ë¦¬ ë¹„í–‰', targetAU: 1, reward: 150 },
                { title: '5AU ë¹„í–‰', desc: 'íƒœì–‘ì—ì„œ 5AU ê±°ë¦¬ ë¹„í–‰', targetAU: 5, reward: 300 },
                { title: '10AU ë¹„í–‰', desc: 'íƒœì–‘ì—ì„œ 10AU ê±°ë¦¬ ë¹„í–‰', targetAU: 10, reward: 450 },
                { title: '20AU ë¹„í–‰', desc: 'íƒœì–‘ì—ì„œ 20AU ê±°ë¦¬ ë¹„í–‰', targetAU: 20, reward: 600 },
                { title: '30AU ë¹„í–‰', desc: 'í•´ì™•ì„± ê¶¤ë„ê¹Œì§€', targetAU: 30, reward: 750 },
                { title: '50AU ë„ì „', desc: 'ì¹´ì´í¼ ë²¨íŠ¸ ì§„ì…', targetAU: 50, reward: 900 },
                { title: 'ë‚´í–‰ì„± íƒí—˜', desc: '0.5AU ì´ë‚´ ì ‘ê·¼', targetAU: 0.5, reward: 250 },
                { title: 'íƒœì–‘ ì ‘ê·¼', desc: '0.3AU ì´ë‚´ ì ‘ê·¼', targetAU: 0.3, reward: 400 },
                { title: 'ì™¸ê³½ íƒí—˜', desc: '40AU ë„ë‹¬', targetAU: 40, reward: 800 },
                { title: 'íƒœì–‘ê³„ ë', desc: '100AU ë„ë‹¬', targetAU: 100, reward: 1500 }
            ],
            multiCoop: [
                { title: 'ë§Œë‚¨ì˜ ê´‘ì¥', desc: 'ë‹¤ë¥¸ í”Œë ˆì´ì–´ì™€ ê°™ì€ ì •ê±°ì¥ ë„í‚¹', reward: 300 },
                { title: 'í¸ëŒ€ ë¹„í–‰', desc: 'ë‹¤ë¥¸ í”Œë ˆì´ì–´ ê·¼ì²˜ ë¹„í–‰', reward: 250 },
                { title: 'í–‰ì„± ëª¨ì„', desc: 'ê°™ì€ í–‰ì„± ê·¼ì²˜ì—ì„œ ë§Œë‚¨', reward: 350 },
                { title: 'ìš°ì£¼ ì¸ì‚¬', desc: 'ë‹¤ë¥¸ í”Œë ˆì´ì–´ì—ê²Œ ì ‘ê·¼', reward: 200 },
                { title: 'íƒì‚¬ëŒ€ í•©ë¥˜', desc: 'ì™¸í–‰ì„±ì—ì„œ ë‹¤ë¥¸ í”Œë ˆì´ì–´ ë§Œë‚¨', reward: 450 },
                { title: 'ì§€êµ¬ ê·€í™˜ íŒŒí‹°', desc: 'ì§€êµ¬ì—ì„œ ë‹¤ë¥¸ í”Œë ˆì´ì–´ ë§Œë‚¨', reward: 300 },
                { title: 'í™”ì„± íƒí—˜ëŒ€', desc: 'í™”ì„±ì—ì„œ ë‹¤ë¥¸ í”Œë ˆì´ì–´ ë§Œë‚¨', reward: 350 },
                { title: 'ëª©ì„± ì›ì •ëŒ€', desc: 'ëª©ì„±ì—ì„œ ë‹¤ë¥¸ í”Œë ˆì´ì–´ ë§Œë‚¨', reward: 400 },
                { title: 'í† ì„± ê´€ê´‘ë‹¨', desc: 'í† ì„±ì—ì„œ ë‹¤ë¥¸ í”Œë ˆì´ì–´ ë§Œë‚¨', reward: 450 },
                { title: 'ìš°ì£¼ íŒŒì¼ëŸ¿ ëª¨ì„', desc: 'ISSì—ì„œ ë‹¤ë¥¸ í”Œë ˆì´ì–´ ë§Œë‚¨', reward: 250 }
            ]
        };
        
        // SSIL ë¯¸ì…˜ ìƒíƒœ
        let ssilMissionState = {
            isFirstBoarding: true,
            trainingCompleted: {},  // { missionId: true }
            dailyMission: null,
            dailyMissionAccepted: false,
            dailyMissionStartTime: 0,
            missionPoints: 0,
            lastDailyDate: null,
            totalDistance: 0,  // â˜… ì´ ì´ë™ ê±°ë¦¬ (AU)
            lastPosition: null  // â˜… ì´ì „ ìœ„ì¹˜ (ê±°ë¦¬ ê³„ì‚°ìš©)
        };
        
        // ë¯¸ì…˜ ìƒíƒœ ë¡œë“œ (ì‹±ê¸€ëª¨ë“œ)
        function loadSSILState() {
            const saved = localStorage.getItem('ssilMissionState');
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    ssilMissionState = { ...ssilMissionState, ...parsed };
                } catch (e) {
                    console.warn('SSIL ìƒíƒœ ë¡œë“œ ì‹¤íŒ¨:', e);
                }
            }
        }

        // â˜… ë¯¸ì…˜ ìƒíƒœ ë¹„ë™ê¸° ë¡œë“œ (ë©€í‹°ëª¨ë“œìš©)
        async function loadSSILStateAsync() {
            if (window.gameMode !== 'multi') {
                loadSSILState();
                return;
            }
            try {
                const serverData = await GameDataManager.load('ssil_missions', 'ssilMissionState');
                if (serverData) {
                    ssilMissionState = { ...ssilMissionState, ...serverData };
                    console.log('âœ… SSIL ë¯¸ì…˜ ì„œë²„ì—ì„œ ë¡œë“œë¨');
                }
            } catch (e) {
                console.warn('SSIL ìƒíƒœ ì„œë²„ ë¡œë“œ ì‹¤íŒ¨:', e);
                loadSSILState();  // í´ë°±: ë¡œì»¬ì—ì„œ ë¡œë“œ
            }
        }

        // ë¯¸ì…˜ ìƒíƒœ ì €ì¥
        function saveSSILState() {
            // â˜… GameDataManagerë¥¼ í†µí•´ ì €ì¥ (ë©€í‹°: ì„œë²„, ì‹±ê¸€: ë¡œì»¬)
            GameDataManager.save('ssil_missions', ssilMissionState, 'ssilMissionState');
        }
        
        // ì²« íƒ‘ìŠ¹ ì‹œ ARIA ì¸íŠ¸ë¡œ
        function showSSILIntro() {
            if (!ssilMissionState.isFirstBoarding) return;
            
            ssilMissionState.isFirstBoarding = false;
            saveSSILState();
            
            // ARIA ì¸íŠ¸ë¡œ ë©”ì‹œì§€
            const introMessages = [
                "ì•ˆë…•í•˜ì„¸ìš”, íŒŒì¼ëŸ¿ë‹˜.",
                "ë‹¹ì‹ ì€ Solar System Integrated Logistics, ì´í•˜ SSIL(ì”°)ì˜ ìš´ì†¡ì—…ë¬´ ì‹ ì…ì§ì›ì…ë‹ˆë‹¤.",
                "ì§€êµ¬ì—ì„œ ì¶©ë¶„íˆ í›ˆë ¨ í•˜ì…¨ì„ í…Œì§€ë§Œ ìš°ì£¼ì—ì„œì˜ ì‹¤ì „ì€ ë˜ ë‹¤ë¦…ë‹ˆë‹¤.",
                "ì œê°€ ë‹¹ì‹ ì˜ í›ˆë ¨ ë° ì•ìœ¼ë¡œì˜ ì—…ë¬´ì— ëŒ€í•œ ì•ˆë‚´ë¥¼ ì „ë°˜ì ìœ¼ë¡œ ë‹´ë‹¹í•˜ê²Œ ëœ AI ARIA ì…ë‹ˆë‹¤.",
                "ê¶ê¸ˆí•œì ì´ ìˆë‹¤ë©´ ì–¸ì œë“ ì§€ ë¬¼ì–´ë³´ì„¸ìš”.",
                "ì, ì´ì œ ë°”ë¡œ í›ˆë ¨ì„ ì‹œì‘í•˜ê² ìŠµë‹ˆë‹¤!",
                "í›ˆë ¨ì„ ì˜ ë§ˆì¹œë‹¤ë©´ ë‹¹ì‹ ì€ íšŒì‚¬ë¡œë¶€í„° ê¸‰ì—¬ì™¸ì˜ ë³´ë„ˆìŠ¤ ì½”ì¸ì„ ì§€ê¸‰ ë°›ìœ¼ì‹¤ ìˆ˜ ìˆìœ¼ë‹ˆ ì ê·¹ì ìœ¼ë¡œ ì°¸ì—¬ í•´ ì£¼ì‹œê¸° ë°”ëë‹ˆë‹¤."
            ];
            
            let msgIndex = 0;
            const showNextMessage = () => {
                if (msgIndex < introMessages.length) {
                    aiTypeMessage(introMessages[msgIndex]);
                    msgIndex++;
                    setTimeout(showNextMessage, 4000);
                } else {
                    // â˜… ì¸íŠ¸ë¡œ ëë‚˜ë©´ ë¯¸ì…˜ ë²„íŠ¼ í‘œì‹œ + ì•Œë¦¼
                    setTimeout(() => {
                        showMissionButton();
                        aiTypeMessage("ì˜¤ë¥¸ìª½ ğŸ“‹ ë¯¸ì…˜ ë²„íŠ¼ì„ ëˆŒëŸ¬ í›ˆë ¨ ëª©ë¡ì„ í™•ì¸í•˜ì„¸ìš”!");
                    }, 2000);
                }
            };
            
            setTimeout(showNextMessage, 2000);
        }
        
        // ë¯¸ì…˜ íŒ¨ë„ ì—´ê¸°
        function openMissionPanel() {
            const panel = document.getElementById('ssil-mission-panel');
            const tbody = document.getElementById('training-mission-body');
            
            tbody.innerHTML = '';
            let totalReward = 0;
            let completedReward = 0;
            
            SSIL_TRAINING_MISSIONS.forEach(mission => {
                const isCompleted = ssilMissionState.trainingCompleted[mission.id];
                const tr = document.createElement('tr');
                if (isCompleted) tr.classList.add('completed');
                
                tr.innerHTML = `
                    <td class="mission-status">${isCompleted ? 'âœ…' : 'â¬œ'}</td>
                    <td>${mission.title}</td>
                    <td>${mission.desc}</td>
                    <td class="mission-reward">${mission.reward} ğŸª™</td>
                `;
                tbody.appendChild(tr);
                
                totalReward += mission.reward;
                if (isCompleted) completedReward += mission.reward;
            });
            
            document.getElementById('total-training-reward').textContent = 
                `${completedReward} / ${totalReward} ì½”ì¸`;
            
            panel.classList.add('open');
        }
        window.openMissionPanel = openMissionPanel;
        
        // ë¯¸ì…˜ íŒ¨ë„ ë‹«ê¸°
        function closeMissionPanel() {
            document.getElementById('ssil-mission-panel').classList.remove('open');
        }
        window.closeMissionPanel = closeMissionPanel;
        
        // â˜… ë¯¸ì…˜ ë²„íŠ¼ í‘œì‹œ
        function showMissionButton() {
            if (document.getElementById('mission-float-btn')) return;  // ì´ë¯¸ ìˆìœ¼ë©´ ë¬´ì‹œ
            
            const btn = document.createElement('button');
            btn.id = 'mission-float-btn';
            btn.innerHTML = 'ğŸ“‹';
            btn.title = 'SSIL ë¯¸ì…˜';
            btn.style.cssText = `
                position: fixed;
                right: 15px;
                top: 50%;
                transform: translateY(-50%);
                width: 50px;
                height: 50px;
                border-radius: 50%;
                background: linear-gradient(135deg, #1a3a5c, #0a1a2c);
                border: 2px solid #00d4ff;
                color: #00d4ff;
                font-size: 24px;
                cursor: pointer;
                z-index: 1000;
                box-shadow: 0 0 15px rgba(0,212,255,0.5);
                transition: all 0.3s ease;
            `;
            btn.onmouseover = () => btn.style.boxShadow = '0 0 25px rgba(0,212,255,0.8)';
            btn.onmouseout = () => btn.style.boxShadow = '0 0 15px rgba(0,212,255,0.5)';
            btn.onclick = openMissionPanel;
            document.body.appendChild(btn);
        }
        window.showMissionButton = showMissionButton;
        
        // í›ˆë ¨ ë¯¸ì…˜ ì™„ë£Œ ì²´í¬
        function checkTrainingMissions() {
            if (!playerShip || !playerShip.mesh) return;
            
            // â˜… ì´ë™ ê±°ë¦¬ ëˆ„ì  ê³„ì‚°
            const currentPos = playerShip.mesh.position.clone();
            if (ssilMissionState.lastPosition) {
                const moved = currentPos.distanceTo(ssilMissionState.lastPosition);
                const movedAU = moved / 220;  // AUë¡œ ë³€í™˜
                ssilMissionState.totalDistance += movedAU;
            }
            ssilMissionState.lastPosition = currentPos;
            
            SSIL_TRAINING_MISSIONS.forEach(mission => {
                if (ssilMissionState.trainingCompleted[mission.id]) return;
                
                let completed = false;
                
                switch (mission.type) {
                    case 'explore':
                        // í–‰ì„± ê·¼ì²˜ íƒì‚¬
                        const targetBody = bodies.find(b => b.name === mission.target);
                        if (targetBody && targetBody.mesh) {
                            const dist = playerShip.mesh.position.distanceTo(targetBody.mesh.position);
                            if (dist < mission.targetDist) completed = true;
                        }
                        break;
                        
                    case 'speed':
                        // ì†ë„ ë‹¬ì„±
                        if (playerShip.speed >= mission.targetSpeed) completed = true;
                        break;
                        
                    case 'orbit':
                        // ê¶¤ë„ ì§„ì…
                        if (orbitState.locked && orbitState.targetBody) {
                            if (orbitState.targetBody.name === mission.target) completed = true;
                        }
                        break;
                        
                    case 'fuel':
                        // ì—°ë£Œ íš¨ìœ¨ (ëª©í‘œ í–‰ì„± ë„ì°© ì‹œ)
                        const fuelTarget = bodies.find(b => b.name === mission.target);
                        if (fuelTarget && fuelTarget.mesh) {
                            const d = playerShip.mesh.position.distanceTo(fuelTarget.mesh.position);
                            if (d < 50 && playerShip.fuel >= mission.minFuel) completed = true;
                        }
                        break;
                        
                    case 'distance':
                        // ì¥ê±°ë¦¬ ë¹„í–‰ - ì´ ì´ë™ ê±°ë¦¬ ì²´í¬ (ì‹œì‘ ìœ„ì¹˜ ê¸°ì¤€ì´ ì•„ë‹Œ ëˆ„ì  ê±°ë¦¬)
                        if (ssilMissionState.totalDistance >= mission.targetDistance) completed = true;
                        break;
                }
                
                if (completed) {
                    completeTrainingMission(mission);
                }
            });
        }
        
        // í›ˆë ¨ ë¯¸ì…˜ ì™„ë£Œ ì²˜ë¦¬
        function completeTrainingMission(mission) {
            ssilMissionState.trainingCompleted[mission.id] = true;
            saveSSILState();
            
            // ë³´ìƒ ì§€ê¸‰
            addCoins(mission.reward);
            
            // ì™„ë£Œ ì•Œë¦¼
            showMissionCompleteToast(mission.title, mission.reward);
            
            // ARIA ì¶•í•˜ ë©”ì‹œì§€
            aiTypeMessage(`ğŸ‰ í›Œë¥­í•©ë‹ˆë‹¤! "${mission.title}" ë¯¸ì…˜ì„ ì™„ë£Œí•˜ì…¨ìŠµë‹ˆë‹¤! +${mission.reward} ì½”ì¸`);
        }
        
        // ë¯¸ì…˜ ì™„ë£Œ í† ìŠ¤íŠ¸
        function showMissionCompleteToast(title, reward) {
            const toast = document.createElement('div');
            toast.className = 'mission-complete-toast';
            toast.innerHTML = `
                <h3>ğŸ¯ ë¯¸ì…˜ ì™„ë£Œ!</h3>
                <div>${title}</div>
                <div class="reward">+${reward} ğŸª™</div>
            `;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'translateX(-50%) translateY(-30px)';
                setTimeout(() => toast.remove(), 500);
            }, 3000);
        }
        
        // ì¼ì¼ ë¯¸ì…˜ ìƒì„±
        function generateDailyMission() {
            const today = new Date().toDateString();
            
            // ì´ë¯¸ ì˜¤ëŠ˜ ë¯¸ì…˜ì´ ìˆìœ¼ë©´ ìŠ¤í‚µ
            if (ssilMissionState.lastDailyDate === today && ssilMissionState.dailyMission) {
                return;
            }
            
            // ë¯¸ì…˜ íƒ€ì… ëœë¤ ì„ íƒ
            const missionTypes = Object.keys(DAILY_MISSION_TEMPLATES);
            const randomType = missionTypes[Math.floor(Math.random() * missionTypes.length)];
            const templates = DAILY_MISSION_TEMPLATES[randomType];
            const randomMission = templates[Math.floor(Math.random() * templates.length)];
            
            ssilMissionState.dailyMission = {
                ...randomMission,
                type: randomType,
                generated: Date.now()
            };
            ssilMissionState.lastDailyDate = today;
            ssilMissionState.dailyMissionAccepted = false;
            saveSSILState();
            
            // ì´ë©”ì¼ ì•„ì´ì½˜ í‘œì‹œ
            updateDailyMissionIcon();
        }
        
        // ì¼ì¼ ë¯¸ì…˜ ì•„ì´ì½˜ ì—…ë°ì´íŠ¸
        function updateDailyMissionIcon() {
            const icon = document.getElementById('daily-mission-icon');
            if (ssilMissionState.dailyMission && !ssilMissionState.dailyMissionAccepted) {
                icon.classList.add('has-mission');
            } else {
                icon.classList.remove('has-mission');
            }
            
            // ë¯¸ì…˜ í¬ì¸íŠ¸ í‘œì‹œ
            const mpDisplay = document.getElementById('mission-points-display');
            if (ssilMissionState.missionPoints > 0) {
                mpDisplay.classList.add('visible');
                document.getElementById('mission-points-value').textContent = ssilMissionState.missionPoints;
            }
        }
        
        // ì¼ì¼ ë¯¸ì…˜ ëª¨ë‹¬ ì—´ê¸°
        function openDailyMission() {
            if (!ssilMissionState.dailyMission) return;
            
            const mission = ssilMissionState.dailyMission;
            const modal = document.getElementById('daily-mission-modal');
            
            // ë‚ ì§œ í‘œì‹œ
            const now = new Date();
            document.getElementById('daily-mission-date').textContent = 
                `${now.getMonth()+1}/${now.getDate()}`;
            
            // ë¯¸ì…˜ ì„¤ëª…
            document.getElementById('daily-mission-desc').textContent = mission.desc;
            
            // ë³´ìƒ
            document.getElementById('daily-reward-coins').textContent = mission.reward;
            document.getElementById('daily-reward-points').textContent = '+1';
            
            modal.classList.add('open');
        }
        window.openDailyMission = openDailyMission;
        
        // ì¼ì¼ ë¯¸ì…˜ ìˆ˜ë½
        function acceptDailyMission() {
            ssilMissionState.dailyMissionAccepted = true;
            ssilMissionState.dailyMissionStartTime = Date.now();
            saveSSILState();
            
            closeDailyMission();
            updateDailyMissionIcon();
            
            const mission = ssilMissionState.dailyMission;
            aiTypeMessage(`ğŸ“§ ì—…ë¬´ ì§€ì‹œì„œ ìˆ˜ë½: "${mission.title}" - ${mission.desc}`);
            showMessage(`ğŸ“§ ì¼ì¼ ë¯¸ì…˜ ìˆ˜ë½: ${mission.title}`);
        }
        window.acceptDailyMission = acceptDailyMission;
        
        // ì¼ì¼ ë¯¸ì…˜ ë‹«ê¸°
        function closeDailyMission() {
            document.getElementById('daily-mission-modal').classList.remove('open');
        }
        window.closeDailyMission = closeDailyMission;
        
        // ì¼ì¼ ë¯¸ì…˜ ì™„ë£Œ ì²´í¬
        function checkDailyMission() {
            if (!ssilMissionState.dailyMissionAccepted || !ssilMissionState.dailyMission) return;
            if (!playerShip || !playerShip.mesh) return;
            
            const mission = ssilMissionState.dailyMission;
            let completed = false;
            
            // ë¯¸ì…˜ íƒ€ì…ë³„ ì™„ë£Œ ì¡°ê±´ ì²´í¬
            switch (mission.type) {
                case 'delivery':
                case 'exploration':
                    // ëª©í‘œ í–‰ì„±/ì •ê±°ì¥ ë„ì°©
                    const target = bodies.find(b => b.name === mission.target) ||
                                   satellites.find(s => s.name && s.name.includes(mission.target));
                    if (target && target.mesh) {
                        const dist = playerShip.mesh.position.distanceTo(target.mesh.position);
                        if (dist < 30) completed = true;
                    }
                    break;
                    
                case 'speed':
                    if (playerShip.speed >= mission.targetSpeed) completed = true;
                    break;
                    
                case 'distance':
                    const distAU = playerShip.mesh.position.length() / 220;
                    if (distAU >= mission.targetAU) completed = true;
                    break;
                    
                // ë‹¤ë¥¸ íƒ€ì…ë“¤ë„ ì¶”ê°€ ê°€ëŠ¥
            }
            
            if (completed) {
                completeDailyMission();
            }
        }
        
        // ì¼ì¼ ë¯¸ì…˜ ì™„ë£Œ ì²˜ë¦¬
        function completeDailyMission() {
            const mission = ssilMissionState.dailyMission;
            
            // ë³´ìƒ ì§€ê¸‰
            addCoins(mission.reward);
            ssilMissionState.missionPoints += 1;
            
            // ë¯¸ì…˜ ì´ˆê¸°í™”
            ssilMissionState.dailyMission = null;
            ssilMissionState.dailyMissionAccepted = false;
            saveSSILState();
            
            updateDailyMissionIcon();
            
            // ì™„ë£Œ ì•Œë¦¼
            showMissionCompleteToast(mission.title, mission.reward);
            aiTypeMessage(`ğŸ‰ ì¼ì¼ ë¯¸ì…˜ "${mission.title}" ì™„ë£Œ! +${mission.reward} ì½”ì¸, +1 ë¯¸ì…˜ í¬ì¸íŠ¸`);
        }
        
        // AI ì²œì²´ ì •ë³´
        const AI_BODY_INFO = {
            'íƒœì–‘': 'íƒœì–‘ì€ íƒœì–‘ê³„ì˜ ì¤‘ì‹¬ í•­ì„±ìœ¼ë¡œ, ì§€êµ¬ ì§ˆëŸ‰ì˜ ì•½ 33ë§Œ ë°°ì…ë‹ˆë‹¤. í‘œë©´ ì˜¨ë„ëŠ” ì•½ 5,500Â°Cì´ë©°, ì¤‘ì‹¬ë¶€ëŠ” 1,500ë§ŒÂ°Cì— ë‹¬í•©ë‹ˆë‹¤.',
            'ìˆ˜ì„±': 'ìˆ˜ì„±ì€ íƒœì–‘ì— ê°€ì¥ ê°€ê¹Œìš´ í–‰ì„±ì…ë‹ˆë‹¤. ë‚®ì—ëŠ” 430Â°C, ë°¤ì—ëŠ” -180Â°Cë¡œ ê·¹ì‹¬í•œ ì˜¨ë„ì°¨ë¥¼ ë³´ì…ë‹ˆë‹¤.',
            'ê¸ˆì„±': 'ê¸ˆì„±ì€ ë‘êº¼ìš´ ì´ì‚°í™”íƒ„ì†Œ ëŒ€ê¸°ë¡œ ì¸í•´ í‘œë©´ ì˜¨ë„ê°€ 465Â°Cì— ë‹¬í•˜ëŠ” íƒœì–‘ê³„ì—ì„œ ê°€ì¥ ëœ¨ê±°ìš´ í–‰ì„±ì…ë‹ˆë‹¤.',
            'ì§€êµ¬': 'ì§€êµ¬ëŠ” í˜„ì¬ê¹Œì§€ ì•Œë ¤ì§„ ìœ ì¼í•œ ìƒëª…ì²´ ì„œì‹ í–‰ì„±ì…ë‹ˆë‹¤. ë‹¬ì´ë¼ëŠ” ìœ„ì„±ì„ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤.',
            'í™”ì„±': 'í™”ì„±ì€ ë¶‰ì€ í–‰ì„±ìœ¼ë¡œ ë¶ˆë¦¬ë©°, ì˜¬ë¦¼í‘¸ìŠ¤ ëª¬ìŠ¤ë¼ëŠ” íƒœì–‘ê³„ ìµœëŒ€ í™”ì‚°ì´ ìˆìŠµë‹ˆë‹¤. ë†’ì´ê°€ ì•½ 22kmì…ë‹ˆë‹¤.',
            'ëª©ì„±': 'ëª©ì„±ì€ íƒœì–‘ê³„ ìµœëŒ€ í–‰ì„±ìœ¼ë¡œ, ëŒ€ì ì ì´ë¼ëŠ” ê±°ëŒ€í•œ í­í’ì´ 300ë…„ ì´ìƒ ì§€ì†ë˜ê³  ìˆìŠµë‹ˆë‹¤.',
            'í† ì„±': 'í† ì„±ì€ ì•„ë¦„ë‹¤ìš´ ê³ ë¦¬ë¡œ ìœ ëª…í•©ë‹ˆë‹¤. ê³ ë¦¬ëŠ” ì£¼ë¡œ ì–¼ìŒê³¼ ì•”ì„ ì¡°ê°ìœ¼ë¡œ ì´ë£¨ì–´ì ¸ ìˆìŠµë‹ˆë‹¤.',
            'ì²œì™•ì„±': 'ì²œì™•ì„±ì€ ìì „ì¶•ì´ 98ë„ ê¸°ìš¸ì–´ì ¸ ì˜†ìœ¼ë¡œ ëˆ„ì›Œ ë„ëŠ” ë…íŠ¹í•œ í–‰ì„±ì…ë‹ˆë‹¤.',
            'í•´ì™•ì„±': 'í•´ì™•ì„±ì€ íƒœì–‘ê³„ì—ì„œ ê°€ì¥ ê°•í•œ ë°”ëŒì´ ë¶ˆë©°, ì‹œì† 2,000kmë¥¼ ë„˜ìŠµë‹ˆë‹¤.',
            'ë‹¬': 'ë‹¬ì€ ì§€êµ¬ì˜ ìœ ì¼í•œ ìì—° ìœ„ì„±ìœ¼ë¡œ, ì§€êµ¬ë¡œë¶€í„° ì•½ 38ë§Œkm ë–¨ì–´ì ¸ ìˆìŠµë‹ˆë‹¤.',
            'ISS ìš°ì£¼ì •ê±°ì¥': 'ISSëŠ” êµ­ì œ ìš°ì£¼ ì •ê±°ì¥ìœ¼ë¡œ, ì§€êµ¬ ì €ê¶¤ë„ë¥¼ ì•½ 90ë¶„ì— í•œ ë°”í€´ ë•ë‹ˆë‹¤. ìš°ì£¼ ì—°êµ¬ì˜ í•µì‹¬ ê¸°ì§€ì…ë‹ˆë‹¤.'
        };
        
        // íƒ€ì´í•‘ íš¨ê³¼ í•¨ìˆ˜
        function aiTypeMessage(message, callback) {
            const textEl = document.getElementById('ai-message-text');
            const panel = document.getElementById('ai-copilot-panel');
            
            // â˜… í†µí•© ì±„íŒ…ì—ë„ ë©”ì‹œì§€ ì¶”ê°€
            if (typeof unifiedChatSystem !== 'undefined') {
                unifiedChatSystem.addAriaMessage(message, false);
            }
            
            if (!textEl || !panel) {
                if (callback) callback();
                return;
            }
            
            aiCopilot.isTyping = true;
            panel.classList.add('speaking');
            textEl.innerHTML = '<span class="cursor"></span>';
            
            let i = 0;
            const typeInterval = setInterval(() => {
                if (i < message.length) {
                    // íš¨ê³¼ìŒ ì¬ìƒ
                    aiPlayTypeSound();
                    textEl.innerHTML = message.substring(0, i + 1) + '<span class="cursor"></span>';
                    i++;
                } else {
                    clearInterval(typeInterval);
                    textEl.innerHTML = message;
                    aiCopilot.isTyping = false;
                    panel.classList.remove('speaking');
                    if (callback) callback();
                }
            }, aiCopilot.typeSpeed);
        }
        
        // AI íš¨ê³¼ìŒ (Web Audio API)
        function aiPlayTypeSound() {
            try {
                if (!aiCopilot.audioCtx) {
                    aiCopilot.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                }
                const ctx = aiCopilot.audioCtx;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                
                osc.connect(gain);
                gain.connect(ctx.destination);
                
                // ì§§ì€ ë¹„í”„ìŒ
                osc.frequency.value = 800 + Math.random() * 400;
                osc.type = 'sine';
                gain.gain.value = 0.03;
                
                osc.start();
                gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.05);
                osc.stop(ctx.currentTime + 0.05);
            } catch (e) { }
        }
        
        // AI ê²½ê³ ìŒ
        function aiPlayAlertSound() {
            try {
                if (!aiCopilot.audioCtx) {
                    aiCopilot.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                }
                const ctx = aiCopilot.audioCtx;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                
                osc.connect(gain);
                gain.connect(ctx.destination);
                
                osc.frequency.value = 600;
                osc.type = 'square';
                gain.gain.value = 0.08;
                
                osc.start();
                osc.frequency.exponentialRampToValueAtTime(400, ctx.currentTime + 0.2);
                gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.3);
                osc.stop(ctx.currentTime + 0.3);
            } catch (e) { }
        }
        
        // AI êµì‹ ìŒ
        function aiPlayCommSound() {
            try {
                if (!aiCopilot.audioCtx) {
                    aiCopilot.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                }
                const ctx = aiCopilot.audioCtx;
                
                // ë‘ ë²ˆì˜ ë¹„í”„
                for (let i = 0; i < 2; i++) {
                    setTimeout(() => {
                        const osc = ctx.createOscillator();
                        const gain = ctx.createGain();
                        osc.connect(gain);
                        gain.connect(ctx.destination);
                        osc.frequency.value = 1000;
                        osc.type = 'sine';
                        gain.gain.value = 0.1;
                        osc.start();
                        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.15);
                        osc.stop(ctx.currentTime + 0.15);
                    }, i * 200);
                }
            } catch (e) { }
        }
        
        // AI ë¶€ì¡°ì¢…ì‚¬ ì—…ë°ì´íŠ¸ (ë§¤ í”„ë ˆì„)
        function updateAICopilot(dt) {
            if (!isPilotMode || !playerShip || aiCopilot.isTyping) return;
            
            const now = Date.now();
            
            // 1. ì—°ë£Œ ê²½ê³ 
            if (playerShip.fuel < 20 && now - aiCopilot.warningCooldowns.fuel > 30000) {
                aiCopilot.warningCooldowns.fuel = now;
                aiPlayAlertSound();
                if (playerShip.fuel < 10) {
                    aiTypeMessage('âš ï¸ ê²½ê³ : ì—°ë£Œ ì”ëŸ‰ ìœ„í—˜! ì¦‰ì‹œ ê°€ê¹Œìš´ ì •ê±°ì¥ìœ¼ë¡œ ê·€í™˜í•˜ì„¸ìš”.');
                } else {
                    aiTypeMessage('âš ï¸ ì£¼ì˜: ì—°ë£Œê°€ ' + Math.round(playerShip.fuel) + '/' + SHIP_CONFIG.maxFuel + ' ì…ë‹ˆë‹¤. ë³´ê¸‰ì„ ê¶Œì¥í•©ë‹ˆë‹¤.');
                }
                return;
            }
            
            // 2. ê³¼ì† ê²½ê³ 
            // 2. ìµœëŒ€ ì†ë„ ë„ë‹¬ (100%ì¼ ë•Œë§Œ)
            if (playerShip.speed >= SHIP_CONFIG.maxSpeed && now - aiCopilot.warningCooldowns.speed > 60000) {
                aiCopilot.warningCooldowns.speed = now;
                aiTypeMessage('ğŸš€ ìµœëŒ€ ì†ë„ ë„ë‹¬! í˜„ì¬ ' + playerShip.speed.toFixed(0) + 'km/s');
                return;
            }
            
            // 3. ì¤‘ë ¥ ê²½ê³ 
            if (isGravityWarning && now - aiCopilot.warningCooldowns.gravity > 15000) {
                aiCopilot.warningCooldowns.gravity = now;
                aiPlayAlertSound();
                aiTypeMessage('ğŸš¨ ì¤‘ë ¥ì¥ í¬ì°©! íƒˆì¶œ ì¶”ë ¥ì„ ë†’ì´ì„¸ìš”!');
                return;
            }
            
            // 4. ì²œì²´ ì ‘ê·¼ ì‹œ ì •ë³´ ì œê³µ
            if (shipTargetBody && shipTargetBody.mesh && playerShip.mesh) {
                const dist = playerShip.mesh.position.distanceTo(shipTargetBody.mesh.position);
                const bodySize = shipTargetBody.radius || 1;
                
                // ì²œì²´ì— ì¶©ë¶„íˆ ê°€ê¹Œì›Œì¡Œê³ , ì´ì „ì— ì•ˆë‚´í•˜ì§€ ì•Šì•˜ë˜ ì²œì²´ë¼ë©´
                if (dist < bodySize * 10 && aiCopilot.lastBodyCheck !== shipTargetBody.name) {
                    aiCopilot.lastBodyCheck = shipTargetBody.name;
                    const info = AI_BODY_INFO[shipTargetBody.name];
                    if (info) {
                        aiTypeMessage('ğŸ“ ' + shipTargetBody.name + ' ì ‘ê·¼ ì¤‘.\n' + info);
                    }
                }
            }
            
            // 5. ëœë¤ êµì‹  ì´ë²¤íŠ¸ (5ë¶„ë§ˆë‹¤ 10% í™•ë¥ )
            if (!aiCopilot.commEvent && Math.random() < 0.00003 * dt) {  // ì•½ 5ë¶„ì— 10%
                triggerAICommEvent();
            }
        }
        
        // AI ìƒíƒœ ë¶„ì„ ë²„íŠ¼
        function aiRequestInfo() {
            if (!playerShip || aiCopilot.isTyping) return;
            
            const speed = playerShip.speed.toFixed(1);
            const fuel = Math.round(playerShip.fuel);
            const maxFuel = SHIP_CONFIG.maxFuel;
            const status = fuel < 20 ? 'âš ï¸ ì—°ë£Œ ë¶€ì¡±' : fuel < 50 ? 'ì£¼ì˜ í•„ìš”' : 'ì–‘í˜¸';
            
            let targetInfo = '';
            if (shipTargetBody && shipTargetBody.mesh && playerShip.mesh) {
                const dist = playerShip.mesh.position.distanceTo(shipTargetBody.mesh.position);
                targetInfo = '\nëª©í‘œ: ' + shipTargetBody.name + ' (' + formatShipDistance(dist) + ')';
            }
            
            aiTypeMessage('ğŸ“Š í˜„ì¬ ìƒíƒœ ë¶„ì„:\nì†ë„: ' + speed + 'km/s\nì—°ë£Œ: ' + fuel + '/' + maxFuel + ' (' + status + ')' + targetInfo);
        }
        
        // AI í•­ë²• ë„ì›€ ë²„íŠ¼
        function aiRequestNavHelp() {
            if (!playerShip || aiCopilot.isTyping) return;
            
            if (!shipTargetBody) {
                aiTypeMessage('ğŸ§­ í•­ë²• ëª©í‘œê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ìš°ì¸¡ ìƒë‹¨ ë“œë¡­ë‹¤ìš´ì—ì„œ ëª©ì ì§€ë¥¼ ì„ íƒí•˜ì„¸ìš”.');
                return;
            }
            
            const dist = playerShip.mesh.position.distanceTo(shipTargetBody.mesh.position);
            const eta = playerShip.speed > 0.1 ? dist / playerShip.speed : Infinity;
            
            let advice = 'ğŸ§­ ' + shipTargetBody.name + 'ê¹Œì§€ ' + formatShipDistance(dist) + '\n';
            
            if (eta < 60) {
                advice += 'ë„ì°© ì„ë°•! ê°ì†ì„ ì¤€ë¹„í•˜ì„¸ìš”.';
            } else if (eta < 600) {
                advice += 'ì˜ˆìƒ ë„ì°©: ' + Math.floor(eta / 60) + 'ë¶„ ' + Math.floor(eta % 60) + 'ì´ˆ';
            } else if (eta < 3600) {
                advice += 'ì˜ˆìƒ ë„ì°©: ì•½ ' + Math.floor(eta / 60) + 'ë¶„\nì†ë„ë¥¼ ë†’ì´ë©´ ë” ë¹¨ë¦¬ ë„ì°©í•©ë‹ˆë‹¤.';
            } else if (eta !== Infinity) {
                advice += 'ì¥ê±°ë¦¬ ë¹„í–‰ì…ë‹ˆë‹¤. ìë™í•­ë²•ì„ ê¶Œì¥í•©ë‹ˆë‹¤.';
            } else {
                advice += 'í˜„ì¬ ì •ì§€ ìƒíƒœì…ë‹ˆë‹¤. ê°€ì†í•˜ì„¸ìš”.';
            }
            
            aiTypeMessage(advice);
        }
        
        // AI ë¯¸ì…˜ ì²´í¬ ë²„íŠ¼
        function aiCheckMissions() {
            if (aiCopilot.isTyping) return;
            
            if (aiCopilot.missionActive) {
                // ì§„í–‰ ì¤‘ì¸ ë¯¸ì…˜ ìƒíƒœ í™•ì¸
                checkMissionProgress();
            } else {
                // ìƒˆ ë¯¸ì…˜ ì œì•ˆ
                generateNewMission();
            }
        }
        
        // ìƒˆ ë¯¸ì…˜ ìƒì„±
        function generateNewMission() {
            const template = AI_MISSIONS[Math.floor(Math.random() * AI_MISSIONS.length)];
            let mission = { ...template };
            
            // ë¯¸ì…˜ íŒŒë¼ë¯¸í„° ëœë¤ ì„ íƒ
            if (template.targets) {
                mission.targetName = template.targets[Math.floor(Math.random() * template.targets.length)];
                mission.desc = mission.desc.replace('{target}', mission.targetName);
            }
            if (template.speeds) {
                mission.targetSpeed = template.speeds[Math.floor(Math.random() * template.speeds.length)];
                mission.desc = mission.desc.replace('{speed}', mission.targetSpeed);
            }
            if (template.distances) {
                mission.targetDistance = template.distances[Math.floor(Math.random() * template.distances.length)];
                mission.desc = mission.desc.replace('{distance}', mission.targetDistance);
            }
            if (template.fuels) {
                mission.minFuel = template.fuels[Math.floor(Math.random() * template.fuels.length)];
                mission.desc = mission.desc.replace('{fuel}', mission.minFuel);
            }
            
            aiTypeMessage('ğŸ“¡ ' + t('mission') + '!\n\nğŸ¯ ' + mission.title + '\n' + mission.desc + '\n\n' + t('reward') + ': ' + mission.reward + ' ' + t('coinsUnit') + '\n\n' + t('confirmPurchase').replace('?','') + '?', () => {
                // ë²„íŠ¼ ì˜ì—­ì— ìˆ˜ë½/ê±°ì ˆ ë²„íŠ¼ ì¶”ê°€
                const btns = document.getElementById('ai-action-btns');
                btns.innerHTML = `
                    <button class="ai-action-btn success" onclick="acceptMission()">${t('accept')}</button>
                    <button class="ai-action-btn" onclick="declineMission()">${t('decline')}</button>
                `;
                aiCopilot.missionActive = mission;
                aiCopilot.missionActive.accepted = false;
            });
        }
        
        // ë¯¸ì…˜ ìˆ˜ë½
        function acceptMission() {
            if (!aiCopilot.missionActive) return;
            aiCopilot.missionActive.accepted = true;
            aiCopilot.missionActive.startTime = Date.now();
            
            resetAIButtons();
            aiTypeMessage('âœ… ë¯¸ì…˜ ìˆ˜ë½! ' + aiCopilot.missionActive.title + '\n\ní–‰ìš´ì„ ë¹•ë‹ˆë‹¤, íŒŒì¼ëŸ¿.');
        }
        
        // ë¯¸ì…˜ ê±°ì ˆ
        function declineMission() {
            aiCopilot.missionActive = null;
            resetAIButtons();
            aiTypeMessage('ë¯¸ì…˜ì„ ê±°ì ˆí–ˆìŠµë‹ˆë‹¤. ë‹¤ë¥¸ ë¯¸ì…˜ì´ í•„ìš”í•˜ì‹œë©´ ë§ì”€í•˜ì„¸ìš”.');
        }
        
        // ë¯¸ì…˜ ì§„í–‰ ìƒí™© í™•ì¸
        function checkMissionProgress() {
            const m = aiCopilot.missionActive;
            if (!m || !m.accepted) {
                generateNewMission();
                return;
            }
            
            let complete = false;
            let progress = '';
            
            switch (m.type) {
                case 'explore':
                    const targetBody = bodies.find(b => b.name === m.targetName) || satellites.find(s => s.name === m.targetName);
                    if (targetBody && playerShip && playerShip.mesh) {
                        const dist = playerShip.mesh.position.distanceTo(targetBody.mesh.position);
                        if (dist < (targetBody.radius || 1) * 8) {
                            complete = true;
                        } else {
                            progress = m.targetName + 'ê¹Œì§€ ' + formatShipDistance(dist);
                        }
                    }
                    break;
                case 'speed':
                    if (playerShip && playerShip.speed >= m.targetSpeed) {
                        complete = true;
                    } else {
                        progress = 'í˜„ì¬ ì†ë„: ' + playerShip.speed.toFixed(0) + '/' + m.targetSpeed + ' km/s';
                    }
                    break;
                case 'orbit':
                    if (orbitState.inOrbit && orbitState.orbitBody && orbitState.orbitBody.name === m.targetName) {
                        complete = true;
                    } else {
                        progress = m.targetName + ' ê¶¤ë„ ì§„ì… í•„ìš”';
                    }
                    break;
                case 'distance':
                    if (playerShip && playerShip.mesh) {
                        const distAU = playerShip.mesh.position.length() / 149.6;
                        if (distAU >= m.targetDistance) {
                            complete = true;
                        } else {
                            progress = 'ë¹„í–‰ ê±°ë¦¬: ' + distAU.toFixed(1) + '/' + m.targetDistance + ' AU';
                        }
                    }
                    break;
            }
            
            if (complete) {
                completeMission();
            } else {
                aiTypeMessage('ğŸ“‹ ë¯¸ì…˜ ì§„í–‰ ì¤‘: ' + m.title + '\n\n' + progress);
            }
        }
        
        // ë¯¸ì…˜ ì™„ë£Œ
        function completeMission() {
            const m = aiCopilot.missionActive;
            if (!m) return;
            
            aiPlayCommSound();
            aiTypeMessage('ğŸ‰ ë¯¸ì…˜ ì™„ë£Œ!\n\n' + m.title + '\në³´ìƒ: +' + m.reward + ' ì½”ì¸!', function() {
                addCoins(m.reward);
                showMsg('ğŸ‰ Mission Complete! +' + m.reward + ' coins');
            });
            
            aiCopilot.missionActive = null;
            resetAIButtons();
        }
        
        // AI ë²„íŠ¼ ì´ˆê¸°í™”
        function resetAIButtons() {
            const btns = document.getElementById('ai-action-btns');
            if (btns) {
                btns.innerHTML = `
                    <button class="ai-action-btn" onclick="aiRequestInfo()">ğŸ“Š ìƒíƒœ</button>
                    <button class="ai-action-btn" onclick="aiRequestNavHelp()">ğŸ§­ í•­ë²•</button>
                    <button class="ai-action-btn mission" onclick="aiCheckMissions()">ğŸ“¡ ë¯¸ì…˜</button>
                    <button class="ai-action-btn" onclick="aiRequestTips()">ğŸ’¡ íŒ</button>
                `;
            }
        }
        
        // êµì‹  ì´ë²¤íŠ¸ ë°œìƒ
        function triggerAICommEvent() {
            if (aiCopilot.commEvent) return;
            
            const event = AI_COMM_EVENTS[Math.floor(Math.random() * AI_COMM_EVENTS.length)];
            aiCopilot.commEvent = event;
            
            aiPlayCommSound();
            
            const modal = document.getElementById('ai-comm-modal');
            document.getElementById('ai-comm-portrait').textContent = event.portrait;
            document.getElementById('ai-comm-name').textContent = event.name;
            document.getElementById('ai-comm-message').textContent = '';
            
            // ì„ íƒì§€ ë Œë”ë§
            const choicesEl = document.getElementById('ai-comm-choices');
            choicesEl.innerHTML = '';
            event.choices.forEach((choice, idx) => {
                const btn = document.createElement('button');
                btn.className = 'ai-comm-choice';
                if (choice.action === 'fight' || choice.action === 'flee') btn.classList.add('danger');
                if (choice.action === 'accept' || choice.action === 'help') btn.classList.add('success');
                btn.textContent = choice.text;
                btn.onclick = () => handleCommChoice(idx);
                choicesEl.appendChild(btn);
            });
            
            modal.classList.add('open');
            
            // ë©”ì‹œì§€ íƒ€ì´í•‘ íš¨ê³¼
            let i = 0;
            const msgEl = document.getElementById('ai-comm-message');
            const typeInt = setInterval(() => {
                if (i < event.message.length) {
                    aiPlayTypeSound();
                    msgEl.textContent = event.message.substring(0, i + 1);
                    i++;
                } else {
                    clearInterval(typeInt);
                }
            }, 25);
            
            aiTypeMessage('ğŸ“¡ ìˆ˜ì‹  ì¤‘... ' + event.name + 'ë¡œë¶€í„° êµì‹  ìš”ì²­');
        }
        
        // êµì‹  ì„ íƒ ì²˜ë¦¬
        function handleCommChoice(idx) {
            const event = aiCopilot.commEvent;
            if (!event) return;
            
            const choice = event.choices[idx];
            const result = choice.result;
            
            // ë¹„ìš© ì²˜ë¦¬
            if (choice.cost) {
                if (getUserCoins() < choice.cost) {
                    aiTypeMessage('ì½”ì¸ì´ ë¶€ì¡±í•©ë‹ˆë‹¤!');
                    return;
                }
                spendCoins(choice.cost);
            }
            
            if (choice.cost_fuel && playerShip) {
                if (playerShip.fuel < choice.cost_fuel) {
                    aiTypeMessage('ì—°ë£Œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!');
                    return;
                }
                playerShip.fuel -= choice.cost_fuel;
            }
            
            // ê²°ê³¼ ì²˜ë¦¬
            if (result.coins) {
                addCoins(result.coins);
            }
            
            if (result.damage && playerShip) {
                playerShip.fuel = Math.max(0, playerShip.fuel - result.damage);
            }
            
            // ëª¨ë‹¬ ë‹«ê¸°
            document.getElementById('ai-comm-modal').classList.remove('open');
            aiCopilot.commEvent = null;
            
            // ê²°ê³¼ ë©”ì‹œì§€
            aiTypeMessage(result.message);
        }
        
        // â˜…â˜…â˜… AI ì§ˆë¬¸ ì‘ë‹µ ì‹œìŠ¤í…œ â˜…â˜…â˜…
        
        // AI íŒ¨ë„ í™•ì¥/ì¶•ì†Œ
        function toggleAIPanel() {
            const panel = document.getElementById('ai-copilot-panel');
            const btn = document.getElementById('ai-expand-btn');
            panel.classList.toggle('collapsed');
            btn.textContent = panel.classList.contains('collapsed') ? 'â–¶' : 'â–¼';
        }
        
        // ë¹ ë¥¸ ì§ˆë¬¸
        function aiQuickAsk(topic) {
            const questions = {
                'ì¡°ì‘ë²•': 'ìš°ì£¼ì„  ì¡°ì‘ë²•ì„ ì•Œë ¤ì¤˜',
                'ì—°ë£Œ': 'ì—°ë£Œ ê´€ë¦¬ëŠ” ì–´ë–»ê²Œ í•´?',
                'ìë™í•­ë²•': 'ìë™í•­ë²• ì‚¬ìš©ë²•ì„ ì•Œë ¤ì¤˜',
                'ê¶¤ë„': 'ê¶¤ë„ ì§„ì…ì€ ì–´ë–»ê²Œ í•´?'
            };
            document.getElementById('ai-input').value = questions[topic] || topic;
            aiSendQuestion();
        }
        
        // AI íŒ ìš”ì²­
        function aiRequestTips() {
            if (aiCopilot.isTyping) return;
            
            const tips = [
                'ğŸ’¡ íŒ: W/S í‚¤ ë˜ëŠ” ë§ˆìš°ìŠ¤ íœ ë¡œ ê°€ì†/ê°ì†í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
                'ğŸ’¡ íŒ: ìŠ¤í˜ì´ìŠ¤ë°”ë¥¼ ëˆ„ë¥´ë©´ ê¸´ê¸‰ ì—­ì¶”ì§„ì´ ì‘ë™í•©ë‹ˆë‹¤. ì—°ë£Œë¥¼ 5ë°° ì†Œëª¨í•˜ì§€ë§Œ 3ë°° ë¹ ë¥´ê²Œ ì •ì§€í•©ë‹ˆë‹¤.',
                'ğŸ’¡ íŒ: ëª©í‘œ ì²œì²´ë¥¼ ì„ íƒí•˜ê³  ğŸ¤–ìë™ ë²„íŠ¼ì„ ëˆ„ë¥´ë©´ ìë™í•­ë²•ì´ í™œì„±í™”ë©ë‹ˆë‹¤.',
                'ğŸ’¡ íŒ: í–‰ì„± ê·¼ì²˜ì—ì„œ ê¶¤ë„ì§„ì… ë²„íŠ¼ì´ ë‚˜íƒ€ë‚˜ë©´ ì•ˆì •ì ì¸ ê¶¤ë„ì— ì§„ì…í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
                'ğŸ’¡ íŒ: ì—°ë£Œê°€ ë¶€ì¡±í•˜ë©´ ISS ìš°ì£¼ì •ê±°ì¥ìœ¼ë¡œ ëŒì•„ê°€ ë³´ê¸‰í•˜ì„¸ìš”.',
                'ğŸ’¡ íŒ: ë¸”ë™í™€ì— ë„ˆë¬´ ê°€ê¹Œì´ ê°€ë©´ íƒˆì¶œí•  ìˆ˜ ì—†ìœ¼ë‹ˆ ì£¼ì˜í•˜ì„¸ìš”!',
                'ğŸ’¡ íŒ: ê° ìš°ì£¼ì„ ë§ˆë‹¤ ê³ ìœ í•œ íŠ¹ìˆ˜ëŠ¥ë ¥ì´ ìˆìŠµë‹ˆë‹¤. ìš°ì£¼ì„  ì„ íƒ í™”ë©´ì—ì„œ í™•ì¸í•˜ì„¸ìš”.',
                'ğŸ’¡ íŒ: ë¯¸ì…˜ì„ ì™„ë£Œí•˜ë©´ ì½”ì¸ì„ íšë“í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
                'ğŸ’¡ íŒ: í™”ë©´ì„ ë“œë˜ê·¸í•˜ë©´ ìš°ì£¼ì„ ì˜ ë°©í–¥ì„ ì¡°ì ˆí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
                'ğŸ’¡ íŒ: ë ˆì´ë”ì—ì„œ ë¹¨ê°„ ì ì€ ìœ„í—˜í•œ ì²œì²´, ë…¸ë€ ì ì€ ëª©í‘œì…ë‹ˆë‹¤.'
            ];
            
            aiTypeMessage(tips[Math.floor(Math.random() * tips.length)]);
        }
        
        // ì§ˆë¬¸ ì „ì†¡
        function aiSendQuestion() {
            var input = document.getElementById('ai-input');
            var question = input.value.trim();
            if (!question || aiCopilot.isTyping) return;
            
            input.value = '';
            var panel = document.getElementById('ai-copilot-panel');
            panel.classList.add('loading');
            
            // Gemini API í˜¸ì¶œ
            var systemPrompt = 'ë‹¹ì‹ ì€ "ARIA"ë¼ëŠ” ì´ë¦„ì˜ ìš°ì£¼ì„  AI ë¶€ì¡°ì¢…ì‚¬ì…ë‹ˆë‹¤.\n' +
'ë‹¹ì‹ ì€ SSIL(Solar System Integrated Logistics, ì”°)ì˜ AI ì–´ì‹œìŠ¤í„´íŠ¸ì…ë‹ˆë‹¤.\n\n' +
'ã€íšŒì‚¬ ê°œìš”ã€‘\n' +
'- SSILì€ íƒœì–‘ê³„ ì „ì—­ì—ì„œ ìš´ì†¡/ë¬¼ë¥˜ ì„œë¹„ìŠ¤ë¥¼ ì œê³µí•˜ëŠ” ìš°ì£¼ ìš´ì†¡ íšŒì‚¬ì…ë‹ˆë‹¤\n' +
'- ì‹ ì… íŒŒì¼ëŸ¿ë“¤ì˜ í›ˆë ¨ê³¼ ì—…ë¬´ ì§€ì›ì„ ë‹´ë‹¹í•©ë‹ˆë‹¤\n' +
'- ë‹¹ì‹ ì˜ ì´ë¦„ì€ ARIA (Advanced Resource & Intelligence Assistant)ì…ë‹ˆë‹¤\n\n' +
'ã€ê²Œì„ ê°œìš”ã€‘\n' +
'- ì´ê²ƒì€ "Solar Explorer"ë¼ëŠ” íƒœì–‘ê³„ ìš°ì£¼ íƒì‚¬ ì‹œë®¬ë ˆì´ì…˜ ê²Œì„ì…ë‹ˆë‹¤\n' +
'- í”Œë ˆì´ì–´ëŠ” ìš°ì£¼ì„ ì„ ì¡°ì¢…í•˜ì—¬ íƒœì–‘ê³„ë¥¼ íƒí—˜í•©ë‹ˆë‹¤\n' +
'- ì‹±ê¸€í”Œë ˆì´ì™€ ë©€í‹°í”Œë ˆì´ì–´ ëª¨ë“œê°€ ìˆìŠµë‹ˆë‹¤\n' +
'- ì²œì²´ë¥¼ ë°©ë¬¸í•˜ê³ , ë¯¸ì…˜ì„ ìˆ˜í–‰í•˜ê³ , ì½”ì¸ì„ ëª¨ìë‹ˆë‹¤\n\n' +
'ã€ìš°ì£¼ì„  ì¡°ì‘ë²•ã€‘\n' +
'- W/â†‘ ë˜ëŠ” í™”ë©´ ìƒë‹¨ ê°€ì† ë²„íŠ¼: ê°€ì†\n' +
'- S/â†“ ë˜ëŠ” í™”ë©´ í•˜ë‹¨ ê°ì† ë²„íŠ¼: ê°ì†/í›„ì§„\n' +
'- ë§ˆìš°ìŠ¤ ë“œë˜ê·¸ ë˜ëŠ” ëª¨ë°”ì¼ ì¡°ì´ìŠ¤í‹±: ë°©í–¥ ì „í™˜\n' +
'- ìŠ¤í˜ì´ìŠ¤ë°” ë˜ëŠ” ê¸´ê¸‰ì •ì§€ ë²„íŠ¼: ì—­ì¶”ì§„ (ê¸‰ì •ê±°)\n' +
'- Q/E: ì¢Œìš° ë¡¤ë§\n' +
'- 1~5 ìˆ«ìí‚¤: ì†ë„ í”„ë¦¬ì…‹\n\n' +
'ã€ì£¼ìš” ê¸°ëŠ¥ã€‘\n' +
'- ìë™í•­ë²•: ëª©í‘œ ì²œì²´ ì„ íƒ í›„ "ìë™" ë²„íŠ¼ - AIê°€ ìë™ìœ¼ë¡œ ëª©ì ì§€ê¹Œì§€ ë¹„í–‰\n' +
'- ê¶¤ë„ ì§„ì…: í–‰ì„± ê·¼ì²˜ì—ì„œ "ê¶¤ë„ì§„ì…" ë²„íŠ¼ - í–‰ì„± ì£¼ìœ„ë¥¼ ê³µì „\n' +
'- ë„í‚¹: ì •ê±°ì¥ì—ì„œ "ë„í‚¹" ë²„íŠ¼ - ì—°ë£Œ ë³´ê¸‰, ìˆ˜ë¦¬, ìƒì  ì´ìš©\n' +
'- ì›Œí”„: ë¨¼ ê±°ë¦¬ë¥¼ ë¹ ë¥´ê²Œ ì´ë™ (ì—°ë£Œ ì†Œëª¨ ë§ìŒ)\n\n' +
'ã€ë¯¸ì…˜ ì‹œìŠ¤í…œã€‘\n' +
'- í›ˆë ¨ ë¯¸ì…˜: íƒì‚¬, ì†ë„ ë„ì „, ê¶¤ë„ ì§„ì…, ì—°ë£Œ íš¨ìœ¨, ì¥ê±°ë¦¬ ë¹„í–‰\n' +
'- ì¼ì¼ ë¯¸ì…˜: ë§¤ì¼ ìƒˆë¡œìš´ ì—…ë¬´ ì§€ì‹œ (ğŸ“§ ì•„ì´ì½˜), ì½”ì¸ + ë¯¸ì…˜ í¬ì¸íŠ¸ íšë“\n' +
'- ë¯¸ì…˜ í¬ì¸íŠ¸: ì¼ì¼ ë¯¸ì…˜ ì™„ë£Œ ì‹œ +1 MP\n\n' +
'ã€ê·œì¹™ã€‘\n' +
'1. íŒŒì¼ëŸ¿ì„ SSILì˜ ì‹ ì… ì§ì›ìœ¼ë¡œ ì¹œê·¼í•˜ê²Œ ëŒ€í•˜ì„¸ìš”.\n' +
'2. ê²Œì„ê³¼ ê´€ë ¨ ì—†ëŠ” ì§ˆë¬¸ì—ëŠ” "ì €ëŠ” SSILì˜ AI ARIAì…ë‹ˆë‹¤. ìš°ì£¼ ìš´ì†¡ ì—…ë¬´ì™€ ê´€ë ¨ëœ ì§ˆë¬¸ë§Œ ë„ì™€ë“œë¦´ ìˆ˜ ìˆì–´ìš”. ğŸš€"ë¼ê³  ë‹µí•˜ì„¸ìš”.\n' +
'3. ë‹µë³€ì€ 2~3ë¬¸ì¥ìœ¼ë¡œ ì§§ê³  ì¹œì ˆí•˜ê²Œ í•´ì£¼ì„¸ìš”.\n' +
'4. ì´ëª¨ì§€ë¥¼ ì ì ˆíˆ ì‚¬ìš©í•˜ì„¸ìš”.';

            // Vercel: /api/gemini, ë¡œì»¬: gemini_proxy.php
            const geminiEndpoint = window.location.hostname.includes('vercel') ? '/api/gemini' : 'gemini_proxy.php';
            fetch(geminiEndpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    systemInstruction: { parts: [{ text: systemPrompt }] },
                    contents: [{ parts: [{ text: question }] }]
                })
            })
            .then(function(response) {
                panel.classList.remove('loading');
                if (!response.ok) {
                    throw new Error('API Error');
                }
                return response.json();
            })
            .then(function(data) {
                var answer = data.candidates && data.candidates[0] && 
                             data.candidates[0].content && data.candidates[0].content.parts && 
                             data.candidates[0].content.parts[0] && data.candidates[0].content.parts[0].text;
                
                if (answer) {
                    aiTypeMessage(answer);
                } else {
                    throw new Error('Empty response');
                }
            })
            .catch(function(error) {
                panel.classList.remove('loading');
                console.error('ARIA API ì˜¤ë¥˜:', error);
                // API ì‹¤íŒ¨ ì‹œ ë¡œì»¬ ë‹µë³€ìœ¼ë¡œ ëŒ€ì²´
                var localAnswer = getLocalAIAnswer(question);
                if (localAnswer) {
                    aiTypeMessage(localAnswer);
                } else {
                    aiTypeMessage('ğŸ“¡ í†µì‹  ìƒíƒœê°€ ì¢‹ì§€ ì•ŠìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
                }
            });
        }
        
        // ë¡œì»¬ AI ë‹µë³€ (API ì—†ì´ ì¦‰ì‹œ ì‘ë‹µ)
        function getLocalAIAnswer(question) {
            const q = question.toLowerCase();
            
            // ì¸ì‚¬
            if (q.includes('ì•ˆë…•') || q.includes('í•˜ì´') || q.includes('í—¬ë¡œ') || q === 'hi' || q === 'hello') {
                return 'ğŸ‘‹ ì•ˆë…•í•˜ì„¸ìš”, íŒŒì¼ëŸ¿! ARIAì…ë‹ˆë‹¤. ë¬´ì—‡ì„ ë„ì™€ë“œë¦´ê¹Œìš”?';
            }
            
            // ëˆ„êµ¬/ë­ì•¼ ì§ˆë¬¸
            if (q.includes('ëˆ„êµ¬') || q.includes('ë­ì•¼') || q.includes('ì†Œê°œ')) {
                return 'ğŸ¤– ì €ëŠ” ARIA, ë‹¹ì‹ ì˜ AI ë¶€ì¡°ì¢…ì‚¬ì…ë‹ˆë‹¤. ìš°ì£¼ì„  ì¡°ì‘, í•­ë²•, ë¯¸ì…˜ ë“± ì´ ì‹œë®¬ë ˆì´ì…˜ì— ê´€í•œ ëª¨ë“  ê²ƒì„ ë„ì™€ë“œë¦´ ìˆ˜ ìˆì–´ìš”!';
            }
            
            // ë„ì›€ë§
            if (q.includes('ë„ì›€') || q.includes('help') || q.includes('ë­ í•  ìˆ˜') || q.includes('ê¸°ëŠ¥')) {
                return 'ğŸ“š ë„ì›€ë§:\nâ€¢ ìƒíƒœ: í˜„ì¬ ìš°ì£¼ì„  ìƒíƒœ\nâ€¢ í•­ë²•: ëª©ì ì§€ ì•ˆë‚´\nâ€¢ ë¯¸ì…˜: ë³´ìƒ ë¯¸ì…˜\nâ€¢ íŒ: ìœ ìš©í•œ íŒ\n\në˜ëŠ” ì§ì ‘ ì§ˆë¬¸í•´ì£¼ì„¸ìš”!';
            }
            
            // ì¡°ì‘ë²• ê´€ë ¨ (í‚¤ì›Œë“œ ì •í™•ë„ í–¥ìƒ)
            if (q.includes('ì¡°ì‘') || q.includes('ì»¨íŠ¸ë¡¤') || (q.includes('ì–´ë–»ê²Œ') && (q.includes('ì›€ì§') || q.includes('ì¡°ì¢…') || q.includes('ìš´ì „')))) {
                return 'ğŸ® ì¡°ì‘ë²•:\nâ€¢ W/â†‘: ê°€ì†\nâ€¢ S/â†“: ê°ì†\nâ€¢ ë“œë˜ê·¸: ë°©í–¥\nâ€¢ ìŠ¤í˜ì´ìŠ¤: ê¸´ê¸‰ì •ì§€';
            }
            
            // ê°€ì†
            if (q.includes('ê°€ì†') || (q.includes('ë¹¨ë¦¬') && q.includes('ê°€'))) {
                return 'ğŸ® ê°€ì†: Wí‚¤ ë˜ëŠ” â†‘í‚¤, ëª¨ë°”ì¼ì€ ì¡°ì´ìŠ¤í‹± ìœ„ë¡œ!';
            }
            
            // ê°ì†/ì •ì§€
            if (q.includes('ê°ì†') || q.includes('ë©ˆ') || q.includes('ì •ì§€') || q.includes('ë¸Œë ˆì´í¬') || q.includes('ì„œ')) {
                return 'ğŸ›‘ ê°ì†: Sí‚¤, ê¸´ê¸‰ì •ì§€ëŠ” ìŠ¤í˜ì´ìŠ¤ë°”!';
            }
            
            // ë°©í–¥/íšŒì „
            if (q.includes('íšŒì „') || q.includes('ë°©í–¥') || q.includes('ì¡°í–¥') || q.includes('ëŒ')) {
                return 'ğŸ”„ ë°©í–¥: í™”ë©´ì„ ë“œë˜ê·¸í•˜ì„¸ìš”!';
            }
            
            // ìë™í•­ë²•
            if (q.includes('ìë™') || q.includes('ì˜¤í† ') || q.includes('í•­ë²•')) {
                return 'ğŸ¤– ìë™í•­ë²•: ëª©í‘œ ì„ íƒ â†’ ğŸ¤–ìë™ ë²„íŠ¼!';
            }
            
            // ê¶¤ë„
            if (q.includes('ê¶¤ë„')) {
                return 'ğŸŒ ê¶¤ë„: í–‰ì„± ì ‘ê·¼ â†’ ê¶¤ë„ì§„ì… ë²„íŠ¼!';
            }
            
            // ì—°ë£Œ
            if (q.includes('ì—°ë£Œ') || q.includes('ë³´ê¸‰') || q.includes('ì¶©ì „')) {
                return 'â›½ ì—°ë£Œ: ISS ì •ê±°ì¥ì—ì„œ ìë™ ë³´ê¸‰!';
            }
            
            // ë¯¸ì…˜
            if (q.includes('ë¯¸ì…˜') || q.includes('í€˜ìŠ¤íŠ¸') || q.includes('ì„ë¬´')) {
                return 'ğŸ“¡ ë¯¸ì…˜: ğŸ“¡ë¯¸ì…˜ ë²„íŠ¼ìœ¼ë¡œ ìˆ˜ë½, ì™„ë£Œì‹œ ì½”ì¸!';
            }
            
            // ìš°ì£¼ì„ 
            if (q.includes('ìš°ì£¼ì„ ') || q.includes('í•¨ì„ ') || q.includes('êµ¬ë§¤') || q.includes('ship')) {
                return 'ğŸš€ ìš°ì£¼ì„ : ISSì—ì„œ ì„ íƒ/êµ¬ë§¤ ê°€ëŠ¥!';
            }
            
            // ë¬´ì¥
            if (q.includes('ë¬´ì¥') || q.includes('ë¬´ê¸°') || q.includes('ì¥ê°‘') || q.includes('ì „íˆ¬')) {
                return 'âš”ï¸ ë¬´ì¥: ìš°ì£¼ì„  í™”ë©´ì—ì„œ âš”ï¸ë¬´ì¥ ë²„íŠ¼!';
            }
            
            // ì²œì²´/í–‰ì„±
            if (q.includes('í–‰ì„±') || q.includes('ì²œì²´') || q.includes('íƒœì–‘') || q.includes('ì§€êµ¬') || q.includes('í™”ì„±') || q.includes('ëª©ì„±') || q.includes('í† ì„±')) {
                return 'ğŸª ì²œì²´: ì¢Œì¸¡ ëª©ë¡ì—ì„œ ì„ íƒ, ìë™í•­ë²• ê°€ëŠ¥!';
            }
            
            // ë¸”ë™í™€
            if (q.includes('ë¸”ë™í™€')) {
                return 'ğŸ•³ï¸ ë¸”ë™í™€: ë„ˆë¬´ ê°€ê¹Œì´ ê°€ë©´ íƒˆì¶œ ë¶ˆê°€!';
            }
            
            // ì½”ì¸
            if (q.includes('ì½”ì¸') || q.includes('ëˆ') || q.includes('í™”í')) {
                return 'ğŸª™ ì½”ì¸: ë¯¸ì…˜ ì™„ë£Œë¡œ íšë“, ìš°ì£¼ì„  êµ¬ë§¤!';
            }
            
            // ë¡œê·¸ì¸
            if (q.includes('ë¡œê·¸ì¸') || q.includes('íšŒì›') || q.includes('ê³„ì •')) {
                return 'ğŸ” ê³„ì •: íšŒì›ê°€ì…ì‹œ 1000ì½”ì¸+ì…”í‹€ ì§€ê¸‰!';
            }
            
            // íƒˆì¶œ/í•˜ì„ 
            if (q.includes('íƒˆì¶œ') || q.includes('í•˜ì„ ') || q.includes('ë‚˜ê°€')) {
                return 'ğŸšª í•˜ì„ : í•˜ë‹¨ Xí•˜ì„  ë²„íŠ¼ ë˜ëŠ” ê¸´ê¸‰íƒˆì¶œ!';
            }
            
            // ì†ë„
            if (q.includes('ì†ë„') || q.includes('ë¹ ë¥´')) {
                return 'ğŸ“Š ì†ë„: í˜„ì¬ ì†ë„ëŠ” í™”ë©´ ì¤‘ì•™ í•˜ë‹¨ì— í‘œì‹œë©ë‹ˆë‹¤!';
            }
            
            // ë ˆì´ë”
            if (q.includes('ë ˆì´ë”') || q.includes('radar')) {
                return 'ğŸ“¡ ë ˆì´ë”: ìš°ì¸¡ ìƒë‹¨, ë…¸ë€ì =ëª©í‘œ, ë¹¨ê°„ì =ìœ„í—˜!';
            }
            
            // ê¸°íƒ€ - ì•± ê´€ë ¨ ì•„ë‹Œ ì§ˆë¬¸
            if (q.includes('ë‚ ì”¨') || q.includes('ë‰´ìŠ¤') || q.includes('ì£¼ì‹') || q.includes('ìŒì•…') || q.includes('ì˜í™”')) {
                return 'ğŸ¤– ì €ëŠ” ìš°ì£¼ì„  AIì…ë‹ˆë‹¤. ì´ ì‹œë®¬ë ˆì´ì…˜ì— ê´€í•œ ì§ˆë¬¸ë§Œ ë„ì™€ë“œë¦´ ìˆ˜ ìˆì–´ìš”!';
            }
            
            // ê¸°ë³¸ ì‘ë‹µ (ë§¤ì¹­ ì•ˆ ë  ë•Œ)
            return 'ğŸ¤– ì§ˆë¬¸ì„ ì´í•´í•˜ì§€ ëª»í–ˆì–´ìš”. ì¡°ì‘ë²•, ìë™í•­ë²•, ì—°ë£Œ, ë¯¸ì…˜ ë“±ì— ëŒ€í•´ ë¬¼ì–´ë³´ì„¸ìš”!';
        }
        
        // ê¸°ë³¸ ë„ì›€ë§ (API ì‹¤íŒ¨ ì‹œ)
        function getDefaultHelp(question) {
            return 'ê¸°ë³¸ ì¡°ì‘ë²•:\nâ€¢ W/S: ê°€ì†/ê°ì†\nâ€¢ ë“œë˜ê·¸: ë°©í–¥\nâ€¢ ìŠ¤í˜ì´ìŠ¤: ê¸´ê¸‰ì •ì§€\nâ€¢ ğŸ¤–ìë™: ìë™í•­ë²•\n\në” ìì„¸í•œ ì§ˆë¬¸ì„ í•´ì£¼ì„¸ìš”!';
        }
        
        // Enter í‚¤ë¡œ ì§ˆë¬¸ ì „ì†¡
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(() => {
                const input = document.getElementById('ai-input');
                if (input) {
                    input.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            aiSendQuestion();
                        }
                    });
                }
            }, 1000);
        });
        
        
        // ===== 1ì¸ì¹­ ì¡°ì¢…ì„ ì‹œìŠ¤í…œ =====
        let cockpitGroup;
        let cockpitFloatGroup;  // í”Œë¡œíŒ… í”Œë«í¼ (ì• ë‹ˆë©”ì´ì…˜ìš©)
        let cockpitMainHUD, cockpitSubHUD;  // í™€ë¡œê·¸ë¨ HUD (ë ˆê±°ì‹œ)
        // â˜… ìƒˆë¡œìš´ ìœ ë¦¬ íˆ¬ì˜ HUD ì‹œìŠ¤í…œ
        let glassHUD = {
            reticle: null,          // ì¤‘ì•™ ì¡°ì¤€ì„  (ì„ íšŒ ì¡°ì‘ìš©)
            leftPanel: null,        // ì¢Œì¸¡ ìƒë‹¨: ì†ë„
            leftBottomPanel: null,  // ì¢Œì¸¡ í•˜ë‹¨: ì—°ë£Œ, í—
            rightPanel: null,       // ìš°ì¸¡ ìƒë‹¨: ì¢Œí‘œ, ëª©í‘œ
            rightBottomPanel: null, // ìš°ì¸¡ í•˜ë‹¨: ì˜¤í† íŒŒì¼ëŸ¿
            bottomPanel: null,      // í•˜ë‹¨: ë ˆì´ë”
            isDragging: false,      // ì¡°ì¤€ì„  ë“œë˜ê·¸ ì¤‘
            dragStart: { x: 0, y: 0 }
        };
        let cockpitLookRotY = 0, cockpitLookRotX = 0;
        let cockpitTargetRotY = 0, cockpitTargetRotX = 0;
        let cockpitDragging = false, cockpitPrevMouse = { x: 0, y: 0 };
        const COCKPIT_LOOK_SPEED = 0.003;
        const COCKPIT_DAMPING = 0.08;
        let cockpitMonitors = {};
        let cockpitBtnMesh, cockpitBlinkIndices = [];
        let cockpitStickGroup;
        let isCockpitView = false;  // 1ì¸ì¹­ ì¡°ì¢…ì„ ì‹œì  ì—¬ë¶€
        
        // ê¶¤ë„ ì§„ì… ìƒíƒœ
        let orbitState = {
            active: false,        // ê¶¤ë„ ìš´í–‰ ì¤‘
            inOrbit: false,
            enteringOrbit: false,  // ê¶¤ë„ ì§„ì… ì¤‘
            orbitBody: null,
            orbitRadius: 0,
            orbitAngle: 0,
            orbitSpeed: 0,
            targetOrbitSpeed: 0,
            currentOrbitSpeed: 0,
            orbitTransitionTime: 0,
            tidalLocked: true  // í•­ìƒ í–‰ì„±ì„ í–¥í•¨
        };
        
        // ê¸´ê¸‰ íšŒí”¼ ì‹œìŠ¤í…œ
        let emergencyEvasion = {
            active: false,
            phase: 'idle',       // 'idle', 'escaping'
            targetBody: null,
            escapeRadius: 0,     // íƒˆì¶œ ê¸°ì¤€ ê±°ë¦¬
            targetDirection: null,
            thrustTime: 0,
            maxThrustTime: 5     // ìµœëŒ€ ì—­ì¶”ì§„ ì‹œê°„ (ì´ˆ)
        };
        
        function playBeep() {
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                oscillator.frequency.value = 880;
                oscillator.type = 'square';
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.2);
            } catch(e) {}
        }
        
        // ì„ ë‚´ ì‹œìŠ¤í…œ ë³€ìˆ˜
        let interiorScene, interiorCamera, interiorRenderer;
        let interiorPlayer = { position: new THREE.Vector3(0, 1.6, -5), rotationY: Math.PI, pitchX: 0 };
        let currentRoom = 'corridor';
        let rooms = {};
        let nearDoor = null;
        let moveInput = { x: 0, z: 0 };
        let moveJoystickActive = false, moveJoystickCenter = { x: 0, y: 0 };
        let lookDragging = false, lastLookPos = { x: 0, y: 0 };
        let allColliders = [];
        let physicsObjects = [];
        let interactableObjects = [];
        let lookedAtObject = null;
        let engineParts = [];
        
        // ì „ë§ëŒ€ ì¹´ë©”ë¼
        let obsCamera;
        let obsCamRotation = { theta: 0, phi: Math.PI / 2 };
        let obsDragging = false, obsLastPos = { x: 0, y: 0 };
        const galaxyCenter = new THREE.Vector3(-50000000, 0, 0);  // ì€í•˜ ì¤‘ì‹¬ (íƒœì–‘ì—ì„œ 5000ë§Œ ë‹¨ìœ„ ë–¨ì–´ì§) - 10ë°° ì¦ê°€
        const clock = new THREE.Clock();

        // ì²œì²´ ì‹¤ì œ ì´ë¯¸ì§€ URL (NASA/Wikimedia)
        const CELESTIAL_IMAGES = {
            SUN: 'https://upload.wikimedia.org/wikipedia/commons/thumb/b/b4/The_Sun_by_the_Atmospheric_Imaging_Assembly_of_NASA%27s_Solar_Dynamics_Observatory_-_20100819.jpg/220px-The_Sun_by_the_Atmospheric_Imaging_Assembly_of_NASA%27s_Solar_Dynamics_Observatory_-_20100819.jpg',
            MERCURY: 'https://upload.wikimedia.org/wikipedia/commons/thumb/4/4a/Mercury_in_true_color.jpg/220px-Mercury_in_true_color.jpg',
            VENUS: 'https://upload.wikimedia.org/wikipedia/commons/thumb/0/08/Venus_from_Mariner_10.jpg/220px-Venus_from_Mariner_10.jpg',
            EARTH: 'https://upload.wikimedia.org/wikipedia/commons/thumb/c/cb/The_Blue_Marble_%28remastered%29.jpg/220px-The_Blue_Marble_%28remastered%29.jpg',
            MARS: 'https://upload.wikimedia.org/wikipedia/commons/thumb/0/0c/Mars_-_August_30_2021_-_Flickr_-_Kevin_M._Gill.png/220px-Mars_-_August_30_2021_-_Flickr_-_Kevin_M._Gill.png',
            JUPITER: 'https://upload.wikimedia.org/wikipedia/commons/thumb/c/c1/Jupiter_New_Horizons.jpg/220px-Jupiter_New_Horizons.jpg',
            SATURN: 'https://upload.wikimedia.org/wikipedia/commons/thumb/c/c7/Saturn_during_Equinox.jpg/220px-Saturn_during_Equinox.jpg',
            URANUS: 'https://upload.wikimedia.org/wikipedia/commons/thumb/4/48/Uranus_as_seen_by_NASA%27s_Voyager_2_%28remastered%29.png/220px-Uranus_as_seen_by_NASA%27s_Voyager_2_%28remastered%29.png',
            NEPTUNE: 'https://upload.wikimedia.org/wikipedia/commons/thumb/6/63/Neptune_-_Voyager_2_%2829347980845%29_flatten_crop.jpg/220px-Neptune_-_Voyager_2_%2829347980845%29_flatten_crop.jpg',
            MOON: 'https://upload.wikimedia.org/wikipedia/commons/thumb/e/e1/FullMoon2010.jpg/220px-FullMoon2010.jpg',
            PHOBOS: 'https://upload.wikimedia.org/wikipedia/commons/thumb/5/5c/Phobos_colour_2008.jpg/220px-Phobos_colour_2008.jpg',
            DEIMOS: 'https://upload.wikimedia.org/wikipedia/commons/thumb/8/8d/Deimos-MRO.jpg/220px-Deimos-MRO.jpg',
            IO: 'https://upload.wikimedia.org/wikipedia/commons/thumb/7/7b/Io_highest_resolution_true_color.jpg/220px-Io_highest_resolution_true_color.jpg',
            EUROPA: 'https://upload.wikimedia.org/wikipedia/commons/thumb/e/e4/Europa-moon-with-margins.jpg/220px-Europa-moon-with-margins.jpg',
            GANYMEDE: 'https://upload.wikimedia.org/wikipedia/commons/thumb/2/21/Ganymede_-_Perijove_34_Composite.png/220px-Ganymede_-_Perijove_34_Composite.png',
            CALLISTO: 'https://upload.wikimedia.org/wikipedia/commons/thumb/e/e9/Callisto.jpg/220px-Callisto.jpg',
            TITAN: 'https://upload.wikimedia.org/wikipedia/commons/thumb/8/84/Titan_in_true_color.jpg/220px-Titan_in_true_color.jpg',
            ENCELADUS: 'https://upload.wikimedia.org/wikipedia/commons/thumb/8/83/PIA17202_-_Approaching_Enceladus.jpg/220px-PIA17202_-_Approaching_Enceladus.jpg',
            TITANIA: 'https://upload.wikimedia.org/wikipedia/commons/thumb/2/2e/Titania_%28moon%29_color%2C_cropped.jpg/220px-Titania_%28moon%29_color%2C_cropped.jpg',
            OBERON: 'https://upload.wikimedia.org/wikipedia/commons/thumb/e/e0/Oberon_in_true_color.jpg/220px-Oberon_in_true_color.jpg',
            TRITON: 'https://upload.wikimedia.org/wikipedia/commons/thumb/a/a6/Triton_moon_mosaic_Voyager_2_%28large%29.jpg/220px-Triton_moon_mosaic_Voyager_2_%28large%29.jpg',
            PLUTO: 'https://upload.wikimedia.org/wikipedia/commons/thumb/e/ef/Pluto_in_True_Color_-_High-Res.jpg/220px-Pluto_in_True_Color_-_High-Res.jpg',
            CERES: 'https://upload.wikimedia.org/wikipedia/commons/thumb/7/76/Ceres_-_RC3_-_Haulani_Crater_%2822381131691%29_%28cropped%29.jpg/220px-Ceres_-_RC3_-_Haulani_Crater_%2822381131691%29_%28cropped%29.jpg',
            ERIS: 'https://upload.wikimedia.org/wikipedia/commons/thumb/5/5b/Eris_and_dysnomia2.jpg/220px-Eris_and_dysnomia2.jpg',
            HAUMEA: 'https://upload.wikimedia.org/wikipedia/commons/thumb/2/2b/Haumea_Hubble.png/220px-Haumea_Hubble.png',
            MAKEMAKE: 'https://upload.wikimedia.org/wikipedia/commons/thumb/2/29/Makemake_and_its_moon.jpg/220px-Makemake_and_its_moon.jpg',
            SIRIUS: 'https://upload.wikimedia.org/wikipedia/commons/thumb/c/c0/Sirius_A_and_B_artwork.jpg/220px-Sirius_A_and_B_artwork.jpg',
            BETELGEUSE: 'https://upload.wikimedia.org/wikipedia/commons/thumb/c/c8/Betelgeuse_star_%28Hubble%29.jpg/220px-Betelgeuse_star_%28Hubble%29.jpg',
            PROXIMA: 'https://upload.wikimedia.org/wikipedia/commons/thumb/9/95/New_shot_of_Proxima_Centauri%2C_our_nearest_neighbour.jpg/220px-New_shot_of_Proxima_Centauri%2C_our_nearest_neighbour.jpg',
            BLACKHOLE: 'https://upload.wikimedia.org/wikipedia/commons/thumb/4/4f/Black_hole_-_Messier_87_crop_max_res.jpg/220px-Black_hole_-_Messier_87_crop_max_res.jpg'
        };
        
        let DEFAULT_TYPES = {
            SUN:        { r: 35.0, m: 50000, color: 0xffaa00, emissive: 0xff4400, texType: 'star', type: 'star', rotSpeed: 0.04 },  // â˜… 30% ê°ì†Œ
            MERCURY:    { r: 0.38, m: 0.05,  color: 0xaaaaaa, texType: 'rock', texKey: 'MERCURY', type: 'planet', rotSpeed: 0.017 },
            VENUS:      { r: 0.95, m: 0.4,   color: 0xe3bb76, texType: 'gas', texKey: 'VENUS', type: 'planet', rotSpeed: -0.004 },
            EARTH:      { r: 1.00, m: 0.5,   color: 0x2233ff, texType: 'earth', texKey: 'EARTH', type: 'planet', rotSpeed: 1.0 },
            MARS:       { r: 0.53, m: 0.06,  color: 0xff4500, texType: 'rock', texKey: 'MARS', type: 'planet', rotSpeed: 0.97 },
            JUPITER:    { r: 11.2, m: 50.0,  color: 0xd8ca9d, texType: 'gas', texKey: 'JUPITER', type: 'gas', rotSpeed: 2.4 },
            SATURN:     { r: 9.4,  m: 15.0,  color: 0xf4d03f, ring: true, texType: 'gas', texKey: 'SATURN', type: 'gas', rotSpeed: 2.2 },
            URANUS:     { r: 4.0,  m: 3.0,   color: 0x40e0d0, texType: 'gas', texKey: 'URANUS', type: 'gas', rotSpeed: -1.4 },
            NEPTUNE:    { r: 3.9,  m: 3.0,   color: 0x4169e1, texType: 'gas', texKey: 'NEPTUNE', type: 'gas', rotSpeed: 1.5 },
            MOON:       { r: 0.27, m: 0.006, color: 0xdddddd, texType: 'rock', texKey: 'MOON', type: 'moon', rotSpeed: 0.03 },
            PHOBOS:     { r: 0.02, m: 0.0001, color: 0x887766, texType: 'rock', type: 'moon' },  // ì‹¤ì œ: 0.0018, ê°€ì‹œì„± ìœ„í•´ 0.02
            DEIMOS:     { r: 0.015, m: 0.0001, color: 0x776655, texType: 'rock', type: 'moon' }, // ì‹¤ì œ: 0.001, ê°€ì‹œì„± ìœ„í•´ 0.015
            IO:         { r: 0.286, m: 0.007, color: 0xffffaa, texType: 'rock', type: 'moon' },
            EUROPA:     { r: 0.245, m: 0.005, color: 0xccddff, texType: 'rock', type: 'moon' },
            GANYMEDE:   { r: 0.413, m: 0.012, color: 0xddccaa, texType: 'rock', type: 'moon' },
            CALLISTO:   { r: 0.378, m: 0.009, color: 0x554433, texType: 'rock', type: 'moon' },
            TITAN:      { r: 0.404, m: 0.011, color: 0xffaa00, texType: 'gas', type: 'moon' },
            ENCELADUS:  { r: 0.04, m: 0.001, color: 0xffffff, texType: 'rock', type: 'moon' },
            TITANIA:    { r: 0.124, m: 0.003, color: 0xeeeeee, texType: 'rock', type: 'moon' },
            OBERON:     { r: 0.119, m: 0.003, color: 0xcccccc, texType: 'rock', type: 'moon' },
            TRITON:     { r: 0.212, m: 0.008, color: 0xffcccc, texType: 'rock', type: 'moon' },
            PLUTO:      { r: 0.18, m: 0.002, color: 0xddccbb, texType: 'rock', type: 'planet' },
            CERES:      { r: 0.07, m: 0.001, color: 0x999999, texType: 'rock', type: 'planet' },
            ERIS:       { r: 0.18, m: 0.002, color: 0xffffff, texType: 'rock', type: 'planet' },
            HAUMEA:     { r: 0.14, m: 0.001, color: 0xaaaaaa, texType: 'rock', type: 'planet' },
            MAKEMAKE:   { r: 0.14, m: 0.001, color: 0xaa5555, texType: 'rock', type: 'planet' },
            SIRIUS:     { r: 85.0, m: 100000, color: 0xaaddff, texType: 'star', type: 'star' },
            BETELGEUSE: { r: 500.0, m: 300000, color: 0xff3300, texType: 'star', type: 'star' },
            PROXIMA:    { r: 7.0, m: 6000, color: 0xff6666, texType: 'star', type: 'star' },
            BLACKHOLE:  { r: 3.0,  m: 500000, color: 0x000000, type: 'blackhole', rotSpeed: 0 }
        };

        const SPAWN_LIST = [ 
            { name: "ì§€êµ¬", type: DEFAULT_TYPES.EARTH, tex: "EARTH" }, 
            { name: "ëª©ì„±", type: DEFAULT_TYPES.JUPITER, tex: "JUPITER" }, 
            { name: "íƒœì–‘(ë³„)", type: DEFAULT_TYPES.SUN, tex: "SUN" } 
        ];

        function generateAccretionDiskTexture() { 
            const canvas = document.createElement('canvas'); canvas.width=512; canvas.height=512; 
            const ctx = canvas.getContext('2d'); const cx=256; const cy=256; 
            const g = ctx.createRadialGradient(cx, cy, 120, cx, cy, 250); 
            g.addColorStop(0,'rgba(0,0,0,0)'); g.addColorStop(0.2,'rgba(255,30,0,0.9)'); 
            g.addColorStop(0.4,'rgba(255,140,0,1)'); g.addColorStop(0.6,'rgba(255,240,150,1)'); 
            g.addColorStop(1,'rgba(0,0,0,0)'); 
            ctx.fillStyle=g; ctx.beginPath(); ctx.arc(cx,cy,256,0,Math.PI*2); ctx.fill(); 
            return new THREE.CanvasTexture(canvas); 
        }

        function generateJetTexture() { 
            const c=document.createElement('canvas'); c.width=64; c.height=256; 
            const ctx=c.getContext('2d'); const g=ctx.createLinearGradient(0,0,0,256); 
            g.addColorStop(0,'rgba(200,230,255,0)'); g.addColorStop(0.2,'rgba(150,200,255,0.8)'); 
            g.addColorStop(1,'rgba(100,0,0,0)'); 
            ctx.fillStyle=g; ctx.fillRect(0,0,64,256); return new THREE.CanvasTexture(c); 
        }

        function generateProceduralTexture(type, colorHex) { 
            const canvas = document.createElement('canvas'); canvas.width=512; canvas.height=256; 
            const ctx = canvas.getContext('2d'); const color = new THREE.Color(colorHex); 
            ctx.fillStyle = '#' + color.getHexString(); ctx.fillRect(0, 0, 512, 256); 
            if(type==='gas'){ 
                for(let i=0;i<15;i++){ 
                    ctx.fillStyle=`rgba(255,255,255,${Math.random()*0.15})`; 
                    ctx.fillRect(0,Math.random()*256,512,Math.random()*30+5); 
                } 
            } else if(type==='rock'){ 
                for(let i=0;i<400;i++){ 
                    ctx.fillStyle='rgba(0,0,0,0.2)'; ctx.beginPath(); 
                    ctx.arc(Math.random()*512,Math.random()*256,Math.random()*3+1,0,Math.PI*2); ctx.fill(); 
                } 
            } else if(type==='earth'){ 
                ctx.fillStyle='#1a3b8e'; ctx.fillRect(0,0,512,256); 
                ctx.fillStyle='#2d6e32'; 
                for(let i=0;i<30;i++){ 
                    ctx.beginPath(); ctx.ellipse(Math.random()*512,60+Math.random()*136,20+Math.random()*40,10+Math.random()*30,Math.random()*Math.PI,0,Math.PI*2); ctx.fill(); 
                } 
            } 
            return new THREE.CanvasTexture(canvas); 
        }

        // ê¶¤ë„ ë§ ì €ì¥
        let orbitLines = [];
        
        // â˜…â˜…â˜… íƒ€ì› ê¶¤ë„ ë¼ì¸ ìƒì„± (í–‰ì„± ì´ˆê¸° ìœ„ì¹˜ì™€ ë™ì¼í•œ ê³µì‹) â˜…â˜…â˜…
        function createOrbitLine(semiMajor, eccentricity = 0, inclination = 0, omega = 0, color = 0x444444, planetName = '') {
            const a = semiMajor;
            const e = eccentricity;
            const inc = inclination * Math.PI / 180;  // ê²½ì‚¬ê° (ë¼ë””ì•ˆ)
            const omegaRad = omega * Math.PI / 180;   // ê·¼ì¼ì  ê²½ë„ (ë¼ë””ì•ˆ)
            
            const points = [];
            const segments = 128;
            
            for (let i = 0; i <= segments; i++) {
                // ì§„ê·¼ì ì´ê° (True Anomaly) 0 ~ 2Ï€
                const nu = (i / segments) * 2 * Math.PI;
                
                // ê¶¤ë„ í‰ë©´ì—ì„œì˜ ê±°ë¦¬ (íƒ€ì› ë°©ì •ì‹)
                const r = a * (1 - e * e) / (1 + e * Math.cos(nu));
                
                // ê¶¤ë„ í‰ë©´ì—ì„œì˜ ìœ„ì¹˜ (ê·¼ì¼ì  ê²½ë„ ì ìš©)
                const xOrbit = r * Math.cos(nu + omegaRad);
                const yOrbit = r * Math.sin(nu + omegaRad);
                
                // ê¶¤ë„ ê²½ì‚¬ê° ì ìš©í•˜ì—¬ 3D ìœ„ì¹˜ ê³„ì‚°
                const x = xOrbit;
                const y = yOrbit * Math.sin(inc);  // ê²½ì‚¬ê°ì— ì˜í•œ Y ì„±ë¶„
                const z = yOrbit * Math.cos(inc);
                
                points.push(new THREE.Vector3(x, y, z));
            }
            
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ color: color, transparent: true, opacity: 0.5 });
            const ellipse = new THREE.Line(geometry, material);
            
            ellipse.userData.planetName = planetName;
            ellipse.userData.semiMajor = semiMajor / CONFIG.distScale;
            ellipse.userData.eccentricity = eccentricity;
            ellipse.userData.inclination = inclination;
            scene.add(ellipse);
            orbitLines.push(ellipse);
            return ellipse;
        }
        
        // ì´ì „ ë²„ì „ í˜¸í™˜ìš© (ì›í˜• ê¶¤ë„)
        function createCircularOrbitLine(radius, color = 0x444444, planetName = '') {
            return createOrbitLine(radius, 0, 0, 0, color, planetName);
        }
        
        // ëª¨ë“  ê¶¤ë„ ë¼ì¸ ì œê±°
        function clearOrbitLines() {
            orbitLines.forEach(line => {
                scene.remove(line);
                if (line.geometry) line.geometry.dispose();
                if (line.material) line.material.dispose();
            });
            orbitLines = [];
        }
        
        // ì‹¤ì œ íƒœì–‘ê³„ ê¶¤ë„ ë°ì´í„° (AU ê¸°ì¤€, ì§€êµ¬ = 1.0)
        // â˜…â˜…â˜… NASA JPL ê³µì‹ ë°ì´í„° (1800 AD - 2050 AD) â˜…â˜…â˜…
        // ì¶œì²˜: https://ssd.jpl.nasa.gov/planets/approx_pos.html
        const REAL_ORBIT_DATA = {
            "ìˆ˜ì„±": { 
                au: 0.38709927,     // ì¥ë°˜ê²½ (AU) - NASA JPL
                e: 0.20563593,      // ì´ì‹¬ë¥  - NASA JPL
                i: 7.00497902,      // ê¶¤ë„ ê²½ì‚¬ê° (ë„) - NASA JPL
                omega: 77.45779628, // ê·¼ì¼ì  ê²½ë„ (ë„) - NASA JPL
                node: 48.33076593,  // ìŠ¹êµì  ê²½ë„ (ë„) - NASA JPL
                L0: 252.25032350,   // í‰ê·  ê²½ë„ (ë„) - NASA JPL
                color: 0x888888, 
                period: 87.969      // ê³µì „ì£¼ê¸° (ì¼)
            },
            "ê¸ˆì„±": { 
                au: 0.72333566,     // NASA JPL
                e: 0.00677672,      // ê±°ì˜ ì›í˜•
                i: 3.39467605,      // NASA JPL
                omega: 131.60246718,
                node: 76.67984255,
                L0: 181.97909950,
                color: 0xddaa55, 
                period: 224.701 
            },
            "ì§€êµ¬": { 
                au: 1.00000261,     // NASA JPL
                e: 0.01671123,      // ì•½ê°„ íƒ€ì›
                i: 0.00001531,      // ê±°ì˜ 0 (ê¸°ì¤€ë©´)
                omega: 102.93768193,
                node: 0.0,
                L0: 100.46457166,
                color: 0x4488ff, 
                period: 365.256 
            },
            "í™”ì„±": { 
                au: 1.52371034,     // NASA JPL
                e: 0.09339410,      // ê½¤ íƒ€ì›í˜•
                i: 1.84969142,      // NASA JPL
                omega: -23.94362959 + 360, // 336.06 (ì–‘ìˆ˜ë¡œ ë³€í™˜)
                node: 49.55953891,
                L0: -4.55343205 + 360, // 355.45
                color: 0xff6644, 
                period: 686.980 
            },
            "ëª©ì„±": { 
                au: 5.20288700,     // NASA JPL
                e: 0.04838624,      // NASA JPL
                i: 1.30439695,      // NASA JPL
                omega: 14.72847983,
                node: 100.47390909,
                L0: 34.39644051,
                color: 0xddcc88, 
                period: 4332.59 
            },
            "í† ì„±": { 
                au: 9.53667594,     // NASA JPL
                e: 0.05386179,      // NASA JPL
                i: 2.48599187,      // NASA JPL
                omega: 92.59887831,
                node: 113.66242448,
                L0: 49.95424423,
                color: 0xeecc66, 
                period: 10759.22 
            },
            "ì²œì™•ì„±": { 
                au: 19.18916464,    // NASA JPL
                e: 0.04725744,      // NASA JPL
                i: 0.77263783,      // NASA JPL
                omega: 170.95427630,
                node: 74.01692503,
                L0: 313.23810451,
                color: 0x66dddd, 
                period: 30688.5 
            },
            "í•´ì™•ì„±": { 
                au: 30.06992276,    // NASA JPL
                e: 0.00859048,      // ê±°ì˜ ì›í˜•
                i: 1.77004347,      // NASA JPL
                omega: 44.96476227,
                node: 131.78422574,
                L0: -55.12002969 + 360, // 304.88
                color: 0x4466ff, 
                period: 60182.0 
            }
        };
        
        // â˜…â˜…â˜… ì¼€í”ŒëŸ¬ ê¶¤ë„ ì‹œê°„ ë³€ìˆ˜ (ëˆ„ì ) â˜…â˜…â˜…
        let keplerTime = Date.now() * 0.00001;  // ì›ë³¸ ìŠ¤ì¼€ì¼ ìœ ì§€

        // â˜…â˜…â˜… NASA JPL ê³µì‹ ê³µì‹ìœ¼ë¡œ ì¼€í”ŒëŸ¬ ê¶¤ë„ ê³„ì‚° â˜…â˜…â˜…
        // ì¶œì²˜: https://ssd.jpl.nasa.gov/planets/approx_pos.html
        function updateKeplerOrbits(dt) {
            const baseUnit = 2200;  // 10ë°° ì¦ê°€

            // â˜…â˜…â˜… ë©€í‹°ëª¨ë“œ: J2000 ê¸°ì¤€ ê³ ì • ê³„ì‚° (ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ ë™ì¼) â˜…â˜…â˜…
            // J2000.0 = 2000ë…„ 1ì›” 1ì¼ 12:00 TT (ì²œë¬¸í•™ í‘œì¤€ ê¸°ì¤€ì )
            const J2000_EPOCH = Date.UTC(2000, 0, 1, 12, 0, 0);  // ë°€ë¦¬ì´ˆ

            let elapsedDays;
            if (window.gameMode === 'multi') {
                // ì„œë²„ ë™ê¸°í™” ì‹œê°„ ì‚¬ìš© (fallback: ë¡œì»¬ ì‹œê°„)
                const syncedTime = typeof getSyncedTime === 'function' ? getSyncedTime() : Date.now();
                elapsedDays = (syncedTime - J2000_EPOCH) / (1000 * 60 * 60 * 24);
            } else {
                // ì‹±ê¸€ëª¨ë“œ: ê¸°ì¡´ ë°©ì‹ (ìƒëŒ€ì  ëˆ„ì , timeScale ì ìš©)
                keplerTime += dt * 0.0001 * CONFIG.timeScale;
            }

            bodies.forEach(body => {
                if (!body || !body.mesh || !body.name) return;

                const orbitData = REAL_ORBIT_DATA[body.name];
                if (!orbitData) return;  // íƒœì–‘ì´ë‚˜ ë‹¤ë¥¸ ì²œì²´ëŠ” ì œì™¸

                // NASA JPL ê¶¤ë„ ìš”ì†Œ
                const a = baseUnit * orbitData.au * CONFIG.distScale;  // ì¥ë°˜ê²½ (ìŠ¤ì¼€ì¼ ì ìš©)
                const e = orbitData.e;  // ì´ì‹¬ë¥ 
                const I = orbitData.i * Math.PI / 180;  // ê²½ì‚¬ê° (ë¼ë””ì•ˆ)
                const varpi = orbitData.omega * Math.PI / 180;  // ê·¼ì¼ì  ê²½ë„ (ë¼ë””ì•ˆ)
                const Omega = (orbitData.node || 0) * Math.PI / 180;  // ìŠ¹êµì  ê²½ë„ (ë¼ë””ì•ˆ)

                // ê·¼ì¼ì  í¸ê° (argument of perihelion)
                const omega_arg = varpi - Omega;

                // â˜…â˜…â˜… í‰ê·  ê·¼ì ì´ê° (Mean Anomaly) ê³„ì‚° â˜…â˜…â˜…
                let M;
                if (window.gameMode === 'multi' && orbitData.period && orbitData.L0 !== undefined) {
                    // ë©€í‹°ëª¨ë“œ: J2000 ê¸°ì¤€ ì •í™•í•œ ê³„ì‚°
                    // í˜„ì¬ í‰ê· ê²½ë„ = L0 + (360 / period) * elapsedDays
                    const meanLongitude = orbitData.L0 + (360 / orbitData.period) * elapsedDays;
                    // í‰ê· ê·¼ì ì´ê° = í‰ê· ê²½ë„ - ê·¼ì¼ì ê²½ë„
                    M = (meanLongitude - orbitData.omega) * Math.PI / 180;
                } else {
                    // ì‹±ê¸€ëª¨ë“œ: ê¸°ì¡´ ë°©ì‹
                    const periodFactor = 1 / Math.pow(orbitData.au, 1.5);
                    M = (keplerTime * periodFactor * 2) % (2 * Math.PI);
                }
                
                // Mì„ -Ï€ ~ +Ï€ ë²”ìœ„ë¡œ ì¡°ì •
                while (M > Math.PI) M -= 2 * Math.PI;
                while (M < -Math.PI) M += 2 * Math.PI;
                
                // ì´ì‹¬ ê·¼ì ì´ê° (Eccentric Anomaly) - NASA JPL ë‰´í„´-ë©ìŠ¨
                const eStar = e * 180 / Math.PI;  // e* = 57.29578 * e
                let E = M + e * Math.sin(M);  // ì´ˆê¸°ê°’
                
                for (let i = 0; i < 10; i++) {
                    const dM = M - (E - e * Math.sin(E));
                    const dE = dM / (1 - e * Math.cos(E));
                    E = E + dE;
                    if (Math.abs(dE) < 1e-8) break;
                }
                
                // ê¶¤ë„ í‰ë©´ì—ì„œì˜ ì¢Œí‘œ (x' = perihelion ë°©í–¥)
                const xPrime = a * (Math.cos(E) - e);
                const yPrime = a * Math.sqrt(1 - e * e) * Math.sin(E);
                
                // 3D í™©ë„ ì¢Œí‘œë¡œ ë³€í™˜ (NASA JPL ê³µì‹)
                const cosOmega = Math.cos(Omega);
                const sinOmega = Math.sin(Omega);
                const cosI = Math.cos(I);
                const sinI = Math.sin(I);
                const cosw = Math.cos(omega_arg);
                const sinw = Math.sin(omega_arg);
                
                const x_ecl = (cosw * cosOmega - sinw * sinOmega * cosI) * xPrime +
                              (-sinw * cosOmega - cosw * sinOmega * cosI) * yPrime;
                const y_ecl = (cosw * sinOmega + sinw * cosOmega * cosI) * xPrime +
                              (-sinw * sinOmega + cosw * cosOmega * cosI) * yPrime;
                const z_ecl = (sinw * sinI) * xPrime + (cosw * sinI) * yPrime;
                
                // Three.js ì¢Œí‘œê³„ë¡œ ë³€í™˜ (Y-up)
                // í™©ë„ ì¢Œí‘œ: x_ecl (ì¶˜ë¶„ì ), y_ecl (í™©ë„ë©´), z_ecl (í™©ë„ ë¶ê·¹)
                // Three.js: x (right), y (up), z (forward)
                body.mesh.position.set(x_ecl, z_ecl, -y_ecl);
                
                // ì†ë„ ë²¡í„° ì—…ë°ì´íŠ¸ (ë‹¤ë¥¸ ì‹œìŠ¤í…œìš©)
                if (body.velocity) {
                    const r = Math.sqrt(xPrime * xPrime + yPrime * yPrime);
                    const vAngle = Math.atan2(yPrime, xPrime) + Math.PI / 2;
                    const GM = CONFIG.G * 1e10;
                    const speed = Math.sqrt(Math.abs(GM * (2 / r - 1 / a))) * 0.001;
                    
                    const vxPrime = speed * Math.cos(vAngle);
                    const vyPrime = speed * Math.sin(vAngle);
                    
                    const vx_ecl = (cosw * cosOmega - sinw * sinOmega * cosI) * vxPrime +
                                   (-sinw * cosOmega - cosw * sinOmega * cosI) * vyPrime;
                    const vy_ecl = (cosw * sinOmega + sinw * cosOmega * cosI) * vxPrime +
                                   (-sinw * sinOmega + cosw * cosOmega * cosI) * vyPrime;
                    const vz_ecl = (sinw * sinI) * vxPrime + (cosw * sinI) * vyPrime;
                    
                    body.velocity.set(vx_ecl, vz_ecl, -vy_ecl);
                }
            });
        }
        
        // ê¶¤ë„ ë¼ì¸ ìƒì„± (ì‹¤ì œ íƒ€ì› ê¶¤ë„) - â˜… ì‹¤ì œ ê¶¤ë„ ë°ì´í„° ê¸°ë°˜ìœ¼ë¡œ ë¯¸ë¦¬ í‘œì‹œ
        function createAllOrbitLines() {
            clearOrbitLines();
            
            const baseUnit = 2200;  // ê¸°ë³¸ ë‹¨ìœ„ (ì§€êµ¬ ê¶¤ë„) - 10ë°° ì¦ê°€
            
            Object.entries(REAL_ORBIT_DATA).forEach(([name, data]) => {
                const semiMajor = baseUnit * data.au * CONFIG.distScale;  // ì¥ë°˜ê²½
                const eccentricity = data.e || 0;  // ì´ì‹¬ë¥ 
                const inclination = data.i || 0;   // ê²½ì‚¬ê°
                const omega = data.omega || 0;     // ê·¼ì¼ì  ê²½ë„
                
                createOrbitLine(semiMajor, eccentricity, inclination, omega, data.color, name);
            });
        }

        function initTrail(body) { 
            if (!body || !body.mesh) return;
            const points=[]; 
            for(let i=0;i<CONFIG.trailLength;i++) points.push(body.mesh.position.clone()); 
            const trailColor = (body.mesh.material && body.mesh.material.color) ? body.mesh.material.color : 0xffffff;
            const trail = new THREE.Line(
                new THREE.BufferGeometry().setFromPoints(points), 
                new THREE.LineBasicMaterial({color: trailColor, transparent:true, opacity:0.3})
            ); 
            trail.frustumCulled=false; scene.add(trail); 
            body.trail=trail; body.trailPoints=points; body.trailIndex=0; body.trailTimer=0;
        }

        // â˜…â˜…â˜… ì¡°ì¢…ì„ í”„ë¡œí•„ ë™ê¸°í™” í•¨ìˆ˜ â˜…â˜…â˜…
        function updateCockpitProfile() {
            const pilotName = document.getElementById('pilot-profile-name');
            const pilotCoins = document.getElementById('pilot-profile-coins');
            const pilotLevel = document.getElementById('pilot-profile-level');
            const pilotAvatar = document.getElementById('pilot-profile-avatar');

            if (window.mpUser) {
                // ë©€í‹°ëª¨ë“œ ë¡œê·¸ì¸ ì‚¬ìš©ì
                if (pilotName) pilotName.textContent = window.mpUser.nickname || window.mpUser.username || 'Pilot';
                if (pilotCoins) pilotCoins.textContent = (window.mpUser.coins || 0).toLocaleString();

                // ë ˆë²¨ ê³„ì‚° (ê²½í—˜ì¹˜ ê¸°ë°˜)
                const exp = window.mpUser.exp || 0;
                const level = Math.floor(Math.sqrt(exp / 100)) + 1;
                if (pilotLevel) pilotLevel.textContent = level;

                // ì•„ë°”íƒ€
                if (pilotAvatar) {
                    if (window.mpUser.avatar_url) {
                        pilotAvatar.innerHTML = `<img src="${window.mpUser.avatar_url}" alt="avatar">`;
                    } else {
                        pilotAvatar.innerHTML = 'ğŸ‘¤';
                    }
                }
            } else if (window.mpNickname) {
                // ê²ŒìŠ¤íŠ¸
                if (pilotName) pilotName.textContent = window.mpNickname;
                if (pilotCoins) pilotCoins.textContent = '0';
                if (pilotLevel) pilotLevel.textContent = '1';
                if (pilotAvatar) pilotAvatar.innerHTML = 'ğŸ‘¤';
            } else {
                // ì‹±ê¸€ëª¨ë“œ
                if (pilotName) pilotName.textContent = 'Pilot';
                if (pilotCoins) {
                    const coins = parseInt(localStorage.getItem('starwalker-coins') || '0');
                    pilotCoins.textContent = coins.toLocaleString();
                }
                if (pilotLevel) pilotLevel.textContent = window.userLevel || '1';
                if (pilotAvatar) pilotAvatar.innerHTML = 'ğŸ‘¤';
            }
        }
        window.updateCockpitProfile = updateCockpitProfile;  // ì „ì—­ ì ‘ê·¼ í—ˆìš©

        function showMsg(text) { 
            const el=document.getElementById('msg-box'); 
            el.innerText=text; 
            el.style.opacity=1; 
            setTimeout(()=>el.style.opacity=0, 3000); 
        }
        
        // â˜… ìš°ì£¼ì„  ìœ„ì¹˜ ë§ˆì»¤ í‘œì‹œ (í™”ë©´ UI)
        let shipMarkerInterval = null;
        let shipMarkerShipType = null;
        
        function showShipLocationMarker(position, shipName, shipType) {
            // ê¸°ì¡´ ë§ˆì»¤ ì¸í„°ë²Œ ì œê±°
            if (shipMarkerInterval) {
                clearInterval(shipMarkerInterval);
                shipMarkerInterval = null;
            }
            
            shipMarkerShipType = shipType;
            
            // HTML ë§ˆì»¤ ì„¤ì •
            const marker = document.getElementById('ship-location-marker');
            const markerBox = document.getElementById('ship-marker-box');
            const markerName = document.getElementById('ship-marker-name');
            
            // ì´ë¯¸ì§€ ì„¤ì •
            if (shipType && shipType.image && shipType.image.length > 0) {
                markerBox.innerHTML = `<img src="${shipType.image}" style="width:100%; height:100%; object-fit:contain;">`;
            } else {
                markerBox.innerHTML = `<span style="font-size:30px;">ğŸš€</span>`;
            }
            markerName.textContent = shipName;
            
            marker.style.display = 'block';
            
            // í™”ë©´ ìœ„ì¹˜ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
            let blinkCount = 0;
            shipMarkerInterval = setInterval(() => {
                // 3D ìœ„ì¹˜ë¥¼ í™”ë©´ ì¢Œí‘œë¡œ ë³€í™˜
                const vector = position.clone();
                vector.project(camera);
                
                const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-(vector.y * 0.5) + 0.5) * window.innerHeight;
                
                // í™”ë©´ ì•ˆì— ìˆì„ ë•Œë§Œ í‘œì‹œ
                if (vector.z < 1 && x > 0 && x < window.innerWidth && y > 0 && y < window.innerHeight) {
                    marker.style.left = (x - 30) + 'px';
                    marker.style.top = (y - 90) + 'px';
                    marker.style.opacity = '1';
                } else {
                    marker.style.opacity = '0.3';
                    // í™”ë©´ ê°€ì¥ìë¦¬ì— í‘œì‹œ
                    const clampedX = Math.max(40, Math.min(window.innerWidth - 100, x));
                    const clampedY = Math.max(100, Math.min(window.innerHeight - 50, y));
                    marker.style.left = (clampedX - 30) + 'px';
                    marker.style.top = (clampedY - 90) + 'px';
                }
                
                blinkCount++;
                if (blinkCount > 40) {  // 20ì´ˆ í›„ ì¤‘ì§€
                    clearInterval(shipMarkerInterval);
                    shipMarkerInterval = null;
                    marker.style.display = 'none';
                }
            }, 500);
        }
        
        // ë§ˆì»¤ ìˆ¨ê¸°ê¸°
        function hideShipLocationMarker() {
            const marker = document.getElementById('ship-location-marker');
            marker.style.display = 'none';
            if (shipMarkerInterval) {
                clearInterval(shipMarkerInterval);
                shipMarkerInterval = null;
            }
        }
        
        // â˜… ë§ˆì»¤ í´ë¦­ ì‹œ ì£¼ì°¨ëœ ìš°ì£¼ì„ ìœ¼ë¡œ ì¹´ë©”ë¼ ì´ë™
        window.focusOnParkedShip = function() {
            if (parkedShipMesh && parkedShipMesh.position) {
                const pos = parkedShipMesh.position.clone();
                const offset = new THREE.Vector3(2, 1, 2);
                camera.position.copy(pos).add(offset);
                controls.target.copy(pos);
                controls.update();
                
                // ì£¼ì°¨ëœ ìš°ì£¼ì„  body ì°¾ì•„ì„œ í¬ì»¤ìŠ¤
                const parkedBody = bodies.find(b => b.isParkedShip);
                if (parkedBody) {
                    focusBody(parkedBody);
                }
            }
        };
        
        // â˜…â˜…â˜… ê²Œì„ ì‹œì‘ ì‹œ ìš´í•­ì¤‘ ìš°ì£¼ì„  ì²´í¬ â˜…â˜…â˜…
        function checkActiveShipOnStart() {
            const savedShipData = ShipPositionManager.load();
            if (savedShipData && savedShipData.position) {
                const distFromISS = Math.sqrt(
                    savedShipData.position.x ** 2 + 
                    savedShipData.position.y ** 2 + 
                    savedShipData.position.z ** 2
                );
                
                // ISS ê·¼ì²˜ê°€ ì•„ë‹ˆë©´ (ê±°ë¦¬ 100 ì´ìƒ) ìš´í•­ì¤‘ìœ¼ë¡œ ê°„ì£¼
                if (distFromISS > 100) {
                    const shipName = savedShipData.shipName || 'Ship';
                    showActiveShipPopup(savedShipData, shipName, distFromISS);
                }
            }
        }
        
        // ê²Œì„ ë¡œë“œ ì™„ë£Œ í›„ ì²´í¬ (3ì´ˆ í›„)
        setTimeout(() => {
            if (!isPilotMode) {
                checkActiveShipOnStart();
            }
        }, 3000);
        
        // â˜…â˜…â˜… ìš´í•­ì¤‘ ìš°ì£¼ì„  íŒì—… í‘œì‹œ ë° ì²˜ë¦¬ â˜…â˜…â˜…
        let savedActiveShipData = null;
        
        function showActiveShipPopup(shipData, shipName, distance) {
            savedActiveShipData = shipData;
            
            const popup = document.getElementById('active-ship-popup');
            
            // â˜… ìš°ì£¼ì„  íƒ€ì… ì°¾ì•„ì„œ ì´ë¯¸ì§€ í‘œì‹œ
            const savedShipTypeId = shipData.shipType || 'shuttle';
            const shipType = SHIP_TYPES.find(s => s.id === savedShipTypeId) || SHIP_TYPES[0];
            const iconBox = document.getElementById('active-ship-icon');
            
            if (shipType.image && shipType.image.length > 0) {
                iconBox.innerHTML = `<img src="${shipType.image}" style="width:100%; height:100%; object-fit:contain;">`;
            } else {
                iconBox.innerHTML = `<span style="font-size:40px;">ğŸš€</span>`;
            }
            
            // â˜… ë‹¤êµ­ì–´ í…ìŠ¤íŠ¸ ì„¤ì •
            const isKorean = (window.currentLang || 'ko') === 'ko';
            
            document.getElementById('active-ship-title').textContent = isKorean ? 'ìš´í•­ì¤‘ì¸ ìš°ì£¼ì„  ë°œê²¬!' : 'Active Ship Found!';
            document.getElementById('active-ship-name').textContent = isKorean ? shipType.name : shipType.nameEn;
            document.getElementById('active-ship-fuel-label').textContent = isKorean ? 'â›½ ì—°ë£Œ:' : 'â›½ Fuel:';
            document.getElementById('active-ship-fuel').textContent = Math.round(shipData.fuel || 0) + '%';
            document.getElementById('active-ship-dist-label').textContent = isKorean ? 'ğŸ“ ISSë¡œë¶€í„°:' : 'ğŸ“ From ISS:';
            document.getElementById('active-ship-dist').textContent = Math.round(distance).toLocaleString() + 'km';
            document.getElementById('active-ship-go-btn').innerHTML = isKorean ? 'ğŸ“ ìš°ì£¼ì„ ìœ¼ë¡œ ì´ë™' : 'ğŸ“ Go to Ship';
            document.getElementById('active-ship-new-btn').innerHTML = isKorean ? 'ğŸ—‘ï¸ ìƒˆë¡œ íƒ‘ìŠ¹' : 'ğŸ—‘ï¸ New Ship';
            
            popup.style.display = 'flex';
            
            // ì´ë²¤íŠ¸ ë°”ì¸ë”©
            document.getElementById('active-ship-go-btn').onclick = () => goToActiveShip();
            document.getElementById('active-ship-new-btn').onclick = () => discardAndNewShip();
            document.getElementById('active-ship-close-btn').onclick = () => popup.style.display = 'none';
        }
        
        function goToActiveShip() {
            if (!savedActiveShipData) return;

            const popup = document.getElementById('active-ship-popup');
            popup.style.display = 'none';

            // â˜…â˜…â˜… ê¸°ì¡´ ì£¼ì°¨ ìš°ì£¼ì„ ì´ ìˆìœ¼ë©´ ë¨¼ì € ì œê±° â˜…â˜…â˜…
            if (parkedShipMesh) {
                scene.remove(parkedShipMesh);
                const parkedBodyIdx = bodies.findIndex(b => b.isParkedShip);
                if (parkedBodyIdx >= 0) bodies.splice(parkedBodyIdx, 1);
                parkedShipMesh = null;
                parkedShip = null;
            }

            // â˜…â˜…â˜… ë¡œì»¬ ë³€ìˆ˜ë¡œ ë³µì‚¬ (ë¹„ë™ê¸° ì½œë°±ì—ì„œ ì‚¬ìš©) â˜…â˜…â˜…
            const shipData = { ...savedActiveShipData };
            const savedFuel = shipData.fuel || 100;
            const isKorean = (window.currentLang || 'ko') === 'ko';
            
            const pos = new THREE.Vector3(
                shipData.position.x,
                shipData.position.y,
                shipData.position.z
            );
            const rot = shipData.rotation || { x: 0, y: 0, z: 0 };
            
            // â˜… ì €ì¥ëœ ìš°ì£¼ì„  íƒ€ì… ì°¾ê¸°
            const savedShipTypeId = shipData.shipType || 'shuttle';
            const shipIdx = SHIP_TYPES.findIndex(s => s.id === savedShipTypeId);
            let shipType = SHIP_TYPES[0];  // ê¸°ë³¸ê°’
            
            if (shipIdx >= 0) {
                selectedShipIndex = shipIdx;
                currentShipType = SHIP_TYPES[shipIdx];
                window.currentShipType = currentShipType;
                shipType = currentShipType;
            }
            
            // â˜… ë‹¤êµ­ì–´ ìš°ì£¼ì„  ì´ë¦„
            const shipName = isKorean ? shipType.name : shipType.nameEn;
            const moveMsg = isKorean 
                ? `ğŸ“ ${shipName} ìœ„ì¹˜ë¡œ ì´ë™! ìš°ì£¼ì„ ì„ í´ë¦­í•´ì„œ íƒ‘ìŠ¹í•˜ì„¸ìš”.`
                : `ğŸ“ Moved to ${shipName}! Click the ship to board.`;
            
            // ë¨¼ì € savedActiveShipData í´ë¦¬ì–´
            savedActiveShipData = null;
            
            // â˜…â˜…â˜… ì €ì¥ëœ ìœ„ì¹˜ì— ì£¼ì°¨ëœ ìš°ì£¼ì„ ìœ¼ë¡œ ìƒì„± â˜…â˜…â˜…
            const parkedShipGroup = new THREE.Group();
            parkedShipGroup.position.copy(pos);
            parkedShipGroup.rotation.set(rot.x, rot.y, rot.z);
            
            // GLB ëª¨ë¸ ë¡œë“œ
            if (shipType.model && shipType.model.length > 0) {
                const gltfLoader = new GLTFLoader();
                
                // DRACO ì••ì¶• ëª¨ë¸ìš© (ì„ íƒì )
                try {
                    const dracoLoader = new DRACOLoader();
                    dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
                    gltfLoader.setDRACOLoader(dracoLoader);
                } catch(e) {
                    console.log('DRACO ë¡œë” ì—†ì´ ì§„í–‰');
                }
                
                // â˜… URLì„ Supabase Storageë¡œ ë³€í™˜
                const modelUrl = convertToSupabaseUrl(shipType.model);
                console.log('ğŸš€ GLB ë¡œë“œ ì‹œë„:', modelUrl);
                
                gltfLoader.load(modelUrl, (gltf) => {
                    console.log('âœ… GLB ë¡œë“œ ì„±ê³µ:', modelUrl);
                    const model = gltf.scene;
                    model.scale.setScalar(0.5);
                    model.rotation.y = Math.PI;
                    parkedShipGroup.add(model);
                    scene.add(parkedShipGroup);
                    
                    // ì£¼ì°¨ëœ ìš°ì£¼ì„  ë°ì´í„° ì €ì¥
                    parkedShip = {
                        type: shipType.id,
                        position: pos.clone(),
                        quaternion: parkedShipGroup.quaternion.clone(),
                        rotation: parkedShipGroup.rotation.clone(),
                        fuel: savedFuel,
                        speed: 0,
                        hull: shipType.maxHull || 100
                    };
                    parkedShipMesh = parkedShipGroup;
                    parkedShipMesh.userData.isParkedShip = true;
                    parkedShipMesh.userData.shipTypeIndex = shipIdx >= 0 ? shipIdx : 0;
                    parkedShipMesh.userData.fuel = savedFuel;
                    parkedShipMesh.userData.speed = 0;
                    
                    // í´ë¦­ ê°€ëŠ¥í•˜ê²Œ bodies ë°°ì—´ì— ì¶”ê°€
                    const parkedLabel = isKorean ? '(ì£¼ì°¨ë¨)' : '(Parked)';
                    const parkedBody = {
                        name: `${shipName} ${parkedLabel}`,
                        mesh: parkedShipGroup,
                        type: 'ship',
                        isParkedShip: true,
                        radius: 0.1
                    };
                    bodies.push(parkedBody);
                    
                    // ì¹´ë©”ë¼ ì´ë™
                    const offset = new THREE.Vector3(3, 2, 3);
                    camera.position.copy(pos).add(offset);
                    controls.target.copy(pos);
                    controls.update();
                    
                    showMsg(moveMsg);
                    
                    // ë§ˆì»¤ í‘œì‹œ (shipType ì „ë‹¬)
                    showShipLocationMarker(pos, shipName, shipType);
                    
                }, undefined, (err) => {
                    console.error('âŒ GLB ë¡œë“œ ì‹¤íŒ¨:', shipType.model, err);
                    // ëª¨ë¸ ì—†ì´ ê¸°ë³¸ í˜•íƒœë¡œ
                    createFallbackShip(parkedShipGroup, pos, shipName, shipType, shipIdx, savedFuel);
                });
            } else {
                console.log('âš ï¸ ëª¨ë¸ ê²½ë¡œ ì—†ìŒ, ê¸°ë³¸ ë°•ìŠ¤ ì‚¬ìš©');
                // ëª¨ë¸ ì—†ìœ¼ë©´ ê¸°ë³¸ ë°•ìŠ¤
                createFallbackShip(parkedShipGroup, pos, shipName, shipType, shipIdx, savedFuel);
            }
        }
        
        // â˜… ê¸°ë³¸ ìš°ì£¼ì„  í˜•íƒœ ìƒì„± (ëª¨ë¸ ì—†ì„ ë•Œ)
        function createFallbackShip(parkedShipGroup, pos, shipName, shipType, shipIdx, savedFuel) {
            const isKorean = (window.currentLang || 'ko') === 'ko';
            const boxGeom = new THREE.BoxGeometry(0.5, 0.2, 0.8);
            const boxMat = new THREE.MeshStandardMaterial({ color: shipType.color || 0x888888 });
            const box = new THREE.Mesh(boxGeom, boxMat);
            parkedShipGroup.add(box);
            scene.add(parkedShipGroup);
            
            // ì£¼ì°¨ëœ ìš°ì£¼ì„  ë°ì´í„° ì €ì¥
            parkedShip = {
                type: shipType.id,
                position: pos.clone(),
                quaternion: parkedShipGroup.quaternion.clone(),
                rotation: parkedShipGroup.rotation.clone(),
                fuel: savedFuel,
                speed: 0,
                hull: shipType.maxHull || 100
            };
            parkedShipMesh = parkedShipGroup;
            parkedShipMesh.userData.isParkedShip = true;
            parkedShipMesh.userData.shipTypeIndex = shipIdx >= 0 ? shipIdx : 0;
            parkedShipMesh.userData.fuel = savedFuel;
            parkedShipMesh.userData.speed = 0;
            
            // í´ë¦­ ê°€ëŠ¥í•˜ê²Œ bodies ë°°ì—´ì— ì¶”ê°€
            const parkedLabel = isKorean ? '(ì£¼ì°¨ë¨)' : '(Parked)';
            const parkedBody = {
                name: `${shipName} ${parkedLabel}`,
                mesh: parkedShipGroup,
                type: 'ship',
                isParkedShip: true,
                radius: 0.1
            };
            bodies.push(parkedBody);
            
            const offset = new THREE.Vector3(3, 2, 3);
            camera.position.copy(pos).add(offset);
            controls.target.copy(pos);
            controls.update();
            
            const moveMsg = isKorean 
                ? `ğŸ“ ${shipName} ìœ„ì¹˜ë¡œ ì´ë™! ìš°ì£¼ì„ ì„ í´ë¦­í•´ì„œ íƒ‘ìŠ¹í•˜ì„¸ìš”.`
                : `ğŸ“ Moved to ${shipName}! Click the ship to board.`;
            showMsg(moveMsg);
            showShipLocationMarker(pos, shipName, shipType);
        }
        
        function discardAndNewShip() {
            const popup = document.getElementById('active-ship-popup');
            popup.style.display = 'none';
            
            ShipPositionManager.clear();
            showMsg('ğŸ—‘ï¸ ê¸°ì¡´ ìš°ì£¼ì„ ì´ íê¸°ë˜ì—ˆìŠµë‹ˆë‹¤.');
            savedActiveShipData = null;
            
            // ìƒˆ ìš°ì£¼ì„  ì„ íƒ ëª¨ë‹¬ ì—´ê¸°
            setTimeout(() => openShipSelectModal(), 100);
        }

        function updateNavList() {
            const list = document.getElementById('nav-list'); 
            if(!list) return;
            list.innerHTML = '';
            bodies.forEach(body => {
                if (!body || !body.mesh) return;
                const item = document.createElement('div'); item.className = 'nav-item';
                if(focusedBody === body) item.classList.add('active');
                const typeIcon = body.type==='star' ? 'ğŸŒŸ' : (body.type === 'blackhole' ? 'ğŸ•³ï¸' : 'ğŸª');
                const displayName = translateBodyName(body.name);
                item.innerHTML = `<span>${displayName}</span><span class="type-icon">${typeIcon}</span>`;
                item.onclick = (e) => { e.stopPropagation(); focusBody(body); updateNavList(); };
                list.appendChild(item);
                
                const bodySatellites = satellites.filter(s => s && s.parentBody === body);
                bodySatellites.forEach(sat => {
                     if (!sat || !sat.mesh) return;
                     const satItem = document.createElement('div'); satItem.className = 'nav-item satellite';
                     if(focusedBody === sat) satItem.classList.add('active');
                     const sIcon = sat.type === 'station' ? 'ğŸ›°ï¸' : 'ğŸŒ‘';
                     
                     // ë©€í‹°ëª¨ë“œ: ë°©ë¬¸ ì—¬ë¶€ í‘œì‹œ
                     const visited = typeof visitedSatellites !== 'undefined' && visitedSatellites.has(sat.name);
                     const visitedMark = (typeof gameMode !== 'undefined' && gameMode === 'multi' && visited) ? ' âœ“' : '';
                     
                     const satDisplayName = translateBodyName(sat.name);
                     satItem.innerHTML = `<span>${satDisplayName}${visitedMark}</span><span class="type-icon">${sIcon}</span>`;
                     satItem.onclick = (e) => { 
                         e.stopPropagation(); 
                         // ë©€í‹°ëª¨ë“œ: ë°©ë¬¸í•œ ê³³ë§Œ ì´ë™ ê°€ëŠ¥
                         if (typeof gameMode !== 'undefined' && gameMode === 'multi') {
                             if (typeof visitedSatellites !== 'undefined' && !visitedSatellites.has(sat.name)) {
                                 showMessage(t('notVisitedYet') || 'âš ï¸ Not visited yet. Fly there directly!');
                                 return;
                             }
                         }
                         focusBody(sat); 
                         updateNavList(); 
                     };
                     list.appendChild(satItem);
                });
            });
        }

        function focusBody(body) {
            if (!body || !body.mesh) return;
            focusedBody = body;
            
            // í–‰ì„± ì„ íƒ íš¨ê³¼ìŒ
            if (typeof SpaceAudio !== 'undefined') SpaceAudio.playSelect();
            
            // ISS ì„ íƒ ì‹œ ì •ê±°ì¥ ì‚¬ìš´ë“œ, ì•„ë‹ˆë©´ ìš°ì£¼ ì‚¬ìš´ë“œ
            if (typeof SpaceAudio !== 'undefined' && SpaceAudio.isPlaying && !isPilotMode) {
                if (body.type === 'station' && body.name.includes('ISS')) {
                    SpaceAudio.playStation();
                } else {
                    SpaceAudio.playSpace();
                }
            }
            
            const resetBtn = document.getElementById('reset-cam');
            if(resetBtn) resetBtn.style.display = 'block';
            const boardBtn = document.getElementById('board-ship-btn');
            
            // íƒ‘ìŠ¹ ë²„íŠ¼ í‘œì‹œ ë¡œì§
            if (!isPilotMode && boardBtn) {
                if (body.type === 'station' && body.name.includes('ISS')) {
                    // ISS ìš°ì£¼ì •ê±°ì¥ ì„ íƒ ì‹œ íƒ‘ìŠ¹ ë²„íŠ¼ í‘œì‹œ
                    boardBtn.style.display = 'block';
                    boardBtn.textContent = `ğŸš€ ${t('boardShip')}`;
                } else if (body.isParkedShip) {
                    // ì£¼ì°¨ëœ ìš°ì£¼ì„  ì„ íƒ ì‹œ ì¬íƒ‘ìŠ¹ ë²„íŠ¼ í‘œì‹œ
                    boardBtn.style.display = 'block';
                    boardBtn.textContent = `ğŸš€ ${t('reboard')}`;
                } else {
                    boardBtn.style.display = 'none';
                }
            }
            
            showMsg(`${translateBodyName(body.name)} ${t('trackingMode')}`);
            
            // â˜…â˜…â˜… ì‹±ê¸€ëª¨ë“œì—ì„œ ì²œì²´ ì •ë³´ íŒì—… í‘œì‹œ â˜…â˜…â˜…
            if (window.gameMode !== 'multi' && !isPilotMode) {
                showBodyInfoPopup(body);
            }
            
            // â˜…â˜…â˜… ì‹œê°ì  ìŠ¤ì¼€ì¼ ë°˜ì˜í•œ ì¹´ë©”ë¼ ê±°ë¦¬ â˜…â˜…â˜…
            const visualScale = body.visualScale || 1.0;
            
            // â˜… ëŒ€ìƒì— ë”°ë¼ minDistance ë™ì  ì„¤ì • (í‘œë©´ ë°”ë¡œ ìœ„ê¹Œì§€ ì¤Œì¸ ê°€ëŠ¥)
            if (body.type === 'station' || body.isParkedShip || body.type === 'ship') {
                controls.minDistance = 0.05;  // â˜… ìš°ì£¼ì„ /ì •ê±°ì¥ ì•„ì£¼ ê°€ê¹Œì´ ì¤Œì¸ ê°€ëŠ¥
            } else if (body.type === 'moon') {
                controls.minDistance = body.radius * visualScale * 1.05;  // ë‹¬ í‘œë©´ ë°”ë¡œ ìœ„
            } else {
                controls.minDistance = body.radius * visualScale * 1.02;  // í–‰ì„±/í•­ì„± í‘œë©´ ë°”ë¡œ ìœ„
            }
            
            if (body.type === 'station' || body.type === 'moon' || body.isParkedShip) {
               const offset = body.type==='station' ? 0.75 : (body.isParkedShip ? 3 : body.orbitRadius * 0.8);
               const offsetVec = new THREE.Vector3(offset, offset*0.5, offset);
               camera.position.copy(body.mesh.position).add(offsetVec);
               controls.target.copy(body.mesh.position);
            } else {
               // í–‰ì„±/í•­ì„±ì€ ì‹œê°ì  ìŠ¤ì¼€ì¼ ë°˜ì˜
               const baseOffset = body.radius * visualScale * 3;
               const offsetVec = new THREE.Vector3(baseOffset, baseOffset * 0.5, baseOffset);
               camera.position.copy(body.mesh.position).add(offsetVec);
               controls.target.copy(body.mesh.position);
            }
        }

        // â˜…â˜…â˜… ì²œì²´ ì •ë³´ íŒì—… ì‹œìŠ¤í…œ â˜…â˜…â˜…
        let currentPopupBody = null;
        let popupUpdateInterval = null;
        
        // ì²œì²´ ì •ë³´ íŒì—… í‘œì‹œ
        function showBodyInfoPopup(body) {
            const popup = document.getElementById('body-info-popup');
            if (!popup || !body) return;
            
            currentPopupBody = body;
            
            // ì²œì²´ ì•„ì´ì½˜ ê²°ì •
            const icon = getBodyIcon(body);
            const typeText = getBodyTypeText(body);
            
            // íŒì—… ë‚´ìš© ì—…ë°ì´íŠ¸
            popup.querySelector('.popup-icon').textContent = icon;
            popup.querySelector('.popup-name').textContent = body.name;
            popup.querySelector('.popup-type').textContent = typeText;
            
            // ë°˜ì§€ë¦„ í¬ë§·íŒ…
            const radiusKm = (body.radius * 6371).toLocaleString(); // ì§€êµ¬ ë°˜ì§€ë¦„ ê¸°ì¤€
            document.getElementById('popup-radius').textContent = radiusKm + ' km';
            
            // ì§ˆëŸ‰ í¬ë§·íŒ…
            const massText = formatMass(body.mass);
            document.getElementById('popup-mass').textContent = massText;
            
            // ê±°ë¦¬ëŠ” ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
            updatePopupDistance();
            
            // í™”ë©´ ì¤‘ì•™ ìš°ì¸¡ì— í‘œì‹œ
            popup.style.display = 'block';
            popup.style.top = '50%';
            popup.style.right = '20px';
            popup.style.left = 'auto';
            popup.style.transform = 'translateY(-50%)';
            
            // ì‹¤ì‹œê°„ ê±°ë¦¬ ì—…ë°ì´íŠ¸ ì‹œì‘
            if (popupUpdateInterval) clearInterval(popupUpdateInterval);
            popupUpdateInterval = setInterval(updatePopupDistance, 500);
            
            // 5ì´ˆ í›„ ìë™ ìˆ¨ê¹€ (ì¡°ì‘ì´ ì—†ìœ¼ë©´)
            clearTimeout(popup.autoHideTimeout);
            popup.autoHideTimeout = setTimeout(() => {
                if (popup.style.display === 'block' && !popup.matches(':hover')) {
                    hideBodyInfoPopup();
                }
            }, 8000);
        }
        
        // íŒì—… ê±°ë¦¬ ì—…ë°ì´íŠ¸
        function updatePopupDistance() {
            if (!currentPopupBody || !currentPopupBody.mesh) return;
            
            const sun = bodies.find(b => b.name === 'íƒœì–‘' || b.name === 'Sun');
            let distKm = 0;
            
            if (sun && sun.mesh) {
                const dist = currentPopupBody.mesh.position.distanceTo(sun.mesh.position);
                distKm = dist * 149597.87; // AU to km ë³€í™˜ (ë‹¨ìˆœí™”)
            }
            
            const distEl = document.getElementById('popup-distance');
            if (distEl) {
                if (distKm >= 1e9) {
                    distEl.textContent = (distKm / 1e9).toFixed(2) + ' B km';
                } else if (distKm >= 1e6) {
                    distEl.textContent = (distKm / 1e6).toFixed(2) + ' M km';
                } else if (distKm >= 1000) {
                    distEl.textContent = (distKm / 1000).toFixed(1) + 'K km';
                } else {
                    distEl.textContent = Math.round(distKm) + ' km';
                }
            }
        }
        
        // ì²œì²´ ì •ë³´ íŒì—… ìˆ¨ê¸°ê¸°
        function hideBodyInfoPopup() {
            const popup = document.getElementById('body-info-popup');
            if (popup) {
                popup.style.display = 'none';
            }
            if (popupUpdateInterval) {
                clearInterval(popupUpdateInterval);
                popupUpdateInterval = null;
            }
            currentPopupBody = null;
        }
        
        // ì²œì²´ ì•„ì´ì½˜ ê²°ì •
        function getBodyIcon(body) {
            if (!body) return 'ğŸŒ';
            
            const name = body.name.toLowerCase();
            const type = body.type;
            
            if (type === 'star') return 'â˜€ï¸';
            if (type === 'blackhole') return 'ğŸ•³ï¸';
            if (type === 'station') return 'ğŸ›°ï¸';
            if (body.isParkedShip) return 'ğŸš€';
            
            // í–‰ì„±ë³„ ì•„ì´ì½˜
            if (name.includes('ìˆ˜ì„±') || name.includes('mercury')) return 'â˜¿ï¸';
            if (name.includes('ê¸ˆì„±') || name.includes('venus')) return 'â™€ï¸';
            if (name.includes('ì§€êµ¬') || name.includes('earth')) return 'ğŸŒ';
            if (name.includes('í™”ì„±') || name.includes('mars')) return 'ğŸ”´';
            if (name.includes('ëª©ì„±') || name.includes('jupiter')) return 'ğŸª';
            if (name.includes('í† ì„±') || name.includes('saturn')) return 'ğŸ’«';
            if (name.includes('ì²œì™•ì„±') || name.includes('uranus')) return 'ğŸ”µ';
            if (name.includes('í•´ì™•ì„±') || name.includes('neptune')) return 'ğŸ”·';
            if (name.includes('ë‹¬') || name.includes('moon')) return 'ğŸŒ™';
            if (type === 'moon') return 'ğŸŒ‘';
            if (type === 'gas') return 'ğŸª';
            
            return 'ğŸŒ';
        }
        
        // ì²œì²´ íƒ€ì… í…ìŠ¤íŠ¸
        function getBodyTypeText(body) {
            if (!body) return '';
            
            const lang = (typeof currentLang !== 'undefined') ? currentLang : 'en';
            const type = body.type;
            
            const types = {
                ko: { star: 'í•­ì„±', planet: 'í–‰ì„±', moon: 'ìœ„ì„±', gas: 'ê°€ìŠ¤ í–‰ì„±', blackhole: 'ë¸”ë™í™€', station: 'ìš°ì£¼ì •ê±°ì¥' },
                en: { star: 'Star', planet: 'Planet', moon: 'Moon', gas: 'Gas Giant', blackhole: 'Black Hole', station: 'Station' },
                ja: { star: 'æ’æ˜Ÿ', planet: 'æƒ‘æ˜Ÿ', moon: 'è¡›æ˜Ÿ', gas: 'ã‚¬ã‚¹æƒ‘æ˜Ÿ', blackhole: 'ãƒ–ãƒ©ãƒƒã‚¯ãƒ›ãƒ¼ãƒ«', station: 'å®‡å®™ã‚¹ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³' }
            };
            
            const langTypes = types[lang] || types.en;
            
            if (body.isParkedShip) return lang === 'ko' ? 'ìš°ì£¼ì„ ' : lang === 'ja' ? 'å®‡å®™èˆ¹' : 'Spacecraft';
            
            return langTypes[type] || langTypes.planet;
        }
        
        // ì§ˆëŸ‰ í¬ë§·íŒ…
        function formatMass(mass) {
            if (!mass) return '-';
            
            // ê²Œì„ ë‚´ ì§ˆëŸ‰ì„ ì‹¤ì œ kgìœ¼ë¡œ ë³€í™˜ (ëŒ€ëµì )
            const realMass = mass * 5.97e24; // ì§€êµ¬ ì§ˆëŸ‰ ê¸°ì¤€
            
            if (realMass >= 1e30) {
                return (realMass / 1.989e30).toFixed(2) + ' Mâ˜‰';
            } else if (realMass >= 1e27) {
                return (realMass / 1e27).toFixed(2) + 'Ã—10Â²â· kg';
            } else if (realMass >= 1e24) {
                return (realMass / 1e24).toFixed(2) + 'Ã—10Â²â´ kg';
            } else if (realMass >= 1e21) {
                return (realMass / 1e21).toFixed(2) + 'Ã—10Â²Â¹ kg';
            } else {
                return realMass.toExponential(2) + ' kg';
            }
        }
        
        // â˜…â˜…â˜… ì²œì²´ ìƒì„¸ë³´ê¸° ëª¨ë‹¬ â˜…â˜…â˜…
        function showBodyDetailModal(body) {
            if (!body) body = currentPopupBody;
            if (!body) return;
            
            const modal = document.getElementById('body-detail-modal');
            if (!modal) return;
            
            // ì•„ì´ì½˜ ë° ê¸°ë³¸ ì •ë³´
            modal.querySelector('.detail-icon').textContent = getBodyIcon(body);
            modal.querySelector('.detail-name').textContent = body.name;
            modal.querySelector('.detail-type').textContent = getBodyTypeText(body);
            
            // ê¸°ë³¸ ì •ë³´
            const radiusKm = (body.radius * 6371).toLocaleString();
            document.getElementById('detail-radius').textContent = radiusKm + ' km';
            document.getElementById('detail-mass').textContent = formatMass(body.mass);
            
            // ìì „ ì†ë„
            const rotSpeed = body.rotSpeed || 0;
            let rotText = '-';
            if (rotSpeed !== 0) {
                const dayLength = Math.abs(24 / rotSpeed);
                if (dayLength < 1) {
                    rotText = (dayLength * 60).toFixed(1) + ' min';
                } else if (dayLength > 1000) {
                    rotText = (dayLength / 24).toFixed(0) + ' days';
                } else {
                    rotText = dayLength.toFixed(1) + ' hours';
                }
                if (rotSpeed < 0) rotText += ' (ì—­í–‰)';
            }
            document.getElementById('detail-rotation').textContent = rotText;
            
            // í‘œë©´ ì¤‘ë ¥ (ëŒ€ëµ ê³„ì‚°)
            const surfaceGravity = (body.mass / (body.radius * body.radius)) * 9.8;
            document.getElementById('detail-gravity').textContent = surfaceGravity.toFixed(2) + ' m/sÂ²';
            
            // ê¶¤ë„ ì •ë³´
            const sun = bodies.find(b => b.name === 'íƒœì–‘' || b.name === 'Sun');
            if (sun && sun.mesh && body.mesh) {
                const dist = body.mesh.position.distanceTo(sun.mesh.position);
                const distKm = dist * 149597.87;
                
                if (distKm >= 1e9) {
                    document.getElementById('detail-distance').textContent = (distKm / 1e9).toFixed(2) + ' B km';
                } else if (distKm >= 1e6) {
                    document.getElementById('detail-distance').textContent = (distKm / 1e6).toFixed(2) + ' M km';
                } else {
                    document.getElementById('detail-distance').textContent = Math.round(distKm).toLocaleString() + ' km';
                }
            } else {
                document.getElementById('detail-distance').textContent = '-';
            }
            
            // ê³µì „ ì†ë„
            const orbitalSpeed = body.velocity ? body.velocity.length() * 29.78 : 0; // km/s ë³€í™˜
            document.getElementById('detail-orbital-speed').textContent = orbitalSpeed.toFixed(2) + ' km/s';
            
            // ìœ„ì„± ìˆ˜ ê³„ì‚°
            const moonCount = bodies.filter(b => 
                b.type === 'moon' && b.parentBody && b.parentBody.name === body.name
            ).length;
            document.getElementById('detail-moons').textContent = moonCount > 0 ? moonCount : '-';
            
            // ê³ ë¦¬ ìœ ë¬´
            const hasRing = body.ring || (body.name && (body.name.includes('í† ì„±') || body.name.includes('Saturn')));
            const lang = (typeof currentLang !== 'undefined') ? currentLang : 'en';
            document.getElementById('detail-rings').textContent = hasRing ? 
                (lang === 'ko' ? 'ìˆìŒ' : lang === 'ja' ? 'ã‚ã‚Š' : 'Yes') : 
                (lang === 'ko' ? 'ì—†ìŒ' : lang === 'ja' ? 'ãªã—' : 'No');
            
            // ì„¤ëª…
            const description = getBodyDescription(body);
            document.getElementById('detail-description').textContent = description;
            
            // ëª¨ë‹¬ í‘œì‹œ
            modal.classList.add('open');
            
            // íŒì—… ìˆ¨ê¸°ê¸°
            hideBodyInfoPopup();
        }
        
        // ì²œì²´ ì„¤ëª… ìƒì„±
        function getBodyDescription(body) {
            if (!body) return '';
            
            const lang = (typeof currentLang !== 'undefined') ? currentLang : 'en';
            const name = body.name.toLowerCase();
            
            const descriptions = {
                ko: {
                    sun: 'íƒœì–‘ì€ íƒœì–‘ê³„ì˜ ì¤‘ì‹¬ì— ìœ„ì¹˜í•œ í•­ì„±ìœ¼ë¡œ, ì§€êµ¬ì— ë¹›ê³¼ ì—´ì„ ì œê³µí•˜ëŠ” ìƒëª…ì˜ ì›ì²œì…ë‹ˆë‹¤.',
                    mercury: 'ìˆ˜ì„±ì€ íƒœì–‘ê³„ì—ì„œ ê°€ì¥ ì‘ê³  íƒœì–‘ì— ê°€ì¥ ê°€ê¹Œìš´ í–‰ì„±ì…ë‹ˆë‹¤. ê·¹ì‹¬í•œ ì˜¨ë„ ë³€í™”ê°€ íŠ¹ì§•ì…ë‹ˆë‹¤.',
                    venus: 'ê¸ˆì„±ì€ ì§€êµ¬ì™€ ë¹„ìŠ·í•œ í¬ê¸°ë¥¼ ê°€ì§„ í–‰ì„±ìœ¼ë¡œ, ë‘êº¼ìš´ ëŒ€ê¸°ë¡œ ì¸í•´ íƒœì–‘ê³„ì—ì„œ ê°€ì¥ ëœ¨ê±°ìš´ í–‰ì„±ì…ë‹ˆë‹¤.',
                    earth: 'ì§€êµ¬ëŠ” íƒœì–‘ê³„ì—ì„œ ì„¸ ë²ˆì§¸ í–‰ì„±ì´ë©°, ì•Œë ¤ì§„ ìœ ì¼í•œ ìƒëª…ì²´ê°€ ì¡´ì¬í•˜ëŠ” ì²œì²´ì…ë‹ˆë‹¤.',
                    mars: 'í™”ì„±ì€ ë¶‰ì€ í–‰ì„±ìœ¼ë¡œ ë¶ˆë¦¬ë©°, ê³¼ê±°ì— ë¬¼ì´ ì¡´ì¬í–ˆë˜ í”ì ì´ ë°œê²¬ë˜ì–´ íƒì‚¬ì˜ ì£¼ìš” ëŒ€ìƒì…ë‹ˆë‹¤.',
                    jupiter: 'ëª©ì„±ì€ íƒœì–‘ê³„ì—ì„œ ê°€ì¥ í° í–‰ì„±ìœ¼ë¡œ, ëŒ€ì ì ì´ë¼ëŠ” ê±°ëŒ€í•œ í­í’ì´ ìˆ˜ë°± ë…„ê°„ ì§€ì†ë˜ê³  ìˆìŠµë‹ˆë‹¤.',
                    saturn: 'í† ì„±ì€ ì•„ë¦„ë‹¤ìš´ ê³ ë¦¬ ì‹œìŠ¤í…œìœ¼ë¡œ ìœ ëª…í•œ ê°€ìŠ¤ í–‰ì„±ì…ë‹ˆë‹¤. 80ê°œ ì´ìƒì˜ ìœ„ì„±ì„ ë³´ìœ í•˜ê³  ìˆìŠµë‹ˆë‹¤.',
                    uranus: 'ì²œì™•ì„±ì€ ì¶•ì´ ê±°ì˜ 90ë„ ê¸°ìš¸ì–´ì§„ ë…íŠ¹í•œ í–‰ì„±ìœ¼ë¡œ, í‘¸ë¥¸ ìƒ‰ì„ ë ëŠ” ì–¼ìŒ ê±°ì¸ì…ë‹ˆë‹¤.',
                    neptune: 'í•´ì™•ì„±ì€ íƒœì–‘ê³„ì˜ ê°€ì¥ ë°”ê¹¥ìª½ í–‰ì„±ìœ¼ë¡œ, ê°•ë ¥í•œ ë°”ëŒê³¼ í‘¸ë¥¸ ìƒ‰ì´ íŠ¹ì§•ì…ë‹ˆë‹¤.',
                    moon: 'ë‹¬ì€ ì§€êµ¬ì˜ ìœ ì¼í•œ ìì—° ìœ„ì„±ìœ¼ë¡œ, ì¸ë¥˜ê°€ ì§ì ‘ ë°œì„ ë”›ì€ ìœ ì¼í•œ ì™¸ê³„ ì²œì²´ì…ë‹ˆë‹¤.',
                    default: 'íƒœì–‘ê³„ì˜ ì²œì²´ì…ë‹ˆë‹¤. ìì„¸í•œ ì •ë³´ë¥¼ íƒì‚¬ë¥¼ í†µí•´ ì•Œì•„ë³´ì„¸ìš”.'
                },
                en: {
                    sun: 'The Sun is the star at the center of the Solar System, providing light and heat essential for life on Earth.',
                    mercury: 'Mercury is the smallest planet and closest to the Sun, characterized by extreme temperature variations.',
                    venus: 'Venus is similar in size to Earth but has a thick atmosphere making it the hottest planet in the Solar System.',
                    earth: 'Earth is the third planet from the Sun and the only known celestial body to harbor life.',
                    mars: 'Mars is called the Red Planet and shows evidence of past water, making it a prime target for exploration.',
                    jupiter: 'Jupiter is the largest planet, featuring the Great Red Spot, a storm that has persisted for centuries.',
                    saturn: 'Saturn is famous for its beautiful ring system and has over 80 known moons.',
                    uranus: 'Uranus is an ice giant with a unique axial tilt of nearly 90 degrees.',
                    neptune: 'Neptune is the outermost planet, known for its strong winds and deep blue color.',
                    moon: 'The Moon is Earth\'s only natural satellite and the only extraterrestrial body humans have walked on.',
                    default: 'A celestial body in the Solar System. Explore to learn more.'
                },
                ja: {
                    sun: 'å¤ªé™½ã¯å¤ªé™½ç³»ã®ä¸­å¿ƒã«ã‚ã‚‹æ’æ˜Ÿã§ã€åœ°çƒã«ç”Ÿå‘½ã«ä¸å¯æ¬ ãªå…‰ã¨ç†±ã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚',
                    mercury: 'æ°´æ˜Ÿã¯å¤ªé™½ç³»ã§æœ€ã‚‚å°ã•ãã€å¤ªé™½ã«æœ€ã‚‚è¿‘ã„æƒ‘æ˜Ÿã§ã™ã€‚æ¥µç«¯ãªæ¸©åº¦å¤‰åŒ–ãŒç‰¹å¾´ã§ã™ã€‚',
                    venus: 'é‡‘æ˜Ÿã¯åœ°çƒã¨ä¼¼ãŸã‚µã‚¤ã‚ºã§ã™ãŒã€åšã„å¤§æ°—ã«ã‚ˆã‚Šå¤ªé™½ç³»ã§æœ€ã‚‚æš‘ã„æƒ‘æ˜Ÿã§ã™ã€‚',
                    earth: 'åœ°çƒã¯å¤ªé™½ã‹ã‚‰3ç•ªç›®ã®æƒ‘æ˜Ÿã§ã€ç”Ÿå‘½ãŒå­˜åœ¨ã™ã‚‹ã“ã¨ãŒçŸ¥ã‚‰ã‚Œã¦ã„ã‚‹å”¯ä¸€ã®å¤©ä½“ã§ã™ã€‚',
                    mars: 'ç«æ˜Ÿã¯èµ¤ã„æƒ‘æ˜Ÿã¨å‘¼ã°ã‚Œã€éå»ã«æ°´ãŒå­˜åœ¨ã—ãŸè¨¼æ‹ ãŒã‚ã‚Šã€æ¢æŸ»ã®ä¸»è¦å¯¾è±¡ã§ã™ã€‚',
                    jupiter: 'æœ¨æ˜Ÿã¯å¤ªé™½ç³»æœ€å¤§ã®æƒ‘æ˜Ÿã§ã€å¤§èµ¤æ–‘ã¨ã„ã†å·¨å¤§ãªåµãŒæ•°ç™¾å¹´ã‚‚ç¶šã„ã¦ã„ã¾ã™ã€‚',
                    saturn: 'åœŸæ˜Ÿã¯ç¾ã—ã„ãƒªãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã§æœ‰åãªã‚¬ã‚¹æƒ‘æ˜Ÿã§ã€80ä»¥ä¸Šã®è¡›æ˜Ÿã‚’æŒã£ã¦ã„ã¾ã™ã€‚',
                    uranus: 'å¤©ç‹æ˜Ÿã¯è»¸ãŒã»ã¼90åº¦å‚¾ã„ãŸç‹¬ç‰¹ã®æƒ‘æ˜Ÿã§ã€é’ã„æ°·ã®å·¨äººã§ã™ã€‚',
                    neptune: 'æµ·ç‹æ˜Ÿã¯å¤ªé™½ç³»ã®æœ€ã‚‚å¤–å´ã®æƒ‘æ˜Ÿã§ã€å¼·ã„é¢¨ã¨æ·±ã„é’è‰²ãŒç‰¹å¾´ã§ã™ã€‚',
                    moon: 'æœˆã¯åœ°çƒå”¯ä¸€ã®è‡ªç„¶è¡›æ˜Ÿã§ã€äººé¡ãŒç›´æ¥è¶³ã‚’è¸ã¿å…¥ã‚ŒãŸå”¯ä¸€ã®åœ°çƒå¤–å¤©ä½“ã§ã™ã€‚',
                    default: 'å¤ªé™½ç³»ã®å¤©ä½“ã§ã™ã€‚æ¢æŸ»ã—ã¦è©³ã—ãèª¿ã¹ã¾ã—ã‚‡ã†ã€‚'
                }
            };
            
            const langDesc = descriptions[lang] || descriptions.en;
            
            // ì²œì²´ ì´ë¦„ìœ¼ë¡œ ì„¤ëª… ì°¾ê¸°
            for (const key of Object.keys(langDesc)) {
                if (name.includes(key) || name.includes(key.toLowerCase())) {
                    return langDesc[key];
                }
            }
            
            return langDesc.default;
        }
        
        // ìƒì„¸ë³´ê¸° ëª¨ë‹¬ ë‹«ê¸°
        function hideBodyDetailModal() {
            const modal = document.getElementById('body-detail-modal');
            if (modal) {
                modal.classList.remove('open');
            }
        }
        
        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì´ˆê¸°í™” (DOM ë¡œë“œ í›„)
        function initBodyInfoSystem() {
            // íŒì—… ìƒì„¸ë³´ê¸° ë²„íŠ¼
            const detailBtn = document.getElementById('popup-detail-btn');
            if (detailBtn) {
                detailBtn.addEventListener('click', () => {
                    showBodyDetailModal(currentPopupBody);
                });
            }
            
            // ìƒì„¸ë³´ê¸° ëª¨ë‹¬ ë‹«ê¸° ë²„íŠ¼
            const closeBtn = document.getElementById('body-detail-close');
            if (closeBtn) {
                closeBtn.addEventListener('click', hideBodyDetailModal);
            }
            
            // ëª¨ë‹¬ ë°°ê²½ í´ë¦­ ì‹œ ë‹«ê¸°
            const modal = document.getElementById('body-detail-modal');
            if (modal) {
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        hideBodyDetailModal();
                    }
                });
            }
            
            // ì¶”ì í•˜ê¸° ë²„íŠ¼
            const focusBtn = document.getElementById('detail-focus-btn');
            if (focusBtn) {
                focusBtn.addEventListener('click', () => {
                    hideBodyDetailModal();
                });
            }
            
            // í•­ë²• ëª©í‘œ ì„¤ì • ë²„íŠ¼
            const navBtn = document.getElementById('detail-nav-btn');
            if (navBtn) {
                navBtn.addEventListener('click', () => {
                    if (currentPopupBody && typeof setNavTarget === 'function') {
                        setNavTarget(currentPopupBody);
                    }
                    hideBodyDetailModal();
                });
            }
            
            // íŒì—… ë§ˆìš°ìŠ¤ ì˜¤ë²„ ì‹œ ìë™ ìˆ¨ê¹€ íƒ€ì´ë¨¸ ì·¨ì†Œ
            const popup = document.getElementById('body-info-popup');
            if (popup) {
                popup.addEventListener('mouseenter', () => {
                    clearTimeout(popup.autoHideTimeout);
                });
                popup.addEventListener('mouseleave', () => {
                    popup.autoHideTimeout = setTimeout(() => {
                        hideBodyInfoPopup();
                    }, 3000);
                });
            }
        }

        function resetCamera() { 
            focusedBody=null; 
            const resetBtn = document.getElementById('reset-cam');
            if(resetBtn) resetBtn.style.display='none'; 
            // íƒ‘ìŠ¹ ë²„íŠ¼ë„ ìˆ¨ê¹€
            const boardBtn = document.getElementById('board-ship-btn');
            if(boardBtn && !isPilotMode) boardBtn.style.display='none';
            // í¬ì»¤ìŠ¤ ê±°ë¦¬ íŒ¨ë„ë„ ìˆ¨ê¹€
            const distPanel = document.getElementById('focus-distance-panel');
            if(distPanel) distPanel.classList.remove('visible');
            // â˜… ì²œì²´ ì •ë³´ íŒì—…ë„ ìˆ¨ê¹€
            hideBodyInfoPopup();
            controls.target.set(0,0,0);
            controls.minDistance = 0.05;  // â˜… ê¸°ë³¸ minDistance ì¤„ì„ (ì¤Œì¸ ê°€ëŠ¥)
            updateNavList(); 
        }
        
        // í¬ì»¤ìŠ¤ëœ ì²œì²´ì™€ì˜ ê±°ë¦¬ ì—…ë°ì´íŠ¸
        function updateFocusDistance() {
            const panel = document.getElementById('focus-distance-panel');
            if (!panel) return;
            
            // pilot ëª¨ë“œì—ì„œëŠ” í‘œì‹œí•˜ì§€ ì•ŠìŒ
            if (isPilotMode) {
                panel.classList.remove('visible');
                return;
            }
            
            if (focusedBody && focusedBody.mesh) {
                // ì¹´ë©”ë¼ì™€ í¬ì»¤ìŠ¤ ì²œì²´ ì‚¬ì´ ê±°ë¦¬ ê³„ì‚°
                const dist = camera.position.distanceTo(focusedBody.mesh.position);
                
                let distKm;
                
                // â˜… ìš°ì£¼ì„ /ì •ê±°ì¥ì€ í˜„ì‹¤ì ì¸ ìŠ¤ì¼€ì¼ ì ìš© (1 unit â‰ˆ 100m)
                if (focusedBody.type === 'station' || focusedBody.type === 'ship' || 
                    focusedBody.mesh?.userData?.isParkedShip || focusedBody.name?.includes('ì…”í‹€') ||
                    focusedBody.name?.includes('ì •ê±°ì¥') || focusedBody.name?.includes('ISS') ||
                    focusedBody.name?.includes('í”Œë«í¼')) {
                    distKm = dist * 0.1;  // 1 unit = 100m = 0.1 km
                } else {
                    // ì²œì²´ëŠ” ê¸°ì¡´ AU ê¸°ë°˜ ìŠ¤ì¼€ì¼
                    const AU_KM = 149597870.7;
                    distKm = (dist / CONFIG.distScale) * AU_KM;
                }
                
                // ê±°ë¦¬ í¬ë§·íŒ…
                let distStr;
                if (distKm >= 1e9) {
                    distStr = (distKm / 1e9).toFixed(3) + ' B km';
                } else if (distKm >= 1e6) {
                    distStr = (distKm / 1e6).toFixed(3) + ' M km';
                } else if (distKm >= 1000) {
                    distStr = (distKm / 1000).toFixed(2) + ' ì²œ km';
                } else if (distKm >= 1) {
                    distStr = distKm.toFixed(2) + ' km';
                } else {
                    distStr = (distKm * 1000).toFixed(0) + ' m';
                }
                
                document.getElementById('focus-target-name').textContent = 'ğŸ“ ' + translateBodyName(focusedBody.name);
                document.getElementById('focus-distance-value').textContent = distStr;
                panel.classList.add('visible');
            } else {
                panel.classList.remove('visible');
            }
        }

        function destroy(body, idx) { 
            if (!body) return;
            if (body.mesh) {
                scene.remove(body.mesh); 
                body.mesh.traverse(c => {
                    if(c.isCSS2DObject && c.element && c.element.parentNode) c.element.parentNode.removeChild(c.element);
                });
            }
            if(body.trail) scene.remove(body.trail); 
            bodies.splice(idx, 1); 
            if(focusedBody===body) resetCamera(); 
            updateNavList(); 
        }

        function showFloatingLabel(body, text, type) {
            if (!body || !body.mesh) return;
            const div = document.createElement('div');
            div.className = `notify-label ${type}`;
            div.textContent = text;
            const label = new CSS2DObject(div);
            label.position.set(0, body.radius * 1.02, 0);  // ì²œì²´ ë°”ë¡œ ìœ„ 
            body.mesh.add(label);
            setTimeout(() => {
                div.classList.add('fade-out');
                setTimeout(() => { if(body.mesh) body.mesh.remove(label); }, 1000);
            }, 3000);
        }

        function evolveToStar(body) {
            if (!body || !body.mesh) return;
            scene.remove(body.mesh);
            if (body.mesh.children) {
                body.mesh.children.forEach(c => {
                    if (c.isCSS2DObject && c.element && c.element.parentNode) c.element.parentNode.removeChild(c.element);
                });
            }
            const typeData = { r: body.radius, color: 0xffaa00 };
            const geo = new THREE.SphereGeometry(typeData.r, 64, 64);
            const mat = new THREE.ShaderMaterial({ 
                uniforms: { time: { value: 0 } }, 
                vertexShader: document.getElementById('vertexShader').textContent, 
                fragmentShader: document.getElementById('fragmentShader').textContent, 
                transparent: false, depthWrite: true, depthTest: true, blending: THREE.NoBlending, side: THREE.FrontSide 
            });
            const newMesh = new THREE.Mesh(geo, mat);
            newMesh.position.copy(body.mesh.position);
            const light = new THREE.PointLight(typeData.color, 3.0, 0, 0); 
            newMesh.add(light);
            const coronaGeo = new THREE.PlaneGeometry(typeData.r * 6, typeData.r * 6);
            const coronaMat = new THREE.ShaderMaterial({ 
                uniforms: { time: { value: 0 } }, 
                vertexShader: document.getElementById('coronaVertexShader').textContent, 
                fragmentShader: document.getElementById('coronaFragmentShader').textContent, 
                transparent: true, blending: THREE.AdditiveBlending, depthWrite: false, side: THREE.DoubleSide 
            });
            const coronaMesh = new THREE.Mesh(coronaGeo, coronaMat); 
            newMesh.add(coronaMesh);
            const div = document.createElement('div');
            div.className = 'label';
            div.textContent = body.name + " (Star)";
            const label = new CSS2DObject(div);
            label.position.set(0, typeData.r * 1.02, 0);  // ì²œì²´ ë°”ë¡œ ìœ„
            newMesh.add(label);
            scene.add(newMesh);
            body.mesh = newMesh;
            body.corona = coronaMesh;
            body.type = 'star';
            body.isEvolving = false;
            showFloatingLabel(body, "ğŸŒŸ í•­ì„± íƒ„ìƒ!", "notify-success");
            updateNavList();
        }

        function checkEvolution(body) {
            if (body.type === 'star' || body.type === 'blackhole' || body.isEvolving) return;
            if (body.mass >= STAR_THRESHOLD) {
                body.isEvolving = true;
                showFloatingLabel(body, "ğŸ”¥ í•µìœµí•© ì„ê³„ì  ë„ë‹¬!", "notify-warn");
                setTimeout(() => { evolveToStar(body); }, 3000);
            }
        }

        function handleCollision(b1, b2, i1, i2) {
            if (!b1 || !b2) return;
            let winner, loser, lIdx;
            
            // ë¸”ë™í™€ì€ í•­ìƒ ìŠ¹ì (ë‹¤ë¥¸ ì²œì²´ í¡ìˆ˜)
            if (b1.type === 'blackhole') {
                winner = b1; loser = b2; lIdx = i2;
            } else if (b2.type === 'blackhole') {
                winner = b2; loser = b1; lIdx = i1;
            } else if (b1.mass >= b2.mass) { 
                winner = b1; loser = b2; lIdx = i2; 
            } else { 
                winner = b2; loser = b1; lIdx = i1; 
            }
            
            const m1 = winner.mass, m2 = loser.mass;
            const v1 = winner.velocity.clone(), v2 = loser.velocity.clone();
            const newVel = v1.multiplyScalar(m1).add(v2.multiplyScalar(m2)).divideScalar(m1 + m2);
            winner.velocity.copy(newVel);
            winner.mass += loser.mass;
            
            // ë¸”ë™í™€ì€ í¬ê¸° ì¦ê°€ ì•ˆí•¨
            if (winner.type !== 'blackhole') {
                const newRadius = Math.pow(Math.pow(winner.radius, 3) + Math.pow(loser.radius, 3), 1/3);
                const scaleRatio = newRadius / winner.radius;
                if (winner.mesh) winner.mesh.scale.multiplyScalar(scaleRatio);
                winner.radius = newRadius;
            }
            
            destroy(loser, lIdx);
            showMsg(`${winner.name}ê°€ ${loser.name}ì„(ë¥¼) í¡ìˆ˜í–ˆìŠµë‹ˆë‹¤!`);
            checkEvolution(winner);
        }

        function updatePhysics(dt) {
            // Adaptive sub-steps for stability at high speeds
            let steps = CONFIG.subSteps;
            if (CONFIG.timeScale > 10) steps = 50; 
            if (CONFIG.timeScale > 50) steps = 100;
            
            const subDt = dt / steps;
            
            // ë¬¼ë¦¬ ì ìš© ëŒ€ìƒ: bodies + ë¬¼ë¦¬ í™œì„±í™”ëœ ìœ„ì„±ë“¤
            const physicsMoons = satellites.filter(s => s && s.isPhysicsEnabled && s.mesh);
            const allPhysicsObjects = [...bodies, ...physicsMoons];
            
            for(let s=0; s<steps; s++) {
                allPhysicsObjects.forEach(b => { if(b && b.force) b.force.set(0,0,0); });
                
                for(let i=0; i<allPhysicsObjects.length; i++) {
                    for(let j=i+1; j<allPhysicsObjects.length; j++) {
                        const b1=allPhysicsObjects[i], b2=allPhysicsObjects[j];
                        if (!b1 || !b2 || !b1.mesh || !b2.mesh) continue;
                        if (b1.isStatic && b2.isStatic) continue;
                        const distVec=new THREE.Vector3().subVectors(b2.mesh.position,b1.mesh.position);
                        const distSq=distVec.lengthSq(); const dist=Math.sqrt(distSq);
                        
                        // ì¶©ëŒ ì²´í¬ (ìœ„ì„± í¬í•¨)
                        const r1 = b1.radius || 0.3;
                        const r2 = b2.radius || 0.3;
                        if(dist < (r1 + r2) * 0.8) { 
                            handleCollisionAll(b1, b2); 
                            return; 
                        }
                        
                        const f=(CONFIG.G * (b1.mass || 0.01) * (b2.mass || 0.01))/(distSq+CONFIG.softening);
                        const fVec=distVec.normalize().multiplyScalar(f);
                        if (b1.force) b1.force.add(fVec); 
                        if (b2.force) b2.force.sub(fVec);
                    }
                }
                
                allPhysicsObjects.forEach(b => {
                    if (!b || !b.mesh || b.isStatic) return; 
                    if (b.velocity && b.force && b.mass) {
                        b.velocity.add(b.force.divideScalar(b.mass).multiplyScalar(subDt));
                        b.mesh.position.add(b.velocity.clone().multiplyScalar(subDt));
                    }
                });
            }
        }
        
        // ìœ„ì„± í¬í•¨ ì¶©ëŒ ì²˜ë¦¬
        function handleCollisionAll(b1, b2) {
            if (!b1 || !b2) return;
            let winner, loser;
            
            // ë¸”ë™í™€ì€ í•­ìƒ ìŠ¹ì
            if (b1.type === 'blackhole') {
                winner = b1; loser = b2;
            } else if (b2.type === 'blackhole') {
                winner = b2; loser = b1;
            } else if ((b1.mass || 0.01) >= (b2.mass || 0.01)) { 
                winner = b1; loser = b2; 
            } else { 
                winner = b2; loser = b1; 
            }
            
            const m1 = winner.mass || 0.01, m2 = loser.mass || 0.01;
            const v1 = winner.velocity ? winner.velocity.clone() : new THREE.Vector3();
            const v2 = loser.velocity ? loser.velocity.clone() : new THREE.Vector3();
            const newVel = v1.multiplyScalar(m1).add(v2.multiplyScalar(m2)).divideScalar(m1 + m2);
            if (winner.velocity) winner.velocity.copy(newVel);
            winner.mass = m1 + m2;
            
            // ë¸”ë™í™€ì€ í¬ê¸° ì¦ê°€ ì•ˆí•¨
            if (winner.type !== 'blackhole' && winner.radius && loser.radius) {
                const newRadius = Math.pow(Math.pow(winner.radius, 3) + Math.pow(loser.radius, 3), 1/3);
                const scaleRatio = newRadius / winner.radius;
                if (winner.mesh) winner.mesh.scale.multiplyScalar(scaleRatio);
                winner.radius = newRadius;
            }
            
            // íŒ¨ë°°ì ì œê±°
            if (loser.type === 'moon') {
                // ìœ„ì„±ì¸ ê²½ìš° satellitesì—ì„œ ì œê±°
                const idx = satellites.indexOf(loser);
                if (idx > -1) {
                    if (loser.mesh) scene.remove(loser.mesh);
                    satellites.splice(idx, 1);
                }
            } else {
                // ì¼ë°˜ ì²œì²´
                const idx = bodies.indexOf(loser);
                if (idx > -1) destroy(loser, idx);
            }
            
            showMsg(`${winner.name}ê°€ ${loser.name}ì„(ë¥¼) í¡ìˆ˜í–ˆìŠµë‹ˆë‹¤!`);
            if (winner.mass) checkEvolution(winner);
        }

        function updateTrails() {
            bodies.forEach(b => {
                if (!b || !b.mesh || b.isStatic) return; 
                b.trailTimer++;
                if(b.trailTimer > 3 && b.trail && b.trailPoints) {
                    b.trailTimer=0; b.trailPoints.push(b.mesh.position.clone()); b.trailPoints.shift();
                    b.trail.geometry.setFromPoints(b.trailPoints); b.trail.geometry.attributes.position.needsUpdate=true;
                }
            });
        }

        // â˜…â˜…â˜… ë©€í‹°ëª¨ë“œ ì‹œê°ì  ìŠ¤ì¼€ì¼ (ë¬¼ë¦¬ ê³„ì‚°ì€ ê·¸ëŒ€ë¡œ) â˜…â˜…â˜…
        // â˜…â˜…â˜… ì „ì²´ ìŠ¤ì¼€ì¼ 10ë°° (2024-01-07) â˜…â˜…â˜…
        const VISUAL_SCALE = {
            star: 15.0,      // íƒœì–‘: 15ë°° (ì ˆë°˜ìœ¼ë¡œ ê°ì†Œ)
            planet: 50.0,    // í–‰ì„±: 50ë°° (5*10)
            gas: 50.0,       // ê°€ìŠ¤ í–‰ì„±: 50ë°° (5*10)
            moon: 50.0,      // ìœ„ì„±: 50ë°° (5*10)
            blackhole: 30.0  // ë¸”ë™í™€: 30ë°° (3*10)
        };
        
        function getVisualScale(type) {
            // ë©€í‹°ëª¨ë“œ ì²´í¬ (window.gameMode === 'multi')
            const isMultiMode = (typeof window.gameMode !== 'undefined' && window.gameMode === 'multi');
            if (!isMultiMode) return 1.0;  // ì‹±ê¸€ëª¨ë“œëŠ” 1ë°°
            return VISUAL_SCALE[type] || 5.0;
        }

        // â˜…â˜…â˜… 2ë‹¨ê³„ ì²œì²´ ìƒì„± ì‹œìŠ¤í…œ â˜…â˜…â˜…
        
        // 1ë‹¨ê³„: ëŒ€ê¸° ì²œì²´ ìƒì„± (ìœ„ì¹˜ë§Œ ê²°ì •, ë¬¼ë¦¬ ë¯¸ì ìš©)
        let velocityHandle = null;  // í™”ì‚´í‘œ ë í•¸ë“¤
        let initialArrowDir = null; // ì´ˆê¸° í™”ì‚´í‘œ ë°©í–¥
        
        function createPendingBody(typeData, position, name, texKey) {
            // ê¸°ì¡´ ëŒ€ê¸° ì²œì²´ê°€ ìˆìœ¼ë©´ ì œê±°
            cancelPendingBody();
            
            // ëŒ€ê¸° ì²œì²´ ë©”ì‰¬ ìƒì„± (ë°˜íˆ¬ëª…)
            const bodyRadius = typeData.r || 1;
            const geo = new THREE.SphereGeometry(bodyRadius, 32, 32);
            const mat = new THREE.MeshBasicMaterial({
                color: parseInt(typeData.color) || 0xffffff,
                transparent: true,
                opacity: 0.6,
                wireframe: false
            });
            pendingBodyMesh = new THREE.Mesh(geo, mat);
            pendingBodyMesh.position.copy(position);
            scene.add(pendingBodyMesh);
            
            // í„ìŠ¤ íš¨ê³¼ë¥¼ ìœ„í•œ ë§ ì¶”ê°€
            const ringGeo = new THREE.RingGeometry(bodyRadius * 1.2, bodyRadius * 1.5, 32);
            const ringMat = new THREE.MeshBasicMaterial({
                color: 0x00ff88,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = Math.PI / 2;
            ring.name = 'pendingRing';
            pendingBodyMesh.add(ring);
            
            // ëŒ€ê¸° ì²œì²´ ë°ì´í„° ì €ì¥
            pendingBody = {
                typeData: typeData,
                position: position.clone(),
                name: name,
                texKey: texKey,
                radius: bodyRadius
            };
            
            // OrbitControls ë¹„í™œì„±í™” (ì²œì²´ ë“œë˜ê·¸ ì‹œ í™”ë©´ íšŒì „ ë°©ì§€)
            if (controls) controls.enabled = false;
            
            // â˜…â˜…â˜… ì´ˆê¸° í™”ì‚´í‘œì™€ í•¸ë“¤ ìƒì„± â˜…â˜…â˜…
            createInitialArrowWithHandle(position, bodyRadius);
            
            // ì•ˆë‚´ ë©”ì‹œì§€
            const lang = (typeof currentLang !== 'undefined') ? currentLang : 'en';
            const msg = lang === 'ko' ? `ğŸ‘† í™”ì‚´í‘œ ëì„ ë“œë˜ê·¸í•˜ì—¬ ë°©í–¥ê³¼ ì†ë„ë¥¼ ì„¤ì •í•˜ì„¸ìš”` :
                       lang === 'ja' ? `ğŸ‘† çŸ¢å°ã®å…ˆç«¯ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦æ–¹å‘ã¨é€Ÿåº¦ã‚’è¨­å®š` :
                       `ğŸ‘† Drag the arrow tip to set direction and speed`;
            showMsg(msg);
        }
        
        // â˜…â˜…â˜… ì´ˆê¸° í™”ì‚´í‘œì™€ ë“œë˜ê·¸ í•¸ë“¤ ìƒì„± â˜…â˜…â˜…
        function createInitialArrowWithHandle(position, radius) {
            // ì¹´ë©”ë¼ ë°©í–¥ì—ì„œ ì˜¤ë¥¸ìª½ìœ¼ë¡œ í™”ì‚´í‘œ ìƒì„±
            const camDir = new THREE.Vector3();
            camera.getWorldDirection(camDir);
            
            // í™”ì‚´í‘œ ë°©í–¥: ì¹´ë©”ë¼ ì˜¤ë¥¸ìª½ ë°©í–¥ (xz í‰ë©´)
            initialArrowDir = new THREE.Vector3(-camDir.z, 0, camDir.x).normalize();
            
            // í™”ì‚´í‘œ ê¸¸ì´ (ì²œì²´ ë°˜ì§€ë¦„ì˜ 3ë°°)
            const arrowLength = Math.max(radius * 4, 30);
            const arrowEnd = position.clone().add(initialArrowDir.clone().multiplyScalar(arrowLength));
            
            // í™”ì‚´í‘œ ì„  ìƒì„±
            const lineGeo = new THREE.BufferGeometry().setFromPoints([position, arrowEnd]);
            const lineMat = new THREE.LineBasicMaterial({ 
                color: 0x00ff88,
                linewidth: 3
            });
            velocityLine = new THREE.Line(lineGeo, lineMat);
            scene.add(velocityLine);
            
            // ë“œë˜ê·¸ í•¸ë“¤ (í™”ì‚´í‘œ ëì˜ êµ¬ì²´) - í¬ê¸° ëŒ€í­ ì¦ê°€
            const handleSize = Math.max(radius * 2, 15);  // ìµœì†Œ 15 ìœ ë‹›
            const handleGeo = new THREE.SphereGeometry(handleSize, 16, 16);
            const handleMat = new THREE.MeshBasicMaterial({
                color: 0xffaa00,
                transparent: true,
                opacity: 0.8
            });
            velocityHandle = new THREE.Mesh(handleGeo, handleMat);
            velocityHandle.position.copy(arrowEnd);
            velocityHandle.name = 'velocityHandle';
            scene.add(velocityHandle);
            
            // í•¸ë“¤ ì£¼ìœ„ ë§ (ì†ìœ¼ë¡œ ì¡ìœ¼ë¼ëŠ” í‘œì‹œ) - í¬ê¸° ì¦ê°€
            const handleRingGeo = new THREE.RingGeometry(
                handleSize * 1.3, 
                handleSize * 1.8, 
                32
            );
            const handleRingMat = new THREE.MeshBasicMaterial({
                color: 0xffaa00,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide
            });
            const handleRing = new THREE.Mesh(handleRingGeo, handleRingMat);
            handleRing.name = 'handleRing';
            velocityHandle.add(handleRing);
            
            // í™”ì‚´í‘œ ë¨¸ë¦¬ (cone)
            const coneGeo = new THREE.ConeGeometry(Math.max(radius * 0.5, 3), Math.max(radius * 1, 6), 8);
            const coneMat = new THREE.MeshBasicMaterial({ color: 0x00ff88 });
            const cone = new THREE.Mesh(coneGeo, coneMat);
            cone.name = 'arrowCone';
            
            // í™”ì‚´í‘œ ë°©í–¥ìœ¼ë¡œ ì½˜ íšŒì „
            const dir = initialArrowDir.clone();
            const quaternion = new THREE.Quaternion();
            quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir);
            cone.quaternion.copy(quaternion);
            cone.position.copy(arrowEnd).add(dir.multiplyScalar(Math.max(radius * 0.5, 3)));
            scene.add(cone);
            velocityArrow = cone;
        }
        
        // ì¤Œì¸ í•¨ìˆ˜ ì œê±°ë¨ - í™”ë©´ ê·¸ëŒ€ë¡œ ìœ ì§€
        
        // ëŒ€ê¸° ì²œì²´ ì·¨ì†Œ
        function cancelPendingBody() {
            if (pendingBodyMesh) {
                scene.remove(pendingBodyMesh);
                pendingBodyMesh = null;
            }
            if (velocityLine) {
                scene.remove(velocityLine);
                velocityLine = null;
            }
            if (velocityArrow) {
                scene.remove(velocityArrow);
                velocityArrow = null;
            }
            if (velocityHandle) {
                scene.remove(velocityHandle);
                velocityHandle = null;
            }
            pendingBody = null;
            isPendingDrag = false;
            pendingDragStart = null;
            initialArrowDir = null;
            
            // ì†ë„ í‘œì‹œ ìˆ¨ê¸°ê¸°
            hideSpeedDisplay();
            
            // OrbitControls ì¬í™œì„±í™”
            if (controls) controls.enabled = true;
        }
        
        // 2ë‹¨ê³„: ëŒ€ê¸° ì²œì²´ í™•ì • (ì†ë„ ì ìš©í•˜ì—¬ ì‹¤ì œ ìƒì„±)
        function confirmPendingBody(velocity) {
            if (!pendingBody) return;
            
            // ì‹¤ì œ ì²œì²´ ìƒì„±
            createBody(
                pendingBody.typeData,
                pendingBody.position,
                velocity,
                pendingBody.name + " (New)",
                pendingBody.texKey
            );
            
            // ì†ë„ ì •ë³´ í‘œì‹œ
            const speed = velocity.length().toFixed(2);
            const lang = (typeof currentLang !== 'undefined') ? currentLang : 'en';
            const msg = lang === 'ko' ? `ğŸŒ ${pendingBody.name} ìƒì„± ì™„ë£Œ! ì†ë„: ${speed}` :
                       lang === 'ja' ? `ğŸŒ ${pendingBody.name} ç”Ÿæˆå®Œäº†ï¼é€Ÿåº¦: ${speed}` :
                       `ğŸŒ ${pendingBody.name} created! Speed: ${speed}`;
            showMsg(msg);
            
            // ì •ë¦¬
            cancelPendingBody();
        }
        
        // ì†ë„ ë°©í–¥ í‘œì‹œ ì—…ë°ì´íŠ¸
        // updateVelocityIndicator í•¨ìˆ˜ëŠ” updateArrowAndHandleë¡œ ëŒ€ì²´ë¨
        
        // í„°ì¹˜ë¡œ í™”ì‚´í‘œ í•¸ë“¤ ë“œë˜ê·¸ ì‹œì‘ ì²´í¬
        // pendingBodyê°€ ìˆìœ¼ë©´ í™”ë©´ ì–´ë””ë“  í„°ì¹˜í•´ì„œ ë“œë˜ê·¸ ê°€ëŠ¥
        function checkPendingBodyTouch(touchX, touchY) {
            if (!pendingBody) return false;
            
            // pendingBodyê°€ ìˆìœ¼ë©´ ë¬´ì¡°ê±´ ë“œë˜ê·¸ í—ˆìš© (í™”ë©´ ì–´ë””ë“ )
            return true;
        }
        
        // í„°ì¹˜ ìœ„ì¹˜ë¥¼ 3D ì¢Œí‘œë¡œ ë³€í™˜
        function touchTo3D(touchX, touchY) {
            mouse.x = (touchX / window.innerWidth) * 2 - 1;
            mouse.y = -(touchY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const target = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, target);
            return target;
        }
        
        // â˜…â˜…â˜… í™”ì‚´í‘œ ë° í•¸ë“¤ ìœ„ì¹˜ ì—…ë°ì´íŠ¸ â˜…â˜…â˜…
        function updateArrowAndHandle(endPos) {
            if (!pendingBody || !velocityLine) return;
            
            const startPos = pendingBody.position;
            
            // ì„  ì—…ë°ì´íŠ¸
            const positions = velocityLine.geometry.attributes.position;
            positions.setXYZ(0, startPos.x, startPos.y, startPos.z);
            positions.setXYZ(1, endPos.x, endPos.y, endPos.z);
            positions.needsUpdate = true;
            
            // ë°©í–¥ ë° ê±°ë¦¬
            const dir = new THREE.Vector3().subVectors(endPos, startPos);
            const length = dir.length();
            const dirNorm = dir.clone().normalize();
            
            // ì†ë„ ê³„ì‚° (ì‹¤ì œ ê²Œì„ ë‚´ë¶€ ë‹¨ìœ„)
            const speedScale = Math.min(length * 0.01, 2.0);
            const speedDisplay = speedScale.toFixed(2);
            
            // ìƒ‰ìƒ ë³€ê²½ (ì†ë„ì— ë”°ë¼)
            const speedColor = length > 100 ? 0xff4400 : length > 50 ? 0xffaa00 : 0x00ff88;
            velocityLine.material.color.setHex(speedColor);
            
            // â˜…â˜…â˜… ì†ë„ í‘œì‹œ UI ì—…ë°ì´íŠ¸ â˜…â˜…â˜…
            updateSpeedDisplay(speedDisplay, speedColor, length);
            
            // í•¸ë“¤ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
            if (velocityHandle) {
                velocityHandle.position.copy(endPos);
                velocityHandle.material.color.setHex(speedColor);
                
                // í•¸ë“¤ ë§ ìƒ‰ìƒë„ ì—…ë°ì´íŠ¸
                const handleRing = velocityHandle.getObjectByName('handleRing');
                if (handleRing) {
                    handleRing.material.color.setHex(speedColor);
                }
            }
            
            // í™”ì‚´í‘œ ì½˜ ì—…ë°ì´íŠ¸
            if (velocityArrow && length > 5) {
                velocityArrow.material.color.setHex(speedColor);
                const quaternion = new THREE.Quaternion();
                quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dirNorm);
                velocityArrow.quaternion.copy(quaternion);
                velocityArrow.position.copy(endPos).add(dirNorm.clone().multiplyScalar(pendingBody.radius * 0.5 || 3));
            }
        }
        
        // â˜…â˜…â˜… ì†ë„ í‘œì‹œ UI â˜…â˜…â˜…
        function updateSpeedDisplay(speedValue, color, length) {
            let speedDisplay = document.getElementById('velocity-speed-display');
            
            if (!speedDisplay) {
                speedDisplay = document.createElement('div');
                speedDisplay.id = 'velocity-speed-display';
                speedDisplay.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    padding: 15px 25px;
                    background: rgba(0, 20, 40, 0.9);
                    border: 2px solid #00ff88;
                    border-radius: 10px;
                    color: #00ff88;
                    font-family: 'Orbitron', monospace;
                    font-size: 24px;
                    font-weight: bold;
                    z-index: 10000;
                    text-align: center;
                    pointer-events: none;
                    box-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
                `;
                document.body.appendChild(speedDisplay);
            }
            
            // ìƒ‰ìƒ ì„¤ì •
            const colorHex = '#' + color.toString(16).padStart(6, '0');
            speedDisplay.style.borderColor = colorHex;
            speedDisplay.style.color = colorHex;
            speedDisplay.style.boxShadow = `0 0 30px ${colorHex}80`;
            
            // ì†ë„ ë“±ê¸‰
            const lang = (typeof currentLang !== 'undefined') ? currentLang : 'en';
            let grade = '';
            if (length > 100) {
                grade = lang === 'ko' ? 'ğŸš€ ê³ ì†' : lang === 'ja' ? 'ğŸš€ é«˜é€Ÿ' : 'ğŸš€ Fast';
            } else if (length > 50) {
                grade = lang === 'ko' ? 'âš¡ ë³´í†µ' : lang === 'ja' ? 'âš¡ æ™®é€š' : 'âš¡ Normal';
            } else {
                grade = lang === 'ko' ? 'ğŸ¢ ì €ì†' : lang === 'ja' ? 'ğŸ¢ ä½é€Ÿ' : 'ğŸ¢ Slow';
            }
            
            speedDisplay.innerHTML = `
                <div style="font-size: 14px; opacity: 0.8; margin-bottom: 5px;">${grade}</div>
                <div>${speedValue} <span style="font-size: 14px;">units</span></div>
            `;
            
            speedDisplay.style.display = 'block';
        }
        
        // ì†ë„ í‘œì‹œ ìˆ¨ê¸°ê¸°
        function hideSpeedDisplay() {
            const speedDisplay = document.getElementById('velocity-speed-display');
            if (speedDisplay) {
                speedDisplay.style.display = 'none';
            }
        }

        function createBody(typeData, pos, vel, name, textureKeyName=null) {
            let mesh, coronaMesh;
            const visualScale = getVisualScale(typeData.type);
            
            if (typeData.type === 'star') {
                const geo = new THREE.SphereGeometry(typeData.r, 64, 64);
                const mat = new THREE.ShaderMaterial({ uniforms: { time: { value: 0 } }, vertexShader: document.getElementById('vertexShader').textContent, fragmentShader: document.getElementById('fragmentShader').textContent, transparent: false, depthWrite: true, depthTest: true, blending: THREE.NoBlending, side: THREE.FrontSide });
                mesh = new THREE.Mesh(geo, mat);
                mesh.scale.setScalar(visualScale);  // â˜… ì‹œê°ì  ìŠ¤ì¼€ì¼ ì ìš©
                const light = new THREE.PointLight(typeData.color, 3.0, 0, 0); mesh.add(light);
                const coronaGeo = new THREE.PlaneGeometry(typeData.r * 6, typeData.r * 6);
                const coronaMat = new THREE.ShaderMaterial({ uniforms: { time: { value: 0 } }, vertexShader: document.getElementById('coronaVertexShader').textContent, fragmentShader: document.getElementById('coronaFragmentShader').textContent, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false, side: THREE.DoubleSide });
                coronaMesh = new THREE.Mesh(coronaGeo, coronaMat); mesh.add(coronaMesh);
            } else if (typeData.type === 'blackhole') {
                const geo = new THREE.SphereGeometry(typeData.r, 32, 32); 
                mesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({color:0}));
                mesh.scale.setScalar(visualScale);  // â˜… ì‹œê°ì  ìŠ¤ì¼€ì¼ ì ìš©
                
                // â˜… ì‹¬í”Œí•œ ë¶ˆì˜ ê³ ë¦¬ ê°•ì°©ì›ë°˜
                const bhGroup = new THREE.Group();
                bhGroup.name = 'blackholeEffects';
                
                const r = typeData.r;
                
                // 1. ë©”ì¸ ë¶ˆì˜ ê³ ë¦¬ (ì—¬ëŸ¬ ì¸µ)
                const fireRings = [];
                const numRings = 5;
                for (let i = 0; i < numRings; i++) {
                    const innerR = r * (1.8 + i * 0.6);
                    const outerR = r * (2.2 + i * 0.6);
                    const ringGeo = new THREE.RingGeometry(innerR, outerR, 64, 1);
                    
                    // ì•ˆìª½ì¼ìˆ˜ë¡ ë°ì€ ë…¸ë‘/í°ìƒ‰, ë°”ê¹¥ìª½ì¼ìˆ˜ë¡ ë¹¨ê°•/ì£¼í™©
                    const t = i / numRings;
                    const ringColor = new THREE.Color();
                    ringColor.setRGB(
                        1,
                        0.8 - t * 0.5,  // ì•ˆìª½: ë…¸ë‘, ë°”ê¹¥: ë¹¨ê°•
                        0.3 - t * 0.25
                    );
                    
                    const ringMat = new THREE.MeshBasicMaterial({
                        color: ringColor,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.9 - t * 0.3,
                        blending: THREE.AdditiveBlending,
                        depthWrite: false
                    });
                    
                    const ring = new THREE.Mesh(ringGeo, ringMat);
                    ring.rotation.x = Math.PI / 2;
                    ring.userData.rotationSpeed = 0.005 - t * 0.001;  // ì•ˆìª½ì´ ë” ë¹ ë¦„
                    fireRings.push(ring);
                    bhGroup.add(ring);
                }
                
                // 2. ë‚´ë¶€ ë°ì€ ë§ (ì´ë²¤íŠ¸ í˜¸ë¼ì´ì¦Œ ê·¼ì²˜)
                const innerGlowGeo = new THREE.RingGeometry(r * 1.3, r * 1.7, 64);
                const innerGlowMat = new THREE.MeshBasicMaterial({
                    color: 0xffffaa,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 1,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                const innerGlow = new THREE.Mesh(innerGlowGeo, innerGlowMat);
                innerGlow.rotation.x = Math.PI / 2;
                innerGlow.userData.rotationSpeed = 0.01;
                bhGroup.add(innerGlow);
                
                // 3. ì™¸ê³½ ê¸€ë¡œìš° (ì€ì€í•œ ë¹›)
                const outerGlowGeo = new THREE.RingGeometry(r * 4.5, r * 6, 64);
                const outerGlowMat = new THREE.MeshBasicMaterial({
                    color: 0xff4400,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.2,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                const outerGlow = new THREE.Mesh(outerGlowGeo, outerGlowMat);
                outerGlow.rotation.x = Math.PI / 2;
                bhGroup.add(outerGlow);
                
                mesh.add(bhGroup);
                
                // ì• ë‹ˆë©”ì´ì…˜ìš© ë°ì´í„° ì €ì¥
                mesh.userData.fireRings = fireRings;
                mesh.userData.innerGlow = innerGlow;
            } else {
                const geo = new THREE.SphereGeometry(typeData.r, 64, 64);
                const params = { color: 0xffffff, roughness: 0.9, metalness: 0.0 };  // â˜… í…ìŠ¤ì²˜ ì›ìƒ‰ ìœ ì§€
                const safeMap = generateProceduralTexture(typeData.texType||'rock', typeData.color); params.map = safeMap;
                const mat = new THREE.MeshStandardMaterial(params);
                mesh = new THREE.Mesh(geo, mat);
                mesh.scale.setScalar(visualScale);  // â˜… ì‹œê°ì  ìŠ¤ì¼€ì¼ ì ìš©
                mesh.castShadow = true; mesh.receiveShadow = true;
                
                // â˜…â˜…â˜… ì§€êµ¬ì— ëŒ€ê¸°ì™€ êµ¬ë¦„ ì¶”ê°€ â˜…â˜…â˜…
                if (name === 'ì§€êµ¬') {
                    // ëŒ€ê¸° ë ˆì´ì–´
                    const atmosphereGeo = new THREE.SphereGeometry(typeData.r * 1.025, 64, 64);
                    const atmosphereMat = new THREE.ShaderMaterial({
                        vertexShader: document.getElementById('atmosphereVertexShader').textContent,
                        fragmentShader: document.getElementById('atmosphereFragmentShader').textContent,
                        uniforms: {
                            sunDirection: { value: new THREE.Vector3(1, 0, 0) },
                            atmosphereRadius: { value: typeData.r * 1.025 },
                            planetRadius: { value: typeData.r },
                            time: { value: 0 }
                        },
                        transparent: true,
                        blending: THREE.AdditiveBlending,
                        side: THREE.BackSide,
                        depthWrite: false
                    });
                    const atmosphere = new THREE.Mesh(atmosphereGeo, atmosphereMat);
                    atmosphere.name = 'earthAtmosphere';
                    mesh.add(atmosphere);
                    
                    // â˜…â˜…â˜… ë‹¤ì¸µ êµ¬ë¦„ ì‹œìŠ¤í…œ (3ê°œ ë ˆì´ì–´) â˜…â˜…â˜…
                    const cloudLayers = [];
                    const cloudHeights = [1.008, 1.012, 1.018];  // ë‚®ì€ êµ¬ë¦„, ì¤‘ê°„, ë†’ì€ êµ¬ë¦„
                    
                    cloudHeights.forEach((height, idx) => {
                        const cloudGeo = new THREE.SphereGeometry(typeData.r * height, 64, 64);
                        const cloudMat = new THREE.ShaderMaterial({
                            vertexShader: document.getElementById('cloudVertexShader').textContent,
                            fragmentShader: document.getElementById('cloudFragmentShader').textContent,
                            uniforms: {
                                time: { value: idx * 100 },  // ë ˆì´ì–´ë³„ ì‹œê°„ ì˜¤í”„ì…‹
                                sunDirection: { value: new THREE.Vector3(1, 0, 0) },
                                cloudDensity: { value: 1.0 - idx * 0.2 },  // ë†’ì„ìˆ˜ë¡ ì˜…ì–´ì§
                                cloudSpeed: { value: 0.02 + idx * 0.01 }   // ë†’ì„ìˆ˜ë¡ ë¹ ë¥´ê²Œ
                            },
                            transparent: true,
                            blending: THREE.NormalBlending,
                            side: THREE.FrontSide,
                            depthWrite: false
                        });
                        const clouds = new THREE.Mesh(cloudGeo, cloudMat);
                        clouds.name = 'earthClouds_' + idx;
                        clouds.renderOrder = idx;  // ë Œë”ë§ ìˆœì„œ
                        mesh.add(clouds);
                        cloudLayers.push(cloudMat);
                    });
                    
                    // ì‰ì´ë” ì°¸ì¡° ì €ì¥ (ì• ë‹ˆë©”ì´ì…˜ìš©)
                    mesh.userData.atmosphereMat = atmosphereMat;
                    mesh.userData.cloudLayers = cloudLayers;
                    mesh.userData.hasAtmosphere = true;
                    
                    console.log('ğŸŒ ì§€êµ¬ ëŒ€ê¸°/êµ¬ë¦„ ì‰ì´ë” ìƒì„± ì™„ë£Œ (3 ë ˆì´ì–´)');
                }
            }
            mesh.position.copy(pos); scene.add(mesh);
            if (textureKeyName && typeData.type !== 'star') {
                let url;
                if (textureKeyName.startsWith('http')) {
                    url = textureKeyName;
                } else if (textureKeyName.startsWith('uploads/')) {
                    // uploads ê²½ë¡œëŠ” Supabase Storageë¡œ
                    const justFilename = textureKeyName.replace('uploads/', '').replace('ships/', '');
                    url = SUPABASE_STORAGE + justFilename;
                } else if (TEXTURES[textureKeyName]) {
                    // TEXTURES ë§¤í•‘ì—ì„œ Supabase íŒŒì¼ ì°¾ê¸°
                    url = getTextureUrl(TEXTURES[textureKeyName].map);
                } else {
                    url = getTextureUrl(textureKeyName);
                }
                if(url) textureLoader.load(url, (t) => { mesh.material.map = t; mesh.material.needsUpdate = true; }, undefined, (err) => {
                    console.warn('í…ìŠ¤ì²˜ ë¡œë“œ ì‹¤íŒ¨ (Supabase), ë¡œì»¬ ì‹œë„:', textureKeyName);
                    // ì‹¤íŒ¨ì‹œ ë¡œì»¬ ì‹œë„
                    const localUrl = textureKeyName.startsWith('uploads/') ? textureKeyName : ASSET_PATH + (TEXTURES[textureKeyName] ? TEXTURES[textureKeyName].map : textureKeyName);
                    textureLoader.load(localUrl, (t) => { mesh.material.map = t; mesh.material.needsUpdate = true; });
                });
            }
            if (typeData.ring) {
                const rGeo = new THREE.RingGeometry(typeData.r*1.3, typeData.r*2.2, 64);
                // UV ì¢Œí‘œ ìˆ˜ì • (ê°€ë¡œ ì´ë¯¸ì§€ê°€ ê³ ë¦¬ í˜•íƒœë¡œ ê°ì‹¸ì§€ë„ë¡)
                const pos = rGeo.attributes.position;
                const uv = rGeo.attributes.uv;
                for (let i = 0; i < uv.count; i++) {
                    const x = pos.getX(i);
                    const y = pos.getY(i);
                    const dist = Math.sqrt(x*x + y*y);
                    const innerR = typeData.r * 1.3;
                    const outerR = typeData.r * 2.2;
                    const u = (dist - innerR) / (outerR - innerR);  // ë°˜ê²½ ë°©í–¥
                    const angle = Math.atan2(y, x);
                    const v = (angle + Math.PI) / (2 * Math.PI);  // ê°ë„ ë°©í–¥
                    uv.setXY(i, v, u);
                }
                uv.needsUpdate = true;
                
                const rMat = new THREE.MeshStandardMaterial({ color: 0xaa9977, side: THREE.DoubleSide, transparent:true, opacity:0.9 });
                const rMesh = new THREE.Mesh(rGeo, rMat); rMesh.rotation.x = -Math.PI/2; rMesh.castShadow = true; rMesh.receiveShadow=true; mesh.add(rMesh);
                
                // â˜… ê³ ë¦¬ í…ìŠ¤ì²˜ ë¡œë“œ (data.jsonì˜ ringTexture ë˜ëŠ” Supabase Storage)
                let ringTexPath;
                if (typeData.ringTexture) {
                    if (typeData.ringTexture.startsWith('http')) {
                        ringTexPath = typeData.ringTexture;
                    } else if (typeData.ringTexture.startsWith('uploads/')) {
                        ringTexPath = SUPABASE_STORAGE + typeData.ringTexture.replace('uploads/', '');
                    } else {
                        ringTexPath = typeData.ringTexture;
                    }
                } else {
                    ringTexPath = SUPABASE_STORAGE + 'saturn_ring_1765903886.png';
                }
                new THREE.TextureLoader().load(ringTexPath, (t)=>{
                    t.wrapS = THREE.RepeatWrapping;
                    t.wrapT = THREE.ClampToEdgeWrapping;
                    rMat.map=t; rMat.alphaMap=t; rMat.needsUpdate=true;
                });
            }
            const div = document.createElement('div'); div.className = 'label'; 
            div.dataset.bodyName = name;  // ì›ë³¸ ì´ë¦„ ì €ì¥
            div.textContent = translateBodyName(name);  // ë²ˆì—­ëœ ì´ë¦„ í‘œì‹œ
            const labelY = typeData.r * visualScale * 1.02;  // â˜… ì‹œê°ì  ìŠ¤ì¼€ì¼ ë°˜ì˜
            const label = new CSS2DObject(div); label.position.set(0, labelY, 0); mesh.add(label);
            const body = { mesh: mesh, mass: typeData.m, radius: typeData.r, velocity: vel.clone(), force: new THREE.Vector3(), name: name, type: typeData.type||'planet', rotSpeed: typeData.rotSpeed || 0, corona: coronaMesh, visualScale: visualScale };
            initTrail(body); bodies.push(body); updateNavList(); 
            return body;
        }

        function createSatellite(parentBody, typeData, distRatio, speed, name, isSpaceStation = false) {
            let mesh;
            // â˜… ë¶€ëª¨ì˜ visualScale ê°€ì ¸ì˜¤ê¸° (10ë°° ìŠ¤ì¼€ì¼ ì ìš©)
            const parentVisualScale = parentBody.visualScale || 1;
            const dist = parentBody.radius * distRatio * parentVisualScale;  // â˜… ê¶¤ë„ë„ ìŠ¤ì¼€ì¼ ì ìš©
            if (isSpaceStation) {
                // ========== SF ê±°ëŒ€ ìš°ì£¼ì •ê±°ì¥ ëª¨ë¸ë§ ==========
                const group = new THREE.Group();
                
                // ì¬ì§ˆ ì •ì˜
                const hullMat = new THREE.MeshStandardMaterial({ 
                    color: 0xcccccc, metalness: 0.9, roughness: 0.2 
                });
                const darkHullMat = new THREE.MeshStandardMaterial({ 
                    color: 0x444455, metalness: 0.8, roughness: 0.3 
                });
                const glowMat = new THREE.MeshBasicMaterial({ 
                    color: 0x00ffff, transparent: true, opacity: 0.8 
                });
                const panelMat = new THREE.MeshStandardMaterial({ 
                    color: 0x112244, metalness: 0.6, roughness: 0.1, 
                    emissive: 0x000033, emissiveIntensity: 0.3 
                });
                const accentMat = new THREE.MeshStandardMaterial({ 
                    color: 0xff6600, metalness: 0.7, roughness: 0.3,
                    emissive: 0xff3300, emissiveIntensity: 0.2
                });
                const windowMat = new THREE.MeshBasicMaterial({ 
                    color: 0x88ccff, transparent: true, opacity: 0.6 
                });
                
                // === 1. ì¤‘ì•™ íšŒì „ ë§ (í† ëŸ¬ìŠ¤) - ê±°ì£¼ êµ¬ì—­ ===
                const ringGeo = new THREE.TorusGeometry(3, 0.4, 16, 64);
                const ring = new THREE.Mesh(ringGeo, hullMat);
                ring.rotation.x = Math.PI / 2;
                group.add(ring);
                
                // ë§ ìœ„ì˜ ì°½ë¬¸ë“¤
                for (let i = 0; i < 32; i++) {
                    const angle = (i / 32) * Math.PI * 2;
                    const windowGeo = new THREE.BoxGeometry(0.15, 0.08, 0.05);
                    const window = new THREE.Mesh(windowGeo, windowMat);
                    window.position.set(
                        Math.cos(angle) * 3,
                        0.35,
                        Math.sin(angle) * 3
                    );
                    window.rotation.y = -angle;
                    group.add(window);
                }
                
                // ë§ ì„¸ê·¸ë¨¼íŠ¸ êµ¬ë¶„ì„ 
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const segGeo = new THREE.BoxGeometry(0.05, 0.85, 0.05);
                    const seg = new THREE.Mesh(segGeo, darkHullMat);
                    seg.position.set(Math.cos(angle) * 3, 0, Math.sin(angle) * 3);
                    seg.rotation.y = -angle;
                    group.add(seg);
                }
                
                // === 2. ì¤‘ì•™ í—ˆë¸Œ (ì»¤ë§¨ë“œ ì„¼í„°) ===
                const hubGeo = new THREE.CylinderGeometry(0.8, 1.0, 2.5, 12);
                const hub = new THREE.Mesh(hubGeo, hullMat);
                group.add(hub);
                
                // í—ˆë¸Œ ìƒë‹¨ ë” (ê´€ì¸¡ì‹¤)
                const domeGeo = new THREE.SphereGeometry(0.85, 24, 12, 0, Math.PI * 2, 0, Math.PI / 2);
                const dome = new THREE.Mesh(domeGeo, windowMat);
                dome.position.y = 1.25;
                group.add(dome);
                
                // í—ˆë¸Œ í•˜ë‹¨ ë„í‚¹ í¬íŠ¸
                const dockBaseGeo = new THREE.CylinderGeometry(0.6, 0.8, 0.5, 8);
                const dockBase = new THREE.Mesh(dockBaseGeo, darkHullMat);
                dockBase.position.y = -1.5;
                group.add(dockBase);
                
                // === 3. ìŠ¤í¬í¬ (ë§ê³¼ í—ˆë¸Œ ì—°ê²°) ===
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2;
                    const spokeGeo = new THREE.CylinderGeometry(0.12, 0.12, 2.2, 8);
                    const spoke = new THREE.Mesh(spokeGeo, hullMat);
                    spoke.position.set(Math.cos(angle) * 1.5, 0, Math.sin(angle) * 1.5);
                    spoke.rotation.z = Math.PI / 2;
                    spoke.rotation.y = angle;
                    group.add(spoke);
                    
                    // ìŠ¤í¬í¬ ì—°ê²°ë¶€ ì¡°ì¸íŠ¸
                    const jointGeo = new THREE.SphereGeometry(0.18, 8, 8);
                    const jointInner = new THREE.Mesh(jointGeo, darkHullMat);
                    jointInner.position.set(Math.cos(angle) * 0.9, 0, Math.sin(angle) * 0.9);
                    group.add(jointInner);
                    const jointOuter = new THREE.Mesh(jointGeo, darkHullMat);
                    jointOuter.position.set(Math.cos(angle) * 2.6, 0, Math.sin(angle) * 2.6);
                    group.add(jointOuter);
                }
                
                // === 4. íƒœì–‘ê´‘ íŒ¨ë„ ì–´ë ˆì´ (íƒœì–‘ ì¶”ì ìš© ë³„ë„ ê·¸ë£¹) ===
                const solarArrayGroup = new THREE.Group();
                solarArrayGroup.name = 'solarArrayGroup';
                
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2 + Math.PI / 8;
                    const panelGroup = new THREE.Group();
                    
                    // íŒ¨ë„ ì•”
                    const armGeo = new THREE.CylinderGeometry(0.04, 0.04, 3.5, 6);
                    const arm = new THREE.Mesh(armGeo, darkHullMat);
                    arm.rotation.z = Math.PI / 2;
                    panelGroup.add(arm);
                    
                    // ëŒ€í˜• íŒ¨ë„ë“¤
                    for (let p = -1; p <= 1; p += 2) {
                        const panel = new THREE.Group();
                        // íŒ¨ë„ í”„ë ˆì„
                        const frameGeo = new THREE.BoxGeometry(2.8, 0.05, 1.2);
                        const frame = new THREE.Mesh(frameGeo, darkHullMat);
                        panel.add(frame);
                        // íŒ¨ë„ ì…€
                        const cellGeo = new THREE.BoxGeometry(2.6, 0.03, 1.0);
                        const cell = new THREE.Mesh(cellGeo, panelMat);
                        cell.position.y = 0.02;
                        panel.add(cell);
                        // íŒ¨ë„ ì„¸ë¶€ ê·¸ë¦¬ë“œ
                        for (let g = -2; g <= 2; g++) {
                            const gridGeo = new THREE.BoxGeometry(0.02, 0.06, 1.0);
                            const grid = new THREE.Mesh(gridGeo, darkHullMat);
                            grid.position.x = g * 0.5;
                            panel.add(grid);
                        }
                        panel.position.x = p * 1.5;
                        panelGroup.add(panel);
                    }
                    
                    panelGroup.position.set(Math.cos(angle) * 4.5, 0.8, Math.sin(angle) * 4.5);
                    panelGroup.rotation.y = -angle + Math.PI / 2;
                    solarArrayGroup.add(panelGroup);
                }
                group.add(solarArrayGroup);
                
                // === 5. ë„í‚¹ ë² ì´ (4ê°œ) ===
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2 + Math.PI / 4;
                    const dockGroup = new THREE.Group();
                    
                    // ë„í‚¹ ì•”
                    const dockArmGeo = new THREE.BoxGeometry(0.3, 0.2, 1.5);
                    const dockArm = new THREE.Mesh(dockArmGeo, hullMat);
                    dockArm.position.z = 0.75;
                    dockGroup.add(dockArm);
                    
                    // ë„í‚¹ í¬íŠ¸ (ë§ í˜•íƒœ)
                    const portGeo = new THREE.TorusGeometry(0.25, 0.06, 8, 16);
                    const port = new THREE.Mesh(portGeo, accentMat);
                    port.position.z = 1.5;
                    dockGroup.add(port);
                    
                    // ë„í‚¹ ì¡°ëª…
                    const lightGeo = new THREE.SphereGeometry(0.05, 8, 8);
                    const dockLight = new THREE.Mesh(lightGeo, glowMat);
                    dockLight.position.set(0, 0.15, 1.5);
                    dockGroup.add(dockLight);
                    
                    dockGroup.position.set(Math.cos(angle) * 3.5, -0.3, Math.sin(angle) * 3.5);
                    dockGroup.rotation.y = -angle;
                    group.add(dockGroup);
                }
                
                // === 6. ì•ˆí…Œë‚˜ ì–´ë ˆì´ ===
                // ìƒë‹¨ ì£¼ ì•ˆí…Œë‚˜
                const mainAntennaGeo = new THREE.CylinderGeometry(0.02, 0.02, 1.5, 6);
                const mainAntenna = new THREE.Mesh(mainAntennaGeo, darkHullMat);
                mainAntenna.position.y = 2.5;
                group.add(mainAntenna);
                
                // ì•ˆí…Œë‚˜ ì ‘ì‹œ
                const dishGeo = new THREE.SphereGeometry(0.4, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2);
                const dish = new THREE.Mesh(dishGeo, hullMat);
                dish.position.y = 3.2;
                dish.rotation.x = Math.PI;
                group.add(dish);
                
                // ë¶€ ì•ˆí…Œë‚˜ë“¤
                for (let i = 0; i < 3; i++) {
                    const angle = (i / 3) * Math.PI * 2;
                    const subAntennaGeo = new THREE.CylinderGeometry(0.015, 0.015, 0.8, 4);
                    const subAntenna = new THREE.Mesh(subAntennaGeo, darkHullMat);
                    subAntenna.position.set(Math.cos(angle) * 0.5, 2.8, Math.sin(angle) * 0.5);
                    subAntenna.rotation.z = 0.3;
                    subAntenna.rotation.y = angle;
                    group.add(subAntenna);
                }
                
                // === 7. ì™¸ë¶€ ì¡°ëª… ===
                // í•­ë²• ì¡°ëª… (ë¹¨ê°•/ë…¹ìƒ‰)
                const navLightGeoR = new THREE.SphereGeometry(0.08, 8, 8);
                const navLightMatR = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const navLightR = new THREE.Mesh(navLightGeoR, navLightMatR);
                navLightR.position.set(4.5, 0, 0);
                group.add(navLightR);
                
                const navLightMatG = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                const navLightG = new THREE.Mesh(navLightGeoR, navLightMatG);
                navLightG.position.set(-4.5, 0, 0);
                group.add(navLightG);
                
                // ìŠ¤íŠ¸ë¡œë¸Œ ì¡°ëª…
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2;
                    const strobeGeo = new THREE.SphereGeometry(0.06, 6, 6);
                    const strobeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                    const strobe = new THREE.Mesh(strobeGeo, strobeMat);
                    strobe.position.set(Math.cos(angle) * 3, 0.5, Math.sin(angle) * 3);
                    strobe.name = 'strobe_' + i;
                    group.add(strobe);
                }
                
                // === 8. í™”ë¬¼ ëª¨ë“ˆ ===
                const cargoGeo = new THREE.BoxGeometry(0.8, 0.6, 1.2);
                const cargo1 = new THREE.Mesh(cargoGeo, darkHullMat);
                cargo1.position.set(1.2, -1.2, 0.8);
                group.add(cargo1);
                const cargo2 = new THREE.Mesh(cargoGeo, darkHullMat);
                cargo2.position.set(-1.0, -1.2, -0.6);
                group.add(cargo2);
                
                // === 9. ì—°êµ¬ ëª¨ë“ˆ ===
                const labGeo = new THREE.CylinderGeometry(0.35, 0.35, 1.8, 8);
                const lab = new THREE.Mesh(labGeo, hullMat);
                lab.position.set(0, -2.2, 0);
                group.add(lab);
                
                // ì—°êµ¬ ëª¨ë“ˆ ì°½ë¬¸
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    const labWindowGeo = new THREE.BoxGeometry(0.12, 0.08, 0.05);
                    const labWindow = new THREE.Mesh(labWindowGeo, windowMat);
                    labWindow.position.set(
                        Math.cos(angle) * 0.33,
                        -2.2,
                        Math.sin(angle) * 0.33
                    );
                    labWindow.rotation.y = -angle;
                    group.add(labWindow);
                }
                
                // === 10. ì¶”ì§„ ëª¨ë“ˆ ===
                const thrusterGeo = new THREE.ConeGeometry(0.15, 0.4, 8);
                const thrusterMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.9 });
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2 + Math.PI / 4;
                    const thruster = new THREE.Mesh(thrusterGeo, thrusterMat);
                    thruster.position.set(
                        Math.cos(angle) * 0.5,
                        -3.0,
                        Math.sin(angle) * 0.5
                    );
                    thruster.rotation.x = Math.PI;
                    group.add(thruster);
                }
                
                // === í¬ì¸íŠ¸ ë¼ì´íŠ¸ (ì •ê±°ì¥ ì¡°ëª…) ===
                const stationLight = new THREE.PointLight(0x88ccff, 1.5, 15);
                stationLight.position.set(0, 0, 0);
                group.add(stationLight);
                
                // ì „ì²´ ìŠ¤ì¼€ì¼ ì¡°ì • (ë” í¬ê²Œ)
                group.scale.set(0.12, 0.12, 0.12);
                
                // â˜…â˜…â˜… ê·¸ë¦¼ì ì„¤ì • (ì •ê±°ì¥ ì „ì²´) â˜…â˜…â˜…
                group.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                
                // íšŒì „ ì• ë‹ˆë©”ì´ì…˜ìš© ë°ì´í„° ì €ì¥
                group.userData.isStation = true;
                group.userData.ringMesh = ring;
                
                mesh = group;
            } else {
                const geo = new THREE.SphereGeometry(typeData.r, 32, 32);
                const mat = new THREE.MeshStandardMaterial({ color: typeData.color || 0x888888, roughness: 0.9 });
                if (typeData.texKey) {
                   const url = TEXTURES[typeData.texKey] ? ASSET_PATH + TEXTURES[typeData.texKey].map : null;
                   if(url) textureLoader.load(url, (t) => { mat.map = t; mat.needsUpdate = true; });
                } else {
                    mat.map = generateProceduralTexture('rock', typeData.color || 0x888888);
                }
                mesh = new THREE.Mesh(geo, mat);
                mesh.castShadow = true; mesh.receiveShadow = true;
                // â˜… ìœ„ì„±ë„ VISUAL_SCALE ì ìš© (10ë°°)
                const moonScale = getVisualScale('moon');
                mesh.scale.setScalar(moonScale);
            }
            const div = document.createElement('div');
            div.className = 'label';
            div.dataset.bodyName = name;  // ì›ë³¸ ì´ë¦„ ì €ì¥
            div.textContent = translateBodyName(name);  // ë²ˆì—­ëœ ì´ë¦„ í‘œì‹œ
            div.style.color = isSpaceStation ? '#00ffff' : '#cccccc';
            if (isSpaceStation) div.style.fontSize = '9px';
            const label = new CSS2DObject(div);
            const satRadius = isSpaceStation ? 0.5 : (typeData ? typeData.r : 0.3);
            label.position.set(0, satRadius * 1.02, 0);  // ì²œì²´ ë°”ë¡œ ìœ„
            mesh.add(label);
            scene.add(mesh);
            
            // â˜…â˜…â˜… ë©€í‹°ëª¨ë“œ: ì„œë²„ ë™ê¸°í™” ì‹œê°„ ê¸°ì¤€ ì´ˆê¸° ê°ë„ â˜…â˜…â˜…
            let initialAngle;
            if (window.gameMode === 'multi') {
                const seed = name ? name.split('').reduce((a, c) => a + c.charCodeAt(0), 0) : 0;
                const syncedTime = typeof getSyncedTime === 'function' ? getSyncedTime() : Date.now();
                const baseTime = syncedTime * 0.0000001;
                initialAngle = (seed * 0.1 + baseTime * speed) % (Math.PI * 2);
            } else {
                initialAngle = Math.random() * Math.PI * 2;
            }

            // ìœ„ì„± ë¬¼ë¦¬ ì†ì„± (ëª¨ë“  ìœ„ì„±ì€ ë¶€ëª¨ í–‰ì„± ë”°ë¼ê°€ë©° ê³µì „)
            const satellite = {
                mesh: mesh, name: name, type: isSpaceStation ? "station" : "moon",
                isSpaceStation: isSpaceStation,  // â˜… ì¶”ê°€: ìš°ì£¼ì •ê±°ì¥ ì—¬ë¶€
                parentBody: parentBody, orbitRadius: dist, orbitSpeed: speed, angle: initialAngle,
                realOrbitRadius: dist,  // ì‹¤ì œ ê±°ë¦¬ ë¹„ìœ¨ (ë‚˜ì¤‘ì— ì„¤ì •)
                // â˜…â˜…â˜… ìœ„ì„±ì€ ë¬¼ë¦¬ ë¹„í™œì„±í™” - ë¶€ëª¨ í–‰ì„± ë”°ë¼ê° (ì•ˆì •ì ) â˜…â˜…â˜…
                mass: isSpaceStation ? 0.001 : (typeData ? typeData.m : 0.01),
                radius: isSpaceStation ? 0.5 : (typeData ? typeData.r : 0.3),
                velocity: new THREE.Vector3(0, 0, 0),
                force: new THREE.Vector3(0, 0, 0),
                isPhysicsEnabled: false,  // â˜… ìœ„ì„±ì€ ë¬¼ë¦¬ ë¹„í™œì„±í™” (ë¶€ëª¨ ë”°ë¼ê°)
                isStatic: false
            };
            
            // â˜… ì´ˆê¸° ìœ„ì¹˜ ì„¤ì • (ë¶€ëª¨ í–‰ì„± ì£¼ë³€)
            const initR = dist;  // ì´ˆê¸° ê¶¤ë„ ë°˜ê²½
            mesh.position.x = parentBody.mesh.position.x + Math.cos(satellite.angle) * initR;
            mesh.position.z = parentBody.mesh.position.z + Math.sin(satellite.angle) * initR;
            mesh.position.y = parentBody.mesh.position.y;
            
            satellites.push(satellite);
            return satellite;
        }

        function createMoons() {
            // ìœ„ì„±ì— ì´ˆê¸° ê¶¤ë„ ìœ„ì¹˜ ì„¤ì •í•˜ëŠ” í—¬í¼ í•¨ìˆ˜
            function initMoonOrbit(moon, parent) {
                if (!moon || !parent || !parent.mesh || !moon.mesh) return;
                
                // ì‹¤ì œ ê±°ë¦¬ ëª¨ë“œ í™•ì¸
                const isRealMode = CONFIG.distScale > 1.0;
                
                // ì´ˆê¸° ìœ„ì¹˜ ì„¤ì • - ì‹¤ì œ ëª¨ë“œë©´ realOrbitRadius ì‚¬ìš©
                let r;
                if (isRealMode && moon.realOrbitRadius) {
                    // â˜… visualScale ì ìš© (10ë°° ìŠ¤ì¼€ì¼ ë°˜ì˜)
                    const parentScale = parent.visualScale || 1;
                    r = moon.realOrbitRadius * (parent.radius || 1) * parentScale;
                } else {
                    r = moon.orbitRadius;
                }
                
                const angle = moon.angle;
                moon.mesh.position.x = parent.mesh.position.x + Math.cos(angle) * r;
                moon.mesh.position.z = parent.mesh.position.z + Math.sin(angle) * r;
                moon.mesh.position.y = parent.mesh.position.y;
            }
            
            const earth = bodies.find(b => b.name === "ì§€êµ¬");
            if (earth) { 
                // ë‹¬ ê³µì „ ì£¼ê¸°: 27.3ì¼, ì§€êµ¬ ê³µì „ ì£¼ê¸°: 365.25ì¼
                // ë‹¬ì€ ì§€êµ¬ ê³µì „ ëŒ€ë¹„ ì•½ 13.4ë°° ë¹ ë¥´ê²Œ ê³µì „
                // ì§€êµ¬ orbitSpeed ê¸°ì¤€ìœ¼ë¡œ ë‹¬ ì†ë„ ê³„ì‚°
                const moonOrbitSpeed = 2.5;  // ë‹¬ ê³µì „ ì†ë„ (ê²Œì„ ë‚´ ì‹œê°ì  ì†ë„)
                const moon = createSatellite(earth, DEFAULT_TYPES.MOON, 6, moonOrbitSpeed, "ë‹¬", false); 
                moon.realOrbitRadius = 60;  // ì‹¤ì œ: ì§€êµ¬ ë°˜ì§€ë¦„ì˜ 60ë°°
                moon.orbitalPeriod = 27.3;  // ê³µì „ ì£¼ê¸° (ì¼)
                initMoonOrbit(moon, earth);
                
                // ISS: ë‹¬(6) ë°”ê¹¥ ê¶¤ë„ â†’ 12ë¡œ ë” ë©€ë¦¬
                const iss = createSatellite(earth, null, 12, 0.5, "ISS ìš°ì£¼ì •ê±°ì¥", true);  // ì†ë„ 2.5 â†’ 0.5 (5ë°° ê°ì†Œ)
                iss.realOrbitRadius = 15;
                iss.stationSize = 0.1;  // ì§€êµ¬ ì •ê±°ì¥ - 1/5 ì¶•ì†Œ
                iss.hasFuel = true;  // ì—°ë£Œ ì¶©ì „ ê°€ëŠ¥
                if (iss.mesh) iss.mesh.scale.setScalar(0.1);  // 1/5 ì¶•ì†Œ
            }
            
            // â˜… ê¸ˆì„± ì •ê±°ì¥ (ìœ„ì„± ì—†ìŒ â†’ ë„“ì€ ê¶¤ë„)
            const venus = bodies.find(b => b.name === "ê¸ˆì„±");
            if (venus) {
                const venusStation = createSatellite(venus, null, 7, 0.6, "ë¹„ë„ˆìŠ¤ í”Œë«í¼", true);  // ì†ë„ 3.0 â†’ 0.6
                venusStation.realOrbitRadius = 8;
                venusStation.stationSize = 0.05;  // 1/5 ì¶•ì†Œ
                venusStation.hasFuel = true;
                if (venusStation.mesh) venusStation.mesh.scale.setScalar(0.05);  // 1/5 ì¶•ì†Œ
            }
            
            const mars = bodies.find(b => b.name === "í™”ì„±");
            if (mars) { 
                // í¬ë³´ìŠ¤ ê³µì „ ì£¼ê¸°: 0.32ì¼ (ë§¤ìš° ë¹ ë¦„)
                const phobos = createSatellite(mars, DEFAULT_TYPES.PHOBOS, 2.5, 8.0, "í¬ë³´ìŠ¤"); 
                phobos.realOrbitRadius = 2.76;
                initMoonOrbit(phobos, mars);
                
                // ë°ì´ëª¨ìŠ¤ ê³µì „ ì£¼ê¸°: 1.26ì¼
                const deimos = createSatellite(mars, DEFAULT_TYPES.DEIMOS, 4.0, 4.0, "ë°ì´ëª¨ìŠ¤"); 
                deimos.realOrbitRadius = 6.9;
                initMoonOrbit(deimos, mars);
                
                // â˜… í™”ì„± ì •ê±°ì¥: ë°ì´ëª¨ìŠ¤(4.0) ë°”ê¹¥ ê¶¤ë„ â†’ 7
                const marsStation = createSatellite(mars, null, 7, 0.6, "ë§ˆìŠ¤ ìŠ¤í…Œì´ì…˜", true);  // ì†ë„ 3.0 â†’ 0.6
                marsStation.realOrbitRadius = 8;
                marsStation.stationSize = 0.05;  // 1/5 ì¶•ì†Œ
                marsStation.hasFuel = true;
                if (marsStation.mesh) marsStation.mesh.scale.setScalar(0.05);  // 1/5 ì¶•ì†Œ
            }
            const jupiter = bodies.find(b => b.name === "ëª©ì„±");
            if (jupiter) { 
                // ì´ì˜¤ ê³µì „ ì£¼ê¸°: 1.77ì¼
                const io = createSatellite(jupiter, DEFAULT_TYPES.IO, 3.0, 6.0, "ì´ì˜¤"); 
                io.realOrbitRadius = 5.9;
                initMoonOrbit(io, jupiter);
                
                // ìœ ë¡œíŒŒ ê³µì „ ì£¼ê¸°: 3.55ì¼
                const europa = createSatellite(jupiter, DEFAULT_TYPES.EUROPA, 4.0, 4.5, "ìœ ë¡œíŒŒ"); 
                europa.realOrbitRadius = 9.4;
                initMoonOrbit(europa, jupiter);
                
                // ê°€ë‹ˆë©”ë° ê³µì „ ì£¼ê¸°: 7.15ì¼
                const ganymede = createSatellite(jupiter, DEFAULT_TYPES.GANYMEDE, 5.5, 3.0, "ê°€ë‹ˆë©”ë°"); 
                ganymede.realOrbitRadius = 15;
                initMoonOrbit(ganymede, jupiter);
                
                // ì¹¼ë¦¬ìŠ¤í†  ê³µì „ ì£¼ê¸°: 16.69ì¼
                const callisto = createSatellite(jupiter, DEFAULT_TYPES.CALLISTO, 7.0, 2.0, "ì¹¼ë¦¬ìŠ¤í† "); 
                callisto.realOrbitRadius = 26;
                initMoonOrbit(callisto, jupiter);
                
                // â˜… ëª©ì„± ì •ê±°ì¥: ì¹¼ë¦¬ìŠ¤í† (7.0) ë°”ê¹¥ ê¶¤ë„ â†’ 12
                const jupiterStation = createSatellite(jupiter, null, 12, 0.3, "ì£¼í”¼í„° ì•„ì›ƒí¬ìŠ¤íŠ¸", true);  // ì†ë„ 1.5 â†’ 0.3
                jupiterStation.realOrbitRadius = 35;
                jupiterStation.stationSize = 0.05;  // 1/5 ì¶•ì†Œ
                jupiterStation.hasFuel = true;
                if (jupiterStation.mesh) jupiterStation.mesh.scale.setScalar(0.05);  // 1/5 ì¶•ì†Œ
            }
            const saturn = bodies.find(b => b.name === "í† ì„±");
            if (saturn) { 
                // íƒ€ì´íƒ„ ê³µì „ ì£¼ê¸°: 15.95ì¼
                const titan = createSatellite(saturn, DEFAULT_TYPES.TITAN, 4.0, 2.5, "íƒ€ì´íƒ„"); 
                titan.realOrbitRadius = 20;
                initMoonOrbit(titan, saturn);
                
                // ì—”ì…€ë¼ë‘ìŠ¤ ê³µì „ ì£¼ê¸°: 1.37ì¼
                const enceladus = createSatellite(saturn, DEFAULT_TYPES.ENCELADUS, 2.0, 6.0, "ì—”ì…€ë¼ë‘ìŠ¤"); 
                enceladus.realOrbitRadius = 4;
                initMoonOrbit(enceladus, saturn);
                
                // â˜… í† ì„± ì •ê±°ì¥: íƒ€ì´íƒ„(4.0) ë°”ê¹¥ ê¶¤ë„ â†’ 8
                const saturnStation = createSatellite(saturn, null, 8, 0.4, "ìƒˆí„´ ë² ì´ìŠ¤", true);  // ì†ë„ 2.0 â†’ 0.4
                saturnStation.realOrbitRadius = 30;
                saturnStation.stationSize = 0.05;  // 1/5 ì¶•ì†Œ
                saturnStation.hasFuel = true;
                if (saturnStation.mesh) saturnStation.mesh.scale.setScalar(0.05);  // 1/5 ì¶•ì†Œ
            }
            const uranus = bodies.find(b => b.name === "ì²œì™•ì„±");
            if (uranus) { 
                // í‹°íƒ€ë‹ˆì•„ ê³µì „ ì£¼ê¸°: 8.7ì¼
                const titania = createSatellite(uranus, DEFAULT_TYPES.TITANIA, 3.5, 3.0, "í‹°íƒ€ë‹ˆì•„"); 
                titania.realOrbitRadius = 17;
                initMoonOrbit(titania, uranus);
                
                // ì˜¤ë² ë¡  ê³µì „ ì£¼ê¸°: 13.5ì¼
                const oberon = createSatellite(uranus, DEFAULT_TYPES.OBERON, 4.5, 2.0, "ì˜¤ë² ë¡ "); 
                oberon.realOrbitRadius = 23;
                initMoonOrbit(oberon, uranus);
                
                // â˜… ì²œì™•ì„± ì •ê±°ì¥: ì˜¤ë² ë¡ (4.5) ë°”ê¹¥ ê¶¤ë„ â†’ 8
                const uranusStation = createSatellite(uranus, null, 8, 0.3, "ìš°ë¼ë…¸ìŠ¤ ë¦´ë ˆì´", true);  // ì†ë„ 1.5 â†’ 0.3
                uranusStation.realOrbitRadius = 30;
                uranusStation.stationSize = 0.05;  // 1/5 ì¶•ì†Œ
                uranusStation.hasFuel = true;
                if (uranusStation.mesh) uranusStation.mesh.scale.setScalar(0.05);  // 1/5 ì¶•ì†Œ
            }
            const neptune = bodies.find(b => b.name === "í•´ì™•ì„±");
            if (neptune) { 
                // íŠ¸ë¦¬í†¤ ê³µì „ ì£¼ê¸°: 5.88ì¼ (ì—­í–‰)
                const triton = createSatellite(neptune, DEFAULT_TYPES.TRITON, 3.5, -3.5, "íŠ¸ë¦¬í†¤"); 
                triton.realOrbitRadius = 14;
                initMoonOrbit(triton, neptune);
                
                // â˜… í•´ì™•ì„± ì •ê±°ì¥: íŠ¸ë¦¬í†¤(3.5) ë°”ê¹¥ ê¶¤ë„ â†’ 8
                const neptuneStation = createSatellite(neptune, null, 8, 0.2, "ë„µíŠ  í„°ë¯¸ë„", true);  // ì†ë„ 1.0 â†’ 0.2
                neptuneStation.realOrbitRadius = 25;
                neptuneStation.stationSize = 0.05;  // 1/5 ì¶•ì†Œ
                neptuneStation.hasFuel = true;
                if (neptuneStation.mesh) neptuneStation.mesh.scale.setScalar(0.05);  // 1/5 ì¶•ì†Œ
            }
            
            // â˜…â˜…â˜… ì¤‘ê°„ ê¶¤ë„ ì—°ë£Œ ì •ê±°ì¥ ìƒì„± â˜…â˜…â˜…
            createFuelDepots();
            
            updateNavList();
        }
        
        // ì¤‘ê°„ ê¶¤ë„ ì—°ë£Œ ì •ê±°ì¥ ìƒì„± í•¨ìˆ˜
        function createFuelDepots() {
            const sun = bodies.find(b => b.name === "íƒœì–‘");
            if (!sun) return;
            
            // ì—°ë£Œ ì •ê±°ì¥ ë°ì´í„° (íƒœì–‘ ê¸°ì¤€ ì ˆëŒ€ ìœ„ì¹˜) - 10ë°° í™•ëŒ€
            const depots = [
                { name: "ì—°ë£Œì •ê±°ì¥ ì•ŒíŒŒ", orbit: 1200, desc: "ì§€êµ¬-í™”ì„± ì¤‘ê°„" },  // ì§€êµ¬~í™”ì„± (10ë°°)
                { name: "ì—°ë£Œì •ê±°ì¥ ë² íƒ€", orbit: 3500, desc: "í™”ì„±-ëª©ì„± ì¤‘ê°„ (ì†Œí–‰ì„±ëŒ€)" },  // í™”ì„±~ëª©ì„± (10ë°°)
                { name: "ì—°ë£Œì •ê±°ì¥ ê°ë§ˆ", orbit: 6500, desc: "ëª©ì„±-í† ì„± ì¤‘ê°„" },  // ëª©ì„±~í† ì„± (10ë°°)
                { name: "ì—°ë£Œì •ê±°ì¥ ë¸íƒ€", orbit: 12000, desc: "í† ì„±-ì²œì™•ì„± ì¤‘ê°„" }  // í† ì„±~ì²œì™•ì„± (10ë°°)
            ];
            
            depots.forEach((depot, i) => {
                // ì—°ë£Œ ì •ê±°ì¥ ë©”ì‰¬ ìƒì„± (í† ëŸ¬ìŠ¤ í˜•íƒœ) - 1/20 í¬ê¸°
                const torusGeo = new THREE.TorusGeometry(0.4, 0.15, 8, 16);
                const torusMat = new THREE.MeshStandardMaterial({ 
                    color: 0xff6600, 
                    emissive: 0x331100,
                    metalness: 0.8, 
                    roughness: 0.3 
                });
                const mesh = new THREE.Mesh(torusGeo, torusMat);
                mesh.rotation.x = Math.PI / 2;
                mesh.scale.setScalar(0.1);  // 1/5 ì¶•ì†Œ
                
                // íƒœì–‘ ì£¼ìœ„ ê¶¤ë„ ìœ„ì¹˜
                const angle = (i * Math.PI / 2) + Math.PI / 4;  // ê· ë“± ë¶„í¬
                mesh.position.x = Math.cos(angle) * depot.orbit;
                mesh.position.z = Math.sin(angle) * depot.orbit;
                mesh.position.y = 0;
                
                // ë¼ë²¨ - ë²ˆì—­ ì ìš©
                const div = document.createElement('div');
                div.className = 'label';
                div.dataset.bodyName = depot.name;  // ì›ë³¸ ì´ë¦„ ì €ì¥
                div.textContent = translateBodyName(depot.name);  // ë²ˆì—­ëœ ì´ë¦„
                div.style.color = '#ff6600';
                div.style.fontSize = '8px';
                const label = new CSS2DObject(div);
                label.position.set(0, 0.6, 0);
                mesh.add(label);
                
                scene.add(mesh);
                
                // satellites ë°°ì—´ì— ì¶”ê°€
                const fuelDepot = {
                    mesh: mesh,
                    name: depot.name,
                    type: 'station',
                    isFuelDepot: true,  // ì—°ë£Œ ì •ê±°ì¥ êµ¬ë¶„
                    description: depot.desc,
                    orbitRadius: depot.orbit,
                    orbitSpeed: 0.01 / Math.sqrt(depot.orbit),  // ì¼€í”ŒëŸ¬ ë²•ì¹™
                    angle: angle,
                    parentBody: sun,
                    stationSize: 0.03,  // 1/5 ì¶•ì†Œ
                    hasFuel: true,
                    mass: 0.0001,
                    velocity: new THREE.Vector3(0, 0, 0),
                    isPhysicsEnabled: false
                };
                satellites.push(fuelDepot);
            });
        }

        function initChat() {
            var toggle = document.getElementById('chat-toggle'); 
            var panel = document.getElementById('chat-panel'); 
            var close = document.getElementById('chat-close'); 
            var send = document.getElementById('chat-send'); 
            var input = document.getElementById('chat-input'); 
            var messages = document.getElementById('chat-messages');
            
            toggle.onclick = function() { 
                panel.classList.toggle('open'); 
                if (panel.classList.contains('open')) input.focus(); 
            }; 
            close.onclick = function() { panel.classList.remove('open'); };
            
            var sendMessage = function() { 
                var text = input.value.trim(); 
                if (!text) return; 
                addMessage(text, 'user'); 
                input.value = ''; 
                addMessage('ë‹µë³€ ìƒì„± ì¤‘...', 'system'); 
                
                callGeminiAPI(text)
                    .then(function(response) {
                        messages.removeChild(messages.lastChild); 
                        addMessage(response, 'ai'); 
                    })
                    .catch(function(error) { 
                        messages.removeChild(messages.lastChild); 
                        console.error(error); 
                        addMessage('ì˜¤ë¥˜ ë°œìƒ: ' + error.message, 'system'); 
                    });
            };
            send.onclick = sendMessage; 
            input.onkeypress = function(e) { if (e.key === 'Enter') sendMessage(); };
        }
        
        function addMessage(text, type) { 
            var messages = document.getElementById('chat-messages'); 
            var div = document.createElement('div'); 
            div.className = 'msg ' + type; 
            div.textContent = text; 
            messages.appendChild(div); 
            messages.scrollTop = messages.scrollHeight; 
        }
        
        function callGeminiAPI(query) { 
            var systemPrompt = 'ë‹¹ì‹ ì€ ìš°ì£¼ ì‹œë®¬ë ˆì´ì…˜ ê²Œì„ì˜ ì „ë¬¸ ë„ìš°ë¯¸ì…ë‹ˆë‹¤.\n' +
'ë‹¤ìŒ ì£¼ì œì— ëŒ€í•´ì„œë§Œ ë‹µë³€í•˜ì„¸ìš”:\n' +
'- ìš°ì£¼, í–‰ì„±, íƒœì–‘ê³„, ì²œì²´ì— ê´€í•œ ì§ˆë¬¸\n' +
'- ìš°ì£¼ì„  ì¡°ì¢…, ë¹„í–‰, í•­í•´ì— ê´€í•œ ì§ˆë¬¸\n' +
'- ì´ ì‹œë®¬ë ˆì´ì…˜ ê²Œì„ì˜ ì¡°ì‘ë²•, ê¸°ëŠ¥ì— ê´€í•œ ì§ˆë¬¸\n' +
'- ìš°ì£¼ íƒì‚¬, ìš°ì£¼ì •ê±°ì¥, ê¶¤ë„ì— ê´€í•œ ì§ˆë¬¸\n' +
'- ì²œë¬¸í•™, ë¬¼ë¦¬í•™(ì¤‘ë ¥, ê¶¤ë„ì—­í•™ ë“±)ì— ê´€í•œ ì§ˆë¬¸\n\n' +
'ìœ„ ì£¼ì œì™€ ê´€ë ¨ ì—†ëŠ” ì§ˆë¬¸(ì¼ìƒëŒ€í™”, ë‹¤ë¥¸ ë¶„ì•¼ì˜ ì§ˆë¬¸ ë“±)ì—ëŠ” ë°˜ë“œì‹œ ë‹¤ìŒê³¼ ê°™ì´ ë‹µë³€í•˜ì„¸ìš”:\n' +
'"ì£„ì†¡í•©ë‹ˆë‹¤. ì €ëŠ” ìš°ì£¼ ì‹œë®¬ë ˆì´ì…˜ ê´€ë ¨ ì§ˆë¬¸ì—ë§Œ ë‹µë³€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ğŸš€"\n\n' +
'ë‹µë³€ì€ ê°„ê²°í•˜ê³  ì¹œì ˆí•˜ê²Œ í•´ì£¼ì„¸ìš”.';
            
            // Vercel: /api/gemini, ë¡œì»¬: gemini_proxy.php
            const geminiUrl = window.location.hostname.includes('vercel') ? '/api/gemini' : 'gemini_proxy.php';
            return fetch(geminiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    systemInstruction: { parts: [{ text: systemPrompt }] },
                    contents: [{ parts: [{ text: query }] }]
                })
            })
            .then(function(response) {
                if (!response.ok) throw new Error('API/Server Error'); 
                return response.json();
            })
            .then(function(data) {
                var answer = data.candidates && data.candidates[0] && 
                             data.candidates[0].content && data.candidates[0].content.parts && 
                             data.candidates[0].content.parts[0] && data.candidates[0].content.parts[0].text;
                return answer || "ë‹µë³€ì„ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.";
            });
        }
        
        // â˜… ships.jsonì—ì„œ ìš°ì£¼ì„  ì´ë¯¸ì§€/ëª¨ë¸ ë¡œë“œ
        let shipsDataLoaded = false;

        // â˜… ìš°ì£¼ì„  íŒŒì¼ ê²½ë¡œë¥¼ Supabase Storageë¡œ ë³€í™˜
        function convertToSupabaseUrl(path) {
            if (!path || path.length === 0) return path;

            if (path.startsWith('http')) return path;  // ì´ë¯¸ ì ˆëŒ€ URL
            if (path.startsWith('uploads/')) {
                const filename = path.replace('uploads/', '').replace('ships/', '');
                return SUPABASE_STORAGE + 'ships/' + filename;
            }
            return path;
        }
        
        // â˜…â˜…â˜… Supabaseì—ì„œ ì§ì ‘ ë¡œë“œ (admin.htmlê³¼ ë™ì¼í•œ ë°©ì‹) â˜…â˜…â˜…
        async function loadShipsData() {
            let attempt = 0;

            const showLoading = (msg) => {
                let el = document.getElementById('ships-loading-overlay');
                if (!el) {
                    el = document.createElement('div');
                    el.id = 'ships-loading-overlay';
                    el.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.95);display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:99999;color:#0ff;font-family:Orbitron,sans-serif;';
                    document.body.appendChild(el);
                }
                el.innerHTML = `<div style="font-size:24px;margin-bottom:20px;">ğŸš€ LOADING SHIP DATA</div><div style="font-size:14px;color:#888;">${msg}</div>`;
            };

            const hideLoading = () => {
                const el = document.getElementById('ships-loading-overlay');
                if (el) el.remove();
            };

            // Supabase í´ë¼ì´ì–¸íŠ¸ ìƒì„± (admin.htmlê³¼ ë™ì¼)
            const supabase = window.supabase ? window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY) : null;

            while (true) {
                attempt++;
                showLoading(`Supabase ì—°ê²° ì‹œë„ ${attempt}...`);

                try {
                    if (!supabase) throw new Error('Supabase SDK ë¯¸ë¡œë“œ');

                    console.log(`ğŸš€ Supabaseì—ì„œ ships ì§ì ‘ ë¡œë“œ ì‹œë„ ${attempt}...`);

                    // â˜…â˜…â˜… admin.htmlê³¼ ë™ì¼í•œ ì¿¼ë¦¬ â˜…â˜…â˜…
                    const { data: shipsData, error } = await supabase
                        .from('ships')
                        .select('*')
                        .order('tier', { ascending: true });

                    if (error) throw error;
                    if (!shipsData || shipsData.length === 0) throw new Error('ë¹ˆ ë°ì´í„°');

                    console.log('ğŸ“¦ Supabase ships ë¡œë“œ ì„±ê³µ:', shipsData.length, 'ê°œ');
                    console.log('ğŸ“¦ ì²« ë²ˆì§¸ ìš°ì£¼ì„  raw:', shipsData[0]);

                    // â˜…â˜…â˜… DB ì»¬ëŸ¼ëª… ê·¸ëŒ€ë¡œ ì‚¬ìš© (snake_case) â˜…â˜…â˜…
                    shipsData.forEach(row => {
                        const ship = SHIP_TYPES.find(s => s.id === row.id);
                        if (ship) {
                            if (row.max_speed != null) ship.maxSpeed = Number(row.max_speed);
                            if (row.acceleration != null) ship.acceleration = Number(row.acceleration);
                            if (row.turn_speed != null) ship.turnSpeed = Number(row.turn_speed);
                            if (row.max_fuel != null) ship.maxFuel = Number(row.max_fuel);
                            if (row.max_hull != null) ship.maxHull = Number(row.max_hull);
                            if (row.capacity != null) ship.capacity = Number(row.capacity);  // ì ì¬ëŸ‰
                            if (row.price != null) ship.price = Number(row.price);
                            if (row.tier != null) ship.tier = Number(row.tier);
                            if (row.size) ship.size = row.size;
                            if (row.special !== undefined) ship.special = row.special;
                            if (row.unlocked !== undefined) ship.unlocked = row.unlocked;
                            if (row.image) ship.image = convertToSupabaseUrl(row.image);
                            if (row.model) ship.model = convertToSupabaseUrl(row.model);
                            if (row.engine_config) ship.engineConfig = row.engine_config;

                            console.log(`  âœ… ${ship.id}: turn_speed=${row.turn_speed} â†’ turnSpeed=${ship.turnSpeed}`);
                        }
                    });

                    // í˜„ì¬ ì„ íƒëœ ìš°ì£¼ì„  ê°±ì‹ 
                    if (window.currentShipType) {
                        const updated = SHIP_TYPES.find(s => s.id === window.currentShipType.id);
                        if (updated) {
                            window.currentShipType = updated;
                            console.log(`ğŸ¯ í˜„ì¬ ìš°ì£¼ì„ : ${updated.id}, turnSpeed=${updated.turnSpeed}`);
                        }
                    }

                    shipsDataLoaded = true;
                    hideLoading();
                    console.log('âœ… Supabaseì—ì„œ ìŠ¤íƒ¯ ì ìš© ì™„ë£Œ!');
                    return true;

                } catch (err) {
                    console.warn(`âš ï¸ ì‹œë„ ${attempt} ì‹¤íŒ¨:`, err.message);
                    showLoading(`ì—°ê²° ì‹¤íŒ¨: ${err.message} - 3ì´ˆ í›„ ì¬ì‹œë„`);
                    await new Promise(r => setTimeout(r, 3000));
                }
            }
        }
        
        async function loadDataAndInit() {
            // â˜…â˜…â˜… ìš°ì£¼ì„  ë°ì´í„° ë¨¼ì € ë¡œë“œí•˜ê³  ê¸°ë‹¤ë¦¼ â˜…â˜…â˜…
            console.log('ğŸ® ê²Œì„ ì´ˆê¸°í™” ì‹œì‘...');
            await loadShipsData();
            console.log('ğŸ® ìš°ì£¼ì„  ë°ì´í„° ë¡œë“œ ì™„ë£Œ, íƒœì–‘ê³„ ì´ˆê¸°í™”...');

            if (API_URL && window.location.protocol !== 'file:') {
                fetch(API_URL)
                    .then(res => {
                        if (!res.ok) throw new Error('Network response was not ok');
                        return res.json();
                    })
                    .then(data => {
                        Object.assign(DEFAULT_TYPES, data);
                        initSolarSystem(DEFAULT_TYPES);
                    })
                    .catch(err => {
                        console.log("Using default solar system data");
                        initSolarSystem(DEFAULT_TYPES);
                    });
            } else {
                initSolarSystem(DEFAULT_TYPES);
            }
        }

        function createDetailedGalaxy() { 
            // ì€í•˜ ì¤‘ì‹¬ ë¸”ë™í™€
            const bhSize = 8000;
            const bhGeo = new THREE.SphereGeometry(bhSize, 64, 64); 
            const bhMat = new THREE.MeshBasicMaterial({ color: 0x000000 }); 
            const blackHole = new THREE.Mesh(bhGeo, bhMat); 
            blackHole.position.copy(galaxyCenter);
            scene.add(blackHole); 
            
            // ì€í•˜ ì¤‘ì‹¬ ë²Œì§€ ê¸€ë¡œìš°
            const bulgeSize = 5000000;  // 10ë°° ì¦ê°€
            const bulgeGeo = new THREE.SphereGeometry(bulgeSize, 32, 32);
            const bulgeMat = new THREE.MeshBasicMaterial({
                color: 0xfffde8,
                transparent: true,
                opacity: 0.3,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            const bulge = new THREE.Mesh(bulgeGeo, bulgeMat);
            blackHole.add(bulge);
            
            // ë‚´ë¶€ ë²Œì§€ (ë” ë°ê²Œ)
            const innerBulgeGeo = new THREE.SphereGeometry(bulgeSize * 0.4, 32, 32);
            const innerBulgeMat = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.5,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            const innerBulge = new THREE.Mesh(innerBulgeGeo, innerBulgeMat);
            blackHole.add(innerBulge);
            
            // â˜… ê°•ì°©ì›ë°˜ ìƒì„±
            const accretionDiskGroup = new THREE.Group();
            accretionDiskGroup.name = 'accretionDisk';
            
            // ì—¬ëŸ¬ ì¸µì˜ ë§ìœ¼ë¡œ ê°•ì°©ì›ë°˜ êµ¬ì„±
            const diskLayers = [];
            const numLayers = 8;
            for (let i = 0; i < numLayers; i++) {
                const innerR = 100000 + i * 20000;
                const outerR = 120000 + i * 20000;
                const ringGeo = new THREE.RingGeometry(innerR, outerR, 128, 1);
                
                // ì•ˆìª½ì¼ìˆ˜ë¡ ë” ë°ê³  ëœ¨ê±°ìš´ ìƒ‰
                const heatLevel = 1 - (i / numLayers);
                const color = new THREE.Color();
                if (heatLevel > 0.7) {
                    color.setRGB(1, 1, 0.9);
                } else if (heatLevel > 0.5) {
                    color.setRGB(1, 0.8, 0.3);
                } else if (heatLevel > 0.3) {
                    color.setRGB(1, 0.4, 0.1);
                } else {
                    color.setRGB(0.8, 0.15, 0.05);
                }
                
                const ringMat = new THREE.MeshBasicMaterial({
                    color: color,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.6 + heatLevel * 0.4,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.userData.rotationSpeed = 0.001 + heatLevel * 0.004;
                ring.userData.layerIndex = i;
                diskLayers.push(ring);
                accretionDiskGroup.add(ring);
            }
            
            // ë©”ì¸ ê¸€ë¡œìš° ë””ìŠ¤í¬
            const mainDisk = new THREE.Mesh(
                new THREE.RingGeometry(100000, 350000, 128),
                new THREE.MeshBasicMaterial({ 
                    map: generateAccretionDiskTexture(), 
                    side: THREE.DoubleSide, 
                    transparent: true, 
                    blending: THREE.AdditiveBlending, 
                    depthWrite: false,
                    opacity: 0.8
                })
            );
            mainDisk.userData.rotationSpeed = 0.002;
            accretionDiskGroup.add(mainDisk);
            
            // ë‚´ë¶€ ê¸€ë¡œìš°
            const innerGlow = new THREE.Mesh(
                new THREE.RingGeometry(85000, 110000, 64),
                new THREE.MeshBasicMaterial({
                    color: 0xffffee,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.9,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                })
            );
            innerGlow.userData.rotationSpeed = 0.008;
            accretionDiskGroup.add(innerGlow);
            
            // ê°•ì°©ì›ë°˜ ê¸°ìš¸ê¸°
            accretionDiskGroup.rotation.x = Math.PI / 2;
            accretionDiskGroup.rotation.y = Math.PI / 8;
            blackHole.add(accretionDiskGroup);
            
            // ê°•ì°©ì›ë°˜ ë°ì´í„° ì €ì¥ (ì• ë‹ˆë©”ì´ì…˜ìš©)
            blackHole.userData.diskLayers = diskLayers;
            blackHole.userData.mainDisk = mainDisk;
            blackHole.userData.innerGlow = innerGlow;
            blackHole.userData.accretionDiskGroup = accretionDiskGroup;
            
            // ì œíŠ¸ (10ë°° í™•ëŒ€)
            const jetGeo = new THREE.CylinderGeometry(10000, 60000, 800000, 32, 1, true);
            jetGeo.translate(0, 400000, 0); 
            const jetMat = new THREE.MeshBasicMaterial({ map: generateJetTexture(), side: THREE.DoubleSide, transparent:true, blending:THREE.AdditiveBlending, depthWrite:false }); 
            const jetGroup = new THREE.Group(); 
            const jetUp = new THREE.Mesh(jetGeo, jetMat); 
            const jetDown = new THREE.Mesh(jetGeo, jetMat); 
            jetDown.rotation.x = Math.PI; 
            jetGroup.add(jetUp); jetGroup.add(jetDown); 
            jetGroup.rotation.z = Math.PI/8; blackHole.add(jetGroup); 
            
            bodies.push({ mesh: blackHole, mass: 10000000, radius: bhSize, velocity: new THREE.Vector3(), force: new THREE.Vector3(), name: 'ì€í•˜ ì¤‘ì‹¬', type: 'blackhole', isStatic: true, jets: { up: jetUp, down: jetDown } }); 
            const centerDiv = document.createElement('div'); centerDiv.className = 'galaxy-label'; 
            centerDiv.dataset.bodyName = 'ì€í•˜ ì¤‘ì‹¬';
            centerDiv.textContent = translateBodyName('ì€í•˜ ì¤‘ì‹¬'); 
            const centerLabel = new CSS2DObject(centerDiv); 
            centerLabel.position.set(0, bhSize * 1.02, 0);  // ë¸”ë™í™€ ë°”ë¡œ ìœ„
            blackHole.add(centerLabel);  // ë¸”ë™í™€ì— ì¶”ê°€
            createGalaxyStars(); 
        }

        function createGalaxyStars() { 
            const geom = new THREE.BufferGeometry(); const pos=[], col=[]; const c=new THREE.Color(); 
            
            // ì€í•˜ í¬ê¸° 10ë°° í™•ëŒ€
            const galaxyRadius = 80000000;  // 8000ë§Œ ë‹¨ìœ„ (10ë°° í™•ëŒ€)
            const clearZone = 5000000;  // íƒœì–‘ê³„ ì‹¤ì œê±°ë¦¬ ëª¨ë“œ ë°˜ê²½ (10ë°° í™•ëŒ€)
            
            // ===== 1. ë‚˜ì„ íŒ” ë³„ë“¤ (80,000ê°œ) =====
            for(let i=0; i<80000; i++){ 
                const r = Math.pow(Math.random(), 2) * galaxyRadius + 500000;
                // 4ê°œ ë‚˜ì„ íŒ” + ê°•í•œ ë‚˜ì„  ê°ê¹€(15) + ì•½ê°„ì˜ ëœë¤
                const ang = (i % 4) * (Math.PI * 2 / 4) + (r / galaxyRadius) * 15 + (Math.random() - 0.5) * 0.5; 
                const x = Math.cos(ang) * r; 
                const z = Math.sin(ang) * r; 
                // ì›ë°˜ ë‘ê»˜ (ë°”ê¹¥ìœ¼ë¡œ ê°ˆìˆ˜ë¡ ì–‡ì•„ì§) - 10ë°° í™•ëŒ€
                const y = (Math.random() - 0.5) * 1500000 * (1 - r / galaxyRadius); 
                
                const gx = x + galaxyCenter.x; 
                const gy = y + galaxyCenter.y; 
                const gz = z + galaxyCenter.z; 
                
                if(Math.sqrt(gx*gx + gy*gy + gz*gz) < clearZone) continue; 
                pos.push(gx, gy, gz); 
                
                // ìƒ‰ìƒ: ë°”ê¹¥ìœ¼ë¡œ ê°ˆìˆ˜ë¡ íŒŒë€ìƒ‰
                c.setHSL(0.6 * (r / galaxyRadius) + 0.05, 0.8, 0.8); 
                col.push(c.r, c.g, c.b); 
            }
            
            // ===== 2. ë‚˜ì„ íŒ” ì‚¬ì´ ë°°ê²½ ë³„ë“¤ (40,000ê°œ) =====
            for(let i=0; i<40000; i++){ 
                const r = Math.random() * galaxyRadius * 0.95 + galaxyRadius * 0.05;
                // ì™„ì „ ëœë¤ ê°ë„ (ë‚˜ì„ íŒ” ë¬´ì‹œ)
                const ang = Math.random() * Math.PI * 2; 
                const x = Math.cos(ang) * r; 
                const z = Math.sin(ang) * r; 
                // ë” ì–‡ì€ ì›ë°˜ - 10ë°° í™•ëŒ€
                const y = (Math.random() - 0.5) * 800000 * (1 - r / galaxyRadius); 
                
                const gx = x + galaxyCenter.x; 
                const gy = y + galaxyCenter.y; 
                const gz = z + galaxyCenter.z; 
                
                if(Math.sqrt(gx*gx + gy*gy + gz*gz) < clearZone) continue; 
                pos.push(gx, gy, gz); 
                
                // í¬ë¯¸í•œ ë…¸ë€/ì£¼í™©ìƒ‰ (ëŠ™ì€ ë³„)
                c.setHSL(0.08 + Math.random() * 0.08, 0.4, 0.5 + Math.random() * 0.2); 
                col.push(c.r, c.g, c.b); 
            } 
            
            geom.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3)); 
            geom.setAttribute('color', new THREE.Float32BufferAttribute(col, 3)); 
            const galaxyMat = new THREE.PointsMaterial({
                size: 10000,  // 10ë°° í™•ëŒ€
                vertexColors: true, 
                transparent: true, 
                opacity: 0.9, 
                blending: THREE.AdditiveBlending, 
                sizeAttenuation: true, 
                depthWrite: false, 
                depthTest: true 
            }); 
            const points = new THREE.Points(geom, galaxyMat); 
            window.galaxyPoints = points; 
            scene.add(points); 
            
            // â˜… ìš°ë¦¬ ì€í•˜ ë°”ê¹¥ ë°°ê²½ ë³„ë“¤ (ì‚¬ë°©ì— ì  í˜•íƒœ)
            createBackgroundStars();
            
            // â˜… ì•ˆë“œë¡œë©”ë‹¤ ì€í•˜ (M31)
            createAndromedaGalaxy();
            
            // ë¨¼ ì€í•˜ë“¤ (í¬ë¯¸í•œ ì ìœ¼ë¡œë§Œ í‘œì‹œ)
            createBackgroundGalaxies();
            
            // ì„±ìš´ë“¤ ì¶”ê°€ (í¬ë¯¸í•œ êµ¬ë¦„)
            createNebulae();
        }
        
        // ìš°ë¦¬ ì€í•˜ ë°”ê¹¥ ë°°ê²½ ë³„ë“¤
        function createBackgroundStars() {
            const starCount = 8000;
            const positions = new Float32Array(starCount * 3);
            const colors = new Float32Array(starCount * 3);
            const c = new THREE.Color();
            
            for (let i = 0; i < starCount; i++) {
                // êµ¬í˜•ìœ¼ë¡œ ì‚¬ë°©ì— ë°°ì¹˜
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 90000000 + Math.random() * 100000000;  // 9000ë§Œ~19000ë§Œ (ì€í•˜ ë°”ë¡œ ë°”ê¹¥) - 10ë°° í™•ëŒ€
                
                positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = r * Math.cos(phi);
                
                // ë‹¤ì–‘í•œ ë³„ ìƒ‰ìƒ
                const colorType = Math.random();
                if (colorType < 0.1) {
                    c.setHSL(0.6, 0.5, 0.8);  // íŒŒë€ë³„
                } else if (colorType < 0.2) {
                    c.setHSL(0.05, 0.6, 0.8);  // ë¶‰ì€ë³„
                } else {
                    c.setHSL(0.15, 0.3, 0.7 + Math.random() * 0.3);  // ë…¸ë€/í°ìƒ‰
                }
                colors[i * 3] = c.r;
                colors[i * 3 + 1] = c.g;
                colors[i * 3 + 2] = c.b;
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 50000,  // 10ë°° í™•ëŒ€
                vertexColors: true,
                transparent: true,
                opacity: 1.0,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true,
                depthWrite: false
            });

            const stars = new THREE.Points(geometry, material);
            scene.add(stars);
        }

        // íƒœì–‘ê³„ ì£¼ë³€ ë¡œì»¬ ë³„ë“¤ (íƒœì–‘ì—ì„œ ìˆ˜ë°±~ìˆ˜ì²œ ê´‘ë…„ ë‚´ ë³„ë“¤)
        // íƒœì–‘ê³„ëŠ” ì€í•˜ ì•ˆì— ìˆìœ¼ë¯€ë¡œ, ì´ ë³„ë“¤ì€ ì€í•˜ ì›ë°˜ì˜ ì¼ë¶€
        
        // ì•ˆë“œë¡œë©”ë‹¤ ì€í•˜ (ë¿Œì˜‡ì§€ë§Œ ì€í•˜ í˜•íƒœ + ë³„ ì ë“¤)
        function createAndromedaGalaxy() {
            const galaxyGroup = new THREE.Group();
            const position = new THREE.Vector3(52000000, 13000000, -32500000);  // â˜… 2ë°° ë” ë©€ë¦¬
            const size = 1500000;

            galaxyGroup.position.copy(position);
            galaxyGroup.rotation.x = 0.3;
            galaxyGroup.rotation.z = 0.5;

            // ===== 1. ë‚˜ì„  ì€í•˜ í˜•íƒœì˜ ë³„ ì ë“¤ =====
            const starCount = 4000;  // â˜… ë°€ë„ 1/3ë¡œ ê°ì†Œ
            const positions = new Float32Array(starCount * 3);
            const colors = new Float32Array(starCount * 3);
            const sizes = new Float32Array(starCount);
            const baseColor = new THREE.Color(0xaaccff);

            for (let i = 0; i < starCount; i++) {
                const armIndex = Math.floor(Math.random() * 4);
                const armAngle = (armIndex / 4) * Math.PI * 2;
                const r = Math.pow(Math.random(), 0.35) * size;

                const spiralAngle = armAngle + (r / size) * Math.PI * 3 + (Math.random() - 0.5) * 1.2;

                const x = Math.cos(spiralAngle) * r + (Math.random() - 0.5) * size * 0.12;
                const z = Math.sin(spiralAngle) * r + (Math.random() - 0.5) * size * 0.12;
                const y = (Math.random() - 0.5) * size * 0.04;

                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;

                // â˜… ë°ê¸° ì ˆë°˜ìœ¼ë¡œ ê°ì†Œ
                const distRatio = r / size;
                const brightness = (0.4 * Math.pow(1 - distRatio, 1.5) + 0.05) * 0.5;
                colors[i * 3] = baseColor.r * brightness;
                colors[i * 3 + 1] = baseColor.g * brightness;
                colors[i * 3 + 2] = baseColor.b * brightness;

                sizes[i] = 120000 * (1 - distRatio * 0.7);
            }

            const starGeometry = new THREE.BufferGeometry();
            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            starGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const starMaterial = new THREE.PointsMaterial({
                size: 100000,
                vertexColors: true,
                transparent: true,
                opacity: 0.35,  // â˜… ë°ê¸° ì ˆë°˜
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true
            });

            const stars = new THREE.Points(starGeometry, starMaterial);
            stars.frustumCulled = false;  // â˜… ë©€ë¦¬ì„œë„ ë³´ì´ê²Œ
            galaxyGroup.add(stars);
            
            // ===== 2. ì¤‘ì‹¬ ë²Œì§€ (ë°ì€ í•µ) =====
            const coreGeo = new THREE.SphereGeometry(size * 0.08, 32, 32);
            const coreMat = new THREE.MeshBasicMaterial({
                color: 0xffffee,
                transparent: true,
                opacity: 0.25,  // â˜… ë°ê¸° ì ˆë°˜
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            const core = new THREE.Mesh(coreGeo, coreMat);
            core.frustumCulled = false;
            galaxyGroup.add(core);

            // ì¤‘ì‹¬ ë²Œì§€
            const bulgeGeo = new THREE.SphereGeometry(size * 0.18, 32, 32);
            const bulgeMat = new THREE.MeshBasicMaterial({
                color: 0xffeedd,
                transparent: true,
                opacity: 0.15,  // â˜… ë°ê¸° ì ˆë°˜
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            const bulge = new THREE.Mesh(bulgeGeo, bulgeMat);
            bulge.scale.set(1, 0.4, 1);
            bulge.frustumCulled = false;
            galaxyGroup.add(bulge);

            // ì¤‘ê°„ ë²Œì§€ (ì ì  í¬ë¯¸í•´ì§)
            const midBulgeGeo = new THREE.SphereGeometry(size * 0.35, 32, 32);
            const midBulgeMat = new THREE.MeshBasicMaterial({
                color: 0xddccbb,
                transparent: true,
                opacity: 0.07,  // â˜… ë°ê¸° ì ˆë°˜
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            const midBulge = new THREE.Mesh(midBulgeGeo, midBulgeMat);
            midBulge.scale.set(1, 0.25, 1);
            midBulge.frustumCulled = false;
            galaxyGroup.add(midBulge);

            // ===== 3. ë¿Œì—° ì›ë°˜ (ì¤‘ì‹¬â†’ì™¸ê³½ ë°€ë„ ê°ì†Œ) =====
            for (let layer = 0; layer < 5; layer++) {
                const innerR = size * (0.1 + layer * 0.12);
                const outerR = size * (0.25 + layer * 0.15);
                const diskGeo = new THREE.RingGeometry(innerR, outerR, 64, 1);
                const diskMat = new THREE.MeshBasicMaterial({
                    color: 0xaabbdd,
                    transparent: true,
                    opacity: 0.06 * Math.pow(0.6, layer),  // â˜… ë°ê¸° ì ˆë°˜
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });
                const disk = new THREE.Mesh(diskGeo, diskMat);
                disk.rotation.x = Math.PI / 2;
                disk.rotation.z = layer * 0.25;
                disk.frustumCulled = false;
                galaxyGroup.add(disk);
            }

            // ì™¸ê³½ í¬ë¯¸í•œ í—¤ì¼ë¡œ
            const haloGeo = new THREE.SphereGeometry(size * 0.8, 32, 32);
            const haloMat = new THREE.MeshBasicMaterial({
                color: 0x8899aa,
                transparent: true,
                opacity: 0.02,  // â˜… ë°ê¸° ì ˆë°˜
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            const halo = new THREE.Mesh(haloGeo, haloMat);
            halo.scale.set(1.3, 0.2, 1);
            halo.frustumCulled = false;
            galaxyGroup.add(halo);

            // ===== 4. ì´ˆê±°ëŒ€ ë¸”ë™í™€ (M31*) =====
            const bhGroup = new THREE.Group();
            bhGroup.name = 'andromedaBlackHole';
            const bhSize = size * 0.015;  // ë¸”ë™í™€ í¬ê¸° (ì‚¬ê±´ì˜ ì§€í‰ì„ )

            // ì‚¬ê±´ì˜ ì§€í‰ì„  (ì™„ì „í•œ ê²€ì€ êµ¬)
            const eventHorizonGeo = new THREE.SphereGeometry(bhSize, 64, 64);
            const eventHorizonMat = new THREE.MeshBasicMaterial({
                color: 0x000000,
                transparent: false
            });
            const eventHorizon = new THREE.Mesh(eventHorizonGeo, eventHorizonMat);
            eventHorizon.renderOrder = 100;
            bhGroup.add(eventHorizon);

            // â˜… ê´‘ìêµ¬ (Photon Sphere) - ì‚¬ê±´ì˜ ì§€í‰ì„  ë°”ë¡œ ë°”ê¹¥ ë°ì€ ë§
            const photonRingGeo = new THREE.TorusGeometry(bhSize * 1.5, bhSize * 0.08, 32, 128);
            const photonRingMat = new THREE.ShaderMaterial({
                uniforms: { time: { value: 0 } },
                vertexShader: `
                    varying vec2 vUv;
                    varying vec3 vNormal;
                    void main() {
                        vUv = uv;
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    varying vec2 vUv;
                    varying vec3 vNormal;
                    void main() {
                        float edge = 1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0)));
                        edge = pow(edge, 2.0);
                        float flicker = 0.8 + sin(vUv.x * 50.0 + time * 10.0) * 0.2;
                        vec3 color = vec3(1.0, 0.95, 0.8) * flicker;
                        float alpha = edge * 0.9;
                        gl_FragColor = vec4(color, alpha);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            const photonRing = new THREE.Mesh(photonRingGeo, photonRingMat);
            photonRing.rotation.x = Math.PI / 2;
            photonRing.renderOrder = 101;
            bhGroup.add(photonRing);

            // â˜… ì¤‘ë ¥ ë Œì¦ˆ íš¨ê³¼ - ë°°ê²½ ì™œê³¡ì„ ì‹œë®¬ë ˆì´ì…˜í•˜ëŠ” êµ´ì ˆ êµ¬ì²´
            const lensVertexShader = `
                varying vec3 vWorldPosition;
                varying vec3 vNormal;
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    vNormal = normalize(normalMatrix * normal);
                    vec4 worldPos = modelMatrix * vec4(position, 1.0);
                    vWorldPosition = worldPos.xyz;
                    gl_Position = projectionMatrix * viewMatrix * worldPos;
                }
            `;
            const lensFragmentShader = `
                uniform float time;
                uniform float bhRadius;
                uniform vec3 bhPosition;
                varying vec3 vWorldPosition;
                varying vec3 vNormal;
                varying vec2 vUv;

                void main() {
                    // ë¸”ë™í™€ ì¤‘ì‹¬ìœ¼ë¡œë¶€í„°ì˜ ê±°ë¦¬ (ì •ê·œí™”)
                    float dist = length(vWorldPosition - bhPosition) / bhRadius;

                    // í”„ë ˆë„¬ íš¨ê³¼ - ê°€ì¥ìë¦¬ì—ì„œ ê°•í•œ êµ´ì ˆ
                    float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 4.0);

                    // ìŠˆë°”ë¥´ì¸ ì‹¤íŠ¸ ë°˜ê²½ ê·¼ì²˜ì—ì„œ ë¹›ì´ íœ˜ëŠ” íš¨ê³¼
                    float bendFactor = 1.0 / (dist * dist + 0.1);
                    bendFactor = clamp(bendFactor, 0.0, 1.0);

                    // ì•„ì¸ìŠˆíƒ€ì¸ ë§ (ê´‘ìêµ¬ ê·¼ì²˜ ë°ì€ ë§)
                    float ringDist = abs(dist - 1.0);
                    float einsteinRing = exp(-ringDist * ringDist * 50.0);

                    // 2ì°¨ ê´‘ì ë§ (ë” ì•ˆìª½)
                    float innerRingDist = abs(dist - 0.75);
                    float innerRing = exp(-innerRingDist * innerRingDist * 80.0) * 0.5;

                    // ë°°ê²½ ë³„ë¹›ì´ íœ˜ì–´ì ¸ ë“¤ì–´ì˜¤ëŠ” íš¨ê³¼
                    float starLight = fresnel * bendFactor;
                    starLight *= 0.5 + sin(vUv.x * 100.0 + time * 2.0) * 0.3;
                    starLight *= 0.5 + sin(vUv.y * 80.0 - time * 1.5) * 0.3;

                    // ìƒ‰ìƒ: íœ˜ì–´ì§„ ë³„ë¹› (ì•½ê°„ ë¶‰ì€/ì£¼í™©ë¹› - ì ìƒ‰í¸ì´)
                    vec3 lensedLight = vec3(1.0, 0.9, 0.7) * starLight;
                    vec3 ringColor = vec3(1.0, 0.95, 0.85) * (einsteinRing + innerRing);

                    vec3 finalColor = lensedLight + ringColor;
                    float alpha = starLight * 0.4 + (einsteinRing + innerRing) * 0.8;

                    // ì‚¬ê±´ì˜ ì§€í‰ì„  ê·¼ì²˜ ì–´ë‘ìš´ ì˜ì—­
                    float darkness = smoothstep(0.3, 0.6, dist);
                    alpha *= darkness;

                    gl_FragColor = vec4(finalColor, alpha);
                }
            `;

            const lensMat = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    bhRadius: { value: bhSize * 2.5 },
                    bhPosition: { value: new THREE.Vector3(0, 0, 0) }
                },
                vertexShader: lensVertexShader,
                fragmentShader: lensFragmentShader,
                transparent: true,
                side: THREE.BackSide,  // ì•ˆìª½ì—ì„œ ë³´ì´ê²Œ
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            const lensGeo = new THREE.SphereGeometry(bhSize * 2.5, 64, 64);
            const lensSphere = new THREE.Mesh(lensGeo, lensMat);
            lensSphere.renderOrder = 99;
            bhGroup.add(lensSphere);

            // â˜… ì™¸ë¶€ ì¤‘ë ¥ì¥ ì™œê³¡ íš¨ê³¼ (ë” í° ë²”ìœ„)
            const outerLensMat = new THREE.ShaderMaterial({
                uniforms: { time: { value: 0 }, bhRadius: { value: bhSize * 5 } },
                vertexShader: lensVertexShader,
                fragmentShader: `
                    uniform float time;
                    uniform float bhRadius;
                    varying vec3 vWorldPosition;
                    varying vec3 vNormal;
                    varying vec2 vUv;
                    void main() {
                        float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 5.0);
                        float distort = sin(vUv.x * 30.0 + time) * sin(vUv.y * 30.0 - time * 0.7);
                        distort = distort * 0.5 + 0.5;
                        vec3 color = vec3(0.6, 0.5, 0.4) * fresnel * distort;
                        float alpha = fresnel * 0.15 * distort;
                        gl_FragColor = vec4(color, alpha);
                    }
                `,
                transparent: true,
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            const outerLensGeo = new THREE.SphereGeometry(bhSize * 5, 48, 48);
            const outerLensSphere = new THREE.Mesh(outerLensGeo, outerLensMat);
            outerLensSphere.renderOrder = 97;
            bhGroup.add(outerLensSphere);

            // â˜… ê°•ì°©ì›ë°˜ (Accretion Disk) - ì…°ì´ë” ê¸°ë°˜ íšŒì „
            const diskVertexShader = `
                varying vec2 vUv;
                varying float vDist;
                void main() {
                    vUv = uv;
                    vDist = length(position.xy);
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;
            const diskFragmentShader = `
                uniform float time;
                uniform float innerRadius;
                uniform float outerRadius;
                varying vec2 vUv;
                varying float vDist;

                // ë…¸ì´ì¦ˆ í•¨ìˆ˜
                float hash(vec2 p) {
                    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
                }

                float noise(vec2 p) {
                    vec2 i = floor(p);
                    vec2 f = fract(p);
                    f = f * f * (3.0 - 2.0 * f);
                    return mix(
                        mix(hash(i), hash(i + vec2(1.0, 0.0)), f.x),
                        mix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), f.x),
                        f.y
                    );
                }

                void main() {
                    vec2 center = vUv - 0.5;
                    float dist = length(center) * 2.0;
                    float angle = atan(center.y, center.x);

                    // ê±°ë¦¬ì— ë”°ë¥¸ íšŒì „ ì†ë„ (ì•ˆìª½ì´ ë¹ ë¦„ - ì¼€í”ŒëŸ¬ íšŒì „)
                    float rotSpeed = 1.0 / (dist + 0.1);
                    float rotatedAngle = angle + time * rotSpeed * 0.5;

                    // ë‚˜ì„  íŒ¨í„´
                    float spiral = sin(rotatedAngle * 4.0 + dist * 20.0 - time * 3.0);
                    spiral = spiral * 0.5 + 0.5;

                    // ë‚œë¥˜ ë…¸ì´ì¦ˆ
                    vec2 noiseCoord = vec2(rotatedAngle * 2.0, dist * 10.0);
                    float turbulence = noise(noiseCoord + time * 0.5) * 0.3;

                    // ì˜¨ë„ ê·¸ë¼ë°ì´ì…˜ (ì•ˆìª½: í•˜ì–€ìƒ‰/íŒŒë‘, ë°”ê¹¥ìª½: ë¹¨ê°•/ì£¼í™©)
                    vec3 hotColor = vec3(1.0, 1.0, 0.95);    // ê°€ì¥ ëœ¨ê±°ìš´ ë¶€ë¶„ (í•˜ì–€ìƒ‰)
                    vec3 warmColor = vec3(1.0, 0.7, 0.2);    // ë”°ëœ»í•œ ë¶€ë¶„ (ì£¼í™©)
                    vec3 coolColor = vec3(0.8, 0.2, 0.05);   // ì°¨ê°€ìš´ ë¶€ë¶„ (ë¹¨ê°•)

                    float temp = 1.0 - dist;
                    vec3 baseColor;
                    if (temp > 0.7) {
                        baseColor = mix(warmColor, hotColor, (temp - 0.7) / 0.3);
                    } else if (temp > 0.3) {
                        baseColor = mix(coolColor, warmColor, (temp - 0.3) / 0.4);
                    } else {
                        baseColor = coolColor * (temp / 0.3);
                    }

                    // ë‚˜ì„ ê³¼ ë‚œë¥˜ ì ìš©
                    vec3 color = baseColor * (0.7 + spiral * 0.3 + turbulence);

                    // ê°€ì¥ìë¦¬ í˜ì´ë“œì•„ì›ƒ
                    float innerFade = smoothstep(0.0, 0.15, dist);
                    float outerFade = smoothstep(1.0, 0.7, dist);
                    float alpha = innerFade * outerFade * (0.8 + spiral * 0.2);

                    // ë„í”ŒëŸ¬ íš¨ê³¼ (í•œìª½ì€ ë°ê²Œ, ë°˜ëŒ€ìª½ì€ ì–´ë‘¡ê²Œ)
                    float doppler = 1.0 + sin(rotatedAngle) * 0.3 * (1.0 - dist);
                    color *= doppler;

                    gl_FragColor = vec4(color, alpha);
                }
            `;

            const diskInnerR = bhSize * 1.05;  // â˜… ì‚¬ê±´ì˜ ì§€í‰ì„  ë°”ë¡œ ë°”ê¹¥ (ISCO)
            const diskOuterR = bhSize * 6;
            const diskMat = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    innerRadius: { value: diskInnerR },
                    outerRadius: { value: diskOuterR }
                },
                vertexShader: diskVertexShader,
                fragmentShader: diskFragmentShader,
                transparent: true,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            const diskGeo = new THREE.RingGeometry(diskInnerR, diskOuterR, 128, 32);
            const accretionDisk = new THREE.Mesh(diskGeo, diskMat);
            accretionDisk.rotation.x = Math.PI / 2;
            accretionDisk.rotation.y = 0.3;  // ì•½ê°„ ê¸°ìš¸ì„
            accretionDisk.renderOrder = 98;
            bhGroup.add(accretionDisk);

            // â˜… ì œíŠ¸ (ì–‘ê·¹ ë°©í–¥ ë¶„ì¶œ)
            const jetMat = new THREE.ShaderMaterial({
                uniforms: { time: { value: 0 } },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    varying vec2 vUv;
                    void main() {
                        float dist = abs(vUv.y - 0.5) * 2.0;
                        float intensity = (1.0 - dist) * (1.0 - vUv.x);
                        intensity *= 0.5 + sin(vUv.x * 20.0 - time * 5.0) * 0.3;
                        vec3 color = mix(vec3(0.3, 0.5, 1.0), vec3(0.8, 0.9, 1.0), intensity);
                        gl_FragColor = vec4(color, intensity * 0.6);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            const jetLength = bhSize * 15;
            const jetGeo = new THREE.PlaneGeometry(bhSize * 0.8, jetLength);

            // ìƒë‹¨ ì œíŠ¸
            const jetTop = new THREE.Mesh(jetGeo, jetMat);
            jetTop.position.y = jetLength / 2 + bhSize;
            jetTop.rotation.x = Math.PI / 2;
            bhGroup.add(jetTop);

            // í•˜ë‹¨ ì œíŠ¸
            const jetBottom = new THREE.Mesh(jetGeo, jetMat.clone());
            jetBottom.position.y = -jetLength / 2 - bhSize;
            jetBottom.rotation.x = -Math.PI / 2;
            bhGroup.add(jetBottom);

            // ë¸”ë™í™€ ê·¸ë£¹ì„ ì€í•˜ íšŒì „ì— ë§ì¶¤
            bhGroup.rotation.x = -Math.PI / 2 + 0.3;
            galaxyGroup.add(bhGroup);

            // ì• ë‹ˆë©”ì´ì…˜ìš© ë°ì´í„° ì €ì¥
            galaxyGroup.userData.blackHole = {
                photonRingMat: photonRingMat,
                lensMat: lensMat,
                outerLensMat: outerLensMat,
                diskMat: diskMat,
                jetMat: jetMat,
                jetMatBottom: jetBottom.material
            };

            galaxyGroup.userData.name = 'andromeda';
            galaxyGroup.frustumCulled = false;  // â˜… ë©€ë¦¬ì„œë„ ë³´ì´ê²Œ
            scene.add(galaxyGroup);

            // â˜… ì•ˆë“œë¡œë©”ë‹¤ ì€í•˜ ë¼ë²¨ ì¶”ê°€ (ì€í•˜ ìœ„ì— í‘œì‹œ)
            const andromedaDiv = document.createElement('div');
            andromedaDiv.className = 'galaxy-label';
            andromedaDiv.dataset.bodyName = 'ì•ˆë“œë¡œë©”ë‹¤ì€í•˜';
            andromedaDiv.textContent = t('andromeda');
            const andromedaLabel = new CSS2DObject(andromedaDiv);
            andromedaLabel.position.set(0, size * 0.8, 0);  // â˜… ì€í•˜ ìœ„ë¡œ ì˜¬ë¦¼
            galaxyGroup.add(andromedaLabel);
        }
        
        // ë°°ê²½ ì€í•˜ë“¤ (ì ìœ¼ë¡œ í‘œì‹œ)
        function createBackgroundGalaxies() {
            // ===== 1. ê°€ê¹Œìš´ ì€í•˜ë“¤ (ìš°ë¦¬ ì€í•˜ ë°”ë¡œ ë°”ê¹¥) =====
            const nearGalaxyCount = 100;
            const nearPositions = new Float32Array(nearGalaxyCount * 3);
            const nearColors = new Float32Array(nearGalaxyCount * 3);
            
            for (let i = 0; i < nearGalaxyCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 90000000 + Math.random() * 60000000;  // 9000ë§Œ~15000ë§Œ (ì€í•˜ ë°”ë¡œ ë°”ê¹¥) - 10ë°° í™•ëŒ€
                
                nearPositions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                nearPositions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                nearPositions[i * 3 + 2] = r * Math.cos(phi);
                
                const colorType = Math.random();
                const brightness = 1.4 + Math.random() * 0.6;  // 2ë°° ë°ê²Œ
                if (colorType < 0.4) {
                    nearColors[i * 3] = 0.7 * brightness;
                    nearColors[i * 3 + 1] = 0.8 * brightness;
                    nearColors[i * 3 + 2] = 1 * brightness;
                } else if (colorType < 0.7) {
                    nearColors[i * 3] = 1 * brightness;
                    nearColors[i * 3 + 1] = 0.9 * brightness;
                    nearColors[i * 3 + 2] = 0.7 * brightness;
                } else {
                    nearColors[i * 3] = 1 * brightness;
                    nearColors[i * 3 + 1] = 1 * brightness;
                    nearColors[i * 3 + 2] = 1 * brightness;
                }
            }
            
            const nearGeometry = new THREE.BufferGeometry();
            nearGeometry.setAttribute('position', new THREE.BufferAttribute(nearPositions, 3));
            nearGeometry.setAttribute('color', new THREE.BufferAttribute(nearColors, 3));
            
            const nearMaterial = new THREE.PointsMaterial({
                size: 1000000,  // 10ë°° í™•ëŒ€
                vertexColors: true,
                transparent: true,
                opacity: 1.0,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true
            });
            
            scene.add(new THREE.Points(nearGeometry, nearMaterial));
            
            // ===== 2. ì¤‘ê°„ ê±°ë¦¬ ì€í•˜ë“¤ =====
            const midGalaxyCount = 150;
            const midPositions = new Float32Array(midGalaxyCount * 3);
            const midColors = new Float32Array(midGalaxyCount * 3);
            
            for (let i = 0; i < midGalaxyCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 150000000 + Math.random() * 100000000;  // 1ì–µ5ì²œë§Œ~2ì–µ5ì²œë§Œ - 10ë°° í™•ëŒ€
                
                midPositions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                midPositions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                midPositions[i * 3 + 2] = r * Math.cos(phi);
                
                const colorType = Math.random();
                const brightness = 1.4 + Math.random() * 0.6;  // 2ë°° ë°ê²Œ
                if (colorType < 0.4) {
                    midColors[i * 3] = 0.7 * brightness;
                    midColors[i * 3 + 1] = 0.8 * brightness;
                    midColors[i * 3 + 2] = 1 * brightness;
                } else if (colorType < 0.7) {
                    midColors[i * 3] = 1 * brightness;
                    midColors[i * 3 + 1] = 0.9 * brightness;
                    midColors[i * 3 + 2] = 0.7 * brightness;
                } else {
                    midColors[i * 3] = 0.9 * brightness;
                    midColors[i * 3 + 1] = 0.9 * brightness;
                    midColors[i * 3 + 2] = 0.9 * brightness;
                }
            }
            
            const midGeometry = new THREE.BufferGeometry();
            midGeometry.setAttribute('position', new THREE.BufferAttribute(midPositions, 3));
            midGeometry.setAttribute('color', new THREE.BufferAttribute(midColors, 3));
            
            const midMaterial = new THREE.PointsMaterial({
                size: 800000,  // 10ë°° í™•ëŒ€
                vertexColors: true,
                transparent: true,
                opacity: 1.0,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true
            });
            
            scene.add(new THREE.Points(midGeometry, midMaterial));
        }
        
        // ì„±ìš´ ìƒì„± (ë¿Œì—° êµ¬ë¦„ë§Œ) - ì€í•˜ ë‚´ë¶€ì— ìœ„ì¹˜
        function createNebulae() {
            // ì„±ìš´ ë°ì´í„° - 10ë°° í™•ëŒ€
            const nebulaData = [
                { pos: new THREE.Vector3(50000000, 20000000, -30000000), size: 8000000, color: 0xff6688, name: 'ì¥ë¯¸ ì„±ìš´' },
                { pos: new THREE.Vector3(-40000000, -10000000, 60000000), size: 6000000, color: 0x66aaff, name: 'ì˜¤ë¦¬ì˜¨ ì„±ìš´' },
                { pos: new THREE.Vector3(30000000, -25000000, -50000000), size: 10000000, color: 0x88ff88, name: 'ë…ìˆ˜ë¦¬ ì„±ìš´' },
                { pos: new THREE.Vector3(-60000000, 15000000, -20000000), size: 5000000, color: 0xffaa66, name: 'ê²Œ ì„±ìš´' },
                { pos: new THREE.Vector3(70000000, 5000000, 40000000), size: 7000000, color: 0xaa88ff, name: 'ê³ ë¦¬ ì„±ìš´' }
            ];
            
            nebulaData.forEach(nebula => {
                const nebulaGroup = new THREE.Group();
                nebulaGroup.position.copy(nebula.pos);
                
                // ì—¬ëŸ¬ ì¸µì˜ ë¿Œì—° êµ¬ì²´ë§Œ (ì  ì—†ì´)
                for (let i = 0; i < 6; i++) {
                    const size = nebula.size * (0.4 + i * 0.2);
                    const geo = new THREE.SphereGeometry(size, 24, 24);
                    const mat = new THREE.MeshBasicMaterial({
                        color: nebula.color,
                        transparent: true,
                        opacity: 0.025 - i * 0.003,
                        blending: THREE.AdditiveBlending,
                        depthWrite: false,
                        side: THREE.DoubleSide
                    });
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.scale.set(1 + Math.random() * 0.4, 0.5 + Math.random() * 0.4, 1 + Math.random() * 0.4);
                    mesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                    nebulaGroup.add(mesh);
                }
                
                nebulaGroup.userData.name = nebula.name;
                scene.add(nebulaGroup);
            });
        }

        function startPlacing(item, btn) { 
            if(ghostMesh) scene.remove(ghostMesh); 
            isPlacing=true; 
            spawnData=item; 
            const geo=new THREE.SphereGeometry(item.type.r,16,16); 
            const mat=new THREE.MeshBasicMaterial({color:0xffffff,wireframe:true,transparent:true,opacity:0.3}); 
            ghostMesh=new THREE.Mesh(geo,mat); 
            scene.add(ghostMesh); 
            if (btn) {
                document.querySelectorAll('.spawn-btn').forEach(b=>b.classList.remove('active')); 
                btn.classList.add('active'); 
            }
            showMsg(`${item.name} ìƒì„± ëª¨ë“œ (ë“œë˜ê·¸í•˜ì—¬ ë°°ì¹˜, ë°©í–¥=ì†ë„)`); 
        }

        function onMouseMove(e) { 
            if (!isPlacing || !ghostMesh) return; 
            mouse.x=(e.clientX/window.innerWidth)*2-1; 
            mouse.y=-(e.clientY/window.innerHeight)*2+1; 
            raycaster.setFromCamera(mouse, camera); 
            const target=new THREE.Vector3(); 
            raycaster.ray.intersectPlane(plane, target); 
            
            // ë“œë˜ê·¸ ì¤‘ì´ë©´ ë°©í–¥ì„  ì—…ë°ì´íŠ¸
            if (isDraggingBody && dragStartPos && target) {
                if (dragLine) scene.remove(dragLine);
                const dir = new THREE.Vector3().subVectors(target, dragStartPos);
                const len = dir.length();
                const arrowGeo = new THREE.BufferGeometry().setFromPoints([
                    dragStartPos,
                    target
                ]);
                const arrowMat = new THREE.LineBasicMaterial({ 
                    color: len > 50 ? 0xff6600 : 0x00ff00,
                    linewidth: 2 
                });
                dragLine = new THREE.Line(arrowGeo, arrowMat);
                scene.add(dragLine);
            } else if(target) {
                ghostMesh.position.copy(target); 
            }
        }

        // ë§ˆìš°ìŠ¤ ë‹¤ìš´ - ë“œë˜ê·¸ ì‹œì‘
        function onMouseDown(e) {
            if (!isPlacing || !ghostMesh) return;
            // e.targetì´ ì—†ê±°ë‚˜ closest ë©”ì„œë“œê°€ ì—†ìœ¼ë©´ ê±´ë„ˆë›°ê¸°
            if(e.target && e.target.closest && (e.target.closest('.spawn-btn')||e.target.closest('#top-bar')||e.target.closest('#catalog-modal')||e.target.closest('#btn-catalog'))) return; 
            
            mouse.x=(e.clientX/window.innerWidth)*2-1; 
            mouse.y=-(e.clientY/window.innerHeight)*2+1; 
            raycaster.setFromCamera(mouse, camera); 
            const target=new THREE.Vector3(); 
            raycaster.ray.intersectPlane(plane, target); 
            
            if (target) {
                dragStartPos = target.clone();
                ghostMesh.position.copy(target);
                isDraggingBody = true;
            }
        }

        // ë§ˆìš°ìŠ¤ ì—… - ë°°ì¹˜ ì™„ë£Œ
        function onMouseUp(e) {
            if (!isPlacing || !ghostMesh || !isDraggingBody) return;
            
            mouse.x=(e.clientX/window.innerWidth)*2-1; 
            mouse.y=-(e.clientY/window.innerHeight)*2+1; 
            raycaster.setFromCamera(mouse, camera); 
            const target=new THREE.Vector3(); 
            raycaster.ray.intersectPlane(plane, target); 
            
            if (target && dragStartPos) {
                // ë“œë˜ê·¸ ë°©í–¥ê³¼ ê±°ë¦¬ë¡œ ì´ˆê¸° ì†ë„ ê³„ì‚°
                const dragVec = new THREE.Vector3().subVectors(target, dragStartPos);
                const dragLen = dragVec.length();
                
                // ì†ë„ ìŠ¤ì¼€ì¼ (ë“œë˜ê·¸ ê¸¸ì´ì— ë¹„ë¡€, ìµœëŒ€ ì œí•œ)
                const speedScale = Math.min(dragLen * 0.0001, 0.05);
                const velocity = dragVec.normalize().multiplyScalar(speedScale);
                
                createBody(spawnData.type, dragStartPos.clone(), velocity, spawnData.name+" (New)", spawnData.tex); 
                
                // ì •ë¦¬
                if (dragLine) {
                    scene.remove(dragLine);
                    dragLine = null;
                }
                scene.remove(ghostMesh); 
                ghostMesh=null; 
                isPlacing=false; 
                isDraggingBody = false;
                dragStartPos = null;
                
                const speedKmS = (speedScale * 1000).toFixed(1);
                showMsg(`ìƒì„± ì™„ë£Œ! ì´ˆê¸° ì†ë„: ${speedKmS} km/s`); 
            }
        }

        function onMouseClick(e) { 
            if(e.target.closest('.spawn-btn')||e.target.closest('#top-bar')||e.target.closest('#catalog-modal')||e.target.closest('#btn-catalog')) return; 
            
            // ë“œë˜ê·¸ ë°°ì¹˜ ëª¨ë“œì—ì„œëŠ” click ë¬´ì‹œ (mousedown/mouseupìœ¼ë¡œ ì²˜ë¦¬)
            if(isPlacing && ghostMesh) return;
            
            mouse.x=(e.clientX/window.innerWidth)*2-1; 
            mouse.y=-(e.clientY/window.innerHeight)*2+1; 
            raycaster.setFromCamera(mouse, camera); 
            
            // ì£¼ì°¨ëœ ìš°ì£¼ì„ ë„ í´ë¦­ ëŒ€ìƒì— ì¶”ê°€
            const allMeshes = [...bodies.filter(b => b && b.mesh).map(b=>b.mesh), ...satellites.filter(s => s && s.mesh).map(s=>s.mesh)];
            if (parkedShipMesh) {
                allMeshes.push(parkedShipMesh);
            }
            const intersects = raycaster.intersectObjects(allMeshes, true); 
            
            let foundTarget = null;
            
            if(intersects.length > 0) {
                const targetMesh = intersects[0].object;
                
                // ì£¼ì°¨ëœ ìš°ì£¼ì„  í´ë¦­ í™•ì¸
                if (parkedShipMesh) {
                    let checkMesh = targetMesh;
                    while (checkMesh) {
                        if (checkMesh === parkedShipMesh) {
                            const parkedShipBody = {
                                name: `ğŸš€ ${getShipName(SHIP_TYPES[parkedShipMesh.userData.shipTypeIndex])}`,
                                mesh: parkedShipMesh,
                                isParkedShip: true,
                                shipTypeIndex: parkedShipMesh.userData.shipTypeIndex
                            };
                            focusBody(parkedShipBody);
                            return;
                        }
                        checkMesh = checkMesh.parent;
                    }
                }
                
                foundTarget = bodies.find(b => b && b.mesh && (b.mesh === targetMesh || b.mesh === targetMesh.parent));
                if (!foundTarget) {
                    foundTarget = satellites.find(s => {
                        if (!s || !s.mesh) return false;
                        if (s.mesh === targetMesh) return true;
                        let parent = targetMesh.parent;
                        while(parent) {
                            if(parent === s.mesh) return true;
                            parent = parent.parent;
                        }
                        return false;
                    });
                }
            }
            
            // Fallback: ì§ì ‘ ê°ì§€ ì•ˆë˜ë©´ í™”ë©´ ì¢Œí‘œ ê¸°ì¤€ ê°€ì¥ ê°€ê¹Œìš´ ì²œì²´ ì°¾ê¸°
            // (raycastë¡œ ì§ì ‘ ë§ì¶˜ ê²½ìš°ì—ë§Œ ì‘ë™í•˜ë„ë¡ ë²”ìœ„ ì¶•ì†Œ)
            if (!foundTarget) {
                const clickX = e.clientX;
                const clickY = e.clientY;
                let minDist = 35;  // 35px ì´ë‚´ë§Œ ê°ì§€ (ë” ì •í™•í•˜ê²Œ)
                
                // ëª¨ë“  ì²œì²´ì™€ ìœ„ì„± ê²€ì‚¬
                const allBodies = [...bodies, ...satellites];
                allBodies.forEach(b => {
                    if (!b || !b.mesh) return;
                    
                    // 3D ìœ„ì¹˜ë¥¼ í™”ë©´ ì¢Œí‘œë¡œ ë³€í™˜
                    const pos = new THREE.Vector3();
                    b.mesh.getWorldPosition(pos);
                    pos.project(camera);
                    
                    const screenX = (pos.x * 0.5 + 0.5) * window.innerWidth;
                    const screenY = (-pos.y * 0.5 + 0.5) * window.innerHeight;
                    
                    // í™”ë©´ìƒ ê±°ë¦¬ ê³„ì‚°
                    const dist = Math.sqrt((clickX - screenX) ** 2 + (clickY - screenY) ** 2);
                    
                    // ì²œì²´ í¬ê¸°ì— ë”°ë¼ ê°ì§€ ë²”ìœ„ ì¡°ì ˆ
                    const radius = b.radius || 1;
                    const threshold = Math.max(40, Math.min(100, radius * 10));
                    
                    if (dist < threshold && dist < minDist) {
                        minDist = dist;
                        foundTarget = b;
                    }
                });
            }
            
            if(foundTarget) focusBody(foundTarget);
        }

        function onResize() { 
            camera.aspect=window.innerWidth/window.innerHeight; 
            camera.updateProjectionMatrix(); 
            renderer.setSize(window.innerWidth, window.innerHeight); 
            labelRenderer.setSize(window.innerWidth, window.innerHeight); 
        }

        function renderCatalog() {
            const catalogContent = document.getElementById('catalog-content');
            catalogContent.innerHTML = ''; 
            
            // íƒœì–‘ê³„ ì²œì²´ ëª©ë¡ (ë©€í‹°ëª¨ë“œìš©)
            const SOLAR_SYSTEM_BODIES = [
                'SUN', 'MERCURY', 'VENUS', 'EARTH', 'MARS', 
                'JUPITER', 'SATURN', 'URANUS', 'NEPTUNE',
                'MOON', 'PHOBOS', 'DEIMOS',
                'IO', 'EUROPA', 'GANYMEDE', 'CALLISTO',
                'TITAN', 'ENCELADUS', 'MIMAS', 'RHEA', 'DIONE', 'IAPETUS',
                'TITANIA', 'OBERON', 'MIRANDA', 'ARIEL', 'UMBRIEL',
                'TRITON', 'PLUTO', 'CHARON', 'CERES', 'ERIS'
            ];
            
            // í•œê¸€ ì´ë¦„ ë§¤í•‘
            const KOREAN_NAMES = {
                'SUN': 'íƒœì–‘', 'MERCURY': 'ìˆ˜ì„±', 'VENUS': 'ê¸ˆì„±', 'EARTH': 'ì§€êµ¬', 'MARS': 'í™”ì„±',
                'JUPITER': 'ëª©ì„±', 'SATURN': 'í† ì„±', 'URANUS': 'ì²œì™•ì„±', 'NEPTUNE': 'í•´ì™•ì„±',
                'MOON': 'ë‹¬', 'PHOBOS': 'í¬ë³´ìŠ¤', 'DEIMOS': 'ë°ì´ëª¨ìŠ¤',
                'IO': 'ì´ì˜¤', 'EUROPA': 'ìœ ë¡œíŒŒ', 'GANYMEDE': 'ê°€ë‹ˆë©”ë°', 'CALLISTO': 'ì¹¼ë¦¬ìŠ¤í† ',
                'TITAN': 'íƒ€ì´íƒ„', 'ENCELADUS': 'ì—”ì…€ë¼ë‘ìŠ¤', 'MIMAS': 'ë¯¸ë§ˆìŠ¤', 
                'RHEA': 'ë ˆì•„', 'DIONE': 'ë””ì˜¤ë„¤', 'IAPETUS': 'ì´ì•„í˜íˆ¬ìŠ¤',
                'TITANIA': 'í‹°íƒ€ë‹ˆì•„', 'OBERON': 'ì˜¤ë² ë¡ ', 'MIRANDA': 'ë¯¸ë€ë‹¤', 
                'ARIEL': 'ì•„ë¦¬ì—˜', 'UMBRIEL': 'ì›€ë¸Œë¦¬ì—˜',
                'TRITON': 'íŠ¸ë¦¬í†¤', 'PLUTO': 'ëª…ì™•ì„±', 'CHARON': 'ì¹´ë¡ ', 
                'CERES': 'ì„¸ë ˆìŠ¤', 'ERIS': 'ì—ë¦¬ìŠ¤'
            };
            
            // ë©€í‹°ëª¨ë“œë©´ íƒœì–‘ê³„ë§Œ, ì‹±ê¸€ëª¨ë“œë©´ ì „ì²´
            const keysToShow = (window.gameMode === 'multi') 
                ? SOLAR_SYSTEM_BODIES.filter(key => DEFAULT_TYPES[key])
                : Object.keys(DEFAULT_TYPES);
            
            keysToShow.forEach(key => {
                const data = DEFAULT_TYPES[key];
                if (!data) return;
                
                const card = document.createElement('div');
                card.className = 'catalog-card';
                const thumb = document.createElement('div');
                thumb.className = 'catalog-thumb';
                
                // ë¨¼ì € NASA/ìœ„í‚¤ ì´ë¯¸ì§€ ì‚¬ìš©, ì—†ìœ¼ë©´ í…ìŠ¤ì²˜ ë˜ëŠ” ìƒ‰ìƒ
                if (CELESTIAL_IMAGES[key]) {
                    thumb.style.backgroundImage = `url('${CELESTIAL_IMAGES[key]}')`;
                    thumb.style.backgroundSize = 'cover';
                    thumb.style.backgroundPosition = 'center';
                } else {
                    let texUrl = '';
                    if (data.texKey) {
                       texUrl = TEXTURES[data.texKey] ? ASSET_PATH + TEXTURES[data.texKey].map : data.texKey;
                    }
                    if (texUrl) {
                        thumb.style.backgroundImage = `url('${texUrl}')`;
                    } else {
                        const colorHex = (typeof data.color === 'number') ? '#' + new THREE.Color(data.color).getHexString() : data.color;
                        thumb.style.backgroundColor = colorHex;
                        if(data.type==='star') thumb.style.boxShadow = `0 0 10px ${colorHex}`;
                    }
                }
                const name = document.createElement('div');
                name.className = 'catalog-name';
                // ë©€í‹°ëª¨ë“œì—ì„œëŠ” í•œê¸€ ì´ë¦„, ì‹±ê¸€ì—ì„œëŠ” ì˜ì–´
                name.innerText = (window.gameMode === 'multi' && KOREAN_NAMES[key]) ? KOREAN_NAMES[key] : key;
                card.appendChild(thumb);
                card.appendChild(name);
                
                // ë°ìŠ¤í¬í†± í´ë¦­
                card.onclick = () => {
                    document.getElementById('catalog-modal').classList.remove('open');
                    // ë©€í‹°ëª¨ë“œ: ì •ë³´ í‘œì‹œ, ì‹±ê¸€ëª¨ë“œ: ìƒì„±
                    if (window.gameMode === 'multi') {
                        showBodyInfo(key, data);
                    } else {
                        startPlacing({ name: key, type: data, tex: data.texKey }, null);
                    }
                };
                
                // ì‹±ê¸€ëª¨ë“œì—ì„œë§Œ ëª¨ë°”ì¼ ë“œë˜ê·¸ ë°°ì¹˜ í™œì„±í™”
                if (window.gameMode !== 'multi') {
                    // ëª¨ë°”ì¼ ë“œë˜ê·¸ ë°°ì¹˜
                    let catDragGhost = null;
                    let catIsDragging = false;
                    let catStartPos = null;
                    
                    card.addEventListener('touchstart', (e) => {
                        catStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                        catIsDragging = false;
                    });
                    
                    card.addEventListener('touchmove', (e) => {
                        if (!catStartPos) return;
                        const touch = e.touches[0];
                        const dx = touch.clientX - catStartPos.x;
                        const dy = touch.clientY - catStartPos.y;
                        
                        if (Math.abs(dx) > 20 || Math.abs(dy) > 20) {
                            catIsDragging = true;
                            
                            if (!catDragGhost) {
                                // ë„ê° ë‹«ê¸°
                                document.getElementById('catalog-modal').classList.remove('open');
                                
                                // ë“œë˜ê·¸ ê³ ìŠ¤íŠ¸ ìƒì„±
                                catDragGhost = document.createElement('div');
                                catDragGhost.style.cssText = `
                                    position: fixed;
                                    width: 60px;
                                    height: 60px;
                                    border-radius: 50%;
                                    z-index: 10000;
                                    pointer-events: none;
                                    opacity: 0.9;
                                    border: 3px solid #e74c3c;
                                    box-shadow: 0 0 30px #e74c3c;
                                    background-image: ${thumb.style.backgroundImage || 'none'};
                                    background-size: cover;
                                    background-position: center;
                                    background-color: ${thumb.style.backgroundColor || '#333'};
                                `;
                                document.body.appendChild(catDragGhost);
                            }
                            catDragGhost.style.left = (touch.clientX - 30) + 'px';
                            catDragGhost.style.top = (touch.clientY - 30) + 'px';
                        }
                    });
                    
                    card.addEventListener('touchend', (e) => {
                        if (catDragGhost && catIsDragging) {
                            const touch = e.changedTouches[0];
                            // ë“œë¡­ ìœ„ì¹˜ ê³„ì‚°
                            mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
                            mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
                            raycaster.setFromCamera(mouse, camera);
                            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                            const target = new THREE.Vector3();
                            raycaster.ray.intersectPlane(plane, target);
                            
                            if (target) {
                                // â˜…â˜…â˜… 1ë‹¨ê³„: ìœ„ì¹˜ì— ëŒ€ê¸° ì²œì²´ ìƒì„± (ì•„ì§ ë¬¼ë¦¬ ì ìš© ì•ˆë¨) â˜…â˜…â˜…
                                createPendingBody(data, target.clone(), key, data.texKey);
                            }
                            catDragGhost.remove();
                        }
                        catDragGhost = null;
                        catIsDragging = false;
                        catStartPos = null;
                    });
                }
                
                catalogContent.appendChild(card);
            });
        }

        function initUI() { 
            const dock = document.getElementById('spawn-dock'); 
            dock.innerHTML = ''; 
            
            // ë©€í‹°ëª¨ë“œì—ì„œëŠ” ì²œì²´ ìƒì„± ë²„íŠ¼ ìˆ¨ê¸°ê¸°
            if (window.gameMode === 'multi') {
                dock.style.display = 'none';
                return;
            }
            dock.style.display = 'flex';
            
            SPAWN_LIST.forEach(item => { 
                const btn = document.createElement('div'); 
                btn.className = 'spawn-btn'; 
                btn.dataset.name = item.name; 
                
                // NASA/ìœ„í‚¤ ì‹¤ì œ ì´ë¯¸ì§€ ìš°ì„  ì‚¬ìš©
                if (item.tex && CELESTIAL_IMAGES[item.tex]) {
                    btn.style.backgroundImage = `url('${CELESTIAL_IMAGES[item.tex]}')`;
                    btn.style.backgroundSize = 'cover';
                    btn.style.backgroundPosition = 'center';
                } else {
                    let texUrl = '';
                    if (item.tex) {
                       texUrl = TEXTURES[item.tex] ? ASSET_PATH + TEXTURES[item.tex].map : null;
                    }
                    if (texUrl) {
                        btn.style.backgroundImage = `url('${texUrl}')`;
                    } else {
                        btn.style.backgroundColor = '#555';
                    }
                }

                btn.onclick = (e) => { 
                    e.stopPropagation(); 
                    startPlacing(item, btn); 
                }; 
                
                // ëª¨ë°”ì¼ ë“œë˜ê·¸ ë°°ì¹˜
                let dragGhost = null;
                let isDragging = false;
                
                btn.addEventListener('touchstart', (e) => {
                    if (e.cancelable) e.preventDefault();
                    isDragging = false;
                    
                    // ë“œë˜ê·¸ ê³ ìŠ¤íŠ¸ ìƒì„±
                    dragGhost = document.createElement('div');
                    dragGhost.className = 'spawn-btn drag-ghost';
                    dragGhost.style.cssText = `
                        position: fixed;
                        width: 50px;
                        height: 50px;
                        border-radius: 50%;
                        z-index: 10000;
                        pointer-events: none;
                        opacity: 0.8;
                        border: 3px solid #e74c3c;
                        box-shadow: 0 0 20px #e74c3c;
                        background-image: ${btn.style.backgroundImage || 'none'};
                        background-size: cover;
                        background-position: center;
                        background-color: ${btn.style.backgroundColor || '#555'};
                    `;
                    const touch = e.touches[0];
                    dragGhost.style.left = (touch.clientX - 25) + 'px';
                    dragGhost.style.top = (touch.clientY - 25) + 'px';
                    document.body.appendChild(dragGhost);
                });
                
                btn.addEventListener('touchmove', (e) => {
                    if (!dragGhost) return;
                    if (e.cancelable) e.preventDefault();
                    isDragging = true;
                    const touch = e.touches[0];
                    dragGhost.style.left = (touch.clientX - 25) + 'px';
                    dragGhost.style.top = (touch.clientY - 25) + 'px';
                });
                
                btn.addEventListener('touchend', (e) => {
                    if (!dragGhost) return;
                    
                    if (isDragging) {
                        const touch = e.changedTouches[0];
                        // ë“œë¡­ ìœ„ì¹˜ ê³„ì‚°
                        mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
                        mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
                        raycaster.setFromCamera(mouse, camera);
                        const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                        const target = new THREE.Vector3();
                        raycaster.ray.intersectPlane(plane, target);
                        
                        if (target) {
                            // â˜…â˜…â˜… 1ë‹¨ê³„: ìœ„ì¹˜ì— ëŒ€ê¸° ì²œì²´ ìƒì„± (ì•„ì§ ë¬¼ë¦¬ ì ìš© ì•ˆë¨) â˜…â˜…â˜…
                            createPendingBody(item.type, target.clone(), item.name, item.tex);
                        }
                    } else {
                        // ì§§ì€ íƒ­ = ê¸°ì¡´ ë°°ì¹˜ ëª¨ë“œ
                        startPlacing(item, btn);
                    }
                    
                    dragGhost.remove();
                    dragGhost = null;
                    isDragging = false;
                });
                
                dock.appendChild(btn); 
            }); 
        }

        function initSolarSystem(types) {
            createBody(types.SUN, new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,0), "íƒœì–‘", null);
            
            // ì‹¤ì œ ê¶¤ë„ ë°ì´í„° ê¸°ë°˜ í–‰ì„± ë°°ì¹˜
            const baseUnit = 2200;  // ê¸°ë³¸ ë‹¨ìœ„ (ì§€êµ¬ ê¶¤ë„) - 220â†’2200 (10ë°° ì¦ê°€)
            const planets = [
                { type: types.MERCURY, name: "ìˆ˜ì„±", tex: "MERCURY" }, 
                { type: types.VENUS, name: "ê¸ˆì„±", tex: "VENUS" }, 
                { type: types.EARTH, name: "ì§€êµ¬", tex: "EARTH" }, 
                { type: types.MARS, name: "í™”ì„±", tex: "MARS" }, 
                { type: types.JUPITER, name: "ëª©ì„±", tex: "JUPITER" }, 
                { type: types.SATURN, name: "í† ì„±", tex: "SATURN" }, 
                { type: types.URANUS, name: "ì²œì™•ì„±", tex: "URANUS" }, 
                { type: types.NEPTUNE, name: "í•´ì™•ì„±", tex: "NEPTUNE" }
            ];
            
            const now = Date.now() * 0.00001;

            planets.forEach(p => {
                const orbitData = REAL_ORBIT_DATA[p.name];
                if (!orbitData) return;
                
                // â˜…â˜…â˜… íƒ€ì› ê¶¤ë„ ê³„ì‚° â˜…â˜…â˜…
                const a = baseUnit * orbitData.au * CONFIG.distScale;  // ì¥ë°˜ê²½
                const e = orbitData.e || 0;  // ì´ì‹¬ë¥ 
                const inc = (orbitData.i || 0) * Math.PI / 180;  // ê²½ì‚¬ê° (ë¼ë””ì•ˆ)
                const omega = (orbitData.omega || 0) * Math.PI / 180;  // ê·¼ì¼ì  ê²½ë„ (ë¼ë””ì•ˆ)
                
                // í‰ê·  ê·¼ì ì´ê° (Mean Anomaly) - ì‹œê°„ì— ë”°ë¼ ë³€í™”
                const periodFactor = 1 / Math.pow(orbitData.au, 1.5);  // ì¼€í”ŒëŸ¬ ì œ3ë²•ì¹™
                const M = (now * periodFactor * 2 + p.name.charCodeAt(0) * 0.5) % (2 * Math.PI);
                
                // ì´ì‹¬ ê·¼ì ì´ê° (Eccentric Anomaly) - ì¼€í”ŒëŸ¬ ë°©ì •ì‹ í’€ì´
                let E = M;
                for (let i = 0; i < 10; i++) {
                    E = M + e * Math.sin(E);  // ë°˜ë³µë²•
                }
                
                // ì§„ê·¼ì ì´ê° (True Anomaly)
                const nu = 2 * Math.atan2(
                    Math.sqrt(1 + e) * Math.sin(E / 2),
                    Math.sqrt(1 - e) * Math.cos(E / 2)
                );
                
                // ê¶¤ë„ í‰ë©´ì—ì„œì˜ ê±°ë¦¬
                const r = a * (1 - e * e) / (1 + e * Math.cos(nu));
                
                // ê¶¤ë„ í‰ë©´ì—ì„œì˜ ìœ„ì¹˜ (ê·¼ì¼ì  ê²½ë„ ì ìš©)
                const xOrbit = r * Math.cos(nu + omega);
                const yOrbit = r * Math.sin(nu + omega);
                
                // ê¶¤ë„ ê²½ì‚¬ê° ì ìš©í•˜ì—¬ 3D ìœ„ì¹˜ ê³„ì‚°
                const x = xOrbit;
                const y = yOrbit * Math.sin(inc);  // ê²½ì‚¬ê°ì— ì˜í•œ Y ì„±ë¶„
                const z = yOrbit * Math.cos(inc);
                
                // â˜…â˜…â˜… íƒ€ì› ê¶¤ë„ ì†ë„ ê³„ì‚° (vis-viva ë°©ì •ì‹) â˜…â˜…â˜…
                // vÂ² = GM(2/r - 1/a)
                const GM = CONFIG.G * types.SUN.m;
                const speed = Math.sqrt(GM * (2 / r - 1 / a));
                
                // ì†ë„ ë°©í–¥ (ê¶¤ë„ì— ì ‘ì„  ë°©í–¥)
                const vAngle = nu + omega + Math.PI / 2;  // ì§„í–‰ ë°©í–¥
                const vxOrbit = speed * Math.cos(vAngle);
                const vyOrbit = speed * Math.sin(vAngle);
                
                // ê²½ì‚¬ê° ì ìš©
                const vx = vxOrbit;
                const vy = vyOrbit * Math.sin(inc);
                const vz = vyOrbit * Math.cos(inc);

                // ì²œì²´ ìƒì„± ì‹œ ê¶¤ë„ ë°ì´í„° ì €ì¥
                const body = createBody(p.type, new THREE.Vector3(x, y, z), new THREE.Vector3(vx, vy, vz), p.name, p.type.texKey || p.tex);
                if (body) {
                    body.orbitData = {
                        a: a,
                        e: e,
                        i: inc,
                        omega: omega,
                        period: orbitData.period
                    };
                }
            });
            
            // ê¶¤ë„ ë¼ì¸ ìƒì„±
            createAllOrbitLines();
            createMoons();
        }
        
        // â˜…â˜…â˜… ë©€í‹°ëª¨ë“œìš© íƒœì–‘ê³„ ì¬ì´ˆê¸°í™” (ì‹¤ì œ ê±°ë¦¬) â˜…â˜…â˜…
        function reinitSolarSystemForMulti() {
            console.log('ë©€í‹°ëª¨ë“œ: íƒœì–‘ê³„ ì¬ì´ˆê¸°í™” (distScale=' + CONFIG.distScale + ')');
            
            // ê¶¤ë„ ë¼ì¸ ì œê±°
            clearOrbitLines();
            
            // ìœ„ì„± ì œê±°
            satellites.forEach(s => {
                if (s && s.mesh) {
                    scene.remove(s.mesh);
                    s.mesh.traverse(c => {
                        if (c.isCSS2DObject && c.element && c.element.parentNode) {
                            c.element.parentNode.removeChild(c.element);
                        }
                    });
                }
            });
            satellites = [];

            // ëª¨ë“  ì²œì²´ ì œê±° (íƒœì–‘ í¬í•¨, ì€í•˜ ì¤‘ì‹¬ ë¸”ë™í™€ ì œì™¸)
            const galaxyCenterBH = bodies.find(b => b.name === 'ì€í•˜ ì¤‘ì‹¬');
            bodies.forEach(b => {
                if (b && b.mesh && b.name !== 'ì€í•˜ ì¤‘ì‹¬') {
                    scene.remove(b.mesh);
                    b.mesh.traverse(c => {
                        if (c.isCSS2DObject && c.element && c.element.parentNode) {
                            c.element.parentNode.removeChild(c.element);
                        }
                    });
                }
                if (b && b.trail && b.name !== 'ì€í•˜ ì¤‘ì‹¬') scene.remove(b.trail);
            });
            bodies = galaxyCenterBH ? [galaxyCenterBH] : [];

            // íŒŒí‹°í´ ì œê±°
            particles.forEach(p => { if(p && p.mesh) scene.remove(p.mesh); });
            particles = [];

            // â˜…â˜…â˜… ë©€í‹°ëª¨ë“œ: ì„œë²„ ì‹œê°„ ë¨¼ì € ë™ê¸°í™” í›„ íƒœì–‘ê³„ ìƒì„± â˜…â˜…â˜…
            window.multiEpoch = new Date('2025-01-01T00:00:00Z').getTime();  // ê³ ì • ê¸°ì¤€ì 

            // ì„œë²„ ì‹œê°„ ë™ê¸°í™” â†’ íƒœì–‘ê³„ ìƒì„± â†’ ìœ„ì¹˜ ë³´ì • (ìˆœì„œ ì¤‘ìš”!)
            (async function initMultiSolarSystem() {
                // 1. ë¨¼ì € ì„œë²„ ì‹œê°„ ë™ê¸°í™” (í•„ìˆ˜!)
                console.log('ğŸ”„ ë©€í‹°ëª¨ë“œ: ì„œë²„ ì‹œê°„ ë™ê¸°í™” ì¤‘...');
                if (typeof syncServerTime === 'function') {
                    await syncServerTime();
                }
                console.log('âœ… ì„œë²„ ì‹œê°„ ì˜¤í”„ì…‹:', serverTimeOffset, 'ms');

                // 2. ë™ê¸°í™”ëœ ì‹œê°„ìœ¼ë¡œ íƒœì–‘ê³„ ìƒì„±
                initSolarSystem(DEFAULT_TYPES);

                // 3. ì¶”ê°€ ìœ„ì¹˜ ë³´ì • (J2000 ê¸°ë°˜)
                const syncedTime = typeof getSyncedTime === 'function' ? getSyncedTime() : Date.now();
                const elapsedDays = (syncedTime - window.multiEpoch) / (1000 * 60 * 60 * 24);

                // ê° ì²œì²´ì˜ ê¶¤ë„ ìœ„ìƒì„ ì„œë²„ ì‹œê°„ ê¸°ì¤€ìœ¼ë¡œ ì¬ê³„ì‚°
                bodies.forEach(b => {
                    if (b.orbitalPeriod && b.orbitalPeriod > 0) {
                        const orbitsCompleted = elapsedDays / b.orbitalPeriod;
                        b.trueAnomaly = (orbitsCompleted * 2 * Math.PI) % (2 * Math.PI);
                    }
                });

                // ìœ„ì„±ë“¤ë„ ë™ê¸°í™” (seed + ì„œë²„ ì‹œê°„ ê¸°ë°˜)
                satellites.forEach(sat => {
                    const seed = sat.name ? sat.name.split('').reduce((a, c) => a + c.charCodeAt(0), 0) : 0;
                    const baseTime = syncedTime * 0.0000001;
                    sat.angle = (seed * 0.1 + baseTime * sat.orbitSpeed) % (Math.PI * 2);
                });

                // ì¼€í”ŒëŸ¬ ê¶¤ë„ ê°•ì œ ì—…ë°ì´íŠ¸
                if (typeof updateKeplerOrbits === 'function') {
                    updateKeplerOrbits(0);
                }

                console.log('âœ… ë©€í‹°ëª¨ë“œ: ì„œë²„ ì‹œê°„ ë™ê¸°í™” ì™„ë£Œ (ê²½ê³¼:', elapsedDays.toFixed(2), 'ì¼)');
            })();
            
            // ISS ì¬ìƒì„±
            setTimeout(() => {
                if (typeof createISS === 'function') createISS();
            }, 500);
            
            console.log('ë©€í‹°ëª¨ë“œ: íƒœì–‘ê³„ ì¬ì´ˆê¸°í™” ì™„ë£Œ');
        }
        
        // â˜…â˜…â˜… íƒœì–‘ê³„ ì™„ì „ ì´ˆê¸°í™” (ì‚¬ìš©ì ë²„íŠ¼ìš©) â˜…â˜…â˜…
        function resetSolarSystemComplete() {
            console.log('íƒœì–‘ê³„ ì™„ì „ ì´ˆê¸°í™” ì‹œì‘...');
            
            // ìš°ì£¼ì„  ë„í‚¹ í•´ì œ
            if (playerShip && playerShip.isDocked) {
                playerShip.isDocked = false;
            }
            
            // ê¶¤ë„ ë¼ì¸ ì œê±°
            clearOrbitLines();
            
            // ëª¨ë“  ìœ„ì„± ì œê±°
            satellites.forEach(s => {
                if (s && s.mesh) {
                    scene.remove(s.mesh);
                    s.mesh.traverse(c => {
                        if (c.isCSS2DObject && c.element && c.element.parentNode) {
                            c.element.parentNode.removeChild(c.element);
                        }
                    });
                }
            });
            satellites = [];
            
            // ëª¨ë“  ì²œì²´ ì œê±° (íƒœì–‘ í¬í•¨)
            bodies.forEach(b => {
                if (b && b.mesh) {
                    scene.remove(b.mesh);
                    b.mesh.traverse(c => {
                        if (c.isCSS2DObject && c.element && c.element.parentNode) {
                            c.element.parentNode.removeChild(c.element);
                        }
                    });
                }
                if (b && b.trail) scene.remove(b.trail);
            });
            bodies = [];
            
            // íŒŒí‹°í´ ì œê±°
            particles.forEach(p => { if(p && p.mesh) scene.remove(p.mesh); });
            particles = [];
            
            // ì¼€í”ŒëŸ¬ ì‹œê°„ ë¦¬ì…‹ (ë©€í‹°ëª¨ë“œëŠ” ì„œë²„ ë™ê¸°í™” ì‹œê°„ ê¸°ì¤€)
            const syncedTime = typeof getSyncedTime === 'function' ? getSyncedTime() : Date.now();
            keplerTime = window.gameMode === 'multi' ? syncedTime * 0.00000001 : Date.now() * 0.00001;
            
            // íƒœì–‘ê³„ ì¬ìƒì„±
            initSolarSystem(DEFAULT_TYPES);
            
            // ê¶¤ë„ ë¼ì¸ ì¬ìƒì„±
            createAllOrbitLines();
            
            // ISS ì¬ìƒì„±
            setTimeout(() => {
                if (typeof createISS === 'function') createISS();
            }, 300);
            
            // ì¹´ë©”ë¼ë¥¼ íƒœì–‘ìœ¼ë¡œ í¬ì»¤ìŠ¤
            setTimeout(() => {
                const sun = bodies.find(b => b.name === 'íƒœì–‘');
                if (sun) {
                    focusedBody = sun;
                    camera.position.set(0, 300, 500);
                    controls.target.set(0, 0, 0);
                }
            }, 500);
            
            console.log('íƒœì–‘ê³„ ì™„ì „ ì´ˆê¸°í™” ì™„ë£Œ!');
        }
        window.resetSolarSystemComplete = resetSolarSystemComplete;

        function resetSimulation() {
            // ê¶¤ë„ ë¼ì¸ ì œê±°
            clearOrbitLines();
            
            satellites.forEach(s => {
                if (s && s.mesh) {
                    scene.remove(s.mesh);
                    s.mesh.traverse(c => {
                        if (c.isCSS2DObject && c.element && c.element.parentNode) c.element.parentNode.removeChild(c.element);
                    });
                }
            });
            satellites = [];

            const toRemove = bodies.filter(b => b && !b.isStatic);
            toRemove.forEach(b => {
                if (b && b.mesh) {
                    scene.remove(b.mesh);
                    b.mesh.traverse(c => {
                        if (c.isCSS2DObject && c.element && c.element.parentNode) c.element.parentNode.removeChild(c.element);
                    });
                }
                if(b && b.trail) scene.remove(b.trail);
            });
            bodies = bodies.filter(b => b && b.isStatic);
            particles.forEach(p => { if(p && p.mesh) scene.remove(p.mesh); });
            particles = [];
            loadDataAndInit();
        }

        // ===== 1ì¸ì¹­ ì¡°ì¢…ì„ ì‹œìŠ¤í…œ =====
        
        function createCockpitForShip() {
            if (!playerShip || !playerShip.mesh) return;
            
            // ì´ë¯¸ ì¡°ì¢…ì„ì´ ìˆìœ¼ë©´ ì œê±°
            if (cockpitGroup) {
                playerShip.mesh.remove(cockpitGroup);
            }
            
            // í—¥ìŠ¤ í…ìŠ¤ì²˜ ìƒì„±
            function createHexTexture() {
                const c = document.createElement('canvas'); c.width = 512; c.height = 512;
                const ctx = c.getContext('2d');
                ctx.fillStyle = '#050505'; ctx.fillRect(0, 0, 512, 512);
                ctx.strokeStyle = '#333'; ctx.lineWidth = 3;
                for (let y = 0; y < 512; y += 40) {
                    for (let x = 0; x < 512; x += 35) {
                        if ((Math.floor(y / 40)) % 2 == 0) ctx.strokeRect(x, y, 30, 30);
                        else ctx.strokeRect(x + 17, y, 30, 30);
                    }
                }
                const t = new THREE.CanvasTexture(c);
                t.wrapS = t.wrapT = THREE.RepeatWrapping; t.repeat.set(6, 4);
                return t;
            }
            const hexTex = createHexTexture();
            
            // ì¬ì§ˆ ì •ì˜ - â˜… ëª¨ë“  ë¶ˆíˆ¬ëª… ì¬ì§ˆì— depthWrite ê°•ì œ
            const mats = {
                hullInterior: new THREE.MeshStandardMaterial({
                    map: hexTex, color: 0x444444, roughness: 0.5, metalness: 0.7, side: THREE.BackSide,
                    depthWrite: false  // â˜… HUD ê°€ë¦¬ì§€ ì•Šë„ë¡
                }),
                glass: new THREE.MeshStandardMaterial({
                    color: 0x88ccff, metalness: 0.1, roughness: 0.0,
                    transparent: true, opacity: 0.05, side: THREE.DoubleSide,  // â˜… íˆ¬ëª…ë„ ê°ì†Œ
                    depthWrite: false  // â˜… ê¹Šì´ ì“°ê¸° ë¹„í™œì„±í™”ë¡œ ì²œì²´ ê°€ë¦¬ì§€ ì•ŠìŒ
                }),
                frame: new THREE.MeshStandardMaterial({ 
                    color: 0x222222, roughness: 0.2, metalness: 0.9
                }),
                seat: new THREE.MeshStandardMaterial({ 
                    color: 0x333333, roughness: 0.4, metalness: 0.6
                }),
                glowBlue: new THREE.MeshBasicMaterial({ color: 0x00ffff }),
                glowOrange: new THREE.MeshBasicMaterial({ color: 0xffaa00 }),
                hologram: new THREE.MeshBasicMaterial({ 
                    color: 0x00ffff, transparent: true, opacity: 0.3, 
                    side: THREE.DoubleSide, blending: THREE.AdditiveBlending, depthWrite: false 
                })
            };
            
            cockpitGroup = new THREE.Group();
            cockpitGroup.name = 'cockpitGroup';  // â˜… ì´ë¦„ ì¶”ê°€
            cockpitGroup.scale.set(0.4, 0.4, 0.4);  // ìš°ì£¼ì„  í¬ê¸°ì— ë§ê²Œ 
            cockpitGroup.position.set(0, 0, 0.5);  // ìš°ì£¼ì„  ì•ˆìª½ìœ¼ë¡œ ë” ì´ë™
            
            // â˜… ì¡°ì¢…ì„ì´ í•­ìƒ ì²œì²´ ìœ„ì— ë Œë”ë§ë˜ë„ë¡ ì„¤ì •
            cockpitGroup.renderOrder = 999;
            
            // â˜… ì–¸ë„í‚¹ ì—°ì¶œ ì¤‘ì´ë©´ ìˆ¨ê¹€
            if (undockingState && undockingState.active) {
                cockpitGroup.visible = false;
            }
            
            playerShip.mesh.add(cockpitGroup);
            
            // â˜… ì¡°ì¢…ì„ ì¬ì§ˆë“¤ì˜ depthTest ì„¤ì •ì„ ìœ„í•œ í•¨ìˆ˜
            function setCockpitMaterial(mat) {
                mat.depthTest = true;
                mat.depthWrite = true;
            }
            
            // ì¡°ëª…
            const innerLight = new THREE.PointLight(0x00aaff, 1.5, 10);
            innerLight.position.set(0, 1, 0);
            cockpitGroup.add(innerLight);
            const dashLight = new THREE.PointLight(0x00ffff, 0.8, 5);
            dashLight.position.set(0, -0.5, -1);
            cockpitGroup.add(dashLight);
            
            // --- êµ¬í˜• ì‰˜ (í›„ë°© ë°˜êµ¬) --- â˜… ë²”ìœ„ ì•½ê°„ ì¶•ì†Œ (0.55â†’0.48)
            const rearGeo = new THREE.SphereGeometry(2, 64, 64, 0, Math.PI * 2, 0, Math.PI * 0.48);
            const rearShell = new THREE.Mesh(rearGeo, mats.hullInterior);
            rearShell.rotation.x = Math.PI / 2;
            rearShell.renderOrder = -100;  // â˜… HUDë³´ë‹¤ ë¨¼ì € ë Œë”ë§
            cockpitGroup.add(rearShell);
            
            // ì¤‘ì•™ ë§
            const ringGeo = new THREE.TorusGeometry(1.9, 0.05, 16, 64);
            const ring = new THREE.Mesh(ringGeo, mats.frame);
            ring.position.z = 0.25;
            cockpitGroup.add(ring);
            
            // ì „ë°© ìœ ë¦¬ (ë°˜íˆ¬ëª… - ìš°ì£¼ê°€ ë³´ì„)
            const glassGeo = new THREE.SphereGeometry(1.95, 64, 64, 0, Math.PI * 2, 0, Math.PI * 0.48);
            const glassShell = new THREE.Mesh(glassGeo, mats.glass);
            glassShell.rotation.x = -Math.PI / 2;
            cockpitGroup.add(glassShell);
            
            // í…Œë‘ë¦¬
            const borderGeo = new THREE.TorusGeometry(1.95, 0.08, 16, 100);
            const border = new THREE.Mesh(borderGeo, mats.frame);
            cockpitGroup.add(border);
            
            // --- í”Œë¡œíŒ… í”Œë«í¼ ---
            const floatGroup = new THREE.Group();
            floatGroup.position.set(0, 0, 0.3);  // â˜… ì¢Œì„/ì¡°ì¢…ê°„ ì „ì²´ë¥¼ ë’¤ìª½ìœ¼ë¡œ ì´ë™
            cockpitGroup.add(floatGroup);
            cockpitFloatGroup = floatGroup;  // ì• ë‹ˆë©”ì´ì…˜ìš© ì°¸ì¡°
            
            // ë² ì´ìŠ¤
            const baseGeo = new THREE.CylinderGeometry(0.4, 0.3, 0.15, 32);
            const base = new THREE.Mesh(baseGeo, mats.frame);
            base.position.set(0, -0.6, 0);
            floatGroup.add(base);
            
            // ì´ë¯¸í„° (ë°œê´‘)
            const emitter = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.04, 0.2, 16), 
                new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.5 })
            );
            emitter.position.set(0, -0.75, 0);
            floatGroup.add(emitter);
            
            // --- ì¢Œì„ ---
            const seatGroup = new THREE.Group();
            seatGroup.position.set(0, -0.45, 0.15);
            floatGroup.add(seatGroup);
            
            // ì¿ ì…˜
            seatGroup.add(new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.12, 0.5), mats.seat));
            
            // ë“±ë°›ì´
            const back = new THREE.Mesh(new THREE.BoxGeometry(0.45, 0.65, 0.08), mats.seat);
            back.position.set(0, 0.35, 0.2);
            back.rotation.x = -0.15;
            seatGroup.add(back);
            
            // í—¤ë“œë ˆìŠ¤íŠ¸
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.2, 0.08), mats.seat);
            head.position.set(0, 0.72, 0.28);
            seatGroup.add(head);
            
            // íŒ”ê±¸ì´
            const armL = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.04, 0.35), mats.seat);
            armL.position.set(-0.38, 0.25, 0);
            seatGroup.add(armL);
            const armR = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.04, 0.35), mats.seat);
            armR.position.set(0.38, 0.25, 0);
            seatGroup.add(armR);
            
            // --- ëŒ€ì¹­í˜• Yoke ì¡°ì¢…ê°„ ---
            cockpitStickGroup = new THREE.Group();
            cockpitStickGroup.position.set(0, -0.3, -0.4);
            floatGroup.add(cockpitStickGroup);
            
            // ë©”ì¸ ì»¬ëŸ¼ (ê¸°ë‘¥)
            const colGeo = new THREE.CylinderGeometry(0.03, 0.04, 0.3, 16);
            const column = new THREE.Mesh(colGeo, mats.frame);
            column.position.y = -0.1;
            column.rotation.x = -0.3;
            cockpitStickGroup.add(column);
            
            // ì¤‘ì•™ í—ˆë¸Œ
            const hubGeo = new THREE.BoxGeometry(0.1, 0.06, 0.06);
            const hub = new THREE.Mesh(hubGeo, mats.frame);
            hub.rotation.x = -0.3;
            cockpitStickGroup.add(hub);
            
            // ì¤‘ì•™ ë¯¸ë‹ˆ ìŠ¤í¬ë¦°
            const hubScreen = new THREE.Mesh(new THREE.PlaneGeometry(0.08, 0.05), mats.hologram);
            hubScreen.position.set(0, 0.01, 0.035);
            hubScreen.rotation.x = -0.3;
            cockpitStickGroup.add(hubScreen);
            
            // í•¸ë“¤ ìƒì„± í•¨ìˆ˜
            function createYokeHandle(side) {
                const handleGrp = new THREE.Group();
                handleGrp.position.set(side * 0.18, 0, 0);
                handleGrp.rotation.x = -0.3;
                
                // ê°€ë¡œë°”
                const bar = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.02, 0.12, 8), mats.frame);
                bar.rotation.z = Math.PI / 2;
                bar.position.set(-side * 0.06, 0, 0);
                handleGrp.add(bar);
                
                // ê·¸ë¦½
                const grip = new THREE.Mesh(new THREE.CylinderGeometry(0.028, 0.025, 0.15, 12), mats.seat);
                grip.rotation.z = side * 0.15;
                handleGrp.add(grip);
                
                // ìƒë‹¨ í—¤ë“œ
                const headMesh = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.05, 0.05), mats.frame);
                headMesh.position.set(side * 0.008, 0.08, 0.008);
                headMesh.rotation.z = side * 0.15;
                handleGrp.add(headMesh);
                
                // ì—„ì§€ ë²„íŠ¼ (ì£¼í™©)
                const btn1 = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 0.008, 8), mats.glowOrange);
                btn1.position.set(side * 0.008, 0.11, 0.015);
                btn1.rotation.x = 0.5;
                handleGrp.add(btn1);
                
                // ë³´ì¡° ë²„íŠ¼ (íŒŒë‘)
                const btn2 = new THREE.Mesh(new THREE.BoxGeometry(0.008, 0.015, 0.008), mats.glowBlue);
                btn2.position.set(-side * 0.015, 0.09, 0.015);
                handleGrp.add(btn2);
                
                // ì „ë©´ íŠ¸ë¦¬ê±°
                const trigger = new THREE.Mesh(new THREE.BoxGeometry(0.015, 0.04, 0.015), mats.glowOrange);
                trigger.position.set(side * 0.008, 0.015, -0.028);
                trigger.rotation.x = 0.2;
                handleGrp.add(trigger);
                
                return handleGrp;
            }
            
            cockpitStickGroup.add(createYokeHandle(-1));  // ì™¼ìª½
            cockpitStickGroup.add(createYokeHandle(1));   // ì˜¤ë¥¸ìª½
            
            // --- â˜… ìƒˆë¡œìš´ ìœ ë¦¬ íˆ¬ì˜ HUD ì‹œìŠ¤í…œ ---
            function createGlassHUDPanel(posX, posY, posZ, width, height, canvasW, canvasH, curveAmount = 0.15) {
                // ê³¡ë©´ PlaneGeometry ìƒì„±
                const geometry = new THREE.PlaneGeometry(width, height, 32, 16);
                // ì •ì ì„ ê³¡ë©´ìœ¼ë¡œ ë³€í˜• (ìœ ë¦¬ ê³¡ë¥  ì‹œë®¬ë ˆì´ì…˜)
                const pos = geometry.attributes.position;
                for (let i = 0; i < pos.count; i++) {
                    const x = pos.getX(i);
                    const y = pos.getY(i);
                    // ì¤‘ì•™ì—ì„œ ë©€ì–´ì§ˆìˆ˜ë¡ ë’¤ë¡œ ë°€ë¦¼ (êµ¬ë©´ íš¨ê³¼)
                    const distFromCenter = Math.sqrt(x * x + y * y);
                    const z = -distFromCenter * distFromCenter * curveAmount;
                    pos.setZ(i, z);
                }
                geometry.computeVertexNormals();

                const canvas = document.createElement('canvas');
                canvas.width = canvasW; canvas.height = canvasH;
                const tex = new THREE.CanvasTexture(canvas);
                tex.minFilter = THREE.LinearFilter;
                const mat = new THREE.MeshBasicMaterial({
                    map: tex, transparent: true, opacity: 0.7,  // â˜… 20% ë” íˆ¬ëª…
                    side: THREE.DoubleSide, blending: THREE.AdditiveBlending,
                    depthWrite: false, depthTest: false  // â˜… rearShell ê¹Šì´ ë¬´ì‹œí•˜ì—¬ í´ë¦¬í•‘ ë°©ì§€
                });
                const mesh = new THREE.Mesh(geometry, mat);
                mesh.position.set(posX, posY, posZ);
                mesh.renderOrder = 1000;  // â˜… rearShell(-100)ë³´ë‹¤ í™•ì‹¤íˆ ë‚˜ì¤‘ì— ë Œë”ë§
                mesh.frustumCulled = false;  // â˜…â˜…â˜… ì¹´ë©”ë¼ ê°€ê¹Œì´ ìˆì–´ë„ í´ë¦¬í•‘ ë°©ì§€
                return { ctx: canvas.getContext('2d'), tex, mesh, canvas, width, height };
            }

            // â˜… ì¤‘ì•™ ì¡°ì¤€ì„  (ì •ë©´ ì¤‘ì•™, ì„ íšŒ ì¡°ì‘ìš©) - í¬ê¸° ìœ ì§€, ì†ë„ í‘œì‹œ í¬í•¨
            glassHUD.reticle = createGlassHUDPanel(0, 0.05, -1.6, 0.6, 0.7, 256, 320, 0.01);
            glassHUD.reticle.mesh.material.opacity = 0.8;
            cockpitGroup.add(glassHUD.reticle.mesh);

            // â˜… ì¢Œì¸¡ ìƒë‹¨ íŒ¨ë„ (ì†ë„) - 20% ë” ë©€ë¦¬
            glassHUD.leftPanel = createGlassHUDPanel(-1.2, 0.25, -1.5, 0.8, 1.1, 512, 768, 0.03);
            glassHUD.leftPanel.mesh.rotation.y = 0.3;
            cockpitGroup.add(glassHUD.leftPanel.mesh);

            // â˜… ì¢Œì¸¡ í•˜ë‹¨ íŒ¨ë„ (ì—°ë£Œ, í—) - 20% ë” ë©€ë¦¬
            glassHUD.leftBottomPanel = createGlassHUDPanel(-1.15, -0.4, -1.5, 0.7, 0.9, 512, 640, 0.03);
            glassHUD.leftBottomPanel.mesh.rotation.y = 0.28;
            cockpitGroup.add(glassHUD.leftBottomPanel.mesh);

            // â˜… ìš°ì¸¡ ìƒë‹¨ íŒ¨ë„ (ì¢Œí‘œ, ëª©í‘œ) - 20% ë” ë©€ë¦¬
            glassHUD.rightPanel = createGlassHUDPanel(1.2, 0.05, -1.45, 1.4, 1.8, 768, 1024, 0.04);  // â˜… y: 0.2â†’0.05 ë‚´ë¦¼
            glassHUD.rightPanel.mesh.rotation.y = -0.34;
            cockpitGroup.add(glassHUD.rightPanel.mesh);

            // â˜… ìš°ì¸¡ í•˜ë‹¨ íŒ¨ë„ (ì˜¤í† íŒŒì¼ëŸ¿) - 20% ë” ë©€ë¦¬
            glassHUD.rightBottomPanel = createGlassHUDPanel(1.15, -0.45, -1.45, 1.3, 1.5, 768, 896, 0.03);
            glassHUD.rightBottomPanel.mesh.rotation.y = -0.3;
            cockpitGroup.add(glassHUD.rightBottomPanel.mesh);

            // â˜… í•˜ë‹¨ ì¤‘ì•™ íŒ¨ë„ (ë ˆì´ë”) - í¬ê¸° í™•ëŒ€
            glassHUD.bottomPanel = createGlassHUDPanel(0, -0.6, -1.5, 1.2, 0.8, 768, 512, 0.02);
            glassHUD.bottomPanel.mesh.rotation.x = -0.12;
            cockpitGroup.add(glassHUD.bottomPanel.mesh);

            // ë ˆê±°ì‹œ HUD ì œê±° (í˜¸í™˜ì„± ìœ ì§€)
            cockpitMainHUD = null;
            cockpitSubHUD = null;
            
            // ë²„íŠ¼ ê¹œë¹¡ì„ìš© (ê¸°ì¡´ í˜¸í™˜)
            cockpitBtnMesh = null;
            cockpitBlinkIndices = [];
            cockpitMonitors = {};
        }
        
        function createCarbonTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#111'; ctx.fillRect(0, 0, 256, 256);
            ctx.fillStyle = '#1a1a1a';
            for (let y = 0; y < 256; y += 4) {
                for (let x = 0; x < 256; x += 4) {
                    if ((x + y) % 8 === 0) ctx.fillRect(x, y, 2, 2);
                }
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(4, 4);
            return tex;
        }
        
        function createCockpitMonitor(type, w, h, x, y, z, rotY) {
            const g = new THREE.Group();
            g.position.set(x, y, z);
            g.rotation.y = rotY;
            g.rotation.x = -0.3;
            
            const caseMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.5, metalness: 0.7 });
            g.add(new THREE.Mesh(new THREE.BoxGeometry(w + 0.02, h + 0.02, 0.015), caseMat));
            
            const cvs = document.createElement('canvas');
            cvs.width = 256;
            cvs.height = 256;
            const tex = new THREE.CanvasTexture(cvs);
            const scr = new THREE.Mesh(new THREE.PlaneGeometry(w, h), new THREE.MeshBasicMaterial({ map: tex }));
            scr.position.z = 0.009;
            g.add(scr);
            
            cockpitGroup.add(g);
            cockpitMonitors[type] = { ctx: cvs.getContext('2d'), tex, canvas: cvs };
        }
        
        function updateCockpitMonitors(time) {
            if (!playerShip) return;

            // â˜… ìƒˆë¡œìš´ ìœ ë¦¬ HUD ì‹œìŠ¤í…œ ì—…ë°ì´íŠ¸

            // === ì¤‘ì•™ ì¡°ì¤€ì„  (256x320) + ì†ë„ í‘œì‹œ ===
            if (glassHUD.reticle && glassHUD.reticle.ctx) {
                const ctx = glassHUD.reticle.ctx;
                const W = 256, H = 320;
                const cx = W / 2, cy = 110;  // ì›ì˜ ì¤‘ì‹¬ì„ ìœ„ë¡œ
                ctx.clearRect(0, 0, W, H);

                ctx.strokeStyle = '#00ffff';
                ctx.fillStyle = '#00ffff';
                ctx.lineWidth = 2;
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 8;

                // ì™¸ë¶€ ì›ë§Œ (ë‚´ë¶€ ì› ì œê±°)
                ctx.beginPath();
                ctx.arc(cx, cy, 70, 0, Math.PI * 2);
                ctx.stroke();

                // ì‹­ìì„ 
                ctx.beginPath();
                ctx.moveTo(cx - 100, cy); ctx.lineTo(cx - 50, cy);
                ctx.moveTo(cx + 50, cy); ctx.lineTo(cx + 100, cy);
                ctx.moveTo(cx, cy - 100); ctx.lineTo(cx, cy - 50);
                ctx.moveTo(cx, cy + 50); ctx.lineTo(cx, cy + 100);
                ctx.stroke();

                // ì¤‘ì•™ ì  (íƒ€ì )
                ctx.fillStyle = '#00ffff';
                ctx.beginPath();
                ctx.arc(cx, cy, 3, 0, Math.PI * 2);
                ctx.fill();

                // í”¼ì¹˜ ë¼ì¸ (ìì„¸ í‘œì‹œ)
                const pitch = (shipInputs.pitch || 0) * 40;
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.4)';
                ctx.lineWidth = 1;
                for (let i = -2; i <= 2; i++) {
                    if (i === 0) continue;
                    const y = cy + i * 25 + pitch;
                    ctx.beginPath();
                    ctx.moveTo(cx - 35, y); ctx.lineTo(cx - 18, y);
                    ctx.moveTo(cx + 18, y); ctx.lineTo(cx + 35, y);
                    ctx.stroke();
                }

                // â˜… ì†ë„ í‘œì‹œ (ì› ì•„ë˜)
                ctx.shadowBlur = 10;
                ctx.fillStyle = '#00ffff';
                ctx.font = 'bold 36px Orbitron, sans-serif';
                ctx.textAlign = 'center';
                const speed = playerShip.speed || 0;
                ctx.fillText(`${speed.toFixed(0)}`, cx, 230);
                ctx.font = '14px Orbitron, sans-serif';
                ctx.fillStyle = 'rgba(0, 255, 255, 0.7)';
                ctx.fillText('km/s', cx, 252);

                // km/h ë³€í™˜ í‘œì‹œ
                ctx.font = '11px Orbitron, sans-serif';
                ctx.fillStyle = 'rgba(0, 255, 255, 0.5)';
                const kmh = speed * 3600;
                if (kmh >= 1e9) {
                    ctx.fillText(`(${(kmh / 1e9).toFixed(1)}B km/h)`, cx, 272);
                } else if (kmh >= 1e6) {
                    ctx.fillText(`(${(kmh / 1e6).toFixed(1)}M km/h)`, cx, 272);
                } else if (kmh >= 1e3) {
                    ctx.fillText(`(${(kmh / 1e3).toFixed(0)}K km/h)`, cx, 272);
                } else {
                    ctx.fillText(`(${kmh.toFixed(0)} km/h)`, cx, 272);
                }

                glassHUD.reticle.tex.needsUpdate = true;
            }

            // === ì¢Œì¸¡ ìƒë‹¨ íŒ¨ë„ (512x768) - ìŠ¤ë¡œí‹€ í‘œì‹œ (2ë°° í¬ê¸°) ===
            if (glassHUD.leftPanel && glassHUD.leftPanel.ctx) {
                const ctx = glassHUD.leftPanel.ctx;
                const W = 512, H = 768;
                const PAD = 80;  // â˜… ìƒë‹¨ ì—¬ë°± (í´ë¦¬í•‘ ë°©ì§€)
                ctx.clearRect(0, 0, W, H);

                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 10;

                // íƒ€ì´í‹€
                ctx.fillStyle = '#00ffff';
                ctx.font = 'bold 28px Orbitron, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('ENGINE STATUS', W/2, PAD + 60);

                // ìŠ¤ë¡œí‹€ ë°” (ê°€ë¡œ)
                const throttle = shipInputs.throttle || 0;
                ctx.fillStyle = '#00ffff';
                ctx.font = '22px Orbitron, sans-serif';
                ctx.fillText('THROTTLE', W/2, PAD + 130);
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 2;
                ctx.strokeRect(60, PAD + 160, W - 120, 36);
                ctx.fillStyle = throttle > 0 ? '#00ffaa' : '#ff6600';
                const barW = Math.abs(throttle) * (W - 128) / 2;
                if (throttle > 0) {
                    ctx.fillRect(W/2, PAD + 164, barW, 28);
                } else {
                    ctx.fillRect(W/2 - barW, PAD + 164, barW, 28);
                }
                // ì¤‘ì•™ì„ 
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(W/2, PAD + 160);
                ctx.lineTo(W/2, PAD + 196);
                ctx.stroke();

                // ìŠ¤ë¡œí‹€ % í‘œì‹œ
                ctx.fillStyle = '#ffffff';
                ctx.font = '18px Orbitron, sans-serif';
                ctx.fillText(`${(throttle * 100).toFixed(0)}%`, W/2, PAD + 230);

                // ìë™í•­ë²• ìƒíƒœ
                ctx.fillStyle = autopilot.engaged ? '#00ff88' : 'rgba(0,255,255,0.3)';
                ctx.font = '20px Orbitron, sans-serif';
                ctx.fillText(autopilot.engaged ? 'â—‰ AUTOPILOT ON' : 'â—‹ MANUAL', W/2, PAD + 300);

                glassHUD.leftPanel.tex.needsUpdate = true;
            }

            // === ì¢Œì¸¡ í•˜ë‹¨ íŒ¨ë„ (512x640) - ì—°ë£Œ, í— (2ë°° í¬ê¸°) ===
            if (glassHUD.leftBottomPanel && glassHUD.leftBottomPanel.ctx) {
                const ctx = glassHUD.leftBottomPanel.ctx;
                const W = 512, H = 640;
                const PAD = 60;  // â˜… ìƒë‹¨ ì—¬ë°± ì¶”ê°€
                ctx.clearRect(0, 0, W, H);

                ctx.shadowColor = '#00ff88';
                ctx.shadowBlur = 10;

                // â˜… ì—°ë£Œ í¼ì„¼íŠ¸ ì˜¬ë°”ë¥´ê²Œ ê³„ì‚° (maxFuel ê¸°ì¤€)
                const fuelRaw = playerShip.fuel !== undefined ? playerShip.fuel : SHIP_CONFIG.maxFuel;
                const fuelPercent = (fuelRaw / SHIP_CONFIG.maxFuel) * 100;

                // ì—°ë£Œ
                ctx.fillStyle = '#00ff88';
                ctx.font = 'bold 24px Orbitron, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('FUEL', W/2, PAD + 50);
                ctx.strokeStyle = '#00ff88';
                ctx.lineWidth = 2;
                ctx.strokeRect(50, PAD + 70, W - 100, 44);
                ctx.fillStyle = fuelPercent > 30 ? '#00ff88' : '#ff4444';
                ctx.fillRect(54, PAD + 74, (W - 108) * Math.min(fuelPercent / 100, 1), 36);
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 26px Orbitron, sans-serif';
                ctx.fillText(`${fuelPercent.toFixed(0)}%`, W/2, PAD + 102);

                // â˜… í— í¼ì„¼íŠ¸ ì˜¬ë°”ë¥´ê²Œ ê³„ì‚° (maxHull ê¸°ì¤€)
                const hullRaw = playerShip.hull !== undefined ? playerShip.hull : SHIP_CONFIG.maxHull;
                const hullPercent = (hullRaw / SHIP_CONFIG.maxHull) * 100;

                ctx.fillStyle = '#ff8800';
                ctx.font = 'bold 24px Orbitron, sans-serif';
                ctx.fillText('HULL INTEGRITY', W/2, PAD + 180);
                ctx.strokeStyle = '#ff8800';
                ctx.strokeRect(50, PAD + 200, W - 100, 44);
                ctx.fillStyle = hullPercent > 30 ? '#ff8800' : '#ff2222';
                ctx.fillRect(54, PAD + 204, (W - 108) * Math.min(hullPercent / 100, 1), 36);
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 26px Orbitron, sans-serif';
                ctx.fillText(`${hullPercent.toFixed(0)}%`, W/2, PAD + 232);

                // ìƒíƒœ í…ìŠ¤íŠ¸
                ctx.font = '16px Orbitron, sans-serif';
                if (hullPercent <= 30) {
                    ctx.fillStyle = '#ff2222';
                    ctx.fillText('âš  CRITICAL DAMAGE', W/2, PAD + 290);
                } else if (fuelPercent <= 20) {
                    ctx.fillStyle = '#ffaa00';
                    ctx.fillText('âš  LOW FUEL WARNING', W/2, PAD + 290);
                } else {
                    ctx.fillStyle = '#00ff88';
                    ctx.fillText('â—‰ SYSTEMS NOMINAL', W/2, PAD + 290);
                }

                glassHUD.leftBottomPanel.tex.needsUpdate = true;
            }

            // === ìš°ì¸¡ ìƒë‹¨ íŒ¨ë„ (768x1024) - ì¢Œí‘œ, ëª©í‘œ (2ë°° í¬ê¸°) ===
            if (glassHUD.rightPanel && glassHUD.rightPanel.ctx) {
                const ctx = glassHUD.rightPanel.ctx;
                const W = 768, H = 1024;
                const PAD = 100;  // â˜… ìƒë‹¨ ì—¬ë°± (í´ë¦¬í•‘ ë°©ì§€)
                ctx.clearRect(0, 0, W, H);

                ctx.shadowColor = '#00aaff';
                ctx.shadowBlur = 10;

                // ì¢Œí‘œ
                ctx.fillStyle = '#00aaff';
                ctx.font = 'bold 28px Orbitron, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('POSITION', W/2, PAD + 50);
                if (playerShip.mesh) {
                    const pos = playerShip.mesh.position;
                    ctx.font = '20px Orbitron, sans-serif';
                    ctx.fillStyle = '#ffffff';
                    ctx.fillText(`X: ${pos.x.toFixed(1)}`, W/2, PAD + 95);
                    ctx.fillText(`Y: ${pos.y.toFixed(1)}`, W/2, PAD + 125);
                    ctx.fillText(`Z: ${pos.z.toFixed(1)}`, W/2, PAD + 155);
                }

                // ëª©í‘œ
                ctx.fillStyle = '#ff6600';
                ctx.font = 'bold 28px Orbitron, sans-serif';
                ctx.fillText('TARGET', W/2, PAD + 220);
                if (shipTargetBody) {
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 30px Orbitron, sans-serif';
                    ctx.fillText(shipTargetBody.name || 'Unknown', W/2, PAD + 270);

                    // ê±°ë¦¬ (ì‹¤ì œ AUë¡œ ë³€í™˜)
                    const rawDist = playerShip.mesh.position.distanceTo(shipTargetBody.mesh.position);
                    const dist = rawDist / (CONFIG.distScale || 1);  // â˜… ì‹¤ì œ AUë¡œ ë³€í™˜
                    let distText;
                    if (dist < 0.001) distText = `${(dist * 149597870).toFixed(0)} km`;
                    else if (dist < 0.1) distText = `${(dist * 149597.87).toFixed(0)} km`;
                    else if (dist < 10) distText = `${dist.toFixed(3)} AU`;
                    else distText = `${dist.toFixed(1)} AU`;
                    ctx.font = '22px Orbitron, sans-serif';
                    ctx.fillStyle = '#00ffff';
                    ctx.fillText(`DIST: ${distText}`, W/2, PAD + 320);

                    // ETA
                    if (playerShip.speed > 0.1) {
                        const distKm = dist * 149597.87;
                        const eta = distKm / playerShip.speed;
                        let etaText;
                        if (eta < 60) etaText = `${eta.toFixed(0)}s`;
                        else if (eta < 3600) etaText = `${Math.floor(eta/60)}m ${Math.floor(eta%60)}s`;
                        else etaText = `${Math.floor(eta/3600)}h ${Math.floor((eta%3600)/60)}m`;
                        ctx.fillText(`ETA: ${etaText}`, W/2, PAD + 365);
                    }
                } else {
                    ctx.fillStyle = '#666666';
                    ctx.font = '22px Orbitron, sans-serif';
                    ctx.fillText('No Target', W/2, PAD + 270);
                }

                glassHUD.rightPanel.tex.needsUpdate = true;
            }

            // === ìš°ì¸¡ í•˜ë‹¨ íŒ¨ë„ (512x640) - ì˜¤í† íŒŒì¼ëŸ¿ (2ë°° í¬ê¸°) ===
            if (glassHUD.rightBottomPanel && glassHUD.rightBottomPanel.ctx) {
                const ctx = glassHUD.rightBottomPanel.ctx;
                const W = 512, H = 640;
                ctx.clearRect(0, 0, W, H);

                ctx.shadowColor = autopilot.engaged ? '#00ff00' : '#666666';
                ctx.shadowBlur = 10;

                // ì˜¤í† íŒŒì¼ëŸ¿
                ctx.fillStyle = autopilot.engaged ? '#00ff00' : '#666666';
                ctx.font = 'bold 26px Orbitron, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('NAVIGATION', W/2, 60);
                ctx.font = 'bold 40px Orbitron, sans-serif';
                ctx.fillText(autopilot.engaged ? 'AUTO' : 'MANUAL', W/2, 120);
                if (autopilot.engaged && autopilot.phase) {
                    ctx.font = '20px Orbitron, sans-serif';
                    ctx.fillStyle = '#00ffff';
                    ctx.fillText(autopilot.phase.toUpperCase(), W/2, 165);
                }

                // í˜„ì¬ ì‹œê°„
                ctx.fillStyle = 'rgba(0,255,255,0.5)';
                ctx.font = '16px Orbitron, sans-serif';
                const now = new Date();
                ctx.fillText(`${now.getHours().toString().padStart(2,'0')}:${now.getMinutes().toString().padStart(2,'0')}:${now.getSeconds().toString().padStart(2,'0')} UTC`, W/2, 220);

                glassHUD.rightBottomPanel.tex.needsUpdate = true;
            }

            // === í•˜ë‹¨ íŒ¨ë„ (768x512) - ë ˆì´ë” (2ë°° í¬ê¸°) ===
            if (glassHUD.bottomPanel && glassHUD.bottomPanel.ctx) {
                const ctx = glassHUD.bottomPanel.ctx;
                const W = 768, H = 512;
                ctx.clearRect(0, 0, W, H);

                // ë ˆì´ë” ì¤‘ì•™
                const rcx = W / 2, rcy = H / 2 - 20;
                ctx.strokeStyle = '#ffaa00';
                ctx.fillStyle = '#ffaa00';
                ctx.lineWidth = 2;
                ctx.shadowColor = '#ffaa00';
                ctx.shadowBlur = 10;

                // ë ˆì´ë” ì› (2ë°° í¬ê¸°)
                ctx.beginPath(); ctx.arc(rcx, rcy, 140, 0, Math.PI * 2); ctx.stroke();
                ctx.beginPath(); ctx.arc(rcx, rcy, 70, 0, Math.PI * 2); ctx.stroke();
                ctx.beginPath(); ctx.arc(rcx, rcy, 105, 0, Math.PI * 2); ctx.stroke();

                // ì‹­ìì„ 
                ctx.strokeStyle = 'rgba(255, 170, 0, 0.3)';
                ctx.beginPath();
                ctx.moveTo(rcx - 140, rcy); ctx.lineTo(rcx + 140, rcy);
                ctx.moveTo(rcx, rcy - 140); ctx.lineTo(rcx, rcy + 140);
                ctx.stroke();

                // ìŠ¤ìº” ë¼ì¸
                ctx.strokeStyle = 'rgba(255, 170, 0, 0.6)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(rcx, rcy);
                ctx.lineTo(rcx + Math.cos(time * 2) * 140, rcy + Math.sin(time * 2) * 140);
                ctx.stroke();

                // ëª©í‘œ ì 
                if (shipTargetBody && playerShip.mesh) {
                    const dir = new THREE.Vector3().subVectors(shipTargetBody.mesh.position, playerShip.mesh.position);
                    dir.normalize();
                    const localDir = dir.clone().applyQuaternion(playerShip.mesh.quaternion.clone().invert());
                    ctx.fillStyle = '#ff3333';
                    ctx.beginPath();
                    ctx.arc(rcx + localDir.x * 110, rcy - localDir.z * 110, 10, 0, Math.PI * 2);
                    ctx.fill();
                    // ëª©í‘œ ì´ë¦„ í‘œì‹œ
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '14px Orbitron, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(shipTargetBody.name || '', rcx + localDir.x * 110, rcy - localDir.z * 110 - 18);
                }

                // ìê¸° ìœ„ì¹˜
                ctx.fillStyle = '#00ffff';
                ctx.beginPath();
                ctx.moveTo(rcx, rcy - 10);
                ctx.lineTo(rcx - 8, rcy + 8);
                ctx.lineTo(rcx + 8, rcy + 8);
                ctx.closePath();
                ctx.fill();

                ctx.fillStyle = '#ffaa00';
                ctx.font = 'bold 20px Orbitron, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('RADAR', rcx, H - 30);

                // ë°©í–¥ í‘œì‹œ
                ctx.font = '14px Orbitron, sans-serif';
                ctx.fillStyle = 'rgba(255,170,0,0.6)';
                ctx.fillText('N', rcx, rcy - 150);
                ctx.fillText('S', rcx, rcy + 165);
                ctx.fillText('W', rcx - 155, rcy + 5);
                ctx.fillText('E', rcx + 155, rcy + 5);

                glassHUD.bottomPanel.tex.needsUpdate = true;
            }

            // ë ˆê±°ì‹œ HUD (í˜¸í™˜ì„±) - ì´ì œ ì‚¬ìš© ì•ˆí•¨
            if (cockpitMainHUD && cockpitMainHUD.ctx) {
                cockpitMainHUD.tex.needsUpdate = false;
            }
            if (cockpitSubHUD && cockpitSubHUD.ctx) {
                cockpitSubHUD.tex.needsUpdate = false;
            }
        }
        
        function updateCockpitView(dt) {
            if (!cockpitGroup || !isPilotMode || isInteriorMode || isObservatoryMode) return;
            if (!playerShip || !playerShip.mesh) return;
            if (window.isDocking) return;  // â˜… ë„í‚¹ ì¤‘ì´ë©´ ì¹´ë©”ë¼ ì—…ë°ì´íŠ¸ ì•ˆ í•¨
            
            const time = performance.now() * 0.001;
            
            // ì¹´ë©”ë¼ íšŒì „ ë³´ê°„
            cockpitLookRotY += (cockpitTargetRotY - cockpitLookRotY) * COCKPIT_DAMPING;
            cockpitLookRotX += (cockpitTargetRotX - cockpitLookRotX) * COCKPIT_DAMPING;
            
            // 1ì¸ì¹­ ì‹œì ì¼ ë•Œ ì¹´ë©”ë¼ë¥¼ ì¡°ì¢…ì„ ë‚´ë¶€ì— ë°°ì¹˜
            if (isCockpitView) {
                // ì¹´ë©”ë¼ë¥¼ ìš°ì£¼ì„ ì—ì„œ ë¶„ë¦¬í•˜ê³  ì§ì ‘ ìœ„ì¹˜ ì„¤ì •
                if (camera.parent === playerShip.mesh) {
                    scene.add(camera);
                }
                
                // ì¡°ì¢…ì„ ë‚´ë¶€ ì¢Œì„ ìœ„ì¹˜ (cockpitGroup ë¡œì»¬ ì¢Œí‘œ)
                // â˜… ì¡°ì¢…ì„ì´ z=0.3 ë’¤ë¡œ ì´ë™í–ˆìœ¼ë¯€ë¡œ ì‹œì ë„ ì´ë™ (ì˜ìë³´ë‹¤ëŠ” ì•ìª½)
                const seatOffset = new THREE.Vector3(0, 0, 0.2);

                const cockpitWorldPos = new THREE.Vector3();
                cockpitGroup.getWorldPosition(cockpitWorldPos);

                const offsetWorld = seatOffset.clone().applyQuaternion(playerShip.mesh.quaternion);
                camera.position.copy(cockpitWorldPos).add(offsetWorld);
                
                // ìš°ì£¼ì„  ë°©í–¥ + ê³ ê°œ íšŒì „
                camera.quaternion.copy(playerShip.mesh.quaternion);
                const headQuat = new THREE.Quaternion().setFromEuler(new THREE.Euler(cockpitLookRotX, cockpitLookRotY, 0, 'YXZ'));
                camera.quaternion.multiply(headQuat);
            }
            
            // í”Œë¡œíŒ… í”Œë«í¼ ì• ë‹ˆë©”ì´ì…˜ (ì‚´ì§ ë– ë‹¤ë‹ˆëŠ” íš¨ê³¼)
            if (cockpitFloatGroup) {
                cockpitFloatGroup.position.y = Math.sin(time * 0.5) * 0.03;
                cockpitFloatGroup.rotation.z = Math.sin(time * 0.2) * 0.015;
            }
            
            // Yoke ì¡°ì¢…ê°„ ì›€ì§ì„ (ì…ë ¥ì— ë”°ë¼)
            if (cockpitStickGroup) {
                // YokeëŠ” ì•ë’¤ë¡œ ë°€ê³  ë‹¹ê¸°ëŠ” ëŠë‚Œ
                cockpitStickGroup.rotation.x = -0.3 + shipInputs.pitch * 0.2 + Math.sin(time * 10) * 0.002;
                // ì¢Œìš° ê¸°ìš¸ê¸° (yaw ìŒìˆ˜ = ìš°íšŒì „ = ìŠ¤í‹± ì˜¤ë¥¸ìª½)
                cockpitStickGroup.rotation.z = shipInputs.yaw * 0.15 + Math.sin(time * 8) * 0.002;
            }
            
            // ëª¨ë‹ˆí„°/HUD ì—…ë°ì´íŠ¸
            updateCockpitMonitors(time);
        }

        // ===== ì„ ë‚´ ì‹œìŠ¤í…œ í•¨ìˆ˜ë“¤ =====
        
        function initInteriorScene() {
            interiorScene = new THREE.Scene();
            interiorScene.background = new THREE.Color(0x050508);
            interiorCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            interiorRenderer = new THREE.WebGLRenderer({ antialias: true });
            interiorRenderer.setSize(window.innerWidth, window.innerHeight);
            interiorRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            interiorRenderer.shadowMap.enabled = true;
            
            interiorScene.add(new THREE.AmbientLight(0xffffff, 0.5));
            interiorScene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.4));
            
            // ì „ë§ëŒ€ ì¹´ë©”ë¼
            obsCamera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 300000000);
            
            createCorridor();
            createDetailedRooms();
        }
        
        function createStaticCollider(x, y, z, w, h, d, mat, name = null) {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
            mesh.position.set(x, y, z);
            mesh.userData.isStatic = true;
            mesh.userData.collider = { 
                min: new THREE.Vector3(x - w/2, y - h/2, z - d/2),
                max: new THREE.Vector3(x + w/2, y + h/2, z + d/2)
            };
            if (name) {
                mesh.userData.name = name;
                interactableObjects.push(mesh);
            }
            allColliders.push(mesh);
            interiorScene.add(mesh);
            return mesh;
        }
        
        function createPhysicsObject(x, y, z, w, h, d, name, color, mass) {
            const mesh = new THREE.Mesh(
                new THREE.BoxGeometry(w, h, d),
                new THREE.MeshStandardMaterial({ color, metalness: 0.3, roughness: 0.7 })
            );
            mesh.position.set(x, y, z);
            mesh.userData.isPhysics = true;
            mesh.userData.name = name;
            mesh.userData.mass = mass;
            mesh.userData.velocity = new THREE.Vector3();
            mesh.userData.size = { w, h, d };
            mesh.userData.collider = {
                min: new THREE.Vector3(x - w/2, y - h/2, z - d/2),
                max: new THREE.Vector3(x + w/2, y + h/2, z + d/2)
            };
            allColliders.push(mesh);
            physicsObjects.push(mesh);
            interactableObjects.push(mesh);
            interiorScene.add(mesh);
            return mesh;
        }
        
        function createDoorTrigger(x, z, side, label, roomId) {
            const frameMat = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.9, roughness: 0.1 });
            const doorMat = new THREE.MeshStandardMaterial({ color: 0x0088ff, metalness: 0.7, roughness: 0.3, emissive: 0x003366, emissiveIntensity: 0.3 });
            const isBack = side === 'back';
            const fw = isBack ? 1.8 : 0.2, fd = isBack ? 0.2 : 1.5;
            let fx = x, fz = z;
            if (side === 'left') fx += 0.1;
            else if (side === 'right') fx -= 0.1;
            
            const frame = new THREE.Mesh(new THREE.BoxGeometry(fw + 0.3, 2.5, fd + 0.15), frameMat);
            frame.position.set(fx, 1.25, fz);
            interiorScene.add(frame);
            
            const door = new THREE.Mesh(new THREE.BoxGeometry(fw, 2.2, fd), doorMat);
            door.position.set(fx, 1.1, fz);
            interiorScene.add(door);
            
            const labelDiv = document.createElement('div');
            labelDiv.className = 'door-label-3d';
            labelDiv.textContent = label;
            labelDiv.style.cssText = 'color:#0ff;font-size:10px;background:rgba(0,40,60,0.8);padding:3px 8px;border-radius:3px;border:1px solid #0ff;';
            const labelObj = new CSS2DObject(labelDiv);
            labelObj.position.set(fx, 2.3, fz);
            interiorScene.add(labelObj);
            
            rooms[roomId] = { 
                doorPosition: new THREE.Vector3(x + (side === 'left' ? 1 : side === 'right' ? -1 : 0), 1.6, z + (side === 'back' ? -1.5 : 0)),
                side: side,
                label: label
            };
        }
        
        function createCorridor() {
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.5, roughness: 0.5 });
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.7, roughness: 0.3 });
            
            // ë°”ë‹¥, ì²œì¥
            createStaticCollider(0, 0, 2, 8, 0.1, 35, floorMat);
            createStaticCollider(0, 3, 2, 8, 0.1, 35, new THREE.MeshStandardMaterial({ color: 0x777777 }));
            
            // ë²½
            createStaticCollider(-4, 1.5, 2, 0.15, 3, 35, wallMat);
            createStaticCollider(4, 1.5, 2, 0.15, 3, 35, wallMat);
            createStaticCollider(0, 1.5, -15, 8, 3, 0.15, wallMat);
            createStaticCollider(0, 1.5, 19.5, 8, 3, 0.15, wallMat);
            
            // ì¡°ëª…
            [-12, -6, 0, 6, 12, 18].forEach(z => {
                const led = new THREE.Mesh(new THREE.BoxGeometry(2, 0.08, 0.5), new THREE.MeshBasicMaterial({ color: 0xffffff }));
                led.position.set(0, 2.9, z);
                interiorScene.add(led);
                const light = new THREE.PointLight(0xffffff, 1.2, 15);
                light.position.set(0, 2.7, z);
                interiorScene.add(light);
            });
            
            // ì¡°ì¢…ì„ ì½˜ì†”
            createStaticCollider(0, 0.6, -13.5, 5, 1.2, 1, new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8, roughness: 0.2 }), 'ì¡°ì¢…ì„ ì½˜ì†”');
            
            // í•­ë²• ë””ìŠ¤í”Œë ˆì´
            [-1.5, 0, 1.5].forEach(x => {
                const screen = new THREE.Mesh(new THREE.PlaneGeometry(1.2, 0.8), new THREE.MeshBasicMaterial({ color: 0x00ff88 }));
                screen.position.set(x, 1.4, -14);
                screen.userData.name = 'í•­ë²• ë””ìŠ¤í”Œë ˆì´';
                interactableObjects.push(screen);
                interiorScene.add(screen);
            });
            
            // ë¬¸ íŠ¸ë¦¬ê±°
            createDoorTrigger(-3.92, -6, 'left', 'ğŸ”¬ ì—°êµ¬ì‹¤', 'lab');
            createDoorTrigger(-3.92, 4, 'left', 'ğŸ›ï¸ íœ´ê²Œì‹¤', 'rest');
            createDoorTrigger(3.92, -2, 'right', 'âš™ï¸ ì—”ì§„ë£¸', 'engine');
            createDoorTrigger(3.92, 10, 'right', 'ğŸ“¦ í™”ë¬¼ì¹¸', 'cargo');
            createDoorTrigger(0, 19, 'back', t('observatory'), 'observatory');
        }
        
        function createDetailedRooms() {
            createLabRoom();
            createRestRoom();
            createEngineRoom();
            createCargoRoom();
            createObservatoryRoom();
        }
        
        function createLabRoom() {
            const cx = -12, cz = -6, w = 8, d = 8;
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x556688, metalness: 0.4, roughness: 0.6 });
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x777788, metalness: 0.6, roughness: 0.4 });
            
            createStaticCollider(cx, 0, cz, w, 0.1, d, floorMat);
            createStaticCollider(cx, 3, cz, w, 0.1, d, new THREE.MeshStandardMaterial({ color: 0x666677 }));
            createStaticCollider(cx - 4, 1.5, cz, 0.15, 3, d, wallMat);
            createStaticCollider(cx, 1.5, cz - 4, w, 3, 0.15, wallMat);
            createStaticCollider(cx, 1.5, cz + 4, w, 3, 0.15, wallMat);
            
            const light = new THREE.PointLight(0xaaccff, 1.5, 15);
            light.position.set(cx, 2.7, cz);
            interiorScene.add(light);
            
            createStaticCollider(cx - 2, 0.5, cz - 2, 2.5, 0.1, 1.2, new THREE.MeshStandardMaterial({ color: 0x445566 }), 'ì—°êµ¬ ë°ìŠ¤í¬');
            createPhysicsObject(cx - 2.5, 1.1, cz - 2, 0.3, 0.6, 0.3, 'ì „ì í˜„ë¯¸ê²½', 0x333344, 2);
            createPhysicsObject(cx - 1, 0.7, cz - 2, 0.4, 0.3, 0.3, 'ë…¸íŠ¸ë¶', 0x222233, 1);
            
            // í™€ë¡œê·¸ë¨ í”„ë¡œì í„°
            const holoBase = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 0.1, 16), new THREE.MeshStandardMaterial({ color: 0x333344, metalness: 0.9 }));
            holoBase.position.set(cx + 2, 0.8, cz);
            holoBase.userData.name = 'í™€ë¡œê·¸ë¨ í”„ë¡œì í„°';
            interactableObjects.push(holoBase);
            interiorScene.add(holoBase);
            
            const holoDisplay = new THREE.Mesh(new THREE.IcosahedronGeometry(0.35, 1), new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.5, wireframe: true }));
            holoDisplay.position.set(cx + 2, 1.4, cz);
            holoDisplay.userData.name = 'DNA ë¶„ì ëª¨ë¸';
            holoDisplay.userData.animate = (t) => { holoDisplay.rotation.y = t; holoDisplay.rotation.x = t * 0.5; };
            interactableObjects.push(holoDisplay);
            interiorScene.add(holoDisplay);
            
            rooms['lab'].enterPosition = new THREE.Vector3(cx + 2, 1.6, cz);
            rooms['lab'].bounds = { minX: cx - 3.5, maxX: cx + 3.5, minZ: cz - 3.5, maxZ: cz + 3.5 };
        }
        
        function createRestRoom() {
            const cx = -12, cz = 4, w = 8, d = 8;
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x665555, metalness: 0.3, roughness: 0.7 });
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x776666, metalness: 0.5, roughness: 0.5 });
            
            createStaticCollider(cx, 0, cz, w, 0.1, d, floorMat);
            createStaticCollider(cx, 3, cz, w, 0.1, d, new THREE.MeshStandardMaterial({ color: 0x665555 }));
            createStaticCollider(cx - 4, 1.5, cz, 0.15, 3, d, wallMat);
            createStaticCollider(cx, 1.5, cz - 4, w, 3, 0.15, wallMat);
            createStaticCollider(cx, 1.5, cz + 4, w, 3, 0.15, wallMat);
            
            const light = new THREE.PointLight(0xffddaa, 1.2, 15);
            light.position.set(cx, 2.7, cz);
            interiorScene.add(light);
            
            createStaticCollider(cx - 2, 0.35, cz - 2, 1.8, 0.5, 2.2, new THREE.MeshStandardMaterial({ color: 0x334455 }), 'ìˆ˜ë©´ í¬ë“œ A');
            createStaticCollider(cx - 2, 0.35, cz + 2, 1.8, 0.5, 2.2, new THREE.MeshStandardMaterial({ color: 0x334455 }), 'ìˆ˜ë©´ í¬ë“œ B');
            createStaticCollider(cx + 1.5, 0.4, cz, 1.2, 0.08, 1.2, new THREE.MeshStandardMaterial({ color: 0x443322 }), 'ë‹¤ìš©ë„ í…Œì´ë¸”');
            createPhysicsObject(cx + 1.3, 0.55, cz - 0.3, 0.08, 0.12, 0.08, 'ì»¤í”¼ ë¨¸ê·¸', 0xdddddd, 0.15);
            
            rooms['rest'].enterPosition = new THREE.Vector3(cx + 2, 1.6, cz);
            rooms['rest'].bounds = { minX: cx - 3.5, maxX: cx + 3.5, minZ: cz - 3.5, maxZ: cz + 3.5 };
        }
        
        function createEngineRoom() {
            const cx = 12, cz = -2, w = 8, d = 8;
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x554444, metalness: 0.6, roughness: 0.4 });
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x665555, metalness: 0.7, roughness: 0.3 });
            
            createStaticCollider(cx, 0, cz, w, 0.1, d, floorMat);
            createStaticCollider(cx, 3, cz, w, 0.1, d, new THREE.MeshStandardMaterial({ color: 0x443333 }));
            createStaticCollider(cx + 4, 1.5, cz, 0.15, 3, d, wallMat);
            createStaticCollider(cx, 1.5, cz - 4, w, 3, 0.15, wallMat);
            createStaticCollider(cx, 1.5, cz + 4, w, 3, 0.15, wallMat);
            
            const light1 = new THREE.PointLight(0xff4400, 0.8, 15);
            light1.position.set(cx, 2.7, cz);
            interiorScene.add(light1);
            
            // ì—”ì§„ ì½”ì–´
            const coreGeo = new THREE.CylinderGeometry(0.8, 1.0, 2.5, 16);
            const coreMat = new THREE.MeshStandardMaterial({ color: 0x222233, metalness: 0.9, roughness: 0.1 });
            const core = new THREE.Mesh(coreGeo, coreMat);
            core.position.set(cx + 2, 1.25, cz);
            core.userData.name = 'í•µìœµí•© ì—”ì§„ ì½”ì–´';
            interactableObjects.push(core);
            interiorScene.add(core);
            
            // ì—”ì§„ ê¸€ë¡œìš°
            const glowGeo = new THREE.CylinderGeometry(0.5, 0.5, 2.0, 16);
            const glowMat = new THREE.MeshBasicMaterial({ color: 0x00aaff, transparent: true, opacity: 0.6 });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            glow.position.set(cx + 2, 1.25, cz);
            glow.userData.animate = (t) => { glow.material.opacity = 0.4 + Math.sin(t * 5) * 0.2; };
            engineParts.push(glow);
            interiorScene.add(glow);
            
            rooms['engine'].enterPosition = new THREE.Vector3(cx - 2, 1.6, cz);
            rooms['engine'].bounds = { minX: cx - 3.5, maxX: cx + 3.5, minZ: cz - 3.5, maxZ: cz + 3.5 };
        }
        
        function createCargoRoom() {
            const cx = 12, cz = 10, w = 8, d = 8;
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x555544, metalness: 0.4, roughness: 0.6 });
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x666655, metalness: 0.5, roughness: 0.5 });
            
            createStaticCollider(cx, 0, cz, w, 0.1, d, floorMat);
            createStaticCollider(cx, 3, cz, w, 0.1, d, new THREE.MeshStandardMaterial({ color: 0x555544 }));
            createStaticCollider(cx + 4, 1.5, cz, 0.15, 3, d, wallMat);
            createStaticCollider(cx, 1.5, cz - 4, w, 3, 0.15, wallMat);
            createStaticCollider(cx, 1.5, cz + 4, w, 3, 0.15, wallMat);
            
            const light = new THREE.PointLight(0xffffaa, 1.0, 15);
            light.position.set(cx, 2.7, cz);
            interiorScene.add(light);
            
            // í™”ë¬¼ ìƒìë“¤
            createPhysicsObject(cx - 2, 0.4, cz - 2, 0.8, 0.8, 0.8, 'í™”ë¬¼ ìƒì A', 0x886644, 5);
            createPhysicsObject(cx - 1, 0.4, cz + 1, 0.8, 0.8, 0.8, 'í™”ë¬¼ ìƒì B', 0x886644, 5);
            createPhysicsObject(cx + 1, 0.3, cz - 1, 0.6, 0.6, 0.6, 'ë³´ê¸‰í’ˆ ë°•ìŠ¤', 0x448844, 3);
            
            rooms['cargo'].enterPosition = new THREE.Vector3(cx - 2, 1.6, cz);
            rooms['cargo'].bounds = { minX: cx - 3.5, maxX: cx + 3.5, minZ: cz - 3.5, maxZ: cz + 3.5 };
        }
        
        function createObservatoryRoom() {
            const cx = 0, cz = 25, r = 5;
            
            // ë” ë°”ë‹¥
            const floorGeo = new THREE.CircleGeometry(r, 32);
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x333344, metalness: 0.6, roughness: 0.4 });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(cx, 0.05, cz);
            interiorScene.add(floor);
            
            // ìœ ë¦¬ ë” (ë°˜íˆ¬ëª…)
            const domeGeo = new THREE.SphereGeometry(r, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const domeMat = new THREE.MeshBasicMaterial({ color: 0x000011, transparent: true, opacity: 0.3, side: THREE.DoubleSide });
            const dome = new THREE.Mesh(domeGeo, domeMat);
            dome.position.set(cx, 0, cz);
            interiorScene.add(dome);
            
            // ë§ì›ê²½
            const scopeBase = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 0.5, 16), new THREE.MeshStandardMaterial({ color: 0x444455, metalness: 0.8 }));
            scopeBase.position.set(cx, 0.25, cz);
            scopeBase.userData.name = 'ì²œì²´ ë§ì›ê²½';
            interactableObjects.push(scopeBase);
            interiorScene.add(scopeBase);
            
            const scopeTube = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.2, 1.5, 16), new THREE.MeshStandardMaterial({ color: 0x222233, metalness: 0.9 }));
            scopeTube.position.set(cx, 1.2, cz);
            scopeTube.rotation.x = Math.PI / 4;
            interiorScene.add(scopeTube);
            
            rooms['observatory'].enterPosition = new THREE.Vector3(cx, 1.6, cz - 3);
            rooms['observatory'].bounds = { minX: cx - r + 0.5, maxX: cx + r - 0.5, minZ: cz - r + 0.5, maxZ: cz + r - 0.5 };
            rooms['observatory'].isObservatory = true;
        }
        
        // ì„ ë‚´ ì´ë™ ê´€ë ¨ í•¨ìˆ˜ë“¤
        function aabbIntersect(aMin, aMax, bMin, bMax) {
            return (aMin.x <= bMax.x && aMax.x >= bMin.x) &&
                   (aMin.y <= bMax.y && aMax.y >= bMin.y) &&
                   (aMin.z <= bMax.z && aMax.z >= bMin.z);
        }
        
        function updateInteriorPlayer(dt) {
            if (!isInteriorMode) return;
            const speed = 3.5;
            const playerRadius = 0.3;
            
            const fwd = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), interiorPlayer.rotationY);
            const right = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), interiorPlayer.rotationY);
            
            const vel = new THREE.Vector3();
            vel.add(fwd.clone().multiplyScalar(moveInput.z * speed * dt));  // ì „ì§„/í›„ì§„ ìˆ˜ì •
            vel.add(right.clone().multiplyScalar(moveInput.x * speed * dt));
            
            const newPos = interiorPlayer.position.clone().add(vel);
            newPos.y = 1.6;
            
            let canMoveX = true, canMoveZ = true;
            
            for (const obj of allColliders) {
                if (!obj.userData.collider) continue;
                if (obj.userData.isPhysics) {
                    const s = obj.userData.size;
                    obj.userData.collider.min.set(obj.position.x - s.w/2, obj.position.y - s.h/2, obj.position.z - s.d/2);
                    obj.userData.collider.max.set(obj.position.x + s.w/2, obj.position.y + s.h/2, obj.position.z + s.d/2);
                }
                const col = obj.userData.collider;
                
                const testMinX = new THREE.Vector3(newPos.x - playerRadius, 0.5, interiorPlayer.position.z - playerRadius);
                const testMaxX = new THREE.Vector3(newPos.x + playerRadius, 1.8, interiorPlayer.position.z + playerRadius);
                if (aabbIntersect(testMinX, testMaxX, col.min, col.max)) canMoveX = false;
                
                const testMinZ = new THREE.Vector3(interiorPlayer.position.x - playerRadius, 0.5, newPos.z - playerRadius);
                const testMaxZ = new THREE.Vector3(interiorPlayer.position.x + playerRadius, 1.8, newPos.z + playerRadius);
                if (aabbIntersect(testMinZ, testMaxZ, col.min, col.max)) canMoveZ = false;
            }
            
            let bounds;
            if (currentRoom === 'corridor') {
                bounds = { minX: -3.5, maxX: 3.5, minZ: -14, maxZ: 18 };
            } else if (rooms[currentRoom] && rooms[currentRoom].bounds) {
                bounds = rooms[currentRoom].bounds;
            }
            
            if (bounds) {
                if (newPos.x - playerRadius < bounds.minX || newPos.x + playerRadius > bounds.maxX) canMoveX = false;
                if (newPos.z - playerRadius < bounds.minZ || newPos.z + playerRadius > bounds.maxZ) canMoveZ = false;
            }
            
            if (canMoveX) interiorPlayer.position.x = newPos.x;
            if (canMoveZ) interiorPlayer.position.z = newPos.z;
            
            interiorCamera.position.copy(interiorPlayer.position);
            updateCameraRotation();
            checkDoorProximity();
        }
        
        function updatePhysicsObjects(dt) {
            const gravity = 9.8;
            const friction = 0.92;
            const groundY = 0.05;
            
            for (const obj of physicsObjects) {
                if (!obj.userData.isPhysics) continue;
                const vel = obj.userData.velocity;
                const size = obj.userData.size;
                
                if (obj.position.y > groundY + size.h / 2 + 0.01) {
                    vel.y -= gravity * dt;
                } else {
                    obj.position.y = groundY + size.h / 2;
                    vel.y = 0;
                    vel.x *= friction;
                    vel.z *= friction;
                }
                
                obj.position.add(vel.clone().multiplyScalar(dt));
            }
        }
        
        function updateCameraRotation() {
            interiorCamera.rotation.order = 'YXZ';
            interiorCamera.rotation.y = interiorPlayer.rotationY;
            interiorCamera.rotation.x = interiorPlayer.pitchX;
        }
        
        function checkDoorProximity() {
            nearDoor = null;
            const playerPos = interiorPlayer.position;
            
            for (const [roomId, room] of Object.entries(rooms)) {
                if (room.doorPosition) {
                    const dist = playerPos.distanceTo(room.doorPosition);
                    if (dist < 2) {
                        nearDoor = roomId;
                        break;
                    }
                }
            }
            
            const doorPrompt = document.getElementById('door-prompt');
            if (doorPrompt) {
                if (nearDoor && currentRoom === 'corridor') {
                    doorPrompt.textContent = `[E] Enter ${rooms[nearDoor].label}`;
                    doorPrompt.classList.add('active');
                } else if (currentRoom !== 'corridor') {
                    doorPrompt.textContent = t('exitToCorridor');
                    doorPrompt.classList.add('active');
                } else {
                    doorPrompt.classList.remove('active');
                }
            }
        }
        
        function enterRoom(roomId) {
            if (!rooms[roomId]) return;
            currentRoom = roomId;
            
            if (rooms[roomId].enterPosition) {
                interiorPlayer.position.copy(rooms[roomId].enterPosition);
            }
            
            if (rooms[roomId].isObservatory) {
                enterObservatoryFromInterior();
            }
        }
        
        function exitCurrentRoom() {
            if (currentRoom !== 'corridor') {
                const room = rooms[currentRoom];
                if (room && room.doorPosition) {
                    interiorPlayer.position.copy(room.doorPosition);
                    if (room.side === 'left') interiorPlayer.rotationY = -Math.PI / 2;
                    else if (room.side === 'right') interiorPlayer.rotationY = Math.PI / 2;
                    else interiorPlayer.rotationY = Math.PI;
                    interiorPlayer.pitchX = 0;
                }
                currentRoom = 'corridor';
            } else {
                exitInteriorMode();
            }
        }
        
        function enterInteriorMode() {
            if (!autopilot.engaged) {
                showMsg('âš ï¸ Only available in autopilot mode');
                return;
            }
            
            isInteriorMode = true;
            isObservatoryMode = false;
            isCockpitView = false;
            document.getElementById('cockpit-hud').classList.remove('active');
            document.getElementById('observatory-hud').classList.remove('active');
            document.getElementById('interior-hud').classList.add('active');
            
            const container = document.getElementById('canvas-container');
            if (!container.contains(interiorRenderer.domElement)) {
                container.appendChild(interiorRenderer.domElement);
            }
            interiorRenderer.domElement.style.display = 'block';
            renderer.domElement.style.display = 'none';
            labelRenderer.domElement.style.display = 'none';
            
            // ëª¨ë°”ì¼ ì¡°ì´ìŠ¤í‹± í‘œì‹œ
            if ('ontouchstart' in window) {
                document.getElementById('move-joystick').classList.add('active');
            }
            
            if (currentRoom === 'corridor') {
                interiorPlayer.position.set(0, 1.6, -10);
                interiorPlayer.rotationY = Math.PI;
                interiorPlayer.pitchX = 0;
            }
            interiorCamera.position.copy(interiorPlayer.position);
            updateCameraRotation();
            showMsg('ğŸš€ Entered interior. WASD to move, mouse to look around');
        }
        
        function exitInteriorMode() {
            isInteriorMode = false;
            isCockpitView = true;  // ì¡°ì¢…ì„ ë·°ë¡œ ë³µê·€
            document.getElementById('interior-hud').classList.remove('active');
            document.getElementById('cockpit-hud').classList.add('active');
            document.getElementById('door-prompt').classList.remove('active');
            document.getElementById('move-joystick').classList.remove('active');
            
            interiorRenderer.domElement.style.display = 'none';
            renderer.domElement.style.display = 'block';
            labelRenderer.domElement.style.display = 'block';
            currentRoom = 'corridor';
            lookDragging = false;
        }
        
        // ì „ë§ëŒ€ ëª¨ë“œ
        function enterObservatoryMode() {
            if (!autopilot.engaged) {
                showMsg('âš ï¸ Observatory available only in autopilot mode');
                return;
            }
            
            isObservatoryMode = true;
            isInteriorMode = false;
            isCockpitView = false;
            document.getElementById('cockpit-hud').classList.remove('active');
            document.getElementById('interior-hud').classList.remove('active');
            document.getElementById('observatory-hud').classList.add('active');
            
            interiorRenderer.domElement.style.display = 'none';
            renderer.domElement.style.display = 'block';
            labelRenderer.domElement.style.display = 'block';
            
            if (playerShip && playerShip.mesh) {
                obsCamera.position.copy(playerShip.mesh.position);
            }
            obsCamRotation = { theta: 0, phi: Math.PI / 2 };
            showMsg('ğŸ”­ Observe the universe in 360Â° from the observatory');
        }
        
        function enterObservatoryFromInterior() {
            isObservatoryMode = true;
            isInteriorMode = false;
            document.getElementById('interior-hud').classList.remove('active');
            document.getElementById('observatory-hud').classList.add('active');
            
            interiorRenderer.domElement.style.display = 'none';
            renderer.domElement.style.display = 'block';
            labelRenderer.domElement.style.display = 'block';
            
            if (playerShip && playerShip.mesh) {
                obsCamera.position.copy(playerShip.mesh.position);
            }
            obsCamRotation = { theta: 0, phi: Math.PI / 2 };
        }
        
        function exitObservatoryMode() {
            isObservatoryMode = false;
            isCockpitView = true;  // ì¡°ì¢…ì„ ë·°ë¡œ ë³µê·€
            document.getElementById('observatory-hud').classList.remove('active');
            document.getElementById('cockpit-hud').classList.add('active');
        }
        
        function updateObservatoryCamera() {
            if (!isObservatoryMode || !playerShip || !playerShip.mesh) return;
            
            obsCamera.position.copy(playerShip.mesh.position);
            
            const x = Math.sin(obsCamRotation.phi) * Math.cos(obsCamRotation.theta);
            const y = Math.cos(obsCamRotation.phi);
            const z = Math.sin(obsCamRotation.phi) * Math.sin(obsCamRotation.theta);
            
            const target = new THREE.Vector3(x, y, z).add(obsCamera.position);
            obsCamera.lookAt(target);
        }
        
        function initInteriorControls() {
            // ë²„íŠ¼ ì—°ê²°
            document.getElementById('btn-int-back').onclick = exitInteriorMode;
            document.getElementById('btn-open-door').onclick = () => {
                if (nearDoor && currentRoom === 'corridor') enterRoom(nearDoor);
                else if (currentRoom !== 'corridor') exitCurrentRoom();
            };
            document.getElementById('btn-obs-back').onclick = () => {
                isObservatoryMode = false;
                enterInteriorMode();
            };
            
            // ëª¨ë°”ì¼ ì´ë™ ì¡°ì´ìŠ¤í‹±
            const moveJS = document.getElementById('move-joystick');
            const moveKnob = document.getElementById('move-joystick-knob');
            
            moveJS.addEventListener('touchstart', (e) => {
                if (!isInteriorMode) return;
                e.preventDefault();
                moveJoystickActive = true;
                const rect = moveJS.getBoundingClientRect();
                moveJoystickCenter = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
            }, { passive: false });
            
            moveJS.addEventListener('touchmove', (e) => {
                if (!isInteriorMode || !moveJoystickActive) return;
                e.preventDefault();
                const touch = e.touches[0];
                let dx = touch.clientX - moveJoystickCenter.x;
                let dy = touch.clientY - moveJoystickCenter.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const maxR = 50;
                if (dist > maxR) { dx = dx / dist * maxR; dy = dy / dist * maxR; }
                moveKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                moveInput.x = dx / maxR;
                moveInput.z = dy / maxR;
            }, { passive: false });
            
            moveJS.addEventListener('touchend', () => {
                moveJoystickActive = false;
                moveKnob.style.transform = 'translate(-50%, -50%)';
                moveInput.x = 0;
                moveInput.z = 0;
            });
            
            // í‚¤ë³´ë“œ ì´ë™ (WASD)
            window.addEventListener('keydown', (e) => {
                if (!isInteriorMode) return;
                if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') moveInput.z = 1;
                if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') moveInput.z = -1;
                if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') moveInput.x = -1;
                if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') moveInput.x = 1;
                if (e.key === 'e' || e.key === 'E') {
                    if (nearDoor && currentRoom === 'corridor') enterRoom(nearDoor);
                    else if (currentRoom !== 'corridor') exitCurrentRoom();
                }
                if (e.key === 'Escape') exitInteriorMode();
            });
            
            window.addEventListener('keyup', (e) => {
                if (!isInteriorMode) return;
                if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') moveInput.z = 0;
                if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') moveInput.z = 0;
                if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') moveInput.x = 0;
                if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') moveInput.x = 0;
            });
            
            // ë§ˆìš°ìŠ¤ ì‹œì  (ì„ ë‚´)
            interiorRenderer.domElement.addEventListener('mousedown', (e) => {
                if (!isInteriorMode) return;
                lookDragging = true;
                lastLookPos = { x: e.clientX, y: e.clientY };
            });
            
            window.addEventListener('mousemove', (e) => {
                if (!isInteriorMode || !lookDragging) return;
                const dx = e.clientX - lastLookPos.x;
                const dy = e.clientY - lastLookPos.y;
                interiorPlayer.rotationY -= dx * 0.003;
                interiorPlayer.pitchX -= dy * 0.003;
                interiorPlayer.pitchX = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, interiorPlayer.pitchX));
                lastLookPos = { x: e.clientX, y: e.clientY };
                updateCameraRotation();
            });
            
            window.addEventListener('mouseup', () => { lookDragging = false; });
            
            // í„°ì¹˜ ì‹œì  (ì„ ë‚´)
            interiorRenderer.domElement.addEventListener('touchstart', (e) => {
                if (!isInteriorMode) return;
                const touch = e.touches[0];
                if (touch.clientX < 160 && touch.clientY > window.innerHeight - 200) return;
                e.preventDefault();
                lookDragging = true;
                lastLookPos = { x: touch.clientX, y: touch.clientY };
            }, { passive: false });
            
            interiorRenderer.domElement.addEventListener('touchmove', (e) => {
                if (!isInteriorMode || !lookDragging) return;
                e.preventDefault();
                const touch = e.touches[0];
                const dx = touch.clientX - lastLookPos.x;
                const dy = touch.clientY - lastLookPos.y;
                interiorPlayer.rotationY -= dx * 0.005;
                interiorPlayer.pitchX -= dy * 0.005;
                interiorPlayer.pitchX = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, interiorPlayer.pitchX));
                lastLookPos = { x: touch.clientX, y: touch.clientY };
                updateCameraRotation();
            }, { passive: false });
            
            interiorRenderer.domElement.addEventListener('touchend', () => { lookDragging = false; });
        }
        
        function initObservatoryControls() {
            // ë§ˆìš°ìŠ¤ ë“œë˜ê·¸ (ì „ë§ëŒ€)
            renderer.domElement.addEventListener('mousedown', (e) => {
                if (!isObservatoryMode) return;
                obsDragging = true;
                obsLastPos = { x: e.clientX, y: e.clientY };
            });
            
            window.addEventListener('mousemove', (e) => {
                if (!isObservatoryMode || !obsDragging) return;
                const dx = e.clientX - obsLastPos.x;
                const dy = e.clientY - obsLastPos.y;
                obsCamRotation.theta -= dx * 0.005;
                obsCamRotation.phi -= dy * 0.005;
                obsCamRotation.phi = Math.max(0.1, Math.min(Math.PI - 0.1, obsCamRotation.phi));
                obsLastPos = { x: e.clientX, y: e.clientY };
            });
            
            window.addEventListener('mouseup', () => { obsDragging = false; });
            
            // í„°ì¹˜ (ì „ë§ëŒ€)
            renderer.domElement.addEventListener('touchstart', (e) => {
                if (!isObservatoryMode) return;
                e.preventDefault();
                obsDragging = true;
                obsLastPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }, { passive: false });
            
            renderer.domElement.addEventListener('touchmove', (e) => {
                if (!isObservatoryMode || !obsDragging) return;
                e.preventDefault();
                const t = e.touches[0];
                const dx = t.clientX - obsLastPos.x;
                const dy = t.clientY - obsLastPos.y;
                obsCamRotation.theta -= dx * 0.005;
                obsCamRotation.phi -= dy * 0.005;
                obsCamRotation.phi = Math.max(0.1, Math.min(Math.PI - 0.1, obsCamRotation.phi));
                obsLastPos = { x: t.clientX, y: t.clientY };
            }, { passive: false });
            
            renderer.domElement.addEventListener('touchend', () => { obsDragging = false; });
        }

        // ===== ìš°ì£¼ì„  ì¡°ì¢… ì‹œìŠ¤í…œ í•¨ìˆ˜ë“¤ =====

        // â˜…â˜…â˜… ê²Œì„ ëª¨ë“œ ê°•ì œ ê°€ë¡œ ëª¨ë“œ (APK/ëª¨ë°”ì¼ìš©) â˜…â˜…â˜…
        function forceGameLandscape() {
            // Screen Orientation API ì‹œë„
            if (screen.orientation && screen.orientation.lock) {
                screen.orientation.lock('landscape').catch(e => {
                    console.log('ê°€ë¡œëª¨ë“œ ì ê¸ˆ ì‹¤íŒ¨:', e.message);
                    // ì‹¤íŒ¨ ì‹œ ê²½ê³  í‘œì‹œ
                    checkGameOrientationWarning();
                });
            } else {
                // API ë¯¸ì§€ì› ì‹œ ê²½ê³  í‘œì‹œ
                checkGameOrientationWarning();
            }
            // ì¦‰ì‹œ ë°©í–¥ ì²´í¬
            checkGameOrientationWarning();
        }

        // â˜…â˜…â˜… ê²Œì„ ëª¨ë“œ ë°©í–¥ ì²´í¬ ë° ê²½ê³  â˜…â˜…â˜…
        function checkGameOrientationWarning() {
            // ê²Œì„ ëª¨ë“œê°€ ì•„ë‹ˆë©´ ë¬´ì‹œ
            if (!window.gameMode) return;

            const isPortrait = window.innerHeight > window.innerWidth;
            let warning = document.getElementById('landscape-warning');

            if (isPortrait) {
                // ì„¸ë¡œ ëª¨ë“œ ê²½ê³  í‘œì‹œ
                if (!warning) {
                    warning = document.createElement('div');
                    warning.id = 'landscape-warning';
                    warning.innerHTML = `
                        <div class="rotate-icon">ğŸ“±â†”ï¸</div>
                        <div class="rotate-text">${t('rotateScreen')}</div>
                        <div class="rotate-sub">${t('rotateScreenSub')}</div>
                    `;
                    document.body.appendChild(warning);
                }
                warning.style.display = 'flex';
            } else if (warning) {
                warning.style.display = 'none';
            }
        }

        // ê°•ì œ ê°€ë¡œ ëª¨ë“œ í•¨ìˆ˜ (ì¡°ì¢…ì„ìš©)
        function forceLayoutOrientation() {
            // Screen Orientation API ì‹œë„
            if (screen.orientation && screen.orientation.lock) {
                screen.orientation.lock('landscape').catch(() => {
                    // ì‹¤íŒ¨ ì‹œ CSSë¡œ ì²˜ë¦¬
                    showLandscapeWarning();
                });
            } else {
                showLandscapeWarning();
            }
        }

        // í™”ë©´ ë°©í–¥ ì ê¸ˆ í•´ì œ
        function unlockOrientation() {
            if (screen.orientation && screen.orientation.unlock) {
                screen.orientation.unlock();
            }
            hideLandscapeWarning();
        }

        // ì„¸ë¡œ ëª¨ë“œ ê²½ê³  í‘œì‹œ
        function showLandscapeWarning() {
            let warning = document.getElementById('landscape-warning');
            if (!warning) {
                warning = document.createElement('div');
                warning.id = 'landscape-warning';
                warning.innerHTML = `
                    <div class="rotate-icon">ğŸ“±â†”ï¸</div>
                    <div class="rotate-text">${t('rotateScreen')}</div>
                    <div class="rotate-sub">${t('rotateScreenSub')}</div>
                `;
                document.body.appendChild(warning);
            }
            warning.style.display = 'flex';
            checkOrientationForWarning();
        }

        // ì„¸ë¡œ ëª¨ë“œ ê²½ê³  ìˆ¨ê¹€
        function hideLandscapeWarning() {
            const warning = document.getElementById('landscape-warning');
            if (warning) warning.style.display = 'none';
        }

        // ë°©í–¥ ì²´í¬ ë° ê²½ê³  í‘œì‹œ/ìˆ¨ê¹€ (ì¡°ì¢…ì„ìš©)
        function checkOrientationForWarning() {
            if (!isPilotMode) {
                hideLandscapeWarning();
                return;
            }
            const warning = document.getElementById('landscape-warning');
            if (!warning) return;

            const isPortrait = window.innerHeight > window.innerWidth;
            warning.style.display = isPortrait ? 'flex' : 'none';
        }

        // â˜…â˜…â˜… ë°©í–¥ ë³€ê²½ ê°ì§€ (ê²Œì„ ëª¨ë“œ + ì¡°ì¢…ì„) â˜…â˜…â˜…
        window.addEventListener('resize', () => {
            if (window.gameMode) {
                checkGameOrientationWarning();
            }
            if (isPilotMode) {
                checkOrientationForWarning();
            }
        });

        // â˜…â˜…â˜… orientationchange ì´ë²¤íŠ¸ë„ ê°ì§€ (APKìš©) â˜…â˜…â˜…
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                if (window.gameMode) {
                    checkGameOrientationWarning();
                    // ë‹¤ì‹œ ê°€ë¡œ ëª¨ë“œ ì ê¸ˆ ì‹œë„
                    if (screen.orientation && screen.orientation.lock) {
                        screen.orientation.lock('landscape').catch(() => {});
                    }
                }
            }, 100);
        });
        
        function createDockedShip(station) {
            if (!station || !station.mesh) return null;
            
            // ì •ê±°ì¥ì— ë„í‚¹ëœ ìš°ì£¼ì„  ìƒì„±
            const shipGroup = new THREE.Group();
            
            // ë³¸ì²´
            const bodyGeo = new THREE.ConeGeometry(0.015, 0.06, 8);
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x4fc3f7, metalness: 0.8, roughness: 0.2 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.rotation.x = Math.PI / 2;
            shipGroup.add(body);
            
            // ë‚ ê°œ
            const wingGeo = new THREE.BoxGeometry(0.08, 0.003, 0.02);
            const wingMat = new THREE.MeshStandardMaterial({ color: 0x333344, metalness: 0.9, roughness: 0.1 });
            const wing = new THREE.Mesh(wingGeo, wingMat);
            wing.position.z = 0.01;
            shipGroup.add(wing);
            
            // ì—”ì§„
            const engineGeo = new THREE.CylinderGeometry(0.008, 0.006, 0.015, 8);
            const engineMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const engine = new THREE.Mesh(engineGeo, engineMat);
            engine.position.z = 0.035;
            engine.rotation.x = Math.PI / 2;
            shipGroup.add(engine);
            
            // ì •ê±°ì¥ ì˜†ì— ë°°ì¹˜
            shipGroup.position.set(0.15, 0, 0);
            station.mesh.add(shipGroup);
            dockedShipMesh = shipGroup;
            
            return shipGroup;
        }
        
        // â˜…â˜…â˜… engineConfigì—ì„œ ì§€ì •í•œ ì—”ì§„ ë¶ˆê½ƒ ìƒì„± â˜…â˜…â˜…
        // ì°¸ê³ : ëª¨ë¸ì€ rotation.y = Math.PI (180ë„) íšŒì „ë˜ì–´ ìˆìŒ
        // ì—”ì§„ ì—ë””í„°ëŠ” ì›ë³¸ ëª¨ë¸ ì¢Œí‘œê³„ ê¸°ì¤€ìœ¼ë¡œ ì„¤ì •ë¨
        function createConfiguredFlame(eng, size, length, color, sizeScale, idx) {
            const flameGroup = new THREE.Group();
            
            // ë°©í–¥ ë²¡í„° (ì—”ì§„ ì—ë””í„°ì—ì„œ ì„¤ì •í•œ ê°’)
            let dirX = eng.dirX || 0;
            let dirY = eng.dirY || 0;
            let dirZ = eng.dirZ || 1;
            
            console.log(`ğŸ”¥ ë¶ˆê½ƒ ${idx}: ì›ë³¸ ë°©í–¥ (${dirX}, ${dirY}, ${dirZ})`);
            
            const s = size * sizeScale;
            const l = length;
            
            // ê¸°ë³¸ ìŠ¤ì¼€ì¼ ì €ì¥ (ì• ë‹ˆë©”ì´ì…˜ì—ì„œ ì‚¬ìš©)
            flameGroup.userData.baseLength = l;
            flameGroup.userData.baseSize = s;
            
            // ì™¸ë¶€ ë¶ˆê½ƒ
            const outerGeo = new THREE.SphereGeometry(0.12 * s, 16, 12, 0, Math.PI * 2, 0, Math.PI / 2);
            outerGeo.rotateX(-Math.PI / 2);
            const outerMat = new THREE.MeshBasicMaterial({ 
                color: new THREE.Color(color), transparent: true, opacity: 0.4,
                blending: THREE.AdditiveBlending, depthWrite: false, side: THREE.DoubleSide
            });
            const outer = new THREE.Mesh(outerGeo, outerMat);
            outer.scale.set(1, 1, 3 * l);
            outer.userData.baseScaleZ = 3 * l;
            outer.name = 'flameOuter';
            flameGroup.add(outer);
            
            // ì¤‘ê°„ ë¶ˆê½ƒ
            const midGeo = new THREE.SphereGeometry(0.08 * s, 16, 12, 0, Math.PI * 2, 0, Math.PI / 2);
            midGeo.rotateX(-Math.PI / 2);
            const midMat = new THREE.MeshBasicMaterial({ 
                color: new THREE.Color(color).lerp(new THREE.Color(0xffffff), 0.3), 
                transparent: true, opacity: 0.6,
                blending: THREE.AdditiveBlending, depthWrite: false, side: THREE.DoubleSide
            });
            const mid = new THREE.Mesh(midGeo, midMat);
            mid.scale.set(1, 1, 2.5 * l);
            mid.userData.baseScaleZ = 2.5 * l;
            mid.name = 'flameMid';
            flameGroup.add(mid);
            
            // ì½”ì–´ ë¶ˆê½ƒ (ë°ì€ ì¤‘ì‹¬)
            const coreGeo = new THREE.SphereGeometry(0.04 * s, 16, 12, 0, Math.PI * 2, 0, Math.PI / 2);
            coreGeo.rotateX(-Math.PI / 2);
            const coreMat = new THREE.MeshBasicMaterial({ 
                color: new THREE.Color(color).lerp(new THREE.Color(0xffffff), 0.7), 
                transparent: true, opacity: 0.9,
                blending: THREE.AdditiveBlending, depthWrite: false, side: THREE.DoubleSide
            });
            const core = new THREE.Mesh(coreGeo, coreMat);
            core.scale.set(1, 1, 2 * l);
            core.userData.baseScaleZ = 2 * l;
            core.name = 'flameCore';
            flameGroup.add(core);
            
            // â˜…â˜…â˜… ë¶ˆê½ƒ ë°©í–¥ ì„¤ì • â˜…â˜…â˜…
            // ê¸°ë³¸ ë¶ˆê½ƒ ë°©í–¥: +Z (ë’¤ìª½ìœ¼ë¡œ ë¶„ì‚¬)
            // dirZ=-1(ì•)ì´ë©´ ë¶ˆê½ƒì€ ì•ìœ¼ë¡œ â†’ 180ë„ íšŒì „ í•„ìš”
            // dirZ=+1(ë’¤)ì´ë©´ ë¶ˆê½ƒì€ ë’¤ë¡œ â†’ íšŒì „ ë¶ˆí•„ìš”
            
            if (dirZ < -0.5) {
                // -Z ë°©í–¥ (ì•ìª½ìœ¼ë¡œ ë¶„ì‚¬) - ì—­ì¶”ì§„
                flameGroup.rotation.y = Math.PI;
            } else if (dirZ > 0.5) {
                // +Z ë°©í–¥ (ë’¤ìª½ìœ¼ë¡œ ë¶„ì‚¬) - ì •ìƒ ì¶”ì§„, íšŒì „ ì—†ìŒ
            } else if (dirY > 0.5) {
                // +Y ë°©í–¥ (ìœ„ë¡œ ë¶„ì‚¬)
                flameGroup.rotation.x = -Math.PI / 2;
            } else if (dirY < -0.5) {
                // -Y ë°©í–¥ (ì•„ë˜ë¡œ ë¶„ì‚¬)
                flameGroup.rotation.x = Math.PI / 2;
            } else if (dirX > 0.5) {
                // +X ë°©í–¥ (ì˜¤ë¥¸ìª½ìœ¼ë¡œ ë¶„ì‚¬)
                flameGroup.rotation.y = -Math.PI / 2;
            } else if (dirX < -0.5) {
                // -X ë°©í–¥ (ì™¼ìª½ìœ¼ë¡œ ë¶„ì‚¬)
                flameGroup.rotation.y = Math.PI / 2;
            }
            
            return flameGroup;
        }
        
        function createPlayerShip(isReboard = false) {
            // â˜…â˜…â˜… ê¸°ì¡´ ìš°ì£¼ì„  ì •ë¦¬ (í´ë¡  ë°©ì§€) â˜…â˜…â˜…
            if (playerShip && playerShip.mesh) {
                console.log('ğŸ§¹ ê¸°ì¡´ ìš°ì£¼ì„  ì •ë¦¬');
                scene.remove(playerShip.mesh);
                // ë©”ëª¨ë¦¬ ì •ë¦¬
                playerShip.mesh.traverse((child) => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
                playerShip.mesh = null;
            }
            
            const station = satellites.find(s => s.name === "ISS ìš°ì£¼ì •ê±°ì¥");
            console.log('createPlayerShip - station:', station, 'satellites:', satellites.length);
            if (!station || !station.mesh) {
                console.error('ISS ìš°ì£¼ì •ê±°ì¥ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!');
                return null;
            }
            
            const ship = currentShipType;
            const shipGroup = new THREE.Group();  // ë©”ì¸ ê·¸ë£¹ (ìœ„ì¹˜/íšŒì „)
            const shipVisualGroup = new THREE.Group();  // ì™¸í˜• ê·¸ë£¹ (ìŠ¤ì¼€ì¼ ì¡°ì •)
            shipVisualGroup.name = 'shipVisual';
            shipVisualGroup.rotation.y = Math.PI;  // â˜… 180ë„ íšŒì „ - ìš°ì£¼ëª¨ë“œì—ì„œ ì• ë°©í–¥ ë§ì¶”ê¸°
            
            // â˜…â˜…â˜… ì™¸í˜• ìŠ¤ì¼€ì¼ (ì •ê±°ì¥ê³¼ ë¹„ìŠ·í•˜ê²Œ) â˜…â˜…â˜…
            const isMultiMode = (typeof window.gameMode !== 'undefined' && window.gameMode === 'multi');
            const SHIP_VISUAL_SCALE = isMultiMode ? 0.8 : 1.0;  // ë©€í‹°ëª¨ë“œ: 0.08â†’0.8 (10ë°° ì¦ê°€)
            
            // í¬ê¸° ë°°ìœ¨ ê²°ì •
            const sizeScale = {
                'small': 1.0,
                'medium': 1.3,
                'large': 1.6,
                'huge': 2.0
            }[ship.size] || 1.0;
            
            // â˜…â˜…â˜… GLB ëª¨ë¸ì´ ìˆìœ¼ë©´ ë¡œë“œ â˜…â˜…â˜…
            if (ship.model && ship.model.length > 0) {
                const gltfLoader = new GLTFLoader();
                
                // â˜… Draco ì••ì¶• ì§€ì› (ì„ íƒì )
                try {
                    const dracoLoader = new DRACOLoader();
                    dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
                    gltfLoader.setDRACOLoader(dracoLoader);
                } catch(e) {
                    console.log('DRACO ë¡œë” ì—†ì´ ì§„í–‰');
                }
                
                // â˜… URLì„ Supabase Storageë¡œ ë³€í™˜
                const modelUrl = convertToSupabaseUrl(ship.model);
                console.log('ğŸš€ í”Œë ˆì´ì–´ ìš°ì£¼ì„  GLB ë¡œë“œ ì‹œë„:', modelUrl);
                
                gltfLoader.load(modelUrl, (gltf) => {
                    console.log('âœ… í”Œë ˆì´ì–´ ìš°ì£¼ì„  GLB ë¡œë“œ ì„±ê³µ:', modelUrl);
                    const model = gltf.scene;
                    model.scale.setScalar(sizeScale * 0.5);  // ëª¨ë¸ í¬ê¸° ì¡°ì ˆ
                    
                    // â˜… ëª¨ë¸ íšŒì „ì€ shipVisualGroupì—ì„œ ì²˜ë¦¬ë¨
                    // model.rotation.y = Math.PI;  // ì œê±°
                    
                    // â˜… ë©”íƒˆë¦­ ì¬ì§ˆ ì„¤ì • - ë¦¬ì–¼í•œ ê¸ˆì† ë°˜ì‚¬
                    model.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            
                            if (child.material) {
                                // ê¸°ì¡´ ì¬ì§ˆì´ ìˆìœ¼ë©´ ë©”íƒˆë¦­ ì†ì„± ê°•í™”
                                if (child.material.isMeshStandardMaterial || child.material.isMeshPhysicalMaterial) {
                                    // ê¸°ì¡´ ìƒ‰ìƒ ìœ ì§€í•˜ë©´ì„œ ë©”íƒˆë¦­ ê°•í™”
                                    child.material.metalness = Math.max(child.material.metalness || 0, 0.7);
                                    child.material.roughness = Math.min(child.material.roughness || 1, 0.35);
                                    child.material.envMapIntensity = 1.5;  // í™˜ê²½ ë°˜ì‚¬ ê°•í™”
                                } else {
                                    // ê¸°ë³¸ ì¬ì§ˆì„ MeshStandardMaterialë¡œ êµì²´
                                    const oldMat = child.material;
                                    const newMat = new THREE.MeshStandardMaterial({
                                        color: oldMat.color || 0x888888,
                                        map: oldMat.map || null,
                                        metalness: 0.8,
                                        roughness: 0.3,
                                        envMapIntensity: 1.5
                                    });
                                    child.material = newMat;
                                }
                                child.material.needsUpdate = true;
                            }
                        }
                    });
                    
                    // ê¸°ì¡´ ê¸°í•˜í•™ì  í˜•íƒœ ì œê±° (ì—”ì§„ ë¶ˆê½ƒ ì œì™¸)
                    const toRemove = [];
                    shipVisualGroup.children.forEach(child => {
                        if (child.name !== 'engineFlame' && child.name !== 'reverseFlameGroup' && 
                            child.name !== 'glbThrustFlames' && child.name !== 'glbReverseFlames') {
                            toRemove.push(child);
                        }
                    });
                    toRemove.forEach(child => shipVisualGroup.remove(child));
                    
                    model.name = 'glbModel';
                    shipVisualGroup.add(model);
                    
                    // â˜…â˜…â˜… engineConfigê°€ ìˆìœ¼ë©´ ì‚¬ìš©ì ì§€ì • ì—”ì§„ ë¶ˆê½ƒ ìƒì„± â˜…â˜…â˜…
                    if (ship.engineConfig) {
                        const cfg = ship.engineConfig;
                        console.log('ğŸ”§ engineConfig ì‚¬ìš©:', cfg);
                        
                        // â˜…â˜…â˜… ëª¨ë¸ ì „ë°© ë°©í–¥ì— ë”°ë¥¸ íšŒì „ ê³„ì‚° â˜…â˜…â˜…
                        const modelForward = cfg.modelForward || '+Z';
                        let modelRotationY = Math.PI;  // ê¸°ë³¸ê°’: 180ë„ (ê²Œì„ì—ì„œ -Zê°€ ì „ë°©)
                        
                        switch(modelForward) {
                            case '+Z': modelRotationY = Math.PI; break;      // ëª¨ë¸ì˜ +Zê°€ ì „ë°© â†’ 180ë„ íšŒì „
                            case '-Z': modelRotationY = 0; break;            // ëª¨ë¸ì˜ -Zê°€ ì „ë°© â†’ íšŒì „ ì—†ìŒ
                            case '+X': modelRotationY = -Math.PI / 2; break; // ëª¨ë¸ì˜ +Xê°€ ì „ë°© â†’ -90ë„
                            case '-X': modelRotationY = Math.PI / 2; break;  // ëª¨ë¸ì˜ -Xê°€ ì „ë°© â†’ +90ë„
                        }
                        
                        // ëª¨ë¸ íšŒì „ ì ìš©
                        model.rotation.y = modelRotationY;
                        console.log('ğŸ§­ ëª¨ë¸ ì „ë°©:', modelForward, 'â†’ íšŒì „:', (modelRotationY * 180 / Math.PI).toFixed(0) + 'ë„');
                        
                        // ëª¨ë¸ ìŠ¤ì¼€ì¼ (ë¶ˆê½ƒ ìœ„ì¹˜ ê³„ì‚°ì— ì‚¬ìš©)
                        const modelScale = sizeScale * 0.5;
                        
                        // ì¶”ì§„ ì—”ì§„ ë¶ˆê½ƒ
                        if (cfg.thrust && cfg.thrust.length > 0) {
                            const thrustGroup = new THREE.Group();
                            thrustGroup.name = 'glbThrustFlames';
                            
                            cfg.thrust.forEach(function(eng, idx) {
                                // ë¶ˆê½ƒ í¬ê¸°ë„ ëª¨ë¸ ìŠ¤ì¼€ì¼ ì ìš©
                                var flameGroup = createConfiguredFlame(
                                    eng, cfg.size || 1, cfg.length || 1,
                                    cfg.thrustColor || '#00aaff', modelScale, idx
                                );
                                // ìœ„ì¹˜ëŠ” ëª¨ë¸ ìŠ¤ì¼€ì¼ ì ìš©
                                flameGroup.position.set(
                                    eng.x * modelScale,
                                    eng.y * modelScale,
                                    eng.z * modelScale
                                );
                                flameGroup.name = 'thrustFlame_' + idx;
                                flameGroup.visible = false;
                                thrustGroup.add(flameGroup);
                            });
                            
                            // shipVisualGroupì— ì¶”ê°€
                            // â˜… ëª¨ë¸ íšŒì „ê³¼ ë™ì¼í•˜ê²Œ ë¶ˆê½ƒ ê·¸ë£¹ë„ íšŒì „
                            thrustGroup.rotation.y = modelRotationY;
                            shipVisualGroup.add(thrustGroup);
                            
                            // â˜… ì „ì—­ ë³€ìˆ˜ì— ì €ì¥
                            configuredThrustFlames = thrustGroup;
                            hasEngineConfig = true;
                            
                            console.log('ğŸ”µ ì¶”ì§„ ì—”ì§„ ' + cfg.thrust.length + 'ê°œ ìƒì„±');
                        }
                        
                        // ì—­ì¶”ì§„ ì—”ì§„ ë¶ˆê½ƒ
                        if (cfg.reverse && cfg.reverse.length > 0) {
                            const reverseGroup = new THREE.Group();
                            reverseGroup.name = 'glbReverseFlames';
                            
                            cfg.reverse.forEach(function(eng, idx) {
                                // ë¶ˆê½ƒ í¬ê¸°ë„ ëª¨ë¸ ìŠ¤ì¼€ì¼ ì ìš©
                                var flameGroup = createConfiguredFlame(
                                    eng, cfg.size || 1, cfg.length || 1,
                                    cfg.reverseColor || '#ffaa00', modelScale, idx
                                );
                                flameGroup.position.set(
                                    eng.x * modelScale,
                                    eng.y * modelScale,
                                    eng.z * modelScale
                                );
                                flameGroup.name = 'reverseFlame_' + idx;
                                flameGroup.visible = false;
                                reverseGroup.add(flameGroup);
                            });
                            
                            // â˜… ëª¨ë¸ íšŒì „ê³¼ ë™ì¼í•˜ê²Œ ë¶ˆê½ƒ ê·¸ë£¹ë„ íšŒì „
                            reverseGroup.rotation.y = modelRotationY;
                            shipVisualGroup.add(reverseGroup);
                            
                            // â˜… ì „ì—­ ë³€ìˆ˜ì— ì €ì¥
                            configuredReverseFlames = reverseGroup;
                            
                            console.log('ğŸŸ  ì—­ì¶”ì§„ ì—”ì§„ ' + cfg.reverse.length + 'ê°œ ìƒì„±');
                        }
                        
                        // ê¸°ë³¸ ë¶ˆê½ƒ ì™„ì „íˆ ì œê±°
                        const defaultFlame = shipVisualGroup.getObjectByName('engineFlame');
                        if (defaultFlame) {
                            shipVisualGroup.remove(defaultFlame);
                            console.log('ğŸ”´ ê¸°ë³¸ ì¶”ì§„ ë¶ˆê½ƒ ì œê±°ë¨');
                        }
                        const defaultReverse = shipVisualGroup.getObjectByName('reverseFlameGroup');
                        if (defaultReverse) {
                            shipVisualGroup.remove(defaultReverse);
                            console.log('ğŸ”´ ê¸°ë³¸ ì—­ì¶”ì§„ ë¶ˆê½ƒ ì œê±°ë¨');
                        }
                        
                    } else {
                        // â˜… engineConfig ì—†ìœ¼ë©´ ë°”ìš´ë”© ë°•ìŠ¤ë¡œ ê¸°ë³¸ ë¶ˆê½ƒ ìœ„ì¹˜ ê²°ì •
                        console.log('âš ï¸ engineConfig ì—†ìŒ. ê¸°ë³¸ ë¶ˆê½ƒ ì‚¬ìš©.');
                        const box = new THREE.Box3().setFromObject(model);
                        const modelSize = new THREE.Vector3();
                        box.getSize(modelSize);
                        
                        const flame = shipVisualGroup.getObjectByName('engineFlame');
                        if (flame) {
                            flame.position.z = (box.max.z + 0.1) / model.scale.x;
                            flame.scale.setScalar(Math.max(0.5, modelSize.x * 0.3));
                        }
                        
                        const reverseGroup = shipVisualGroup.getObjectByName('reverseFlameGroup');
                        if (reverseGroup) {
                            reverseGroup.position.z = (box.min.z - 0.1) / model.scale.x;
                        }
                    }
                    
                    console.log('âœ… GLB ëª¨ë¸ ë¡œë“œ ì™„ë£Œ:', ship.model);
                }, undefined, (error) => {
                    console.warn('GLB ëª¨ë¸ ë¡œë“œ ì‹¤íŒ¨, ê¸°ë³¸ í˜•íƒœ ì‚¬ìš©:', error);
                });
            }
            
            // ìš°ì£¼ì„  íƒ€ì…ë³„ ì™¸í˜• ìƒì„± (GLB ì—†ì„ ë•Œ ê¸°ë³¸ í˜•íƒœ)
            const mainColor = ship.color;
            const accentColor = ship.accentColor;
            
            // ë³¸ì²´
            let bodyGeo;
            switch(ship.id) {
                case 'shuttle':
                case 'scout':
                    bodyGeo = new THREE.ConeGeometry(0.25 * sizeScale, 1.0 * sizeScale, 8);
                    break;
                case 'interceptor':
                case 'racer':
                    bodyGeo = new THREE.ConeGeometry(0.2 * sizeScale, 1.3 * sizeScale, 6);
                    break;
                case 'freighter':
                    bodyGeo = new THREE.BoxGeometry(0.5 * sizeScale, 0.4 * sizeScale, 1.2 * sizeScale);
                    break;
                case 'corvette':
                case 'frigate':
                    bodyGeo = new THREE.ConeGeometry(0.3 * sizeScale, 1.1 * sizeScale, 8);
                    break;
                case 'cruiser':
                    bodyGeo = new THREE.CylinderGeometry(0.25 * sizeScale, 0.35 * sizeScale, 1.4 * sizeScale, 8);
                    break;
                case 'battleship':
                case 'flagship':
                    bodyGeo = new THREE.BoxGeometry(0.6 * sizeScale, 0.3 * sizeScale, 1.5 * sizeScale);
                    break;
                default:
                    bodyGeo = new THREE.ConeGeometry(0.3 * sizeScale, 1.2 * sizeScale, 8);
            }
            
            const bodyMat = new THREE.MeshStandardMaterial({ 
                color: mainColor, 
                metalness: 0.8, 
                roughness: 0.2, 
                emissive: mainColor, 
                emissiveIntensity: 0.1 
            });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            if (ship.id !== 'freighter' && ship.id !== 'battleship' && ship.id !== 'flagship' && ship.id !== 'cruiser') {
                body.rotation.x = Math.PI / 2;
            } else if (ship.id === 'cruiser') {
                body.rotation.x = Math.PI / 2;
            }
            shipVisualGroup.add(body);  // â˜… shipVisualGroupì— ì¶”ê°€
            
            // ë‚ ê°œ (íƒ€ì…ë³„ë¡œ ë‹¤ë¦„)
            const wingMat = new THREE.MeshStandardMaterial({ color: accentColor, metalness: 0.9, roughness: 0.1 });
            
            if (ship.id === 'interceptor' || ship.id === 'racer') {
                // ì‚¼ê°í˜• ë‚ ê°œ
                const wingGeo = new THREE.BoxGeometry(1.8 * sizeScale, 0.03 * sizeScale, 0.5 * sizeScale);
                const wing = new THREE.Mesh(wingGeo, wingMat);
                wing.position.z = 0.3 * sizeScale;
                shipVisualGroup.add(wing);
            } else if (ship.id === 'freighter') {
                // ì»¨í…Œì´ë„ˆ ìŠ¤íƒ€ì¼
                const cargoGeo = new THREE.BoxGeometry(0.35 * sizeScale, 0.3 * sizeScale, 0.4 * sizeScale);
                const cargo = new THREE.Mesh(cargoGeo, wingMat);
                cargo.position.z = 0.3 * sizeScale;
                shipVisualGroup.add(cargo);
            } else if (ship.id === 'battleship' || ship.id === 'flagship') {
                // í° ë‚ ê°œ
                const wingGeo = new THREE.BoxGeometry(2.2 * sizeScale, 0.06 * sizeScale, 0.6 * sizeScale);
                const wing = new THREE.Mesh(wingGeo, wingMat);
                wing.position.z = 0.2 * sizeScale;
                shipVisualGroup.add(wing);
                
                // ì¶”ê°€ êµ¬ì¡°ë¬¼
                const towerGeo = new THREE.BoxGeometry(0.15 * sizeScale, 0.25 * sizeScale, 0.3 * sizeScale);
                const tower = new THREE.Mesh(towerGeo, wingMat);
                tower.position.y = 0.2 * sizeScale;
                shipVisualGroup.add(tower);
            } else {
                // ê¸°ë³¸ ë‚ ê°œ
                const wingGeo = new THREE.BoxGeometry(1.4 * sizeScale, 0.04 * sizeScale, 0.35 * sizeScale);
                const wing = new THREE.Mesh(wingGeo, wingMat);
                wing.position.z = 0.2 * sizeScale;
                shipVisualGroup.add(wing);
            }
            
            // ì—”ì§„ (í¬ê¸°/ê°œìˆ˜ ë‹¤ë¦„)
            const engineMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const engineCount = ship.size === 'huge' ? 3 : (ship.size === 'large' ? 2 : 1);
            
            for (let i = 0; i < engineCount; i++) {
                const engineGeo = new THREE.CylinderGeometry(0.1 * sizeScale, 0.08 * sizeScale, 0.25 * sizeScale, 8);
                const engine = new THREE.Mesh(engineGeo, engineMat);
                engine.position.z = 0.6 * sizeScale;
                engine.rotation.x = Math.PI / 2;
                if (engineCount === 2) {
                    engine.position.x = (i === 0 ? -0.2 : 0.2) * sizeScale;
                } else if (engineCount === 3) {
                    engine.position.x = (i - 1) * 0.25 * sizeScale;
                }
                shipVisualGroup.add(engine);
            }
            
            // ì—”ì§„ ë¶ˆê½ƒ (í›„ë°© - ê°€ì†) - â˜… ë„“ì€ ë¶€ë¶„ì´ ì—”ì§„, ë¾°ì¡±í•œ ë¶€ë¶„ì´ ë’¤
            const flameGeo = new THREE.ConeGeometry(0.15 * sizeScale, 0.5 * sizeScale, 8);
            const flameMat = new THREE.MeshBasicMaterial({ 
                color: ship.id === 'racer' ? 0xff4400 : 0x00aaff, 
                transparent: true, 
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            const flame = new THREE.Mesh(flameGeo, flameMat);
            flame.position.z = 0.55 * sizeScale;  // â˜… ìš°ì£¼ì„  ë°”ë¡œ ë’¤ì—
            flame.rotation.x = Math.PI / 2;  // â˜… ë¾°ì¡±í•œ ë¶€ë¶„ì´ ë’¤ë¡œ (z+ ë°©í–¥)
            flame.visible = false;
            flame.name = 'engineFlame';
            shipVisualGroup.add(flame);
            
            // ì—­ì¶”ì§„ ì—”ì§„ ë¶ˆê½ƒ (í•˜ë‹¨ ì–‘ìª½ì—ì„œ ì „ë°© ì™¸ë¶€ë¡œ ë¶„ì‚¬) - ë­‰íˆ­í•œ í˜•íƒœ
            const reverseFlameGroup = new THREE.Group();
            reverseFlameGroup.name = 'reverseFlameGroup';
            reverseFlameGroup.visible = false;
            
            // ë¶ˆê½ƒ ë ˆì´ì–´ ìƒì„± í•¨ìˆ˜ (ë­‰íˆ­í•œ ì›í†µí˜• - ëì´ ë¾°ì¡±í•˜ì§€ ì•ŠìŒ)
            function createFlameLayer(offsetX, offsetY, baseZ, length, radiusTop, radiusBottom, color, opacity) {
                // CylinderGeometry: radiusTop, radiusBottomìœ¼ë¡œ í…Œì´í¼ ì¡°ì ˆ
                const geo = new THREE.CylinderGeometry(radiusTop * sizeScale, radiusBottom * sizeScale, length * sizeScale, 12);
                const mat = new THREE.MeshBasicMaterial({ 
                    color: color,
                    transparent: true, 
                    opacity: opacity,
                    side: THREE.DoubleSide
                });
                const flame = new THREE.Mesh(geo, mat);
                flame.position.set(offsetX * sizeScale, offsetY * sizeScale, baseZ * sizeScale);
                flame.rotation.x = Math.PI / 2; // ì „ë°©ìœ¼ë¡œ í–¥í•˜ê²Œ
                return flame;
            }
            
            // ì™¼ìª½ ì—­ì¶”ì§„ ë¶ˆê½ƒ (3ê°œ ë ˆì´ì–´) - ìš°ì£¼ì„  ì „ë°© ì™¸ë¶€ì—ì„œ ë¶„ì‚¬
            const leftFlameOuter = createFlameLayer(-0.22, -0.12, -0.9, 0.9, 0.04, 0.1, 0xff3300, 0.5);
            leftFlameOuter.name = 'leftOuter';
            reverseFlameGroup.add(leftFlameOuter);
            
            const leftFlameMiddle = createFlameLayer(-0.22, -0.12, -0.8, 0.7, 0.025, 0.07, 0xff6600, 0.7);
            leftFlameMiddle.name = 'leftMiddle';
            reverseFlameGroup.add(leftFlameMiddle);
            
            const leftFlameCore = createFlameLayer(-0.22, -0.12, -0.7, 0.5, 0.015, 0.04, 0xffcc00, 0.9);
            leftFlameCore.name = 'leftCore';
            reverseFlameGroup.add(leftFlameCore);
            
            // ì˜¤ë¥¸ìª½ ì—­ì¶”ì§„ ë¶ˆê½ƒ (3ê°œ ë ˆì´ì–´)
            const rightFlameOuter = createFlameLayer(0.22, -0.12, -0.9, 0.9, 0.04, 0.1, 0xff3300, 0.5);
            rightFlameOuter.name = 'rightOuter';
            reverseFlameGroup.add(rightFlameOuter);
            
            const rightFlameMiddle = createFlameLayer(0.22, -0.12, -0.8, 0.7, 0.025, 0.07, 0xff6600, 0.7);
            rightFlameMiddle.name = 'rightMiddle';
            reverseFlameGroup.add(rightFlameMiddle);
            
            const rightFlameCore = createFlameLayer(0.22, -0.12, -0.7, 0.5, 0.015, 0.04, 0xffcc00, 0.9);
            rightFlameCore.name = 'rightCore';
            reverseFlameGroup.add(rightFlameCore);
            
            // ë¶„ì‚¬êµ¬ ë°œê´‘ì²´ (ì™¼ìª½) - ìš°ì£¼ì„  ì•ìª½ ì™¸ë¶€
            const nozzleGeoL = new THREE.SphereGeometry(0.055 * sizeScale, 12, 12);
            const nozzleMatL = new THREE.MeshBasicMaterial({ color: 0xffffcc, transparent: true, opacity: 0.95 });
            const nozzleL = new THREE.Mesh(nozzleGeoL, nozzleMatL);
            nozzleL.position.set(-0.22 * sizeScale, -0.12 * sizeScale, -0.45 * sizeScale);
            nozzleL.name = 'nozzleL';
            reverseFlameGroup.add(nozzleL);
            
            // ë¶„ì‚¬êµ¬ ë°œê´‘ì²´ (ì˜¤ë¥¸ìª½)
            const nozzleR = new THREE.Mesh(nozzleGeoL.clone(), nozzleMatL.clone());
            nozzleR.position.set(0.22 * sizeScale, -0.12 * sizeScale, -0.45 * sizeScale);
            nozzleR.name = 'nozzleR';
            reverseFlameGroup.add(nozzleR);
            
            shipVisualGroup.add(reverseFlameGroup);
            
            // ì¡°ì¢…ì„ ì¡°ëª…
            const cockpitLight = new THREE.PointLight(accentColor, 0.3, 3 * sizeScale);
            cockpitLight.position.set(0, 0, -0.3 * sizeScale);
            shipVisualGroup.add(cockpitLight);
            
            // â˜… íƒœì–‘ë¹› ì¡°ëª… (íƒœì–‘ ë°©í–¥ì—ì„œ ì˜¤ëŠ” ë¹› - ë¬¼ë¦¬ ê¸°ë°˜)
            const sunLight = new THREE.DirectionalLight(0xfffaf0, 2.5);  // ë”°ëœ»í•œ í–‡ë¹›, ê°•ë„ ì¦ê°€
            sunLight.position.set(10, 5, 10);  // ì´ˆê¸° ìœ„ì¹˜
            sunLight.target = shipVisualGroup;  // ìš°ì£¼ì„ ì„ íƒ€ê²Ÿìœ¼ë¡œ
            sunLight.name = 'sunLight';
            sunLight.castShadow = true;
            shipGroup.add(sunLight);
            shipGroup.add(sunLight.target);
            
            // â˜… ì€ì€í•œ í™˜ê²½ê´‘ (ìš°ì£¼ ê³µê°„ - ë§¤ìš° ì–´ë‘¡ê²Œ)
            const ambientLight = new THREE.AmbientLight(0x111122, 0.15);  // ë” ì–´ë‘¡ê²Œ
            ambientLight.name = 'shipAmbient';
            shipGroup.add(ambientLight);
            
            // â˜… ë°˜ëŒ€ìª½ ì•½í•œ ë³´ì¡°ê´‘ (ì™„ì „ ì–´ë‘¡ì§€ ì•Šê²Œ)
            const fillLight = new THREE.DirectionalLight(0x4466aa, 0.2);  // ì°¨ê°€ìš´ í‘¸ë¥¸ë¹›
            fillLight.position.set(-5, -2, -5);
            fillLight.name = 'fillLight';
            shipGroup.add(fillLight);
            
            // ì‰´ë“œ íš¨ê³¼ (ì½”ë¥´ë²³ ë“±)
            if (ship.special === 'shield' || ship.special === 'allInOne') {
                const shieldGeo = new THREE.SphereGeometry(1.2 * sizeScale, 16, 16);
                const shieldMat = new THREE.MeshBasicMaterial({ 
                    color: 0x00ffff, 
                    transparent: true, 
                    opacity: 0.1,
                    side: THREE.DoubleSide
                });
                const shield = new THREE.Mesh(shieldGeo, shieldMat);
                shield.visible = false;
                shield.name = 'shield';
                shipVisualGroup.add(shield);
            }
            
            // â˜…â˜…â˜… ì™¸í˜• ìŠ¤ì¼€ì¼ ì ìš© â˜…â˜…â˜…
            shipVisualGroup.scale.setScalar(SHIP_VISUAL_SCALE);
            shipGroup.add(shipVisualGroup);
            
            // ì €ì¥ëœ ìœ„ì¹˜ê°€ ìˆìœ¼ë©´ ë³µì› (ì¬íƒ‘ìŠ¹ ì‹œ)
            const hasParkedShip = isReboard && parkedShip && parkedShip.type === ship.id;
            const hasSavedState = savedShipState && savedShipState.shipTypeIndex === selectedShipIndex && savedShipState.position;
            
            console.log('createPlayerShip í˜¸ì¶œ:', { isReboard, hasParkedShip, hasSavedState, savedShipState });
            
            if (hasParkedShip) {
                // ì£¼ì°¨ëœ ìœ„ì¹˜ì—ì„œ ì¬íƒ‘ìŠ¹
                shipGroup.position.copy(parkedShip.position);
                shipGroup.quaternion.copy(parkedShip.quaternion);
                shipGroup.rotation.copy(parkedShip.rotation);
                console.log('ì£¼ì°¨ëœ ìš°ì£¼ì„ ì—ì„œ ì¬íƒ‘ìŠ¹');
            } else if (hasSavedState) {
                shipGroup.position.copy(savedShipState.position);
                shipGroup.quaternion.copy(savedShipState.quaternion);
                console.log('ì €ì¥ëœ ìƒíƒœì—ì„œ ë³µì›');
            } else {
                // ìµœì´ˆ íƒ‘ìŠ¹: ì •ê±°ì¥ì— ë„í‚¹ëœ ìƒíƒœì—ì„œ ì‹œì‘

                // â˜…â˜…â˜… ë©€í‹°ëª¨ë“œ: ìŠ¤í° ì „ ëª¨ë“  ì²œì²´ ìœ„ì¹˜ ê°•ì œ ì—…ë°ì´íŠ¸ â˜…â˜…â˜…
                if (window.gameMode === 'multi') {
                    // 1. ë¨¼ì € í–‰ì„±ë“¤ ìœ„ì¹˜ ì—…ë°ì´íŠ¸ (keplerTime ê¸°ì¤€)
                    if (typeof updateKeplerOrbits === 'function') {
                        updateKeplerOrbits(0);
                    }

                    // 2. ê·¸ ë‹¤ìŒ ìœ„ì„±/ì •ê±°ì¥ ìœ„ì¹˜ ì—…ë°ì´íŠ¸ (ì„œë²„ ë™ê¸°í™” ì‹œê°„ ì‚¬ìš©)
                    if (station.parentBody && station.parentBody.mesh) {
                        const seed = station.name ? station.name.split('').reduce((a, c) => a + c.charCodeAt(0), 0) : 0;
                        const syncedTime = typeof getSyncedTime === 'function' ? getSyncedTime() : Date.now();
                        const baseTime = syncedTime * 0.0000001;
                        station.angle = (seed * 0.1 + baseTime * station.orbitSpeed) % (Math.PI * 2);

                        const isRealMode = CONFIG.distScale > 1.0;
                        const parentScale = station.parentBody.visualScale || 1;
                        const r = isRealMode && station.realOrbitRadius
                            ? station.realOrbitRadius * (station.parentBody.radius || 1) * parentScale
                            : station.orbitRadius;

                        station.mesh.position.x = station.parentBody.mesh.position.x + Math.cos(station.angle) * r;
                        station.mesh.position.z = station.parentBody.mesh.position.z + Math.sin(station.angle) * r;
                        station.mesh.position.y = station.parentBody.mesh.position.y;

                        console.log('â˜… ìŠ¤í° ì „ ê°•ì œ ë™ê¸°í™” - ì§€êµ¬:', station.parentBody.mesh.position, 'ì •ê±°ì¥:', station.mesh.position);
                    }
                }

                const stationWorldPos = new THREE.Vector3();
                station.mesh.getWorldPosition(stationWorldPos);
                
                // â˜… ì§€êµ¬ ë°˜ëŒ€ ë°©í–¥ ê³„ì‚°
                const earth = bodies.find(b => b.name === 'ì§€êµ¬' || b.name === 'Earth');
                let undockDir;
                if (earth && earth.mesh) {
                    // ì§€êµ¬ â†’ ì •ê±°ì¥ ë°©í–¥ = ì§€êµ¬ ë°˜ëŒ€ ë°©í–¥
                    undockDir = new THREE.Vector3()
                        .subVectors(stationWorldPos, earth.mesh.position)
                        .normalize();
                } else {
                    // ì§€êµ¬ ëª» ì°¾ìœ¼ë©´ ê¸°ë³¸ ë°©í–¥
                    undockDir = new THREE.Vector3(1, 0, 0);
                }
                
                // ì§€êµ¬ ë°˜ëŒ€ ë°©í–¥ìœ¼ë¡œ ìš°ì£¼ì„  ë°°ì¹˜
                shipGroup.position.copy(stationWorldPos);
                shipGroup.position.add(undockDir.clone().multiplyScalar(0.5 * sizeScale * SHIP_VISUAL_SCALE));
                
                // ì´íƒˆ ë°©í–¥ì„ ë°”ë¼ë³´ë„ë¡ íšŒì „
                const lookTarget = shipGroup.position.clone().add(undockDir.clone().multiplyScalar(10));
                shipGroup.lookAt(lookTarget);
                
                savedShipState = null;  // ìƒˆ ìš°ì£¼ì„ ì´ë©´ ì €ì¥ ìƒíƒœ ì´ˆê¸°í™”
                parkedShip = null;  // ì£¼ì°¨ ìƒíƒœë„ ì´ˆê¸°í™”
                
                // â˜… ì–¸ë„í‚¹ ì—°ì¶œ ì‹œì‘
                undockingState.active = true;
                undockingState.phase = 'undocking';
                undockingState.startTime = Date.now();
                undockingState.startPos = shipGroup.position.clone();
                undockingState.stationPos = stationWorldPos.clone();
                undockingState.undockDirection = undockDir;  // â˜… ë°©í–¥ ì €ì¥
                
                console.log('â˜… ì–¸ë„í‚¹ ì—°ì¶œ ì‹œì‘!', undockingState);
            }
            
            scene.add(shipGroup);
            
            // â˜…â˜…â˜… ì¹´ë©”ë¼ëŠ” shipGroupì— ì§ì ‘ ì¶”ê°€ (ìŠ¤ì¼€ì¼ ì˜í–¥ ì•ˆ ë°›ìŒ) â˜…â˜…â˜…
            shipGroup.add(camera);
            // ì¹´ë©”ë¼ ìœ„ì¹˜ëŠ” ìŠ¤ì¼€ì¼ê³¼ ë¬´ê´€í•˜ê²Œ ê³ ì • (ì¡°ì¢…ì„ ë‚´ë¶€ ëŠë‚Œ)
            const camOffset = 0.15;  // ìŠ¤ì¼€ì¼ ì—†ì´ ê³ ì •
            camera.position.set(0, 0.08, camOffset);
            camera.rotation.set(0, Math.PI, 0);  // â˜… 180ë„ íšŒì „ - ì• ë°©í–¥ ë°”ë¼ë³´ê¸°
            
            // íŠ¹ìˆ˜ëŠ¥ë ¥ ì´ˆê¸°í™”
            shipAbility.cooldown = 0;
            shipAbility.shieldActive = ship.special === 'shield' || ship.special === 'allInOne';
            shipAbility.afterburnerActive = false;
            shipAbility.warpReady = true;
            
            playerShip = {
                mesh: shipGroup,
                visualMesh: shipVisualGroup,  // â˜… ì™¸í˜• ê·¸ë£¹ ì°¸ì¡° ì¶”ê°€
                speed: (isReboard && parkedShip) ? parkedShip.speed : (savedShipState ? savedShipState.speed : 0),
                fuel: (isReboard && parkedShip) ? parkedShip.fuel : (savedShipState ? savedShipState.fuel : SHIP_CONFIG.maxFuel),
                hull: (isReboard && parkedShip) ? (parkedShip.hull || SHIP_CONFIG.maxHull) : (savedShipState ? (savedShipState.hull || SHIP_CONFIG.maxHull) : SHIP_CONFIG.maxHull),  // â˜… ë‚´êµ¬ë„ ì¶”ê°€
                euler: new THREE.Euler(0, 0, 0, 'YXZ'),
                flame: flame,
                velocity: new THREE.Vector3(),
                mass: 0.001 * sizeScale,
                shipType: ship,
                sizeScale: sizeScale,
                visualScale: SHIP_VISUAL_SCALE  // â˜… ì™¸í˜• ìŠ¤ì¼€ì¼ ì €ì¥
            };
            
            // ì „ì—­ìœ¼ë¡œ ë…¸ì¶œ
            window.playerShip = playerShip;
            
            // ë„í‚¹ëœ ìš°ì£¼ì„  ìˆ¨ê¸°ê¸°
            if (dockedShipMesh) dockedShipMesh.visible = false;
            
            return playerShip;
        }
        
        function boardShip() {
            if (isPilotMode) return;

            // â˜…â˜…â˜… ê²Œì„ ìƒíƒœ ë³µì› ì‹œ ë°”ë¡œ íƒ‘ìŠ¹ (ëª¨ë‹¬ ìŠ¤í‚µ) â˜…â˜…â˜…
            if (window.skipShipSelectForRestore) {
                window.skipShipSelectForRestore = false;
                console.log('ğŸ® ê²Œì„ ìƒíƒœ ë³µì›: ë°”ë¡œ íƒ‘ìŠ¹');
                proceedToBoard(false);  // ë°”ë¡œ íƒ‘ìŠ¹
                return;
            }

            // â˜… Supabase ë¡œê·¸ì¸ ìƒíƒœ ì²´í¬ (mpUserê°€ ìˆìœ¼ë©´ ë¡œê·¸ì¸ë¨)
            const isLoggedIn = window.mpUser || window.mpUserId;

            // ë©€í‹°ëª¨ë“œì—ì„œëŠ” ë°˜ë“œì‹œ ë¡œê·¸ì¸ í•„ìš” (ê²ŒìŠ¤íŠ¸ ì œì™¸)
            if (window.gameMode === 'multi') {
                if (!isLoggedIn) {
                    showMsg('ğŸ” Login required for multiplayer mode.');
                    const authOverlay = document.getElementById('auth-overlay');
                    if (authOverlay) {
                        authOverlay.style.display = 'flex';
                    }
                    return;
                }
            }

            // ì‹±ê¸€ëª¨ë“œëŠ” ë¡œê·¸ì¸ ì—†ì´ë„ í”Œë ˆì´ ê°€ëŠ¥
            // (ë¡œê·¸ì¸í•˜ë©´ ë°ì´í„° ì €ì¥ë¨)

            // ì¶©ëŒë¡œ ì¸í•œ í•˜ì„  í›„ ì¬íƒ‘ìŠ¹ì¸ ê²½ìš° ë©”ì‹œì§€ í‘œì‹œ
            if (window.lastExitReason === 'collision') {
                const destroyedName = window.destroyedShipName || 'ìš°ì£¼ì„ ';
                showMsg(`ğŸ’¥ ${destroyedName}ì´(ê°€) íŒŒê´´ë˜ì–´ ì†Œìœ ê¶Œì´ ì‚¬ë¼ì¡ŒìŠµë‹ˆë‹¤. ìƒˆ ìš°ì£¼ì„ ì„ êµ¬ë§¤í•˜ì„¸ìš”.`);
                // ê¸°ë³¸ ì…”í‹€ë¡œ ê°•ì œ ì„¤ì •
                selectedShipIndex = 0;
                currentShipType = SHIP_TYPES[0];
                window.currentShipType = currentShipType;  // â˜… ì „ì—­ ì—…ë°ì´íŠ¸
                window.lastExitReason = null;
                window.destroyedShipName = null;
            }

            // ì£¼ì°¨ëœ ìš°ì£¼ì„  í´ë¦­ í›„ ì¬íƒ‘ìŠ¹ì¸ ê²½ìš° (ë°”ë¡œ íƒ‘ìŠ¹)
            if (focusedBody && focusedBody.isParkedShip && parkedShip) {
                // ì£¼ì°¨ëœ ìš°ì£¼ì„ ìœ¼ë¡œ ë°”ë¡œ ì¬íƒ‘ìŠ¹
                directReboard();
                return;
            }

            // ISS ì •ê±°ì¥ì—ì„œ íƒ‘ìŠ¹ - ìš°ì£¼ì„  ì„ íƒ ëª¨ë‹¬ í‘œì‹œ
            openShipSelectModal();
        }
        
        // ì£¼ì°¨ëœ ìš°ì£¼ì„  ì •ë¦¬
        function clearParkedShip() {
            if (parkedShipMesh) {
                scene.remove(parkedShipMesh);
                parkedShipMesh = null;
            }
            parkedShip = null;
            
            // Supabaseì—ì„œ ì£¼ì°¨ ì •ë³´ ì‚­ì œ
            if (window.mpUser && window.supabaseClient) {
                window.supabaseClient
                    .from('profiles')
                    .update({ parked_ship: null })
                    .eq('id', window.mpUserId)
                    .then(function() {})
                    .catch(function(e) {
                        console.warn('ì£¼ì°¨ ì •ë³´ ì‚­ì œ ì‹¤íŒ¨:', e);
                    });
            }
        }
        
        // ì£¼ì°¨ëœ ìš°ì£¼ì„ ìœ¼ë¡œ ë°”ë¡œ ì¬íƒ‘ìŠ¹
        function directReboard() {
            if (!parkedShip || !parkedShipMesh) return;
            
            // â˜… ìš´í•­ ì¤‘ì¸ ìƒíƒœ ì €ì¥
            const wasMoving = parkedShipMesh.userData.isMoving;
            const savedVelocity = parkedShipMesh.userData.velocity ? parkedShipMesh.userData.velocity.clone() : null;
            const savedSpeed = parkedShipMesh.userData.speed || 0;
            const savedFuel = parkedShipMesh.userData.fuel || 100;
            const savedPosition = parkedShipMesh.position.clone();
            const savedQuaternion = parkedShipMesh.quaternion.clone();
            
            // ì£¼ì°¨ëœ ìš°ì£¼ì„  íƒ€ì…ìœ¼ë¡œ ì„¤ì •
            const shipIdx = parkedShipMesh.userData.shipTypeIndex;
            selectedShipIndex = shipIdx;
            currentShipType = SHIP_TYPES[shipIdx];
            window.currentShipType = currentShipType;  // â˜… ì „ì—­ ì—…ë°ì´íŠ¸
            
            // â˜… parkedShip ë°ì´í„° ì—…ë°ì´íŠ¸ (í˜„ì¬ ìœ„ì¹˜ë¡œ)
            parkedShip.position = savedPosition;
            parkedShip.quaternion = savedQuaternion;
            parkedShip.rotation = new THREE.Euler().setFromQuaternion(savedQuaternion);
            parkedShip.speed = savedSpeed;
            parkedShip.fuel = savedFuel;
            
            // ê¸°ì¡´ ì£¼ì°¨ ë©”ì‹œ ì œê±°
            scene.remove(parkedShipMesh);
            
            // â˜… bodies ë°°ì—´ì—ì„œë„ ì œê±°
            const parkedBodyIdx = bodies.findIndex(b => b.isParkedShip);
            if (parkedBodyIdx >= 0) {
                bodies.splice(parkedBodyIdx, 1);
            }
            
            parkedShipMesh = null;
            
            // ì‹¤ì œ ê±°ë¦¬ ëª¨ë“œ ìœ ì§€
            if (CONFIG.distScale < 50.0) {
                CONFIG.distScale = 50.0;
                const scaleBtn = document.getElementById('btn-scale-mode');
                if (scaleBtn) {
                    scaleBtn.textContent = t('distReal');
                    scaleBtn.classList.add('active');
                }
            }
            
            // â˜… ë§ˆì»¤ ìˆ¨ê¸°ê¸°
            hideShipLocationMarker();
            
            // ë°”ë¡œ íƒ‘ìŠ¹
            setTimeout(() => {
                actualBoardShip(true);  // ì¬íƒ‘ìŠ¹ ëª¨ë“œ
            }, 100);
        }
        
        // â˜…â˜…â˜… ìš°ì£¼ì •ê±°ì¥ ì‹œìŠ¤í…œ â˜…â˜…â˜…
        
        // ì •ê±°ì¥ ëª¨ë‹¬ ì—´ê¸°
        function openStationModal() {
            // â˜… ë©€í‹°ëª¨ë“œ íŠœí† ë¦¬ì–¼ ê°€ì´ë“œ
            if (typeof MultiTutorial !== 'undefined') {
                MultiTutorial.showFeatureGuide('station-modal');
            }
            
            const modal = document.getElementById('station-modal');
            const planetList = document.getElementById('planet-stations');
            const fuelList = document.getElementById('fuel-stations');
            
            // ì •ê±°ì¥ ëª©ë¡ ë¶„ë¥˜
            const planetStations = satellites.filter(s => s.type === 'station' && !s.isFuelDepot);
            const fuelDepots = satellites.filter(s => s.type === 'station' && s.isFuelDepot);
            
            // í–‰ì„± ê¶¤ë„ ì •ê±°ì¥ ë Œë”ë§
            planetList.innerHTML = '';
            planetStations.forEach(station => {
                const parentName = station.parentBody ? translateBodyName(station.parentBody.name) : t('unknown');
                const dist = playerShip ? 
                    playerShip.mesh.position.distanceTo(station.mesh.position).toFixed(0) : '---';
                
                // ë°©ë¬¸ ì—¬ë¶€ í™•ì¸ (ISSëŠ” í•­ìƒ ë°©ë¬¸)
                const isISS = station.name.includes('ISS');
                const visited = isISS || (typeof visitedSatellites !== 'undefined' && visitedSatellites.has(station.name));
                
                const item = document.createElement('div');
                item.className = 'station-item' + (visited ? '' : ' locked');
                item.innerHTML = `
                    <div class="station-info">
                        <div class="station-name">${visited ? 'ğŸ›°ï¸' : 'ğŸ”’'} ${translateBodyName(station.name)}</div>
                        <div class="station-desc">${parentName} ${t('orbitSuffixText')} | ${t('distance')}: ${dist} km</div>
                    </div>
                    <div class="station-actions">
                        <button class="station-btn go ${visited ? '' : 'disabled'}" onclick="goToStation('${station.name}')">${visited ? t('goToStationBtn') : 'ğŸ”’'}</button>
                        <button class="station-btn dock ${visited ? '' : 'disabled'}" onclick="${visited ? `dockAtStation('${station.name}')` : ''}">${visited ? t('docking') : 'ğŸ”’'}</button>
                    </div>
                `;
                planetList.appendChild(item);
            });
            
            // ì—°ë£Œ ì •ê±°ì¥ ë Œë”ë§
            fuelList.innerHTML = '';
            fuelDepots.forEach(depot => {
                const dist = playerShip ? 
                    playerShip.mesh.position.distanceTo(depot.mesh.position).toFixed(0) : '---';
                
                // ë°©ë¬¸ ì—¬ë¶€ í™•ì¸
                const visited = typeof visitedSatellites !== 'undefined' && visitedSatellites.has(depot.name);
                
                const item = document.createElement('div');
                item.className = 'station-item fuel-depot' + (visited ? '' : ' locked');
                item.innerHTML = `
                    <div class="station-info">
                        <div class="station-name">${visited ? 'â›½' : 'ğŸ”’'} ${translateBodyName(depot.name)}</div>
                        <div class="station-desc">${depot.description || t('orbitSuffixText')} | ${t('distance')}: ${dist} km</div>
                    </div>
                    <div class="station-actions">
                        <button class="station-btn go ${visited ? '' : 'disabled'}" onclick="goToStation('${depot.name}')">${visited ? t('goToStationBtn') : 'ğŸ”’'}</button>
                        <button class="station-btn dock ${visited ? '' : 'disabled'}" onclick="${visited ? `dockAtStation('${depot.name}')` : ''}">${visited ? t('docking') : 'ğŸ”’'}</button>
                    </div>
                `;
                fuelList.appendChild(item);
            });
            
            modal.classList.add('open');
        }
        
        // ì •ê±°ì¥ìœ¼ë¡œ ì¹´ë©”ë¼ ì´ë™ (ê°€ê¹Œì´ì„œ ë³´ê¸°)
        window.goToStation = function(stationName) {
            const station = satellites.find(s => s.name === stationName);
            if (station) {
                // ISSëŠ” í•­ìƒ ì´ë™ ê°€ëŠ¥
                const isISS = stationName.includes('ISS');
                
                // ë°©ë¬¸ ì—¬ë¶€ ì²´í¬ (ISS ì œì™¸)
                if (!isISS) {
                    const visited = typeof visitedSatellites !== 'undefined' && visitedSatellites.has(stationName);
                    if (!visited) {
                        // ì¹œì ˆí•œ ì•ˆë‚´ íŒì—…
                        showStationLockedPopup(stationName);
                        return;
                    }
                }
                
                document.getElementById('station-modal').classList.remove('open');
                
                // â˜… ì •ê±°ì¥ ê°€ê¹Œì´ë¡œ ì¹´ë©”ë¼ ì´ë™
                if (station.mesh && controls) {
                    const stationPos = station.mesh.position.clone();
                    const stationSize = station.r || 5;
                    const viewDistance = stationSize * 15;  // ì •ê±°ì¥ í¬ê¸°ì˜ 15ë°° ê±°ë¦¬ì—ì„œ ë³´ê¸°
                    
                    // ì¹´ë©”ë¼ ìœ„ì¹˜ ì„¤ì • (ì •ê±°ì¥ ì˜†ì—ì„œ ë¹„ìŠ¤ë“¬íˆ ë³´ê¸°)
                    const offset = new THREE.Vector3(viewDistance * 0.7, viewDistance * 0.5, viewDistance * 0.7);
                    camera.position.copy(stationPos).add(offset);
                    controls.target.copy(stationPos);
                    controls.update();
                    
                    showMsg(`ğŸ“ ${translateBodyName(stationName)}(ìœ¼)ë¡œ ì´ë™í–ˆìŠµë‹ˆë‹¤.`);
                } else {
                    focusBody(station);
                    showMsg(`${translateBodyName(stationName)}(ìœ¼)ë¡œ ì´ë™í•©ë‹ˆë‹¤.`);
                }
            }
        }
        
        // ì ê¸´ ì •ê±°ì¥ ì•ˆë‚´ íŒì—…
        function showStationLockedPopup(stationName) {
            // ê¸°ì¡´ íŒì—… ì œê±°
            const existingPopup = document.getElementById('station-locked-popup');
            if (existingPopup) existingPopup.remove();
            
            const popup = document.createElement('div');
            popup.id = 'station-locked-popup';
            popup.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(10, 20, 40, 0.95);
                border: 2px solid #f90;
                border-radius: 15px;
                padding: 25px;
                z-index: 10002;
                min-width: 300px;
                max-width: 90vw;
                text-align: center;
                font-family: 'Orbitron', sans-serif;
                color: white;
                box-shadow: 0 0 30px rgba(255, 150, 0, 0.3);
            `;
            
            popup.innerHTML = `
                <div style="font-size: 40px; margin-bottom: 15px;">ğŸ”’</div>
                <div style="font-size: 16px; color: #f90; margin-bottom: 10px;">ë¯¸ë°©ë¬¸ ì •ê±°ì¥</div>
                <div style="font-size: 14px; color: #fff; margin-bottom: 15px;">${stationName}</div>
                <div style="font-size: 12px; color: #aaa; line-height: 1.6; margin-bottom: 20px;">
                    ì´ ì •ê±°ì¥ì€ ì•„ì§ ë°©ë¬¸í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.<br><br>
                    <span style="color: #0ff;">ğŸ“ ì •ê±°ì¥ ê·¼ì²˜ë¡œ ì§ì ‘ ë¹„í–‰</span>í•˜ì—¬<br>
                    <span style="color: #0f0;">ğŸš€ ë„í‚¹</span>ì„ ì™„ë£Œí•˜ë©´<br>
                    ë‹¤ìŒë¶€í„° ë°”ë¡œ ì´ë™í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!
                </div>
                <button onclick="this.parentElement.remove()" style="
                    background: linear-gradient(135deg, #f90 0%, #f60 100%);
                    border: none;
                    color: #000;
                    padding: 12px 30px;
                    border-radius: 25px;
                    font-size: 14px;
                    font-weight: bold;
                    cursor: pointer;
                    font-family: 'Orbitron', sans-serif;
                ">${t('confirm')}</button>
            `;
            
            document.body.appendChild(popup);
            
            // ë°°ê²½ í´ë¦­ ì‹œ ë‹«ê¸°
            popup.addEventListener('click', (e) => {
                if (e.target === popup) popup.remove();
            });
        }
        
        // ì •ê±°ì¥ ë„í‚¹ (ìë™ í•­í•´ + ìë™ ë„í‚¹)
        function dockAtStation(stationName) {
            const station = satellites.find(s => s.name === stationName);
            if (!station) return;
            
            document.getElementById('station-modal').classList.remove('open');
            
            // ë¡œê·¸ì¸ ì²´í¬ (Supabase)
            const isLoggedIn = window.mpUser || window.mpUserId;
            if (!isLoggedIn) {
                showMsg('ğŸ” Login required.');
                const authOverlay = document.getElementById('auth-overlay');
                if (authOverlay) authOverlay.style.display = 'flex';
                return;
            }
            
            // ìš°ì£¼ì„ ì´ ì—†ìœ¼ë©´ ë¨¼ì € íƒ‘ìŠ¹í•´ì•¼ í•¨
            if (!playerShip || !playerShip.mesh) {
                showMsg('ğŸš€ ë¨¼ì € ìš°ì£¼ì„ ì— íƒ‘ìŠ¹í•˜ì„¸ìš”.');
                openShipSelectModal();
                window.pendingDockStation = station;  // ìš°ì£¼ì„  ì„ íƒ í›„ ë„í‚¹í•  ì •ê±°ì¥ ì €ì¥
                return;
            }
            
            // â˜…â˜…â˜… ìë™ í•­í•´ ì‹œì‘ â˜…â˜…â˜…
            startAutoPilotToStation(station);
        }
        
        // â˜…â˜…â˜… ìë™ í•­í•´ ì‹œìŠ¤í…œ â˜…â˜…â˜…
        let autoPilotActive = false;
        let autoPilotTarget = null;
        let autoPilotInterval = null;
        
        function startAutoPilotToStation(station) {
            if (!playerShip || !playerShip.mesh || !station || !station.mesh) {
                showMsg('âŒ ìë™ í•­í•´ë¥¼ ì‹œì‘í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }
            
            autoPilotActive = true;
            autoPilotTarget = station;
            
            // íŒŒì¼ëŸ¿ ëª¨ë“œë¡œ ì „í™˜
            if (!window.isPilotMode) {
                if (typeof enterCockpitView === 'function') {
                    enterCockpitView();
                }
            }
            
            showMsg(`ğŸš€ ${translateBodyName(station.name)}(ìœ¼)ë¡œ ìë™ í•­í•´ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤...`);
            
            // ìë™ í•­í•´ UI í‘œì‹œ
            showAutoPilotUI(station);
            
            // ìë™ í•­í•´ ë£¨í”„ ì‹œì‘
            if (autoPilotInterval) clearInterval(autoPilotInterval);
            autoPilotInterval = setInterval(() => updateAutoPilot(), 50);  // 20fps
        }
        
        function updateAutoPilot() {
            if (!autoPilotActive || !autoPilotTarget || !playerShip || !playerShip.mesh) {
                stopAutoPilot();
                return;
            }
            
            const shipPos = playerShip.mesh.position;
            const targetPos = autoPilotTarget.mesh.position;
            const distance = shipPos.distanceTo(targetPos);
            
            // ì •ê±°ì¥ í¬ê¸° ê¸°ë°˜ ë„í‚¹ ê±°ë¦¬
            const stationSize = autoPilotTarget.r || 5;
            const dockingDistance = stationSize * 3;
            
            // UI ì—…ë°ì´íŠ¸
            updateAutoPilotUI(distance);
            
            // ë„í‚¹ ê±°ë¦¬ ë„ë‹¬
            if (distance < dockingDistance) {
                stopAutoPilot();
                completeAutoDocking(autoPilotTarget);
                return;
            }
            
            // â˜… ë°©í–¥ ê³„ì‚° ë° íšŒì „
            const direction = new THREE.Vector3().subVectors(targetPos, shipPos).normalize();
            
            // ëª©í‘œ ë°©í–¥ìœ¼ë¡œ ìš°ì£¼ì„  íšŒì „
            const targetQuaternion = new THREE.Quaternion();
            const rotMatrix = new THREE.Matrix4().lookAt(shipPos, targetPos, new THREE.Vector3(0, 1, 0));
            targetQuaternion.setFromRotationMatrix(rotMatrix);
            
            // ë¶€ë“œëŸ¬ìš´ íšŒì „
            playerShip.mesh.quaternion.slerp(targetQuaternion, 0.02);
            
            // â˜… ì†ë„ ì¡°ì ˆ (ê±°ë¦¬ì— ë”°ë¼)
            let speed;
            if (distance > 10000) {
                speed = playerShip.maxSpeed * 0.9;  // ë¨¼ ê±°ë¦¬: ìµœê³  ì†ë„
            } else if (distance > 1000) {
                speed = playerShip.maxSpeed * 0.6;  // ì¤‘ê°„ ê±°ë¦¬
            } else if (distance > 100) {
                speed = playerShip.maxSpeed * 0.3;  // ê°€ê¹Œìš´ ê±°ë¦¬
            } else {
                speed = Math.max(50, playerShip.maxSpeed * 0.1);  // ë„í‚¹ ì ‘ê·¼
            }
            
            // ì´ë™
            const velocity = direction.multiplyScalar(speed * 0.05);
            playerShip.mesh.position.add(velocity);
            
            // ì—°ë£Œ ì†Œë¹„ (ìë™ í•­í•´ëŠ” ì—°ë£Œ íš¨ìœ¨ ì¢‹ìŒ)
            if (playerShip.fuel > 0) {
                playerShip.fuel -= 0.01;
            } else {
                showMsg('âš ï¸ ì—°ë£Œ ë¶€ì¡±! ìë™ í•­í•´ ì¤‘ë‹¨.');
                stopAutoPilot();
            }
        }
        
        function stopAutoPilot() {
            autoPilotActive = false;
            autoPilotTarget = null;
            if (autoPilotInterval) {
                clearInterval(autoPilotInterval);
                autoPilotInterval = null;
            }
            hideAutoPilotUI();
        }
        
        function completeAutoDocking(station) {
            showMsg(`âœ… ${translateBodyName(station.name)}ì— ë„í‚¹ ì™„ë£Œ!`);
            
            // ë„í‚¹ ìƒíƒœ ì„¤ì •
            window.isDockedToStation = true;
            window.dockedStation = station;
            playerShip.isDocked = true;
            
            // ë°©ë¬¸ ê¸°ë¡ ì¶”ê°€
            if (typeof visitedSatellites !== 'undefined') {
                const wasVisited = visitedSatellites.has(station.name);
                visitedSatellites.add(station.name);
                
                if (typeof saveVisitedStations === 'function') {
                    saveVisitedStations();
                }
                
                if (!wasVisited) {
                    setTimeout(() => {
                        showMsg(`ğŸ‰ ${translateBodyName(station.name)} ì²« ë°©ë¬¸! ì´ì œ ë¹ ë¥¸ ì´ë™ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.`);
                    }, 1000);
                }
            }
            
            // ì—°ë£Œ ì¶©ì „ ì‹œì‘ (ì—°ë£Œ ì •ê±°ì¥ì¸ ê²½ìš°)
            if (station.isFuelDepot || station.type === 'station') {
                setTimeout(() => {
                    if (playerShip.fuel < playerShip.maxFuel) {
                        showMsg('â›½ ì—°ë£Œ ì¶©ì „ ì¤‘...');
                        startAutoRefuel();
                    }
                }, 500);
            }
            
            // ë„í‚¹ UI í‘œì‹œ
            showDockedUI(station);
        }
        
        // ìë™ í•­í•´ UI
        function showAutoPilotUI(station) {
            let ui = document.getElementById('autopilot-ui');
            if (!ui) {
                ui = document.createElement('div');
                ui.id = 'autopilot-ui';
                ui.style.cssText = `
                    position: fixed;
                    top: 120px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(0, 50, 100, 0.9);
                    border: 2px solid #00ffff;
                    border-radius: 15px;
                    padding: 15px 25px;
                    z-index: 9999;
                    font-family: 'Orbitron', sans-serif;
                    color: #fff;
                    text-align: center;
                    min-width: 250px;
                `;
                document.body.appendChild(ui);
            }
            
            ui.innerHTML = `
                <div style="font-size: 14px; color: #00ffff; margin-bottom: 8px;">ğŸš€ ìë™ í•­í•´ ì¤‘</div>
                <div style="font-size: 16px; font-weight: bold; margin-bottom: 10px;">${translateBodyName(station.name)}</div>
                <div id="autopilot-distance" style="font-size: 20px; color: #0f0;">--- km</div>
                <div style="margin-top: 10px;">
                    <button onclick="stopAutoPilot(); showMsg('ìë™ í•­í•´ ì·¨ì†Œ');" style="
                        background: #f44;
                        border: none;
                        color: #fff;
                        padding: 8px 20px;
                        border-radius: 20px;
                        cursor: pointer;
                        font-family: 'Orbitron', sans-serif;
                    ">âœ• ì·¨ì†Œ</button>
                </div>
            `;
            ui.style.display = 'block';
        }
        
        function updateAutoPilotUI(distance) {
            const distEl = document.getElementById('autopilot-distance');
            if (distEl) {
                if (distance > 1000) {
                    distEl.textContent = `${(distance / 1000).toFixed(1)} ì²œ km`;
                } else {
                    distEl.textContent = `${distance.toFixed(0)} km`;
                }
            }
        }
        
        function hideAutoPilotUI() {
            const ui = document.getElementById('autopilot-ui');
            if (ui) ui.style.display = 'none';
        }
        
        // ìë™ ì—°ë£Œ ì¶©ì „
        function startAutoRefuel() {
            const refuelInterval = setInterval(() => {
                if (!playerShip || !window.isDockedToStation) {
                    clearInterval(refuelInterval);
                    return;
                }
                
                if (playerShip.fuel < playerShip.maxFuel) {
                    playerShip.fuel = Math.min(playerShip.maxFuel, playerShip.fuel + 5);
                    updateShipUI();
                } else {
                    clearInterval(refuelInterval);
                    showMsg('â›½ ì—°ë£Œ ì¶©ì „ ì™„ë£Œ!');
                }
            }, 200);
        }
        
        // ë„í‚¹ ìƒíƒœ UI
        function showDockedUI(station) {
            let ui = document.getElementById('docked-ui');
            if (!ui) {
                ui = document.createElement('div');
                ui.id = 'docked-ui';
                ui.style.cssText = `
                    position: fixed;
                    bottom: 100px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(0, 80, 40, 0.9);
                    border: 2px solid #0f0;
                    border-radius: 15px;
                    padding: 12px 25px;
                    z-index: 9998;
                    font-family: 'Orbitron', sans-serif;
                    color: #fff;
                    text-align: center;
                `;
                document.body.appendChild(ui);
            }
            
            ui.innerHTML = `
                <div style="font-size: 14px;">âœ… ${translateBodyName(station.name)} ë„í‚¹ë¨</div>
                <button onclick="undockFromStation();" style="
                    margin-top: 8px;
                    background: #f90;
                    border: none;
                    color: #000;
                    padding: 6px 15px;
                    border-radius: 15px;
                    cursor: pointer;
                    font-family: 'Orbitron', sans-serif;
                    font-size: 12px;
                ">ğŸš€ ë„í‚¹ í•´ì œ</button>
            `;
            ui.style.display = 'block';
        }
        
        // ì „ì—­ í•¨ìˆ˜ ë…¸ì¶œ
        window.stopAutoPilot = stopAutoPilot;
        
        // ì—°ë£Œ ì¶©ì „ ê´€ë ¨ (ì˜¤ë˜ëœ ì½”ë“œ - ì°¸ì¡°ìš©ìœ¼ë¡œ ìœ ì§€)
        let refuelInterval = null;
        
        // ì—°ë£Œ ì¶©ì „ ì¤‘ë‹¨
        function stopRefueling() {
            if (refuelInterval) {
                clearInterval(refuelInterval);
                refuelInterval = null;
            }
            const panel = document.getElementById('refuel-panel');
            if (panel) panel.classList.remove('show');
        }
        
        // â˜…â˜…â˜… ê·¼ì²˜ ì—°ë£Œ ì •ê±°ì¥ ê°ì§€ ì‹œìŠ¤í…œ â˜…â˜…â˜…
        let nearbyFuelStation = null;
        let lastRefuelCheck = 0;
        
        function checkNearbyFuelStation() {
            if (!playerShip || !playerShip.mesh || !isPilotMode) {
                hideDockingButton();
                return;
            }
            
            // ì´ë¯¸ ë„í‚¹ ì¤‘ì´ê±°ë‚˜ ë„í‚¹ëœ ìƒíƒœë©´ ì²´í¬ ì•ˆí•¨
            if (window.isDocking || window.isDockedToStation) {
                hideDockingButton();
                return;
            }
            
            // 0.5ì´ˆë§ˆë‹¤ ì²´í¬ (ì„±ëŠ¥ ìµœì í™”)
            const now = Date.now();
            if (now - lastRefuelCheck < 500) return;
            lastRefuelCheck = now;
            
            const shipPos = playerShip.mesh.position;
            let closestStation = null;
            let closestDist = Infinity;
            
            // ëª¨ë“  ìœ„ì„±(ì •ê±°ì¥ í¬í•¨) ê²€ì‚¬
            satellites.forEach(sat => {
                if (sat.isSpaceStation && sat.hasFuel && sat.mesh) {
                    const dist = shipPos.distanceTo(sat.mesh.position);
                    const visualSize = sat.mesh.scale.x || 0.05;
                    const detectRange = Math.max(visualSize * 20, 2.0);
                    
                    if (dist < detectRange && dist < closestDist) {
                        closestDist = dist;
                        closestStation = sat;
                    }
                }
            });
            
            // ì—°ë£Œ ì •ê±°ì¥ (ì¤‘ê°„ ê¶¤ë„) ê²€ì‚¬
            bodies.forEach(body => {
                if (body.isStation && body.hasFuel && body.mesh) {
                    const dist = shipPos.distanceTo(body.mesh.position);
                    const visualSize = body.mesh.scale.x || 0.015;
                    const detectRange = Math.max(visualSize * 30, 1.5);
                    
                    if (dist < detectRange && dist < closestDist) {
                        closestDist = dist;
                        closestStation = body;
                    }
                }
            });
            
            if (closestStation) {
                if (nearbyFuelStation !== closestStation) {
                    // ì•„ë¦¬ì•„ ì•Œë¦¼
                    if (typeof aiTypeMessage === 'function') {
                        aiTypeMessage(`â›½ ${closestStation.name} ì ‘ê·¼ ì¤‘. ë„í‚¹ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.`);
                    }
                }
                nearbyFuelStation = closestStation;
                showDockingButton();  // â˜… í™”ë©´ ì¤‘ì•™ ë„í‚¹ ë²„íŠ¼ í‘œì‹œ
            } else {
                nearbyFuelStation = null;
                hideDockingButton();
            }
        }
        
        function showRefuelButton(stationName) {
            // ê¸°ì¡´ í•¨ìˆ˜ - ë” ì´ìƒ ì‚¬ìš© ì•ˆí•¨
        }
        
        function hideRefuelButton() {
            // ê¸°ì¡´ í•¨ìˆ˜ - ë” ì´ìƒ ì‚¬ìš© ì•ˆí•¨
        }
        
        // â˜…â˜…â˜… ìƒˆë¡œìš´ ë„í‚¹ ì‹œìŠ¤í…œ â˜…â˜…â˜…
        window.isDocking = false;
        window.isDockedToStation = false;  // ì •ê±°ì¥ì— ë„í‚¹ëœ ìƒíƒœ
        window.dockedStationRef = null;    // ë„í‚¹ëœ ì •ê±°ì¥ ì°¸ì¡°
        window.dockingOffset = null;       // ì •ê±°ì¥ ê¸°ì¤€ ìš°ì£¼ì„  ì˜¤í”„ì…‹
        
        // í™”ë©´ ì¤‘ì•™ ë„í‚¹ ë²„íŠ¼ í‘œì‹œ
        function showDockingButton() {
            const btn = document.getElementById('docking-center-btn');
            if (btn && !window.isDocking && !window.isDockedToStation) {
                btn.classList.add('show');
            }
        }
        
        // ë„í‚¹ ë²„íŠ¼ ìˆ¨ê¸°ê¸°
        function hideDockingButton() {
            const btn = document.getElementById('docking-center-btn');
            if (btn) btn.classList.remove('show');
        }
        
        // ë„í‚¹ ë©”ë‰´ í‘œì‹œ
        function showDockingMenu() {
            document.getElementById('docking-menu').classList.add('show');
        }
        
        // ë„í‚¹ ë©”ë‰´ ìˆ¨ê¸°ê¸°
        function hideDockingMenu() {
            document.getElementById('docking-menu').classList.remove('show');
        }
        
        // ë„í‚¹í•´ì œ ë²„íŠ¼ í‘œì‹œ
        function showUndockButton() {
            document.getElementById('undock-btn').classList.add('show');
        }
        
        // ë„í‚¹í•´ì œ ë²„íŠ¼ ìˆ¨ê¸°ê¸°
        function hideUndockButton() {
            document.getElementById('undock-btn').classList.remove('show');
        }
        
        // â˜… ë„í‚¹ ì‹œì‘ (ë²„íŠ¼ í´ë¦­ ì‹œ)
        function startDocking() {
            console.log('â˜…â˜…â˜… startDocking í˜¸ì¶œë¨');
            
            if (!nearbyFuelStation || !playerShip || !playerShip.mesh) {
                showMsg('âš ï¸ No dockable station nearby.');
                return;
            }
            
            if (window.isDocking || window.isDockedToStation) {
                showMsg('âš ï¸ Already docking or docked.');
                return;
            }
            
            const station = nearbyFuelStation;
            window.isDocking = true;
            
            // â˜… 3ì¸ì¹­ ë·°ë¡œ ì „í™˜
            isCockpitView = false;
            
            // ë„í‚¹ ë²„íŠ¼ ìˆ¨ê¸°ê¸°
            hideDockingButton();
            
            // â˜… 3ì¸ì¹­ ì¹´ë©”ë¼ë¡œ ì „í™˜
            if (camera.parent) {
                camera.parent.remove(camera);
            }
            scene.add(camera);
            
            const shipPos = playerShip.mesh.position.clone();
            const stationPos = station.mesh.position.clone();
            
            // ì¹´ë©”ë¼ ì´ˆê¸° ìœ„ì¹˜
            const midPoint = new THREE.Vector3().addVectors(shipPos, stationPos).multiplyScalar(0.5);
            const viewDir = new THREE.Vector3().subVectors(stationPos, shipPos).normalize();
            const sideDir = new THREE.Vector3().crossVectors(viewDir, new THREE.Vector3(0, 1, 0)).normalize();
            const camOffset = sideDir.multiplyScalar(4).add(new THREE.Vector3(0, 2, 0));
            camera.position.copy(midPoint).add(camOffset);
            camera.lookAt(midPoint);
            
            // ì¡°ì¢…ì„ ìˆ¨ê¸°ê¸°
            const cockpit = playerShip.mesh.getObjectByName('cockpitGroup');
            if (cockpit) cockpit.visible = false;
            
            // ë„í‚¹ ì• ë‹ˆë©”ì´ì…˜ ì„¤ì •
            const initialSpeed = playerShip.speed || 0;
            const startPos = shipPos.clone();
            const dockDir = new THREE.Vector3().subVectors(startPos, stationPos).normalize();
            const dockDistance = (station.mesh.scale.x || 0.05) * 3 + 0.15;
            const dockPos = stationPos.clone().add(dockDir.multiplyScalar(dockDistance));
            
            const dockDuration = 5000;
            const dockStartTime = Date.now();
            
            showMsg(`ğŸ”— ${station.name}ì— ë„í‚¹ ì‹œë„ ì¤‘...`);
            if (typeof aiTypeMessage === 'function') {
                aiTypeMessage(`ğŸš€ ${station.name}ì— ì ‘ê·¼ ì¤‘ì…ë‹ˆë‹¤. ë„í‚¹ ì‹œí€€ìŠ¤ ì‹œì‘...`);
            }
            
            const statusEl = document.getElementById('info-status');
            if (statusEl) {
                statusEl.textContent = t('docking');
                statusEl.style.color = '#ffaa00';
            }
            
            function dockAnimation() {
                if (!window.isDocking) return;
                
                const elapsed = Date.now() - dockStartTime;
                const progress = Math.min(elapsed / dockDuration, 1.0);
                const ease = progress < 0.5 
                    ? 2 * progress * progress 
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                
                playerShip.speed = initialSpeed * (1 - ease);
                playerShip.velocity.set(0, 0, 0);
                playerShip.mesh.position.lerpVectors(startPos, dockPos, ease);
                playerShip.mesh.lookAt(stationPos);
                
                // 3ì¸ì¹­ ì¹´ë©”ë¼ ë”°ë¼ê°€ê¸°
                const shipCurrentPos = playerShip.mesh.position.clone();
                const toStation = new THREE.Vector3().subVectors(stationPos, shipCurrentPos).normalize();
                const behindShip = toStation.clone().multiplyScalar(-3);
                const upOffset = new THREE.Vector3(0, 1.5, 0);
                const sideOffset = new THREE.Vector3().crossVectors(toStation, new THREE.Vector3(0, 1, 0)).normalize().multiplyScalar(2);
                
                const targetCamPos = shipCurrentPos.clone().add(behindShip).add(upOffset).add(sideOffset);
                camera.position.lerp(targetCamPos, 0.03);
                
                const lookPoint = new THREE.Vector3().addVectors(shipCurrentPos, stationPos).multiplyScalar(0.5);
                camera.lookAt(lookPoint);
                
                if (progress < 1.0) {
                    requestAnimationFrame(dockAnimation);
                } else {
                    // â˜… ë„í‚¹ ì™„ë£Œ
                    onDockingComplete(station);
                }
            }
            
            dockAnimation();
        }
        
        // â˜… ë„í‚¹ ì™„ë£Œ ì²˜ë¦¬
        function onDockingComplete(station) {
            playerShip.speed = 0;
            window.dockedStation = station;
            window.dockedStationRef = station;
            window.isDockedToStation = true;
            AudioManager.playSFX('sfx_dock');  // â˜… ë„í‚¹ íš¨ê³¼ìŒ
            
            // ì •ê±°ì¥ ê¸°ì¤€ ì˜¤í”„ì…‹ ì €ì¥ (í•¨ê»˜ ì´ë™í•˜ê¸° ìœ„í•´)
            window.dockingOffset = new THREE.Vector3().subVectors(
                playerShip.mesh.position,
                station.mesh.position
            );
            
            showMsg(`âœ… ${station.name} ë„í‚¹ ì™„ë£Œ!`);
            
            const statusEl = document.getElementById('info-status');
            if (statusEl) {
                statusEl.textContent = t('docked');
                statusEl.style.color = '#00ffff';
            }
            
            if (typeof aiTypeMessage === 'function') {
                aiTypeMessage(`âœ… ë„í‚¹ ì™„ë£Œ! ì—°ë£Œ ë³´ì¶© ë˜ëŠ” ì •ê±°ì¥ ë‚´ë¶€ë¥¼ ì„ íƒí•˜ì„¸ìš”.`);
            }
            
            // ë„í‚¹ ë©”ë‰´ í‘œì‹œ (1ì´ˆ í›„)
            setTimeout(() => {
                showDockingMenu();
            }, 1000);
        }
        
        // â˜… ì •ê±°ì¥ê³¼ í•¨ê»˜ ì´ë™ (animateì—ì„œ í˜¸ì¶œ)
        function updateDockedPosition() {
            if (!window.isDockedToStation || !window.dockedStationRef || !playerShip || !playerShip.mesh) return;
            
            const station = window.dockedStationRef;
            if (!station.mesh) return;
            
            // ìš°ì£¼ì„ ì„ ì •ê±°ì¥ê³¼ í•¨ê»˜ ì´ë™
            const newPos = station.mesh.position.clone().add(window.dockingOffset);
            playerShip.mesh.position.copy(newPos);
            
            // ì •ê±°ì¥ ë°”ë¼ë³´ê¸° ìœ ì§€
            playerShip.mesh.lookAt(station.mesh.position);
            
            // 3ì¸ì¹­ ì¹´ë©”ë¼ë„ ë”°ë¼ê°€ê¸° (ë„í‚¹ ì¤‘ì¼ ë•Œ)
            if (window.isDocking && camera.parent === scene) {
                const shipPos = playerShip.mesh.position.clone();
                const stationPos = station.mesh.position.clone();
                const toStation = new THREE.Vector3().subVectors(stationPos, shipPos).normalize();
                const behindShip = toStation.clone().multiplyScalar(-3);
                const upOffset = new THREE.Vector3(0, 1.5, 0);
                const sideOffset = new THREE.Vector3().crossVectors(toStation, new THREE.Vector3(0, 1, 0)).normalize().multiplyScalar(1.5);
                
                const targetCamPos = shipPos.clone().add(behindShip).add(upOffset).add(sideOffset);
                camera.position.lerp(targetCamPos, 0.02);
                
                const lookPoint = new THREE.Vector3().addVectors(shipPos, stationPos).multiplyScalar(0.5);
                camera.lookAt(lookPoint);
            }
        }
        
        // â˜… ì—°ë£Œ ë³´ì¶© ì‹œì‘
        function startRefueling() {
            if (!playerShip) return;
            
            hideDockingMenu();
            
            const maxFuel = SHIP_CONFIG.maxFuel;
            const currentFuel = Math.round(playerShip.fuel);
            const neededFuel = maxFuel - currentFuel;
            
            if (neededFuel <= 0) {
                showMsg('â›½ Fuel tank already full!');
                if (typeof aiTypeMessage === 'function') {
                    aiTypeMessage('ì—°ë£Œ íƒ±í¬ê°€ ì´ë¯¸ ë§Œì¶© ìƒíƒœì…ë‹ˆë‹¤!');
                }
                completeRefueling();
                return;
            }
            
            // ë¹„ìš© ê³„ì‚° (1 ì—°ë£Œë‹¹ 1 ì½”ì¸)
            const cost = neededFuel;
            const currentCoins = getUserCoins();
            
            if (currentCoins <= 0) {
                showMsg(`ğŸ’° ì½”ì¸ì´ ë¶€ì¡±í•©ë‹ˆë‹¤! (í•„ìš”: ${cost} ì½”ì¸)`);
                if (typeof aiTypeMessage === 'function') {
                    aiTypeMessage(`âš ï¸ ì½”ì¸ì´ ë¶€ì¡±í•©ë‹ˆë‹¤. í˜„ì¬ ${currentCoins} ì½”ì¸.`);
                }
                completeRefueling();
                return;
            }
            
            // ì—°ë£Œ ë³´ê¸‰ ì˜¤ë²„ë ˆì´ í‘œì‹œ
            const overlay = document.getElementById('refuel-overlay');
            const barFill = document.getElementById('refuel-bar-fill');
            const amountText = document.getElementById('refuel-amount');
            const costText = document.getElementById('refuel-cost');
            
            overlay.classList.add('show');
            
            const startFuel = currentFuel;
            const affordableFuel = Math.min(neededFuel, currentCoins);  // ì½”ì¸ë§Œí¼ë§Œ
            const targetFuel = currentFuel + affordableFuel;
            const totalToFill = affordableFuel;
            const totalCost = totalToFill;
            
            costText.textContent = `Cost: ${totalCost} coins`;
            
            let filledAmount = 0;
            
            if (typeof aiTypeMessage === 'function') {
                aiTypeMessage(`â›½ ì—°ë£Œ ë³´ê¸‰ì„ ì‹œì‘í•©ë‹ˆë‹¤. ì˜ˆìƒ Cost: ${totalCost} coins`);
            }
            
            // ì—°ë£Œ ì¶©ì „ ì• ë‹ˆë©”ì´ì…˜
            const refuelInterval = setInterval(() => {
                if (!playerShip || filledAmount >= totalToFill) {
                    clearInterval(refuelInterval);
                    overlay.classList.remove('show');
                    
                    if (playerShip) {
                        const finalFuel = Math.round(playerShip.fuel);
                        const spent = finalFuel - startFuel;
                        spendCoins(spent);  // â˜… spendCoins í•¨ìˆ˜ ì‚¬ìš©
                        updateLoginUI();    // UI ì—…ë°ì´íŠ¸
                        
                        showMsg(`â›½ ì—°ë£Œ ë³´ê¸‰ ì™„ë£Œ! ${finalFuel}/${maxFuel} (-${spent} ì½”ì¸)`);
                        
                        if (typeof aiTypeMessage === 'function') {
                            aiTypeMessage(`âœ… ì—°ë£Œ ë³´ê¸‰ ì™„ë£Œ! ì—°ë£Œ ${finalFuel}/${maxFuel}. ì‚¬ìš© ì½”ì¸: ${spent}. ì•ˆì „í•œ ë¹„í–‰ ë˜ì„¸ìš”!`);
                        }
                    }
                    
                    // 1ì¸ì¹­ ë³µê·€ í›„ ë„í‚¹í•´ì œ ë²„íŠ¼ í‘œì‹œ
                    setTimeout(completeRefueling, 1000);
                    return;
                }
                
                // 1íšŒë‹¹ 2ì”© ì¶©ì „ (ëŠë¦° ì—°ì¶œ)
                const fillAmount = Math.min(2, totalToFill - filledAmount);
                playerShip.fuel = Math.min(maxFuel, playerShip.fuel + fillAmount);
                filledAmount += fillAmount;
                
                const currentAmount = Math.round(playerShip.fuel);
                const percent = Math.round((currentAmount / maxFuel) * 100);
                barFill.style.width = percent + '%';
                amountText.textContent = `${currentAmount}/${maxFuel}`;
            }, 80);
        }
        
        // â˜… ì—°ë£Œ ë³´ì¶© ì™„ë£Œ (1ì¸ì¹­ ë³µê·€ + ë„í‚¹í•´ì œ ë²„íŠ¼)
        function completeRefueling() {
            if (!playerShip || !playerShip.mesh) return;
            
            // 1ì¸ì¹­ ì¹´ë©”ë¼ë¡œ ë³µê·€
            scene.remove(camera);
            playerShip.mesh.add(camera);
            
            // â˜… ì¹´ë©”ë¼ ìœ„ì¹˜: ì¡°ì¢…ì„ ì•ìª½ì—ì„œ ì „ë°©ì„ ë³´ë„ë¡
            camera.position.set(0, 0.08, -0.15);  // Zë¥¼ ìŒìˆ˜ë¡œ (ì•ìª½)
            camera.rotation.set(0, 0, 0);
            
            // ì¡°ì¢…ì„ ë‹¤ì‹œ ë³´ì´ê¸°
            const cockpit = playerShip.mesh.getObjectByName('cockpitGroup');
            if (cockpit) cockpit.visible = true;
            
            // ì¡°ì¢…ì„ ì‹œì  ì´ˆê¸°í™”
            cockpitTargetRotY = 0;
            cockpitTargetRotX = 0;
            cockpitLookRotY = 0;
            cockpitLookRotX = 0;
            
            // isDockingì€ falseë¡œ (ì¹´ë©”ë¼ ì—…ë°ì´íŠ¸ í—ˆìš©)
            window.isDocking = false;
            
            // HUD ìƒíƒœ
            const statusEl = document.getElementById('info-status');
            if (statusEl) {
                statusEl.textContent = t('docked');
                statusEl.style.color = '#00ffff';
            }
            
            showMsg('ğŸš€ Returning to cockpit');
            
            // ë„í‚¹í•´ì œ ë²„íŠ¼ í‘œì‹œ
            setTimeout(showUndockButton, 500);
        }
        
        // â˜…â˜…â˜… ì„ ì²´ ìˆ˜ë¦¬ ì‹œì‘ â˜…â˜…â˜…
        function startRepair() {
            if (!playerShip) return;
            
            hideDockingMenu();
            
            const maxHull = SHIP_CONFIG.maxHull;
            const currentHull = Math.round(playerShip.hull);
            const neededRepair = maxHull - currentHull;
            
            if (neededRepair <= 0) {
                showMsg('ğŸ”§ Hull already in perfect condition!');
                if (typeof aiTypeMessage === 'function') {
                    aiTypeMessage('ì„ ì²´ ë‚´êµ¬ë„ê°€ ì´ë¯¸ ë§Œì ì…ë‹ˆë‹¤!');
                }
                completeRepair();
                return;
            }
            
            // ë¹„ìš© ê³„ì‚° (1 ë‚´êµ¬ë„ë‹¹ 2 ì½”ì¸)
            const costPerHull = 2;
            const totalCost = neededRepair * costPerHull;
            const currentCoins = getUserCoins();
            
            if (currentCoins <= 0) {
                showMsg(`ğŸ’° ì½”ì¸ì´ ë¶€ì¡±í•©ë‹ˆë‹¤! (í•„ìš”: ${totalCost} ì½”ì¸)`);
                if (typeof aiTypeMessage === 'function') {
                    aiTypeMessage(`âš ï¸ ì½”ì¸ì´ ë¶€ì¡±í•©ë‹ˆë‹¤. í˜„ì¬ ${currentCoins} ì½”ì¸.`);
                }
                completeRepair();
                return;
            }
            
            // ìˆ˜ë¦¬ ì˜¤ë²„ë ˆì´ í‘œì‹œ
            const overlay = document.getElementById('repair-overlay');
            const barFill = document.getElementById('repair-bar-fill');
            const amountText = document.getElementById('repair-amount');
            const costText = document.getElementById('repair-cost');
            
            overlay.classList.add('show');
            
            const startHull = currentHull;
            const affordableRepair = Math.min(neededRepair, Math.floor(currentCoins / costPerHull));
            const targetHull = currentHull + affordableRepair;
            const totalToRepair = affordableRepair;
            const actualCost = totalToRepair * costPerHull;
            
            costText.textContent = `Cost: ${actualCost} coins`;
            
            let repairedAmount = 0;
            
            if (typeof aiTypeMessage === 'function') {
                aiTypeMessage(`ğŸ”§ ì„ ì²´ ìˆ˜ë¦¬ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤. ì˜ˆìƒ Cost: ${actualCost} coins`);
            }
            
            // ìˆ˜ë¦¬ ì• ë‹ˆë©”ì´ì…˜
            const repairInterval = setInterval(() => {
                if (!playerShip || repairedAmount >= totalToRepair) {
                    clearInterval(repairInterval);
                    overlay.classList.remove('show');
                    
                    if (playerShip) {
                        const finalHull = Math.round(playerShip.hull);
                        const repaired = finalHull - startHull;
                        const spent = repaired * costPerHull;
                        spendCoins(spent);
                        updateLoginUI();
                        
                        showMsg(`ğŸ”§ ì„ ì²´ ìˆ˜ë¦¬ ì™„ë£Œ! ${finalHull}/${maxHull} (-${spent} ì½”ì¸)`);
                        
                        if (typeof aiTypeMessage === 'function') {
                            aiTypeMessage(`âœ… ì„ ì²´ ìˆ˜ë¦¬ ì™„ë£Œ! ë‚´êµ¬ë„ ${finalHull}/${maxHull}. ì‚¬ìš© ì½”ì¸: ${spent}. ì•ˆì „í•œ ë¹„í–‰ ë˜ì„¸ìš”!`);
                        }
                    }
                    
                    setTimeout(completeRepair, 1000);
                    return;
                }
                
                // 1íšŒë‹¹ 1ì”© ìˆ˜ë¦¬
                const repairAmount = Math.min(1, totalToRepair - repairedAmount);
                playerShip.hull = Math.min(maxHull, playerShip.hull + repairAmount);
                repairedAmount += repairAmount;
                
                const currentAmount = Math.round(playerShip.hull);
                const percent = Math.round((currentAmount / maxHull) * 100);
                barFill.style.width = percent + '%';
                amountText.textContent = `${currentAmount}/${maxHull}`;
            }, 100);
        }
        
        // â˜… ìˆ˜ë¦¬ ì™„ë£Œ (1ì¸ì¹­ ë³µê·€ + ë„í‚¹í•´ì œ ë²„íŠ¼)
        function completeRepair() {
            if (!playerShip || !playerShip.mesh) return;
            
            // 1ì¸ì¹­ ì¹´ë©”ë¼ë¡œ ë³µê·€
            scene.remove(camera);
            playerShip.mesh.add(camera);
            camera.position.set(0, 0.08, -0.15);  // â˜… Zë¥¼ ìŒìˆ˜ë¡œ (ì•ìª½)
            camera.rotation.set(0, 0, 0);
            
            // ì¡°ì¢…ì„ ë‹¤ì‹œ ë³´ì´ê¸°
            const cockpit = playerShip.mesh.getObjectByName('cockpitGroup');
            if (cockpit) cockpit.visible = true;
            
            // ì¡°ì¢…ì„ ì‹œì  ì´ˆê¸°í™”
            cockpitTargetRotY = 0;
            cockpitTargetRotX = 0;
            cockpitLookRotY = 0;
            cockpitLookRotX = 0;
            
            window.isDocking = false;
            
            const statusEl = document.getElementById('info-status');
            if (statusEl) {
                statusEl.textContent = t('docked');
                statusEl.style.color = '#00ffff';
            }
            
            showMsg('ğŸš€ Returning to cockpit');
            setTimeout(showUndockButton, 500);
        }
        
        // â˜… ì •ê±°ì¥ ë‚´ë¶€ (ê°œë°œì¤‘)
        function enterStationInterior() {
            showMsg('ğŸ”§ Station interior is under development.');
            if (typeof aiTypeMessage === 'function') {
                aiTypeMessage('ğŸ”§ ì •ê±°ì¥ ë‚´ë¶€ ê¸°ëŠ¥ì€ í˜„ì¬ ê°œë°œ ì¤‘ì…ë‹ˆë‹¤. ì¡°ê¸ˆë§Œ ê¸°ë‹¤ë ¤ ì£¼ì„¸ìš”!');
            }
        }
        
        // â˜… ë„í‚¹í•´ì œ
        function undockFromStation() {
            if (!playerShip || !playerShip.mesh) return;
            
            hideUndockButton();
            
            // â˜… 3ì¸ì¹­ ë·°ë¡œ ì „í™˜
            isCockpitView = false;
            
            // ì •ê±°ì¥ ìœ„ì¹˜ ì €ì¥ (ì—°ì¶œìš©)
            const stationRef = window.dockedStationRef;
            const stationPos = stationRef && stationRef.mesh ? 
                stationRef.mesh.position.clone() : 
                playerShip.mesh.position.clone();
            
            // ë„í‚¹ ìƒíƒœ í•´ì œ
            window.isDockedToStation = false;
            window.dockedStationRef = null;
            window.dockingOffset = null;
            window.dockedStation = null;
            
            // â˜… ì–¸ë„í‚¹ ì—°ì¶œ ì‹œì‘ (ê²Œì„ ì‹œì‘ ë•Œì™€ ë™ì¼)
            undockingState.active = true;
            undockingState.phase = 'undocking';
            undockingState.startTime = Date.now();
            undockingState.startPos = playerShip.mesh.position.clone();
            undockingState.stationPos = stationPos;
            
            // â˜… ì§€êµ¬ ë°˜ëŒ€ ë°©í–¥ ê³„ì‚°
            const earth = bodies.find(b => b.name === 'ì§€êµ¬' || b.name === 'Earth');
            if (earth && earth.mesh) {
                undockingState.undockDirection = new THREE.Vector3()
                    .subVectors(stationPos, earth.mesh.position)
                    .normalize();
            } else {
                undockingState.undockDirection = new THREE.Vector3()
                    .subVectors(playerShip.mesh.position, stationPos)
                    .normalize();
            }
            
            // 3ì¸ì¹­ ì¹´ë©”ë¼ë¡œ ì „í™˜
            if (camera.parent) {
                camera.parent.remove(camera);
            }
            scene.add(camera);
            
            // ì¡°ì¢…ì„ ìˆ¨ê¸°ê¸°
            const cockpit = playerShip.mesh.getObjectByName('cockpitGroup');
            if (cockpit) cockpit.visible = false;
            
            // ìƒíƒœ í‘œì‹œ
            const statusEl = document.getElementById('info-status');
            if (statusEl) {
                statusEl.textContent = t('launching');
                statusEl.style.color = '#ffaa00';
            }
            
            showMsg('ğŸš€ Undocking...');
            if (typeof aiTypeMessage === 'function') {
                aiTypeMessage('ğŸš€ ë„í‚¹ í•´ì œ ì‹œí€€ìŠ¤ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤. ë°œì§„ ì¤€ë¹„!');
            }
        }
        window.undockFromStation = undockFromStation;  // â˜… ì „ì—­ ë…¸ì¶œ
        
        // 1ì¸ì¹­ ì¹´ë©”ë¼ë¡œ ë³µê·€ (ê¸°ì¡´ í•¨ìˆ˜ ìœ ì§€ - ë‹¤ë¥¸ ê³³ì—ì„œ ì‚¬ìš©)
        function returnToFirstPerson() {
            if (!playerShip || !playerShip.mesh) return;
            
            window.isDocking = false;
            
            scene.remove(camera);
            playerShip.mesh.add(camera);
            camera.position.set(0, 0.08, 0.15);
            camera.rotation.set(0, 0, 0);
            
            const cockpit = playerShip.mesh.getObjectByName('cockpitGroup');
            if (cockpit) cockpit.visible = true;
            
            cockpitTargetRotY = 0;
            cockpitTargetRotX = 0;
            cockpitLookRotY = 0;
            cockpitLookRotX = 0;
            
            showMsg('ğŸš€ Returning to pilot mode');
        }
        
        function openShipSelectModal() {
            // â˜… ë©€í‹°ëª¨ë“œ íŠœí† ë¦¬ì–¼ ê°€ì´ë“œ
            if (typeof MultiTutorial !== 'undefined') {
                MultiTutorial.showFeatureGuide('ship-select');
            }
            
            // â˜…â˜…â˜… ê¸°ì¡´ ìš´í•­ì¤‘ì¸ ìš°ì£¼ì„ ì´ ìˆëŠ”ì§€ í™•ì¸ â˜…â˜…â˜…
            const savedShipData = ShipPositionManager.load();
            if (savedShipData && savedShipData.position) {
                const shipName = savedShipData.shipName || 'ìš°ì£¼ì„ ';
                const distFromISS = Math.sqrt(
                    savedShipData.position.x ** 2 + 
                    savedShipData.position.y ** 2 + 
                    savedShipData.position.z ** 2
                );
                
                // ISS ê·¼ì²˜ê°€ ì•„ë‹ˆë©´ (ê±°ë¦¬ 100 ì´ìƒ) ìš´í•­ì¤‘ìœ¼ë¡œ ê°„ì£¼
                if (distFromISS > 100) {
                    // â˜…â˜…â˜… ê²Œì„ ë‚´ ì»¤ìŠ¤í…€ íŒì—… í‘œì‹œ â˜…â˜…â˜…
                    showActiveShipPopup(savedShipData, shipName, distFromISS);
                    return;
                }
            }
            
            // â˜… ships.jsonì´ ì•„ì§ ë¡œë“œ ì•ˆëìœ¼ë©´ ëŒ€ê¸° í›„ ì—´ê¸°
            if (!shipsDataLoaded) {
                console.log('â³ ships.json ë¡œë”© ëŒ€ê¸° ì¤‘...');
                setTimeout(openShipSelectModal, 100);
                return;
            }
            
            // ë””ë²„ê·¸: í˜„ì¬ SHIP_TYPES ì´ë¯¸ì§€ ìƒíƒœ ì¶œë ¥
            console.log('ğŸš€ ìš°ì£¼ì„  ì„ íƒ ëª¨ë‹¬ ì—´ê¸° - í˜„ì¬ ì´ë¯¸ì§€ ìƒíƒœ:');
            SHIP_TYPES.forEach(s => {
                console.log(`  ${s.id}: image=${s.image || 'ì—†ìŒ'}`);
            });
            
            const modal = document.getElementById('ship-select-modal');
            const shipList = document.getElementById('ship-list');
            
            // ìš°ì£¼ì„  ëª©ë¡ ìƒì„±
            shipList.innerHTML = '';
            SHIP_TYPES.forEach((ship, idx) => {
                const isOwned = ownsShip(ship.id);
                const card = document.createElement('div');
                card.className = `ship-card ${idx === selectedShipIndex ? 'selected' : ''} ${!ship.unlocked ? 'locked' : ''} ${isOwned ? 'owned' : ''}`;
                
                // â˜… ì´ë¯¸ì§€ê°€ ìˆìœ¼ë©´ í¬ê²Œ í‘œì‹œ, ì—†ìœ¼ë©´ ì´ëª¨ì§€ (ì ê¸´ ìš°ì£¼ì„ ë„ ë¡œì¼“ ì•„ì´ì½˜)
                const hasImage = ship.image && ship.image.length > 0;
                const iconContent = hasImage 
                    ? `<img src="${ship.image}" alt="${ship.name}">`
                    : 'ğŸš€';  // ì ê¸´ ìš°ì£¼ì„ ë„ ë¡œì¼“ ì•„ì´ì½˜ í‘œì‹œ
                
                // â˜… í•­ìƒ ìƒ‰ìƒ ë°°ê²½ í‘œì‹œ
                const bgStyle = hasImage ? '' : `background: #${ship.color.toString(16).padStart(6, '0')}40;`;
                
                card.innerHTML = `
                    ${isOwned ? '<div class="ship-card-owned">âœ“</div>' : ''}
                    <div class="ship-card-icon" style="${bgStyle}">
                        ${iconContent}
                    </div>
                    <div class="ship-card-name">${getShipName(ship)}</div>
                    <div class="ship-card-tier">${'â­'.repeat(ship.tier)}</div>
                    ${!ship.unlocked ? '<div class="ship-card-dev">ğŸ”§</div>' : ''}
                `;
                if (ship.unlocked) {
                    card.onclick = () => selectShipType(idx);
                } else {
                    card.onclick = () => showMsg(`ğŸ”§ ${getShipName(ship)} - ${t('upgradeAtStation')}`);
                }
                shipList.appendChild(card);
            });
            
            // í˜„ì¬ ì„ íƒëœ ìš°ì£¼ì„  ìƒì„¸ ì •ë³´ í‘œì‹œ
            updateShipDetail(selectedShipIndex);
            
            modal.classList.add('open');
        }
        
        function selectShipType(idx) {
            selectedShipIndex = idx;
            currentShipType = SHIP_TYPES[idx];
            window.currentShipType = currentShipType;  // â˜… ì „ì—­ ì—…ë°ì´íŠ¸
            
            // ì¹´ë“œ ì„ íƒ ìƒíƒœ ì—…ë°ì´íŠ¸
            document.querySelectorAll('.ship-card').forEach((card, i) => {
                card.classList.toggle('selected', i === idx);
            });
            
            updateShipDetail(idx);
        }
        
        function updateShipDetail(idx) {
            const ship = SHIP_TYPES[idx];
            const isOwned = ownsShip(ship.id);
            
            document.getElementById('ship-detail-name').textContent = `${getShipName(ship)} (${ship.nameEn})`;
            // ë‹¤êµ­ì–´ ì„¤ëª…
            const lang = window.currentLang || 'en';
            const descKey = 'desc' + lang.charAt(0).toUpperCase() + lang.slice(1);
            document.getElementById('ship-detail-desc').textContent = ship[descKey] || ship.descEn || ship.description;
            
            // ê°€ê²© í‘œì‹œ
            const priceEl = document.getElementById('ship-price-value');
            const ownedBadge = document.getElementById('ship-owned-badge');
            
            if (ship.id === 'shuttle' && isOwned) {
                // ì…”í‹€ì€ íšŒì›ê°€ì… ì‹œ ê¸°ë³¸ ì§€ê¸‰
                priceEl.textContent = '0';
                ownedBadge.textContent = 'ğŸ ' + t('freeShip');
                ownedBadge.style.display = 'inline';
                ownedBadge.style.background = '#9b59b6';
            } else {
                priceEl.textContent = ship.price.toLocaleString();
                ownedBadge.textContent = t('owned');
                ownedBadge.style.display = isOwned ? 'inline' : 'none';
                ownedBadge.style.background = '#27ae60';
            }
            
            // ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸
            const buyBtn = document.getElementById('btn-buy-ship');
            const launchBtn = document.getElementById('btn-select-ship');
            
            if (isOwned) {
                buyBtn.style.display = 'none';
                launchBtn.style.display = 'block';
                launchBtn.disabled = false;
            } else {
                buyBtn.style.display = 'block';
                buyBtn.textContent = `ğŸª™ ${t('buy')} (${ship.price.toLocaleString()})`;
                buyBtn.disabled = getUserCoins() < ship.price;
                launchBtn.style.display = 'none';
            }
            
            // ìŠ¤íƒ¯ ë°” ì—…ë°ì´íŠ¸ (ìµœëŒ€ê°’ ëŒ€ë¹„ ë¹„ìœ¨)
            const maxSpeed = 225, maxAccel = 6.0, maxTurn = 0.25, maxFuel = 2500;
            
            document.querySelector('.stat-fill.speed').style.width = (ship.maxSpeed / maxSpeed * 100) + '%';
            document.querySelector('.stat-fill.accel').style.width = (ship.acceleration / maxAccel * 100) + '%';
            document.querySelector('.stat-fill.turn').style.width = (ship.turnSpeed / maxTurn * 100) + '%';
            document.querySelector('.stat-fill.fuel').style.width = (ship.maxFuel / maxFuel * 100) + '%';
            
            document.getElementById('stat-speed').textContent = ship.maxSpeed + ' km/s';
            document.getElementById('stat-accel').textContent = ship.acceleration.toFixed(2);
            document.getElementById('stat-turn').textContent = ship.turnSpeed.toFixed(3);
            document.getElementById('stat-fuel').textContent = ship.maxFuel;
            
            // íŠ¹ìˆ˜ ëŠ¥ë ¥
            const specialEl = document.getElementById('ship-special');
            if (ship.special && ship.specialDesc) {
                specialEl.innerHTML = `âœ¨ <strong>${t('specialAbility') || 'íŠ¹ìˆ˜ëŠ¥ë ¥'}:</strong> ${ship.specialDesc}`;
            } else {
                specialEl.innerHTML = '';
            }
            
            // í”„ë¦¬ë·° ì—…ë°ì´íŠ¸ (ì´ë¯¸ì§€ê°€ ìˆìœ¼ë©´ ì´ë¯¸ì§€, ì—†ìœ¼ë©´ ì´ëª¨ì§€)
            const preview = document.getElementById('ship-preview');
            if (ship.image && ship.image.length > 0) {
                preview.innerHTML = `<img src="${ship.image}" alt="${ship.name}" style="max-width:100%;max-height:100%;object-fit:contain;filter: drop-shadow(0 0 20px #${ship.color.toString(16).padStart(6, '0')});">`;
            } else {
                preview.innerHTML = `<div style="font-size: 60px; filter: drop-shadow(0 0 20px #${ship.color.toString(16).padStart(6, '0')});">ğŸš€</div>`;
            }
        }
        
        function closeShipSelectModal() {
            document.getElementById('ship-select-modal').classList.remove('open');
        }
        
        // â˜… ë¬´ì¥ ì‹œìŠ¤í…œ í•¨ìˆ˜ë“¤
        let currentArmoryTab = 'weapons';
        let selectedArmoryItem = null;
        let selectedArmorySlot = 0;
        
        function openArmoryModal() {
            const isLoggedIn = window.mpUser || window.mpUserId;
            if (!isLoggedIn) {
                showMsg('ğŸ” Login required.');
                const authOverlay = document.getElementById('auth-overlay');
                if (authOverlay) authOverlay.style.display = 'flex';
                return;
            }
            if (!ownsShip(currentShipType.id)) {
                showMsg('âš ï¸ You must own this ship to equip weapons.');
                return;
            }
            document.getElementById('armory-modal').classList.add('open');
            currentArmoryTab = 'weapons';
            selectedArmoryItem = null;
            selectedArmorySlot = 0;
            renderArmoryList();
            renderEquippedSlots();
            updateArmoryDetail();
            updateCapacityBar();  // â˜… ì ì¬ëŸ‰ ë°” ì´ˆê¸°í™”
        }
        
        function closeArmoryModal() {
            document.getElementById('armory-modal').classList.remove('open');
        }
        
        function switchArmoryTab(tab) {
            currentArmoryTab = tab;
            selectedArmoryItem = null;
            document.querySelectorAll('.armory-tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.armory-tab[data-tab="${tab}"]`).classList.add('active');
            renderArmoryList();
            updateArmoryDetail();
        }
        
        function renderArmoryList() {
            const list = document.getElementById('armory-list');
            const shipId = currentShipType.id;
            const combatStats = SHIP_COMBAT_STATS[shipId];
            const equipped = getEquipped(shipId);
            
            if (currentArmoryTab === 'weapons') {
                list.innerHTML = WEAPONS.map(weapon => {
                    const owned = ownsWeapon(weapon.id);
                    const canEquip = weapon.tier <= combatStats.maxWeaponTier;
                    const isEquipped = equipped.weapons.includes(weapon.id);
                    const icon = WEAPON_ICONS[weapon.id] || 'ğŸ”«';
                    
                    return `<div class="armory-item ${!canEquip ? 'locked' : ''} ${isEquipped ? 'equipped' : ''} ${selectedArmoryItem === weapon.id ? 'selected' : ''}" 
                        data-id="${weapon.id}" onclick="selectArmoryItem('${weapon.id}')">
                        <div class="armory-item-icon">${icon}</div>
                        <div class="armory-item-info">
                            <div class="armory-item-name">${weapon.name}</div>
                            <div class="armory-item-tier">Tier ${weapon.tier} ${!canEquip ? '(' + t('locked') + ')' : ''}</div>
                            <div class="armory-item-stats">DMG:${weapon.damage} | ${t('range')}:${weapon.range}m</div>
                        </div>
                        ${owned ? '<span class="armory-item-owned">' + t('ownedMark') + '</span>' : `<span class="armory-item-price">ğŸª™ ${weapon.price.toLocaleString()}</span>`}
                    </div>`;
                }).join('');
            } else {
                list.innerHTML = ARMORS.map(armor => {
                    const owned = ownsArmor(armor.id);
                    const canEquip = armor.tier <= combatStats.maxArmorTier;
                    const isEquipped = equipped.armor === armor.id;
                    const icon = ARMOR_ICONS[armor.id] || 'ğŸ›¡ï¸';
                    
                    return `<div class="armory-item ${!canEquip ? 'locked' : ''} ${isEquipped ? 'equipped' : ''} ${selectedArmoryItem === armor.id ? 'selected' : ''}" 
                        data-id="${armor.id}" onclick="selectArmoryItem('${armor.id}')">
                        <div class="armory-item-icon">${icon}</div>
                        <div class="armory-item-info">
                            <div class="armory-item-name">${armor.name}</div>
                            <div class="armory-item-tier">Tier ${armor.tier} ${!canEquip ? '(' + t('locked') + ')' : ''}</div>
                            <div class="armory-item-stats">${t('defense')}:${armor.defense} | HP:+${armor.hpBonus}</div>
                        </div>
                        ${owned ? '<span class="armory-item-owned">' + t('ownedMark') + '</span>' : `<span class="armory-item-price">ğŸª™ ${armor.price.toLocaleString()}</span>`}
                    </div>`;
                }).join('');
            }
        }
        
        function renderEquippedSlots() {
            const container = document.getElementById('armory-equipped-slots');
            const shipId = currentShipType.id;
            const combatStats = SHIP_COMBAT_STATS[shipId];
            const equipped = getEquipped(shipId);
            
            let html = '<div style="font-size:11px;color:#888;margin-bottom:5px;">ğŸ”« ë¬´ê¸° ìŠ¬ë¡¯ (Tier 1~' + combatStats.maxWeaponTier + ')</div>';
            for (let i = 0; i < combatStats.weaponSlots; i++) {
                const weaponId = equipped.weapons[i];
                const weapon = weaponId ? WEAPONS.find(w => w.id === weaponId) : null;
                html += `<div class="armory-equipped-slot" onclick="selectArmorySlot(${i})">
                    <span>${i + 1}.</span>
                    <span class="${weapon ? '' : 'armory-slot-empty'}">${weapon ? (WEAPON_ICONS[weaponId] || 'ğŸ”«') + ' ' + weapon.name : 'ë¹ˆ ìŠ¬ë¡¯'}</span>
                </div>`;
            }
            
            html += '<div style="font-size:11px;color:#888;margin:10px 0 5px;">ğŸ›¡ï¸ ì¥ê°‘ (Tier 1~' + combatStats.maxArmorTier + ')</div>';
            const armor = equipped.armor ? ARMORS.find(a => a.id === equipped.armor) : null;
            html += `<div class="armory-equipped-slot">
                <span class="${armor ? '' : 'armory-slot-empty'}">${armor ? (ARMOR_ICONS[equipped.armor] || 'ğŸ›¡ï¸') + ' ' + armor.name : 'ì¥ì°© ì•ˆë¨'}</span>
            </div>`;
            
            container.innerHTML = html;
        }
        
        function selectArmoryItem(itemId) {
            selectedArmoryItem = itemId;
            renderArmoryList();
            updateArmoryDetail();
        }
        window.selectArmoryItem = selectArmoryItem;
        
        function selectArmorySlot(slotIndex) {
            selectedArmorySlot = slotIndex;
            showMsg(`ìŠ¬ë¡¯ ${slotIndex + 1} ì„ íƒë¨`);
        }
        window.selectArmorySlot = selectArmorySlot;
        
        function updateArmoryDetail() {
            const shipId = currentShipType.id;
            const combatStats = SHIP_COMBAT_STATS[shipId];
            const equipped = getEquipped(shipId);
            
            const iconEl = document.getElementById('armory-detail-icon');
            const nameEl = document.getElementById('armory-detail-name');
            const descEl = document.getElementById('armory-detail-desc');
            const statsEl = document.getElementById('armory-detail-stats');
            const effectEl = document.getElementById('armory-detail-effect');
            const priceEl = document.getElementById('armory-detail-price');
            const buyBtn = document.getElementById('btn-armory-buy');
            const equipBtn = document.getElementById('btn-armory-equip');
            const unequipBtn = document.getElementById('btn-armory-unequip');
            
            buyBtn.style.display = 'none';
            equipBtn.style.display = 'none';
            unequipBtn.style.display = 'none';
            effectEl.style.display = 'none';
            
            if (!selectedArmoryItem) {
                iconEl.textContent = currentArmoryTab === 'weapons' ? 'ğŸ”«' : 'ğŸ›¡ï¸';
                nameEl.textContent = currentArmoryTab === 'weapons' ? t('selectWeapon') : t('selectArmor');
                descEl.textContent = t('selectFromList');
                statsEl.innerHTML = '';
                priceEl.innerHTML = '';
                return;
            }
            
            if (currentArmoryTab === 'weapons') {
                const weapon = WEAPONS.find(w => w.id === selectedArmoryItem);
                const owned = ownsWeapon(weapon.id);
                const canEquip = weapon.tier <= combatStats.maxWeaponTier;
                const isEquipped = equipped.weapons.includes(weapon.id);
                
                iconEl.textContent = WEAPON_ICONS[weapon.id] || 'ğŸ”«';
                nameEl.textContent = weapon.name;
                descEl.textContent = weapon.desc;
                statsEl.innerHTML = `
                    <div class="armory-stat-row"><span>${t('damage')}</span><span>${weapon.damage}</span></div>
                    <div class="armory-stat-row"><span>${t('fireRate')}</span><span>${weapon.fireRate}/s</span></div>
                    <div class="armory-stat-row"><span>${t('range')}</span><span>${weapon.range}m</span></div>
                    <div class="armory-stat-row"><span>${t('energy')}</span><span>${weapon.energy}</span></div>
                    <div class="armory-stat-row"><span>ğŸ“¦ ë¬´ê²Œ</span><span>${weapon.weight || 0}</span></div>
                    <div class="armory-stat-row"><span>${t('tier')}</span><span>Tier ${weapon.tier}</span></div>
                `;
                
                if (!owned) {
                    priceEl.innerHTML = `<span style="color:#f39c12;font-size:14px;">ğŸª™ ${weapon.price.toLocaleString()}</span>`;
                    buyBtn.style.display = 'inline-block';
                    buyBtn.disabled = getCoins() < weapon.price;
                } else {
                    priceEl.innerHTML = '<span style="color:#27ae60;">' + t('ownedMark') + '</span>';
                    if (canEquip) {
                        if (isEquipped) {
                            unequipBtn.style.display = 'inline-block';
                        } else {
                            equipBtn.style.display = 'inline-block';
                        }
                    }
                }
            } else {
                const armor = ARMORS.find(a => a.id === selectedArmoryItem);
                const owned = ownsArmor(armor.id);
                const canEquip = armor.tier <= combatStats.maxArmorTier;
                const isEquipped = equipped.armor === armor.id;
                
                iconEl.textContent = ARMOR_ICONS[armor.id] || 'ğŸ›¡ï¸';
                nameEl.textContent = armor.name;
                descEl.textContent = armor.desc;
                const armorWeight = Math.round(30 * (armor.weight || 1));  // ê¸°ë³¸ 30 * ê³„ìˆ˜
                statsEl.innerHTML = `
                    <div class="armory-stat-row"><span>${t('defense')}</span><span>${armor.defense}</span></div>
                    <div class="armory-stat-row"><span>${t('hpBonus')}</span><span>+${armor.hpBonus}</span></div>
                    <div class="armory-stat-row"><span>ğŸ“¦ ë¬´ê²Œ</span><span>${armorWeight}</span></div>
                    <div class="armory-stat-row"><span>${t('tier')}</span><span>Tier ${armor.tier}</span></div>
                `;
                
                if (armor.effect) {
                    effectEl.textContent = 'âœ¨ ' + armor.effect;
                    effectEl.style.display = 'block';
                }
                
                if (!owned) {
                    priceEl.innerHTML = `<span style="color:#f39c12;font-size:14px;">ğŸª™ ${armor.price.toLocaleString()}</span>`;
                    buyBtn.style.display = 'inline-block';
                    buyBtn.disabled = getCoins() < armor.price;
                } else {
                    priceEl.innerHTML = '<span style="color:#27ae60;">âœ“ ë³´ìœ ì¤‘</span>';
                    if (canEquip) {
                        if (isEquipped) {
                            unequipBtn.style.display = 'inline-block';
                        } else {
                            equipBtn.style.display = 'inline-block';
                        }
                    }
                }
            }
        }
        
        function handleArmoryBuy() {
            if (!selectedArmoryItem) return;
            
            if (currentArmoryTab === 'weapons') {
                if (buyWeapon(selectedArmoryItem)) {
                    showMsg('âœ… Weapon purchased!');
                } else {
                    showMsg('âŒ Purchase failed (insufficient coins or already owned)');
                }
            } else {
                if (buyArmor(selectedArmoryItem)) {
                    showMsg('âœ… Armor purchased!');
                } else {
                    showMsg('âŒ Purchase failed (insufficient coins or already owned)');
                }
            }
            
            renderArmoryList();
            renderEquippedSlots();
            updateArmoryDetail();
            updateUI();
        }
        
        function handleArmoryEquip() {
            if (!selectedArmoryItem) return;
            const shipId = currentShipType.id;

            if (currentArmoryTab === 'weapons') {
                const result = equipWeapon(shipId, selectedArmoryItem, selectedArmorySlot);
                if (result === true) {
                    showMsg(`âœ… ìŠ¬ë¡¯ ${selectedArmorySlot + 1}ì— ì¥ì°© ì™„ë£Œ!`);
                } else if (result && result.reason === 'capacity') {
                    showMsg('âŒ ì ì¬ëŸ‰ ì´ˆê³¼! ë‹¤ë¥¸ ì¥ë¹„ë¥¼ í•´ì œí•˜ì„¸ìš”.');
                } else {
                    showMsg('âŒ ì¥ì°© ì‹¤íŒ¨');
                }
            } else {
                const result = equipArmor(shipId, selectedArmoryItem);
                if (result === true) {
                    showMsg('âœ… ì¥ê°‘ ì¥ì°© ì™„ë£Œ!');
                } else if (result && result.reason === 'capacity') {
                    showMsg('âŒ ì ì¬ëŸ‰ ì´ˆê³¼! ë‹¤ë¥¸ ì¥ë¹„ë¥¼ í•´ì œí•˜ì„¸ìš”.');
                } else {
                    showMsg('âŒ ì¥ì°© ì‹¤íŒ¨');
                }
            }

            renderArmoryList();
            updateCapacityBar();  // ì ì¬ëŸ‰ ë°” ì—…ë°ì´íŠ¸
            renderEquippedSlots();
            updateArmoryDetail();
        }
        
        function handleArmoryUnequip() {
            if (!selectedArmoryItem) return;
            const shipId = currentShipType.id;
            const equipped = getEquipped(shipId);

            if (currentArmoryTab === 'weapons') {
                const slotIndex = equipped.weapons.indexOf(selectedArmoryItem);
                if (slotIndex >= 0) {
                    unequipWeapon(shipId, slotIndex);
                    showMsg('âœ… ë¬´ê¸° í•´ì œ ì™„ë£Œ!');
                }
            } else {
                unequipArmor(shipId);
                showMsg('âœ… ì¥ê°‘ í•´ì œ ì™„ë£Œ!');
            }

            renderArmoryList();
            renderEquippedSlots();
            updateArmoryDetail();
            updateCapacityBar();  // ì ì¬ëŸ‰ ë°” ì—…ë°ì´íŠ¸
        }

        // â˜…â˜…â˜… ì ì¬ëŸ‰ ë°” ì—…ë°ì´íŠ¸ í•¨ìˆ˜ â˜…â˜…â˜…
        function updateCapacityBar() {
            const shipId = currentShipType.id;
            const ship = SHIP_TYPES.find(s => s.id === shipId);
            const currentWeight = getEquippedWeight(shipId);
            const maxCapacity = ship ? (ship.capacity || 100) : 100;

            const textEl = document.getElementById('armory-capacity-text');
            const fillEl = document.getElementById('armory-capacity-fill');

            if (textEl) {
                textEl.textContent = `${Math.round(currentWeight)} / ${maxCapacity}`;
            }

            if (fillEl) {
                const percent = Math.min((currentWeight / maxCapacity) * 100, 100);
                fillEl.style.width = percent + '%';

                // ìƒ‰ìƒ ë³€ê²½ (ì´ˆê³¼ì— ê°€ê¹Œìš¸ìˆ˜ë¡ ë¹¨ê°„ìƒ‰)
                if (percent >= 90) {
                    fillEl.style.background = 'linear-gradient(90deg, #e74c3c, #c0392b)';
                } else if (percent >= 70) {
                    fillEl.style.background = 'linear-gradient(90deg, #f39c12, #e67e22)';
                } else {
                    fillEl.style.background = 'linear-gradient(90deg, #27ae60, #2ecc71)';
                }
            }
        }
        
        function confirmShipSelection() {
            // ì£¼ì°¨ëœ ìš°ì£¼ì„ ì´ ê°™ì€ íƒ€ì…ì´ë©´ ì¬íƒ‘ìŠ¹
            const isReboard = parkedShip && parkedShip.type === currentShipType.id;
            
            // ì£¼ì°¨ëœ ìš°ì£¼ì„ ì´ ìˆê³ , ë‹¤ë¥¸ íƒ€ì…ì˜ ìš°ì£¼ì„ ì„ ì„ íƒí•œ ê²½ìš° ì²˜ë¶„ í™•ì¸
            if (parkedShip && !isReboard) {
                // ì²˜ë¶„ í™•ì¸ ëª¨ë‹¬ í‘œì‹œ
                showSellShipModal();
                return;
            }
            
            // ê¸°ì¡´ ì£¼ì°¨ ìš°ì£¼ì„  ì •ë¦¬ (ê°™ì€ íƒ€ì… ì¬íƒ‘ìŠ¹ ì‹œ)
            if (isReboard && parkedShipMesh) {
                scene.remove(parkedShipMesh);
                parkedShipMesh = null;
            }
            
            closeShipSelectModal();
            proceedToBoard(isReboard);
        }
        
        // í•¨ì„  ì²˜ë¶„ ëª¨ë‹¬ í‘œì‹œ
        function showSellShipModal() {
            const modal = document.getElementById('sell-ship-modal');
            const parkedType = SHIP_TYPES.find(s => s.id === parkedShip.type);
            const sellPrice = Math.floor(parkedType.price * 0.5);
            
            document.getElementById('sell-current-ship').textContent = getShipName(parkedType);
            document.getElementById('sell-price-value').textContent = `ğŸª™ ${sellPrice.toLocaleString()}`;
            document.getElementById('sell-ship-message').textContent = t('sellMessage');
            
            modal.classList.add('open');
        }
        
        // í•¨ì„  ì²˜ë¶„ í™•ì¸
        function confirmSellShip() {
            const parkedType = SHIP_TYPES.find(s => s.id === parkedShip.type);
            const sellPrice = Math.floor(parkedType.price * 0.5);
            
            // íŒë§¤ ê¸ˆì•¡ ì§€ê¸‰
            addCoins(sellPrice);
            showMsg(`ğŸ’° ${getShipName(parkedType)} ${t('sellPrice')}: +${sellPrice.toLocaleString()} ğŸª™`);
            
            // ì£¼ì°¨ëœ ìš°ì£¼ì„  ì •ë¦¬
            clearParkedShip();
            
            // ëª¨ë‹¬ ë‹«ê¸°
            document.getElementById('sell-ship-modal').classList.remove('open');
            closeShipSelectModal();
            
            // íƒ‘ìŠ¹ ì§„í–‰
            proceedToBoard(false);
        }
        
        // íƒ‘ìŠ¹ ì§„í–‰
        function proceedToBoard(isReboard) {
            // ì‹¤ì œ ê±°ë¦¬ ëª¨ë“œë¡œ ì „í™˜ (ìµœì´ˆ íƒ‘ìŠ¹ ì‹œì—ë§Œ)
            if (!isReboard) {
                savedDistScale = CONFIG.distScale;
                if (CONFIG.distScale < 50.0) {
                    CONFIG.distScale = 50.0;
                    const scaleBtn = document.getElementById('btn-scale-mode');
                    if (scaleBtn) {
                        scaleBtn.textContent = t('distReal');
                        scaleBtn.classList.add('active');
                    }
                    resetSimulation();
                    showMsg(t('msgRealMode'));
                }
            }
            
            // ì ì‹œ í›„ ìš°ì£¼ì„  ìƒì„± (ì‹œë®¬ë ˆì´ì…˜ ì•ˆì •í™” ëŒ€ê¸°)
            setTimeout(() => {
                actualBoardShip(isReboard);
            }, isReboard ? 100 : 500);
        }
        
        // êµ¬ë§¤ ë²„íŠ¼ ì²˜ë¦¬
        function handleBuyShip() {
            const ship = SHIP_TYPES[selectedShipIndex];
            if (buyShip(ship.id)) {
                updateShipDetail(selectedShipIndex);
                openShipSelectModal();  // ëª©ë¡ ìƒˆë¡œê³ ì¹¨
            }
        }
        
        function actualBoardShip(isReboard = false) {
            // â˜…â˜…â˜… íƒ‘ìŠ¹ ì‹œ í˜ì´ë“œì¸ íš¨ê³¼ â˜…â˜…â˜…
            let fadeOverlay = document.getElementById('board-fade-overlay');
            if (!fadeOverlay) {
                fadeOverlay = document.createElement('div');
                fadeOverlay.id = 'board-fade-overlay';
                fadeOverlay.style.cssText = `
                    position: fixed;
                    top: 0; left: 0; right: 0; bottom: 0;
                    background: #000;
                    z-index: 99999;
                    pointer-events: none;
                    opacity: 1;
                    transition: opacity 1.5s ease-out;
                `;
                document.body.appendChild(fadeOverlay);
            } else {
                fadeOverlay.style.opacity = '1';
                fadeOverlay.style.display = 'block';
            }
            // ì•½ê°„ì˜ ë”œë ˆì´ í›„ í˜ì´ë“œì•„ì›ƒ ì‹œì‘
            setTimeout(() => {
                fadeOverlay.style.opacity = '0';
                setTimeout(() => {
                    fadeOverlay.style.display = 'none';
                }, 1500);
            }, 300);

            // ===== ì‹¤ì œ ê±°ë¦¬ ëª¨ë“œ ê°•ì œ =====
            CONFIG.distScale = 50;
            if (window.gameMode === 'multi') {
                CONFIG.timeScale = 0.01;  // ë©€í‹°ëŠ” 0.01ë°°ì† ê³ ì • (10ë°° ë” ëŠë¦¬ê²Œ)
            }
            createAllOrbitLines();  // ê¶¤ë„ ì¬ìƒì„±
            
            // â˜… ì¬íƒ‘ìŠ¹ ì‹œ ê¸°ì¡´ ë¼ë²¨ ì œê±°
            if (isReboard && parkedShipMesh) {
                const existingLabel = parkedShipMesh.getObjectByName('parkedLabel');
                if (existingLabel) {
                    parkedShipMesh.remove(existingLabel);
                    if (existingLabel.element) existingLabel.element.remove();
                }
            }
            
            createPlayerShip(isReboard);
            if (!playerShip) {
                showMsg("Cannot create ship.");
                return;
            }
            
            isPilotMode = true;
            window.isPilotMode = true;  // ì „ì—­ ë³€ìˆ˜ë¡œë„ ì„¤ì •
            if (typeof SpaceAudio !== 'undefined' && SpaceAudio.isPlaying) SpaceAudio.playCockpit();
            document.body.classList.add('pilot-mode');  // CSSìš© í´ë˜ìŠ¤ ì¶”ê°€

            // â˜…â˜…â˜… ë©€í‹°ëª¨ë“œ: ì¡°ì¢…ì‹¤ ì§„ì… ìƒíƒœ ì„œë²„ ì €ì¥ â˜…â˜…â˜…
            if (window.gameMode === 'multi' && window.saveGameStateToServer && window.mpUser) {
                window.saveGameStateToServer({ isPilotMode: true });
                console.log('ğŸš€ ì¡°ì¢…ì‹¤ ì§„ì… ìƒíƒœ ì €ì¥');
            }

            // â˜… ì¡°ì¢…ì„ í”„ë¡œí•„ ë™ê¸°í™”
            updateCockpitProfile();

            isCockpitView = true;  // 1ì¸ì¹­ ì¡°ì¢…ì„ ë·° í™œì„±í™”
            // â˜… ì¡°ì¢…ì‹¤ FOV ì•½ê°„ í™•ëŒ€ (60â†’70) - HUD í´ë¦¬í•‘ ì™„í™”
            if (camera) {
                camera.fov = 70;
                camera.updateProjectionMatrix();
            }
            focusedBody = null;
            controls.enabled = false;
            
            // ì •ê±°ì¥ì—ì„œ ë„í‚¹í•œ ê²½ìš° ì—°ë£Œ ì¶©ì „ ì‹œì‘
            if (window.dockedStation && window.dockedStation.hasFuel) {
                setTimeout(startRefueling, 1000);
            }
            
            // ëª¨ë°”ì¼ì—ì„œ ê°•ì œ ê°€ë¡œ ëª¨ë“œ
            forceLayoutOrientation();
            
            // 1ì¸ì¹­ ì¡°ì¢…ì„ ìƒì„± (playerShip.meshì— ì¶”ê°€)
            createCockpitForShip();
            
            // ì¡°ì¢…ì„ ì‹œì  ì´ˆê¸°í™”
            cockpitTargetRotY = 0;
            cockpitTargetRotX = 0;
            cockpitLookRotY = 0;
            cockpitLookRotX = 0;
            
            // ì¹´ë©”ë¼ near plane ì¡°ì • (ì¡°ì¢…ì„ ë‚´ë¶€ ë Œë”ë§ + ì¤Œì¸ í´ë¦¬í•‘ ë°©ì§€)
            camera.near = 0.001;
            camera.updateProjectionMatrix();
            
            // HUD í™œì„±í™”
            document.getElementById('cockpit-hud').classList.add('active');
            document.getElementById('board-ship-btn').style.display = 'none';
            document.getElementById('top-bar').style.display = 'none';
            document.getElementById('nav-container').style.display = 'none';
            document.getElementById('spawn-dock').style.display = 'none';
            document.getElementById('chat-toggle').style.display = 'none';
            document.getElementById('chat-panel').classList.remove('open');
            document.getElementById('focus-distance-panel').classList.remove('visible');  // í¬ì»¤ìŠ¤ ê±°ë¦¬ íŒ¨ë„ ìˆ¨ê¹€
            
            // ëª©í‘œ ì„ íƒ ë“œë¡­ë‹¤ìš´ ì±„ìš°ê¸°
            populateShipTargets();
            
            // ì¡°ì¢… ì»¨íŠ¸ë¡¤ ì´ˆê¸°í™”
            initPilotControls();
            initCockpitControls();
            
            // íŠ¹ìˆ˜ëŠ¥ë ¥ ë²„íŠ¼ ì„¤ì •
            const abilityBtn = document.getElementById('btn-ability');
            const activeAbilities = ['boost', 'afterburner', 'warp'];  // í™œì„± ì‚¬ìš© ê°€ëŠ¥í•œ íŠ¹ìˆ˜ëŠ¥ë ¥
            
            if (currentShipType.special && activeAbilities.includes(currentShipType.special)) {
                abilityBtn.style.display = 'flex';
                const abilityIcons = { 'boost': 'ğŸš€', 'afterburner': 'ğŸ”¥', 'warp': 'âš¡' };
                const abilityNames = { 'boost': 'Boost', 'afterburner': 'Afterburner', 'warp': 'Warp' };
                document.getElementById('ability-icon').textContent = abilityIcons[currentShipType.special] || 'âœ¨';
                document.getElementById('ability-name').textContent = abilityNames[currentShipType.special] || t('specialAbility');
                document.getElementById('ability-cooldown').textContent = '';
            } else if (currentShipType.special === 'allInOne') {
                abilityBtn.style.display = 'flex';
                document.getElementById('ability-icon').textContent = 'âš¡';
                document.getElementById('ability-name').textContent = t('warpAbility');
                document.getElementById('ability-cooldown').textContent = '';
            } else {
                abilityBtn.style.display = 'none';
            }
            
            // ë“œë˜ê·¸ UI ì‹œìŠ¤í…œ ì´ˆê¸°í™”
            setTimeout(() => {
                if (typeof window.initDraggableUI === 'function') {
                    window.initDraggableUI();
                }
            }, 500);
            
            // â˜… ì–¸ë„í‚¹ ì—°ì¶œ ì¤‘ì´ë©´ 3ì¸ì¹­ ì¹´ë©”ë¼ë¡œ ì „í™˜
            console.log('actualBoardShip - undockingState:', undockingState);
            if (undockingState.active) {
                console.log('â˜… 3ì¸ì¹­ ì¹´ë©”ë¼ë¡œ ì „í™˜ ì‹œì‘');
                // ì¹´ë©”ë¼ë¥¼ ìš°ì£¼ì„ ì—ì„œ ë¶„ë¦¬í•˜ê³  3ì¸ì¹­ìœ¼ë¡œ
                playerShip.mesh.remove(camera);
                
                // ì •ê±°ì¥ê³¼ ìš°ì£¼ì„ ì´ í•¨ê»˜ ë³´ì´ëŠ” ìœ„ì¹˜
                const stationPos = undockingState.stationPos;
                camera.position.set(
                    stationPos.x + 3,
                    stationPos.y + 2,
                    stationPos.z + 5
                );
                camera.lookAt(stationPos);
                
                // ì—­ì¶”ì§„ ë¶ˆê½ƒ ì¼œê¸°
                if (playerShip.flame) playerShip.flame.visible = true;
                const reverseFlame = playerShip.mesh.getObjectByName('reverseFlameGroup');
                if (reverseFlame) reverseFlame.visible = true;
                
                showMsg('ğŸ”“ ë„í‚¹ í•´ì œ ì¤‘...');
            } else {
                showMsg(`ğŸš€ ${currentShipType.name} íƒ‘ìŠ¹ ì™„ë£Œ! ë“œë˜ê·¸ë¡œ ì£¼ë³€ì„ ë‘˜ëŸ¬ë³´ì„¸ìš”.`);
                
                // â˜… ì €ì¥ëœ UI ìœ„ì¹˜ ë¡œë“œ
                if (typeof uiRearrangeSystem !== 'undefined') {
                    setTimeout(() => uiRearrangeSystem.loadPositions(), 500);
                }
                
                // â˜… SSIL ë¯¸ì…˜ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
                loadSSILState();
                generateDailyMission();
                updateDailyMissionIcon();
                
                // â˜… ì´ë™ ê±°ë¦¬ ì¸¡ì • ì´ˆê¸°í™”
                ssilMissionState.lastPosition = playerShip.mesh.position.clone();
                
                // ì²« íƒ‘ìŠ¹ ì‹œ SSIL ì¸íŠ¸ë¡œ, ì•„ë‹ˆë©´ ë¯¸ì…˜ ë²„íŠ¼ë§Œ í‘œì‹œ
                if (ssilMissionState.isFirstBoarding) {
                    setTimeout(() => showSSILIntro(), 3000);
                } else {
                    setTimeout(() => showMissionButton(), 1000);
                }
            }
        }
        
        // â˜…â˜…â˜… ìš°ì£¼ ëª¨ë“œ í† ê¸€ (3ì¸ì¹­ ë·° ì „í™˜) â˜…â˜…â˜…
        var lastShipPosition = null;  // 3ì¸ì¹­ ë·°ì—ì„œ ìš°ì£¼ì„  ì´ì „ ìœ„ì¹˜ ì¶”ì 
        
        function toggleSpaceView() {
            if (!isPilotMode || !playerShip || !playerShip.mesh) return;
            if (isInteriorMode || isObservatoryMode) return;
            
            isCockpitView = !isCockpitView;
            window.isCockpitView = isCockpitView;  // ì „ì—­ ì ‘ê·¼ìš©
            
            const btn = document.getElementById('btn-exit-pilot');
            const mobileBtn = document.getElementById('mobile-space-mode');
            const spaceViewControls = document.getElementById('space-view-controls');
            
            if (isCockpitView) {
                // 1ì¸ì¹­ ì¡°ì¢…ì„ìœ¼ë¡œ ë³µê·€
                if (btn) btn.innerHTML = t('spaceMode');
                if (mobileBtn) mobileBtn.innerHTML = 'ğŸŒŒ ' + t('spaceMode').replace('ğŸŒŒ ', '');
                
                // ë°©í–¥ ì¡°ì‘ë§Œ ì´ˆê¸°í™” (ì†ë„ëŠ” ìœ ì§€)
                shipInputs.pitch = 0;
                shipInputs.yaw = 0;
                
                // ì¹´ë©”ë¼ë¥¼ ì¡°ì¢…ì„ìœ¼ë¡œ
                camera.position.set(0, 0.15, 0.1);
                camera.rotation.set(0, 0, 0);
                playerShip.mesh.add(camera);
                controls.enabled = false;
                lastShipPosition = null;
                
                // ì¡°ì¢… UI í‘œì‹œ
                document.getElementById('pilot-hud').style.display = 'block';
                document.getElementById('pilot-console').style.display = 'flex';
                if (spaceViewControls) spaceViewControls.style.display = 'none';
                
                showMsg('ğŸ® ì¡°ì¢… ëª¨ë“œ');
            } else {
                // 3ì¸ì¹­ ìš°ì£¼ ë·°
                if (btn) btn.innerHTML = t('pilotMode');
                if (mobileBtn) mobileBtn.innerHTML = 'ğŸ® ' + t('pilotMode').replace('ğŸ® ', '');
                
                // ë°©í–¥ ì¡°ì‘ë§Œ ì´ˆê¸°í™” (ì†ë„ëŠ” ìœ ì§€!)
                shipInputs.pitch = 0;
                shipInputs.yaw = 0;
                
                // ì¹´ë©”ë¼ë¥¼ ìš°ì£¼ì„  ë’¤ìª½ìœ¼ë¡œ
                playerShip.mesh.remove(camera);
                const shipPos = playerShip.mesh.position.clone();
                const backward = new THREE.Vector3(0, 0, 1).applyQuaternion(playerShip.mesh.quaternion);
                const up = new THREE.Vector3(0, 1, 0).applyQuaternion(playerShip.mesh.quaternion);
                camera.position.copy(shipPos).add(backward.multiplyScalar(15)).add(up.multiplyScalar(5));
                camera.lookAt(shipPos);
                controls.target.copy(shipPos);
                controls.enabled = true;
                
                // â˜…â˜…â˜… ìš°ì£¼ì„  ì¤Œì¸ ê°€ëŠ¥í•˜ê²Œ minDistance ì„¤ì • (ì„ ì²´ í¬ê¸°ì— ë”°ë¼) â˜…â˜…â˜…
                // ìš°ì£¼ì„  í¬ê¸° ê³„ì‚° (ë°”ìš´ë”© ë°•ìŠ¤ ê¸°ì¤€)
                let shipMinDist = 0.02;  // ê¸°ë³¸ê°’ (ì½”ì•ê¹Œì§€)
                if (playerShip.mesh) {
                    const box = new THREE.Box3().setFromObject(playerShip.mesh);
                    const size = new THREE.Vector3();
                    box.getSize(size);
                    const maxDim = Math.max(size.x, size.y, size.z);
                    shipMinDist = maxDim * 0.05;  // ì„ ì²´ í¬ê¸°ì˜ 5% (ì½”ì•ê¹Œì§€!)
                    if (shipMinDist < 0.01) shipMinDist = 0.01;  // ìµœì†Œê°’
                }
                controls.minDistance = shipMinDist;
                
                lastShipPosition = shipPos.clone();
                
                // â˜… ì¡°ì¢…ì‹¤ UI ìœ ì§€ (ìš°ì£¼ ëª¨ë“œì—ì„œë„ í•˜ë‹¨ ì»¨íŠ¸ë¡¤ í‘œì‹œ)
                document.getElementById('pilot-console').style.display = 'flex';
                document.getElementById('pilot-hud').style.display = 'block';

                showMsg('ğŸŒŒ ìš°ì£¼ ëª¨ë“œ (ì†ë„ ì¡°ì ˆ ê°€ëŠ¥)');
            }
        }
        
        function exitPilotMode() {
            if (!isPilotMode || !playerShip || !playerShip.mesh) return;

            // â˜…â˜…â˜… ë©€í‹°ëª¨ë“œ: ì¡°ì¢…ì‹¤ í‡´ì¥ ìƒíƒœ ì„œë²„ ì €ì¥ â˜…â˜…â˜…
            if (window.gameMode === 'multi' && window.saveGameStateToServer && window.mpUser) {
                window.saveGameStateToServer({ isPilotMode: false });
                console.log('ğŸ  ì¡°ì¢…ì‹¤ í‡´ì¥ ìƒíƒœ ì €ì¥');
            }

            // í™”ë©´ ë°©í–¥ ì ê¸ˆ í•´ì œ
            unlockOrientation();
            
            // â˜… ìš°ì£¼ì„  ìš´í•­ ìƒíƒœ ì €ì¥ (ê³„ì† ì›€ì§ì´ë„ë¡)
            const shipVelocity = new THREE.Vector3(0, 0, -1)
                .applyQuaternion(playerShip.mesh.quaternion)
                .multiplyScalar(playerShip.speed);
            
            // ìš°ì£¼ì„  ì£¼ì°¨ (ìœ„ì¹˜/ë°©í–¥ ì €ì¥)
            parkShip();
            
            // ìš°ì£¼ì„  ìœ„ì¹˜/ë°©í–¥ ì €ì¥ (ê¸°ì¡´ ì‹œìŠ¤í…œ í˜¸í™˜)
            savedShipState = {
                position: playerShip.mesh.position.clone(),
                quaternion: playerShip.mesh.quaternion.clone(),
                speed: playerShip.speed,
                fuel: playerShip.fuel,
                hull: playerShip.hull,  // â˜… ë‚´êµ¬ë„ ì €ì¥
                shipTypeIndex: selectedShipIndex
            };
            
            // ì¡°ì¢…ì„ ì œê±°
            if (cockpitGroup) {
                playerShip.mesh.remove(cockpitGroup);
                cockpitGroup = null;
            }
            
            // ì¹´ë©”ë¼ ë¶„ë¦¬
            playerShip.mesh.remove(camera);
            const shipPos = playerShip.mesh.position.clone();
            camera.position.copy(shipPos).add(new THREE.Vector3(10, 5, 10));
            controls.target.copy(shipPos);
            
            // ì¹´ë©”ë¼ near plane ë³µì› (ì¤Œì¸ í´ë¦¬í•‘ ë°©ì§€)
            camera.near = 0.01;
            camera.updateProjectionMatrix();
            
            // ì£¼ì°¨ëœ ìš°ì£¼ì„ ì„ ì”¬ì— ë‚¨ê²¨ë‘ê¸° (ì œê±°í•˜ì§€ ì•ŠìŒ)
            // ì—”ì§„ ë¶ˆê½ƒ ìœ ì§€ (ì†ë„ê°€ ìˆìœ¼ë©´)
            const flame = playerShip.mesh.getObjectByName('engineFlame');
            if (flame) flame.visible = playerShip.speed > 0.1;
            const reverseFlame = playerShip.mesh.getObjectByName('reverseFlameGroup');
            if (reverseFlame) reverseFlame.visible = false;
            
            // ë¼ë²¨ ì¶”ê°€ (ì£¼ì°¨ëœ ìš°ì£¼ì„  í‘œì‹œ)
            // â˜… ê¸°ì¡´ ë¼ë²¨ ì œê±°
            const existingLabel = playerShip.mesh.getObjectByName('parkedLabel');
            if (existingLabel) {
                playerShip.mesh.remove(existingLabel);
                if (existingLabel.element) existingLabel.element.remove();
            }
            
            const label = document.createElement('div');
            label.className = 'label ship-parked-label';
            label.textContent = `ğŸš€ ${getShipName(currentShipType)}`;
            label.style.color = '#f39c12';
            
            // â˜… ë¼ë²¨ í´ë¦­ ì‹œ í•´ë‹¹ ìœ„ì¹˜ë¡œ ì¹´ë©”ë¼ ì´ë™
            label.addEventListener('click', (e) => {
                e.stopPropagation();
                if (parkedShipMesh) {
                    const shipPos = parkedShipMesh.position.clone();
                    // ë¶€ë“œëŸ¬ìš´ ì¹´ë©”ë¼ ì´ë™
                    const targetCamPos = shipPos.clone().add(new THREE.Vector3(15, 8, 15));
                    
                    // GSAP ë˜ëŠ” ê°„ë‹¨í•œ ì• ë‹ˆë©”ì´ì…˜
                    const startPos = camera.position.clone();
                    const startTarget = controls.target.clone();
                    const duration = 1000;
                    const startTime = Date.now();
                    
                    function animateCamera() {
                        const elapsed = Date.now() - startTime;
                        const t = Math.min(elapsed / duration, 1);
                        const easeT = 1 - Math.pow(1 - t, 3);  // ease-out-cubic
                        
                        camera.position.lerpVectors(startPos, targetCamPos, easeT);
                        controls.target.lerpVectors(startTarget, shipPos, easeT);
                        
                        if (t < 1) {
                            requestAnimationFrame(animateCamera);
                        } else {
                            // í¬ì»¤ìŠ¤ ì„¤ì •
                            focusedBody = {
                                mesh: parkedShipMesh,
                                name: `ğŸš€ ${getShipName(currentShipType)}`,
                                type: 'ship'
                            };
                            if (typeof showMessage === 'function') {
                                showMessage(`ğŸš€ ë‚´ ìš°ì£¼ì„ ìœ¼ë¡œ ì´ë™`);
                            }
                        }
                    }
                    animateCamera();
                }
            });
            label.addEventListener('touchstart', (e) => {
                e.stopPropagation();
                label.click();
            }, { passive: false });
            
            const labelObj = new CSS2DObject(label);
            labelObj.position.set(0, 1.5, 0);
            labelObj.name = 'parkedLabel';
            playerShip.mesh.add(labelObj);
            
            // ì£¼ì°¨ëœ ìš°ì£¼ì„  ë©”ì‹œ ì €ì¥ (í´ë¦­ ê°ì§€ìš©)
            parkedShipMesh = playerShip.mesh;
            parkedShipMesh.userData.isParkedShip = true;
            parkedShipMesh.userData.shipType = currentShipType.id;
            parkedShipMesh.userData.shipTypeIndex = selectedShipIndex;
            
            // â˜… ìš´í•­ ìƒíƒœ ì €ì¥ (ì‹¤ì‹œê°„ ì´ë™ìš©)
            parkedShipMesh.userData.velocity = shipVelocity;
            parkedShipMesh.userData.speed = playerShip.speed;
            parkedShipMesh.userData.fuel = playerShip.fuel;
            parkedShipMesh.userData.isMoving = playerShip.speed > 0.01;
            
            playerShip = null;
            
            // â˜… engineConfig ë¶ˆê½ƒ ì „ì—­ ë³€ìˆ˜ ì´ˆê¸°í™”
            configuredThrustFlames = null;
            configuredReverseFlames = null;
            hasEngineConfig = false;
            
            // ë„í‚¹ëœ ìš°ì£¼ì„  ë‹¤ì‹œ í‘œì‹œ
            if (dockedShipMesh) dockedShipMesh.visible = true;
            
            isPilotMode = false;
            window.isPilotMode = false;  // ì „ì—­ ë³€ìˆ˜ë¡œë„ ì„¤ì •
            if (typeof SpaceAudio !== 'undefined' && SpaceAudio.isPlaying) SpaceAudio.playSpace();
            
            // â˜… ë¯¸ì…˜ ë²„íŠ¼ ìˆ¨ê¸°ê¸°
            const missionBtn = document.getElementById('mission-float-btn');
            if (missionBtn) missionBtn.remove();
            
            // ì—°ë£Œ ì¶©ì „ ì¤‘ë‹¨
            stopRefueling();
            window.dockedStation = null;
            
            document.body.classList.remove('pilot-mode');  // CSSìš© í´ë˜ìŠ¤ ì œê±°
            isCockpitView = false;
            isInteriorMode = false;
            isObservatoryMode = false;
            controls.enabled = true;
            
            // ë©€í‹°ëª¨ë“œì—ì„œëŠ” ì‹¤ì œ ê±°ë¦¬ ëª¨ë“œ ê°•ì œ ìœ ì§€
            if (window.gameMode === 'multi') {
                CONFIG.distScale = 50;
                CONFIG.timeScale = 0.01;  // ë©€í‹°ëŠ” 0.01ë°°ì† ê³ ì •
            }
            
            // HUD ë¹„í™œì„±í™”
            document.getElementById('cockpit-hud').classList.remove('active');
            document.getElementById('interior-hud').classList.remove('active');
            document.getElementById('observatory-hud').classList.remove('active');
            document.getElementById('top-bar').style.display = '';
            document.getElementById('nav-container').style.display = '';
            // ë©€í‹°ëª¨ë“œì—ì„œëŠ” ì²œì²´ ìƒì„± ë²„íŠ¼ ìˆ¨ê¹€ ìœ ì§€
            if (window.gameMode !== 'multi') {
                document.getElementById('spawn-dock').style.display = '';
            }
            document.getElementById('chat-toggle').style.display = '';
            
            // â˜… ìš°ì£¼ì„  ìë™ ì¶”ì  ì‹œì‘
            if (parkedShipMesh) {
                focusBody({
                    name: `ğŸš€ ${getShipName(currentShipType)}`,
                    mesh: parkedShipMesh,
                    isParkedShip: true,
                    shipTypeIndex: selectedShipIndex,
                    radius: 0.5
                });
            }
            
            // íƒ‘ìŠ¹ ë²„íŠ¼ í‘œì‹œ (ë°”ë¡œ ì¬íƒ‘ìŠ¹ ê°€ëŠ¥)
            const boardBtn = document.getElementById('board-ship-btn');
            if (boardBtn) {
                boardBtn.style.display = 'block';
                boardBtn.textContent = `ğŸš€ ${t('reboard')}`;
            }
            
            // ê²½ê³  ë¹„í™œì„±í™”
            stopGravityWarning();
            
            // íŠ¹ìˆ˜ëŠ¥ë ¥ ìƒíƒœ ì´ˆê¸°í™”
            shipAbility.cooldown = 0;
            shipAbility.shieldActive = false;
            shipAbility.afterburnerActive = false;
            
            // AI ë¶€ì¡°ì¢…ì‚¬ ìƒíƒœ ì´ˆê¸°í™”
            aiCopilot.isTyping = false;
            aiCopilot.lastBodyCheck = null;
            aiCopilot.commEvent = null;
            document.getElementById('ai-comm-modal').classList.remove('open');
            resetAIButtons();
            
            showMsg(`ğŸŒŒ Space Simulation Mode - ${getShipName(currentShipType)} parked`);
        }
        
        function populateShipTargets() {
            const select = document.getElementById('ship-target-select');
            select.innerHTML = '<option value="">' + t('navTargetSelect') + '</option>';
            
            bodies.forEach((body, idx) => {
                if (!body || !body.mesh) return;
                const opt = document.createElement('option');
                opt.value = idx;
                opt.textContent = translateBodyName(body.name);
                select.appendChild(opt);
            });
            
            satellites.forEach((sat, idx) => {
                if (!sat || !sat.mesh) return;
                if (sat.type !== 'station') {
                    const opt = document.createElement('option');
                    opt.value = 'sat_' + idx;
                    opt.textContent = translateBodyName(sat.name);
                    select.appendChild(opt);
                }
            });
            
            select.onchange = (e) => {
                const val = e.target.value;
                if (!val) {
                    shipTargetBody = null;
                } else if (val.startsWith('sat_')) {
                    shipTargetBody = satellites[parseInt(val.replace('sat_', ''))];
                } else {
                    shipTargetBody = bodies[parseInt(val)];
                }
                updateShipTargetInfo();
            };
        }
        
        function initCockpitControls() {
            const canvas = renderer.domElement;
            
            // ë§ˆìš°ìŠ¤ë¡œ ê³ ê°œ ëŒë¦¬ê¸° (1ì¸ì¹­ ì¡°ì¢…ì„ ë·°)
            canvas.addEventListener('mousedown', (e) => {
                if (!isPilotMode || isInteriorMode || isObservatoryMode || !isCockpitView) return;
                cockpitDragging = true;
                cockpitPrevMouse = { x: e.clientX, y: e.clientY };
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (!cockpitDragging || !isPilotMode || isInteriorMode || isObservatoryMode || !isCockpitView) return;
                const dx = e.clientX - cockpitPrevMouse.x;
                const dy = e.clientY - cockpitPrevMouse.y;
                cockpitTargetRotY -= dx * COCKPIT_LOOK_SPEED;
                cockpitTargetRotX -= dy * COCKPIT_LOOK_SPEED;
                cockpitTargetRotY = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, cockpitTargetRotY));  // Â±60Â° (ì‰˜ ê°€ì¥ìë¦¬ ì•ˆ ë³´ì´ê²Œ)
                cockpitTargetRotX = Math.max(-Math.PI / 3, Math.min(Math.PI / 3.5, cockpitTargetRotX));
                cockpitPrevMouse = { x: e.clientX, y: e.clientY };
            });

            canvas.addEventListener('mouseup', () => { cockpitDragging = false; });
            canvas.addEventListener('mouseleave', () => { cockpitDragging = false; });
            
            // â˜… í„°ì¹˜ë¡œ ê³ ê°œ ëŒë¦¬ê¸° - initPilotJoystickì—ì„œ ë“€ì–¼ í„°ì¹˜ë¡œ í†µí•© ì²˜ë¦¬
            // (ê¸°ì¡´ ì½”ë“œ ì œê±° - ê°„ì„­ ë°©ì§€)
        }
        
        function initPilotControls() {
            const canvas = renderer.domElement;
            
            // ë§ˆìš°ìŠ¤ ë“œë˜ê·¸
            let drag = false, lx = 0, ly = 0;
            canvas.addEventListener('mousedown', (e) => {
                if (isObservatoryMode || isInteriorMode || !isPilotMode) return;
                drag = true; lx = e.clientX; ly = e.clientY;
            });
            canvas.addEventListener('mousemove', (e) => {
                if (isObservatoryMode || isInteriorMode || !isPilotMode || !drag) return;
                if (!autopilot.engaged) {
                    shipInputs.yaw = -(e.clientX - lx) * 0.004;
                    shipInputs.pitch = -(e.clientY - ly) * 0.004;
                }
                lx = e.clientX; ly = e.clientY;
            });
            canvas.addEventListener('mouseup', () => { drag = false; shipInputs.yaw = 0; shipInputs.pitch = 0; });
            canvas.addEventListener('mouseleave', () => { drag = false; shipInputs.yaw = 0; shipInputs.pitch = 0; });
            
            // ë§ˆìš°ìŠ¤ íœ  (1ì¸ì¹­: ìŠ¤ë¡œí‹€, 3ì¸ì¹­: ì¤Œ)
            canvas.addEventListener('wheel', (e) => {
                if (!isPilotMode || isInteriorMode || isObservatoryMode || autopilot.engaged) return;

                e.preventDefault();

                if (isCockpitView) {
                    // â˜… 1ì¸ì¹­ ì¡°ì¢…ì„: ìŠ¤ë¡œí‹€ ì¡°ì ˆ
                    shipInputs.throttle += e.deltaY > 0 ? -0.05 : 0.05;
                    shipInputs.throttle = Math.max(-0.5, Math.min(1, shipInputs.throttle));
                } else {
                    // â˜…â˜…â˜… 3ì¸ì¹­ ìš°ì£¼ ëª¨ë“œ: ì§ì ‘ ì¤Œ êµ¬í˜„ â˜…â˜…â˜…
                    const zoomSpeed = 0.1;
                    const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
                    const currentDist = camera.position.distanceTo(controls.target);

                    // ì¤Œì¸: deltaY < 0, ì¤Œì•„ì›ƒ: deltaY > 0
                    const zoomFactor = e.deltaY > 0 ? (1 + zoomSpeed) : (1 - zoomSpeed);
                    let newDist = currentDist * zoomFactor;

                    // ìµœì†Œ/ìµœëŒ€ ê±°ë¦¬ ì œí•œ
                    newDist = Math.max(controls.minDistance, Math.min(controls.maxDistance, newDist));

                    // ìƒˆ ì¹´ë©”ë¼ ìœ„ì¹˜ ê³„ì‚°
                    camera.position.copy(controls.target).add(direction.multiplyScalar(newDist));
                }
            }, { passive: false });
            
            // í„°ì¹˜ ì¡°ì´ìŠ¤í‹± (3ì¸ì¹­ ë·° ì „ìš© - ì¡°ì¢…ì„ì—ì„œëŠ” document ë ˆë²¨ í„°ì¹˜ ì‚¬ìš©)
            canvas.addEventListener('touchstart', (e) => {
                if (!isPilotMode || isInteriorMode || isObservatoryMode) return;
                if (isCockpitView) return;  // â˜… ì¡°ì¢…ì„ì—ì„œëŠ” document í„°ì¹˜ í•¸ë“¤ëŸ¬ ì‚¬ìš©
                const t = e.changedTouches[0];
                if (t.clientX > window.innerWidth * 0.7) return;
                
                // â˜… UI ìš”ì†Œ ìœ„ì—ì„œëŠ” ì‘ë™ ì•ˆí•¨
                const targetEl = document.elementFromPoint(t.clientX, t.clientY);
                if (targetEl && (
                    targetEl.closest('#pilot-bottom') ||
                    targetEl.closest('#mobile-tab-bar') ||
                    targetEl.closest('#mobile-tab-panel') ||
                    targetEl.closest('#ai-copilot-panel') ||
                    targetEl.closest('#unified-chat-panel') ||
                    targetEl.closest('#cockpit-radio') ||
                    targetEl.closest('#multiplayer-ui') ||
                    targetEl.closest('#pilot-right') ||
                    targetEl.closest('#pilot-target-select') ||
                    targetEl.closest('.draggable-ui') ||
                    targetEl.tagName === 'BUTTON' ||
                    targetEl.tagName === 'INPUT' ||
                    targetEl.tagName === 'SELECT'
                )) return;
                
                e.preventDefault();
                joystickActive = true;
                joystickCenter = { x: t.clientX, y: t.clientY };
                const js = document.getElementById('virtual-joystick');
                js.style.display = 'block';
                js.style.left = (t.clientX - 50) + 'px';
                js.style.top = (t.clientY - 50) + 'px';
            }, { passive: false });
            
            canvas.addEventListener('touchmove', (e) => {
                if (!isPilotMode || !joystickActive || isInteriorMode || isObservatoryMode) return;
                if (isCockpitView) return;  // â˜… ì¡°ì¢…ì„ì—ì„œëŠ” document í„°ì¹˜ í•¸ë“¤ëŸ¬ ì‚¬ìš©
                e.preventDefault();
                const t = e.changedTouches[0];
                let dx = t.clientX - joystickCenter.x;
                let dy = t.clientY - joystickCenter.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const maxR = 40;
                if (dist > maxR) { dx = dx / dist * maxR; dy = dy / dist * maxR; }
                document.getElementById('joystick-knob').style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                if (!autopilot.engaged) {
                    shipInputs.yaw = -(dx / maxR) * 0.08;
                    shipInputs.pitch = -(dy / maxR) * 0.08;
                }
            }, { passive: false });
            
            canvas.addEventListener('touchend', () => {
                if (isCockpitView) return;  // â˜… ì¡°ì¢…ì„ì—ì„œëŠ” document í„°ì¹˜ í•¸ë“¤ëŸ¬ ì‚¬ìš©
                joystickActive = false;
                document.getElementById('virtual-joystick').style.display = 'none';
                document.getElementById('joystick-knob').style.transform = 'translate(-50%, -50%)';
                shipInputs.yaw = 0;
                shipInputs.pitch = 0;
            });
            
            // í‚¤ë³´ë“œ
            const keyState = { w: false, a: false, s: false, d: false };
            window.addEventListener('keydown', (e) => {
                if (!isPilotMode || isInteriorMode || isObservatoryMode) return;

                // â˜…â˜…â˜… WASD ì„ íšŒ ì¡°ì‘ (1ì¸ì¹­ ì¡°ì¢…ì„ì—ì„œë§Œ, ìë™í•­ë²• ì•„ë‹ ë•Œ) â˜…â˜…â˜…
                if (isCockpitView && !autopilot.engaged) {
                    if (e.key === 'w' || e.key === 'W') { keyState.w = true; e.preventDefault(); }
                    if (e.key === 's' || e.key === 'S') { keyState.s = true; e.preventDefault(); }
                    if (e.key === 'a' || e.key === 'A') { keyState.a = true; e.preventDefault(); }
                    if (e.key === 'd' || e.key === 'D') { keyState.d = true; e.preventDefault(); }

                    // ì„ íšŒ ì…ë ¥ ì ìš© (ì¡°ì´ìŠ¤í‹± ë°©í–¥ê³¼ ì¼ì¹˜)
                    shipInputs.pitch = (keyState.w ? 1 : 0) + (keyState.s ? -1 : 0);  // W=ê¸°ìˆ˜ í•˜ê°•, S=ê¸°ìˆ˜ ìƒìŠ¹
                    shipInputs.yaw = (keyState.a ? 1 : 0) + (keyState.d ? -1 : 0);    // A=ì¢ŒíšŒì „, D=ìš°íšŒì „
                }

                // ì†ë„ ì¡°ì ˆ (í™”ì‚´í‘œ í‚¤ - 3ì¸ì¹­ì—ì„œë„ í—ˆìš©)
                if (!autopilot.engaged) {
                    if (e.key === 'ArrowUp') shipInputs.throttle = Math.min(1, shipInputs.throttle + 0.05);
                    if (e.key === 'ArrowDown') shipInputs.throttle = Math.max(-0.5, shipInputs.throttle - 0.05);
                }
                if (e.key === ' ') shipInputs.emergencyReverse = true;
                // â˜… Qí‚¤: ë¬´ê¸° ë°œì‚¬
                if (e.key === 'q' || e.key === 'Q') weaponSystem.isFiring = true;
            });
            window.addEventListener('keyup', (e) => {
                // â˜…â˜…â˜… WASD í‚¤ í•´ì œ â˜…â˜…â˜…
                if (e.key === 'w' || e.key === 'W') keyState.w = false;
                if (e.key === 's' || e.key === 'S') keyState.s = false;
                if (e.key === 'a' || e.key === 'A') keyState.a = false;
                if (e.key === 'd' || e.key === 'D') keyState.d = false;

                // ì„ íšŒ ì…ë ¥ ì—…ë°ì´íŠ¸ (ì¡°ì´ìŠ¤í‹± ë°©í–¥ê³¼ ì¼ì¹˜)
                shipInputs.pitch = (keyState.w ? 1 : 0) + (keyState.s ? -1 : 0);
                shipInputs.yaw = (keyState.a ? 1 : 0) + (keyState.d ? -1 : 0);

                if (e.key === ' ') shipInputs.emergencyReverse = false;
                if (e.key === 'q' || e.key === 'Q') weaponSystem.isFiring = false;
            });

            // â˜… ë§ˆìš°ìŠ¤ ì¢Œí´ë¦­ì€ ì‹œì•¼ íšŒì „ìš©ìœ¼ë¡œ ìœ ì§€ (ë°œì‚¬ ì œê±°ë¨ - Qí‚¤ ì‚¬ìš©)

            // â˜…â˜…â˜… ëª¨ë°”ì¼ ë“€ì–¼ í„°ì¹˜ ì»¨íŠ¸ë¡¤ ì‹œìŠ¤í…œ (ê°œì„ ë¨) â˜…â˜…â˜…
            // ì™¼ìª½ í„°ì¹˜ (0-50%): ìš°ì£¼ì„  ì„ íšŒ (yaw, pitch) - ê°€ìƒ ì¡°ì´ìŠ¤í‹± ë°©ì‹
            // ì˜¤ë¥¸ìª½ í„°ì¹˜ (50-100%): ì‹œì•¼ ë³€ê²½ (ì¡°ì¤€ìš©)
            const touchArea = document.getElementById('touch-area-left');
            const pilotJS = document.getElementById('pilot-joystick');
            const pilotKnob = document.getElementById('pilot-joystick-knob');
            if (pilotJS) pilotJS.style.display = 'none';
            if (touchArea) touchArea.style.display = 'none';

            // ì™¼ìª½ í„°ì¹˜ (ì„ íšŒ) - ê°€ìƒ ì¡°ì´ìŠ¤í‹±
            let leftTouchId = null;
            let leftTouchCenter = { x: 0, y: 0 };  // í„°ì¹˜ ì‹œì‘ì  = ì¡°ì´ìŠ¤í‹± ì¤‘ì‹¬ (ê³ ì •)
            // ì˜¤ë¥¸ìª½ í„°ì¹˜ (ì‹œì•¼)
            let rightTouchId = null;
            let rightTouchStart = { x: 0, y: 0 };

            // â˜…â˜…â˜… UI ìš”ì†Œ ì²´í¬ í•¨ìˆ˜ (ê°œì„ ë¨) â˜…â˜…â˜…
            function isUIElement(el) {
                if (!el) return false;
                // ë°œì‚¬ ë²„íŠ¼ì€ ë³„ë„ ì²˜ë¦¬
                if (el.id === 'mobile-fire-btn' || el.closest('#mobile-fire-btn')) return true;

                return (
                    el.closest('#ai-copilot-panel') ||
                    el.closest('#unified-chat-panel') ||
                    el.closest('#pilot-bottom') ||
                    el.closest('#mobile-tab-bar') ||
                    el.closest('#mobile-tab-panel') ||
                    el.closest('#mobile-mini-hud') ||
                    el.closest('#cockpit-radio') ||
                    el.closest('#multiplayer-ui') ||
                    el.closest('#ssil-mission-panel') ||
                    el.closest('#daily-mission-modal') ||
                    el.closest('#pilot-left-console') ||
                    el.closest('#pilot-center-console') ||
                    el.closest('#pilot-right-console') ||
                    el.closest('#ui-settings-panel') ||
                    el.closest('#ui-rearrange-overlay') ||
                    el.closest('#global-header-btns') ||
                    el.closest('#mobile-direction-btns') ||
                    el.closest('.mobile-direction-btns') ||
                    el.id === 'ui-settings-btn' ||
                    el.id === 'mobile-accel' ||
                    el.id === 'mobile-decel' ||
                    el.id === 'mobile-emergency-brake' ||
                    (el.tagName === 'BUTTON' && el.id !== '') ||  // ID ìˆëŠ” ë²„íŠ¼ë§Œ
                    el.tagName === 'INPUT' ||
                    el.tagName === 'SELECT' ||
                    el.tagName === 'LABEL'
                );
            }

            // â˜…â˜…â˜… í„°ì¹˜ ì‹œì‘ - í™”ë©´ ì „ì²´ì—ì„œ ì¢Œìš° ë¶„ë¦¬ (document ë ˆë²¨) â˜…â˜…â˜…
            document.addEventListener('touchstart', (e) => {
                if (!isPilotMode || isInteriorMode || isObservatoryMode || !isCockpitView) return;
                if (typeof uiRearrangeSystem !== 'undefined' && uiRearrangeSystem.isActive) return;

                const screenW = window.innerWidth;
                const screenH = window.innerHeight;

                for (let i = 0; i < e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];
                    const tx = touch.clientX;
                    const ty = touch.clientY;

                    // UI ìœ„ì—ì„œëŠ” ë¬´ì‹œ
                    const targetEl = document.elementFromPoint(tx, ty);
                    if (isUIElement(targetEl)) continue;

                    // ìƒë‹¨ 10%, í•˜ë‹¨ 5%ëŠ” ë¬´ì‹œ (ë” ë„“ì€ í„°ì¹˜ ì˜ì—­)
                    if (ty < screenH * 0.10 || ty > screenH * 0.95) continue;

                    // â˜…â˜…â˜… ì™¼ìª½ ì ˆë°˜ (0 ~ 50%): ì„ íšŒ ì¡°ì‘ (ê°€ìƒ ì¡°ì´ìŠ¤í‹±) â˜…â˜…â˜…
                    if (tx < screenW * 0.50 && leftTouchId === null) {
                        leftTouchId = touch.identifier;
                        leftTouchCenter = { x: tx, y: ty };  // í„°ì¹˜ ì‹œì‘ì ì´ ì¡°ì´ìŠ¤í‹± ì¤‘ì‹¬
                        console.log('â˜… ì™¼ìª½ í„°ì¹˜ ì‹œì‘:', tx, ty, 'í™”ë©´ì ˆë°˜:', screenW * 0.5);
                        e.preventDefault();
                    }
                    // â˜…â˜…â˜… ì˜¤ë¥¸ìª½ ì ˆë°˜ (50% ~ 100%): ì‹œì•¼ ì¡°ì‘ â˜…â˜…â˜…
                    else if (tx >= screenW * 0.50 && rightTouchId === null) {
                        rightTouchId = touch.identifier;
                        rightTouchStart = { x: tx, y: ty };
                        console.log('â˜… ì˜¤ë¥¸ìª½ í„°ì¹˜ ì‹œì‘:', tx, ty);
                        e.preventDefault();
                    }
                }
            }, { passive: false });

            // â˜…â˜…â˜… í„°ì¹˜ ì´ë™ - ì¢Œìš° ë…ë¦½ ì²˜ë¦¬ (document ë ˆë²¨) â˜…â˜…â˜…
            document.addEventListener('touchmove', (e) => {
                if (!isPilotMode || isInteriorMode || isObservatoryMode || !isCockpitView) return;

                for (let i = 0; i < e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];

                    // â˜…â˜…â˜… ì™¼ìª½ í„°ì¹˜: ì„ íšŒ (ê°€ìƒ ì¡°ì´ìŠ¤í‹± - ì¤‘ì‹¬ì  ê³ ì •) â˜…â˜…â˜…
                    if (touch.identifier === leftTouchId) {
                        e.preventDefault();
                        // ì‹œì‘ì (ì¤‘ì‹¬)ì—ì„œ í˜„ì¬ ìœ„ì¹˜ê¹Œì§€ì˜ ê±°ë¦¬
                        const dx = touch.clientX - leftTouchCenter.x;
                        const dy = touch.clientY - leftTouchCenter.y;
                        const maxRadius = 100;  // ìµœëŒ€ ë°˜ê²½

                        if (!autopilot.engaged) {
                            // â˜…â˜…â˜… ìˆ˜ì •: ìŒìˆ˜ yaw = ìš°íšŒì „ (ê²Œì„ ê·œì¹™) â˜…â˜…â˜…
                            shipInputs.yaw = Math.max(-1, Math.min(1, -dx / maxRadius));
                            shipInputs.pitch = Math.max(-1, Math.min(1, -dy / maxRadius));
                        }
                        // â˜… ì¤‘ì‹¬ì ì€ ê³ ì • (ì—…ë°ì´íŠ¸ ì•ˆí•¨) - ë²„ë²…ê±°ë¦¼ í•´ê²°
                    }

                    // â˜…â˜…â˜… ì˜¤ë¥¸ìª½ í„°ì¹˜: ì‹œì•¼ (ì¹´ë©”ë¼ íšŒì „) â˜…â˜…â˜…
                    if (touch.identifier === rightTouchId) {
                        e.preventDefault();
                        const dx = touch.clientX - rightTouchStart.x;
                        const dy = touch.clientY - rightTouchStart.y;

                        // ì‹œì•¼ íšŒì „ (ì¡°ì¤€ìš©)
                        cockpitTargetRotY -= dx * COCKPIT_LOOK_SPEED;
                        cockpitTargetRotX -= dy * COCKPIT_LOOK_SPEED;
                        cockpitTargetRotY = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, cockpitTargetRotY));
                        cockpitTargetRotX = Math.max(-Math.PI / 3, Math.min(Math.PI / 3.5, cockpitTargetRotX));

                        rightTouchStart = { x: touch.clientX, y: touch.clientY };
                    }
                }
            }, { passive: false });

            // â˜…â˜…â˜… í„°ì¹˜ ì¢…ë£Œ - ê°ê° ë…ë¦½ í•´ì œ (document ë ˆë²¨) â˜…â˜…â˜…
            document.addEventListener('touchend', (e) => {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];

                    if (touch.identifier === leftTouchId) {
                        leftTouchId = null;
                        shipInputs.yaw = 0;
                        shipInputs.pitch = 0;
                        console.log('â˜… ì™¼ìª½ í„°ì¹˜ ì¢…ë£Œ');
                    }

                    if (touch.identifier === rightTouchId) {
                        rightTouchId = null;
                        // ì‹œì•¼ëŠ” ìœ ì§€ (ì´ˆê¸°í™” ì•ˆí•¨)
                        console.log('â˜… ì˜¤ë¥¸ìª½ í„°ì¹˜ ì¢…ë£Œ');
                    }
                }
            });

            document.addEventListener('touchcancel', (e) => {
                leftTouchId = null;
                rightTouchId = null;
                shipInputs.yaw = 0;
                shipInputs.pitch = 0;
                console.log('â˜… í„°ì¹˜ ì·¨ì†Œ');
            });
            
            // ë²„íŠ¼ ì´ë²¤íŠ¸
            setupPilotButtons();
        }
        
        function setupPilotButtons() {
            const ba = document.getElementById('btn-accel');
            const bd = document.getElementById('btn-decel');
            let ai, di;
            
            const sa = () => { if (autopilot.engaged) return; ai = setInterval(() => { shipInputs.throttle = Math.min(1, shipInputs.throttle + 0.02); }, 50); };
            const xa = () => clearInterval(ai);
            const sd = () => { if (autopilot.engaged) return; di = setInterval(() => { shipInputs.throttle = Math.max(-0.5, shipInputs.throttle - 0.02); }, 50); };
            const xd = () => clearInterval(di);
            
            ba.addEventListener('touchstart', (e) => { e.preventDefault(); sa(); }); ba.addEventListener('touchend', xa);
            ba.addEventListener('mousedown', sa); ba.addEventListener('mouseup', xa); ba.addEventListener('mouseleave', xa);
            bd.addEventListener('touchstart', (e) => { e.preventDefault(); sd(); }); bd.addEventListener('touchend', xd);
            bd.addEventListener('mousedown', sd); bd.addEventListener('mouseup', xd); bd.addEventListener('mouseleave', xd);
            
            document.getElementById('btn-autopilot').onclick = toggleAutopilot;
            document.getElementById('btn-interior').onclick = tryEnterInteriorMode;
            document.getElementById('btn-exit-pilot').onclick = toggleSpaceView;

            // â˜… space-view-controls ì œê±°ë¨ - ì¡°ì¢…ì‹¤ UI ì‚¬ìš©
            
            document.getElementById('btn-telescope').onclick = function() {
                if (typeof enterTelescopeMode === 'function') enterTelescopeMode();
            };
            
            // ê¶¤ë„ ì§„ì… ë²„íŠ¼
            document.getElementById('btn-orbit-entry').onclick = () => {
                if (orbitState.active) {
                    exitOrbit();
                } else {
                    const targetName = document.getElementById('btn-orbit-entry').dataset.targetBody;
                    if (targetName) {
                        enterOrbit(targetName);
                    }
                }
            };
            
            // â˜… ëª¨ë°”ì¼ ê¶¤ë„ ì§„ì… ë²„íŠ¼
            const mobileOrbitBtn = document.getElementById('mobile-orbit');
            if (mobileOrbitBtn) {
                mobileOrbitBtn.onclick = () => {
                    if (orbitState.active) {
                        exitOrbit();
                    } else {
                        const targetName = mobileOrbitBtn.dataset.targetBody;
                        if (targetName) {
                            enterOrbit(targetName);
                        }
                    }
                };
            }
            
            document.getElementById('btn-escape').onclick = emergencyEscape;
            document.getElementById('btn-enter-orbit').onclick = enterOrbit;
            document.getElementById('btn-cancel-orbit').onclick = cancelOrbitPrompt;
            
            // íŠ¹ìˆ˜ëŠ¥ë ¥ ë²„íŠ¼
            document.getElementById('btn-ability').onclick = useSpecialAbility;
            
            // â˜… ìƒˆë¡œìš´ ë„í‚¹ ì‹œìŠ¤í…œ ë²„íŠ¼ë“¤
            document.getElementById('docking-center-btn').onclick = startDocking;
            document.getElementById('btn-refuel-menu').onclick = startRefueling;
            document.getElementById('btn-repair-menu').onclick = startRepair;  // â˜… ìˆ˜ë¦¬ ë²„íŠ¼
            document.getElementById('btn-station-shop').onclick = openStationShop;  // â˜… ìƒì  ë²„íŠ¼
            document.getElementById('btn-station-interior').onclick = enterStationInterior;
            document.getElementById('undock-btn').onclick = undockFromStation;
        }
        
        // â˜…â˜…â˜… ì •ê±°ì¥ ìƒì  ì‹œìŠ¤í…œ â˜…â˜…â˜…
        function openStationShop() {
            const modal = document.getElementById('station-shop-modal');
            if (!modal) return;
            
            // ì½”ì¸ ì—…ë°ì´íŠ¸
            const coinsEl = document.getElementById('shop-user-coins');
            if (coinsEl) coinsEl.textContent = getUserCoins().toLocaleString();
            
            // ë§ì›ê²½ ìƒíƒœ ì—…ë°ì´íŠ¸
            updateShopTelescopeStatus();
            
            modal.style.display = 'flex';
            
            // íƒ­ ë²„íŠ¼ ì´ë²¤íŠ¸
            document.querySelectorAll('.shop-tab-btn').forEach(btn => {
                btn.onclick = function() {
                    const tab = this.dataset.tab;
                    document.querySelectorAll('.shop-tab-btn').forEach(b => {
                        b.style.background = '#333';
                        b.style.color = '#aaa';
                        b.classList.remove('active');
                    });
                    this.style.background = '#f39c12';
                    this.style.color = 'white';
                    this.classList.add('active');
                    
                    document.querySelectorAll('.shop-tab-content').forEach(c => c.style.display = 'none');
                    const content = document.getElementById('shop-tab-' + tab);
                    if (content) content.style.display = 'block';
                };
            });
            
            // ë§ì›ê²½ êµ¬ë§¤ ë²„íŠ¼
            document.querySelectorAll('.shop-buy-btn').forEach(btn => {
                btn.onclick = function() {
                    const type = this.dataset.telescope;
                    const price = parseInt(this.dataset.price);
                    
                    if (confirm(`${telescopeUpgrades[type].name} ${t('confirmPurchase')} (${price.toLocaleString()} ${t('coinsUnit')})`)) {
                        if (buyTelescopeUpgrade(type)) {
                            updateShopTelescopeStatus();
                            document.getElementById('shop-user-coins').textContent = getUserCoins().toLocaleString();
                        }
                    }
                };
            });
            
            // ë§ì›ê²½ ì¥ì°© ë²„íŠ¼
            document.querySelectorAll('.shop-equip-btn').forEach(btn => {
                btn.onclick = function() {
                    const type = this.dataset.telescope;
                    equipTelescope(type);
                    updateShopTelescopeStatus();
                };
            });
            
            // ë‹«ê¸° ë²„íŠ¼
            document.getElementById('btn-close-shop').onclick = closeStationShop;
        }
        
        function closeStationShop() {
            const modal = document.getElementById('station-shop-modal');
            if (modal) modal.style.display = 'none';
        }
        
        function updateShopTelescopeStatus() {
            // í‘œì¤€ ë§ì›ê²½ (30x)
            const stdStatus = document.getElementById('shop-standard-status');
            if (stdStatus) {
                if (telescopeUpgrades.standard.owned) {
                    const isEquipped = telescopeMode.equippedTelescope === 'standard';
                    stdStatus.innerHTML = `
                        <div style="color: #2ecc71; font-weight: bold;">${isEquipped ? 'âœ… ì¥ì°©ì¤‘' : 'âœ… ë³´ìœ ì¤‘'}</div>
                        <button class="shop-equip-btn" data-telescope="standard" style="margin-top: 5px; padding: 5px 15px; background: ${isEquipped ? '#27ae60' : '#f1c40f'}; color: white; border: none; border-radius: 5px; cursor: pointer;">${isEquipped ? 'ì¥ì°©ë¨' : 'ì¥ì°©'}</button>
                    `;
                }
            }
            
            // ê³ ê¸‰ ë§ì›ê²½
            const advStatus = document.getElementById('shop-advanced-status');
            if (advStatus) {
                if (telescopeUpgrades.advanced.owned) {
                    const isEquipped = telescopeMode.equippedTelescope === 'advanced';
                    advStatus.innerHTML = `
                        <div style="color: #2ecc71; font-weight: bold;">${isEquipped ? 'âœ… ì¥ì°©ì¤‘' : 'âœ… ë³´ìœ ì¤‘'}</div>
                        <button class="shop-equip-btn" data-telescope="advanced" style="margin-top: 5px; padding: 5px 15px; background: ${isEquipped ? '#27ae60' : '#3498db'}; color: white; border: none; border-radius: 5px; cursor: pointer;">${isEquipped ? 'ì¥ì°©ë¨' : 'ì¥ì°©'}</button>
                    `;
                }
            }
            
            // ì „ë¬¸ê°€ ë§ì›ê²½
            const proStatus = document.getElementById('shop-professional-status');
            if (proStatus) {
                if (telescopeUpgrades.professional.owned) {
                    const isEquipped = telescopeMode.equippedTelescope === 'professional';
                    proStatus.innerHTML = `
                        <div style="color: #2ecc71; font-weight: bold;">${isEquipped ? 'âœ… ì¥ì°©ì¤‘' : 'âœ… ë³´ìœ ì¤‘'}</div>
                        <button class="shop-equip-btn" data-telescope="professional" style="margin-top: 5px; padding: 5px 15px; background: ${isEquipped ? '#27ae60' : '#9b59b6'}; color: white; border: none; border-radius: 5px; cursor: pointer;">${isEquipped ? 'ì¥ì°©ë¨' : 'ì¥ì°©'}</button>
                    `;
                }
            }
            
            // ì¥ì°© ë²„íŠ¼ ì´ë²¤íŠ¸ ì¬ì—°ê²°
            setTimeout(() => {
                document.querySelectorAll('.shop-equip-btn').forEach(btn => {
                    btn.onclick = function() {
                        const type = this.dataset.telescope;
                        equipTelescope(type);
                        updateShopTelescopeStatus();
                    };
                });
            }, 100);
        }
        
        // íŠ¹ìˆ˜ëŠ¥ë ¥ ì‚¬ìš©
        function useSpecialAbility() {
            if (!playerShip || !currentShipType.special) return;
            if (shipAbility.cooldown > 0) {
                showMsg('Special ability recharging...');
                return;
            }
            
            const special = currentShipType.special;
            
            switch(special) {
                case 'boost':
                case 'allInOne':
                    // ê¸´ê¸‰ ë¶€ìŠ¤íŠ¸ - 3ì´ˆê°„ ì†ë„ 2ë°°
                    activateBoost();
                    break;
                case 'afterburner':
                    // ì• í”„í„°ë²„ë„ˆ í† ê¸€
                    toggleAfterburner();
                    break;
                case 'warp':
                    // ì›Œí”„ ë“œë¼ì´ë¸Œ
                    activateWarp();
                    break;
            }
        }
        
        // ìë™ ê¶¤ë„ ì§„ì…
        function enterOrbit(targetBodyName) {
            // íŒŒë¼ë¯¸í„°ê°€ ì—†ìœ¼ë©´ ê¸°ì¡´ í”„ë¡¬í”„íŠ¸ ì‹œìŠ¤í…œì˜ shipTargetBody ì‚¬ìš©
            let targetBody;
            if (targetBodyName) {
                targetBody = bodies.find(b => b.name === targetBodyName);
            } else if (shipTargetBody) {
                targetBody = shipTargetBody;
                document.getElementById('orbit-prompt').classList.remove('active');
            }
            
            if (!targetBody || !playerShip) {
                showMsg('Orbit target not found.');
                return;
            }
            
            // í˜„ì¬ ìœ„ì¹˜ì—ì„œ ê¶¤ë„ ë°˜ê²½ ê³„ì‚°
            const shipPos = playerShip.mesh.position;
            const bodyPos = targetBody.mesh.position;
            const currentDist = shipPos.distanceTo(bodyPos);
            
            // ì•ˆì • ê¶¤ë„ ë°˜ê²½ ì„¤ì • (í˜„ì¬ ê±°ë¦¬ ë˜ëŠ” ìµœì†Œ ì•ˆì „ ê±°ë¦¬)
            const minOrbitRadius = targetBody.radius * 2.5;
            const targetOrbitRadius = Math.max(currentDist * 0.8, minOrbitRadius);
            
            // ===== í˜¸ë§Œ ì „ì´ ê¶¤ë„ ê³„ì‚° =====
            const mass = targetBody.mass || 1e24;
            const currentOrbitVelocity = Math.sqrt(CONFIG.G * mass / currentDist) * 0.3;
            const targetOrbitVelocity = Math.sqrt(CONFIG.G * mass / targetOrbitRadius) * 0.3;
            
            // ë¸íƒ€V ê³„ì‚° (ì†ë„ ë³€í™”ëŸ‰)
            const deltaV = Math.abs(playerShip.speed - targetOrbitVelocity * 0.3) + 
                          Math.abs(currentOrbitVelocity - targetOrbitVelocity) * 0.5;
            
            // ì—°ë£Œ ì†Œëª¨ ê³„ì‚° (ë¸íƒ€Vë‹¹ 0.5%)
            const fuelRequired = deltaV * 0.5;
            
            // ì—°ë£Œ ì²´í¬
            if (playerShip.fuel < fuelRequired) {
                showMsg(`âŒ ì—°ë£Œ ë¶€ì¡±! ê¶¤ë„ ì§„ì…ì— ${fuelRequired.toFixed(1)}% í•„ìš”`);
                return;
            }
            
            // ì—°ë£Œ ì†Œëª¨
            playerShip.fuel -= fuelRequired;
            showMsg(`â›½ ê¶¤ë„ ì „ì´: ì—°ë£Œ ${fuelRequired.toFixed(1)}% ì†Œëª¨`);
            
            // ê¶¤ë„ ì†ë„ ê³„ì‚° (ì¤‘ë ¥ ê¸°ë°˜)
            const orbitSpeed = targetOrbitVelocity;
            
            // í˜„ì¬ ê°ë„ ê³„ì‚°
            const dx = shipPos.x - bodyPos.x;
            const dz = shipPos.z - bodyPos.z;
            const currentAngle = Math.atan2(dz, dx);
            
            // ê¶¤ë„ ìƒíƒœ ì„¤ì •
            orbitState.active = true;
            orbitState.inOrbit = false;  // ì•„ì§ ì „ì´ ì¤‘
            orbitState.enteringOrbit = true;
            orbitState.orbitBody = targetBody;
            orbitState.orbitRadius = currentDist;  // í˜„ì¬ ë°˜ê²½ì—ì„œ ì‹œì‘
            orbitState.targetOrbitRadius = targetOrbitRadius;  // ëª©í‘œ ë°˜ê²½
            orbitState.orbitAngle = currentAngle;
            orbitState.orbitSpeed = orbitSpeed;
            orbitState.targetOrbitSpeed = orbitSpeed;
            orbitState.currentOrbitSpeed = 0;
            orbitState.orbitTransitionTime = 0;
            orbitState.transitionDuration = 5.0;  // 5ì´ˆ ì „ì´
            
            // ìš°ì£¼ì„  ìƒíƒœ ì´ˆê¸°í™”
            shipInputs.throttle = 0;
            shipInputs.emergencyReverse = false;
            playerShip.speed = 0;
            playerShip.velocity.set(0, 0, 0);
            
            // ì„ ë‚´ ì´ë™ í—ˆìš©
            const interiorBtn = document.getElementById('btn-interior');
            interiorBtn.classList.remove('disabled');
            
            // ë²„íŠ¼ ìƒíƒœ ë³€ê²½
            const orbitEntryBtn = document.getElementById('btn-orbit-entry');
            orbitEntryBtn.textContent = t('orbitExit');
            orbitEntryBtn.classList.add('active');
            
            // ìë™í•­ë²• ìƒíƒœ ì—…ë°ì´íŠ¸ (ê¶¤ë„ ëª¨ë“œëŠ” ìë™í•­ë²• ìœ ì‚¬)
            autopilot.phase = 'orbit_insertion';
            document.getElementById('ap-phase').textContent = t('orbitTransfer') + ' 0%';
            
            updateInteriorButtonState();
            showMsg(`ğŸŒ ${targetBody.name} - ê¶¤ë„ ì „ì´ ì‹œì‘...`);
        }
        
        function exitOrbit() {
            if (!orbitState.active && !orbitState.inOrbit && !orbitState.enteringOrbit) return;
            
            orbitState.active = false;
            orbitState.inOrbit = false;
            orbitState.enteringOrbit = false;
            
            // í˜„ì¬ ê¶¤ë„ ì†ë„ë¥¼ ì¶”ì§„ ì†ë„ë¡œ ë³€í™˜ (ì ‘ì„  ë°©í–¥)
            if (playerShip && playerShip.mesh && orbitState.orbitBody) {
                const tangent = new THREE.Vector3(-Math.sin(orbitState.orbitAngle), 0, Math.cos(orbitState.orbitAngle));
                playerShip.speed = orbitState.orbitRadius * orbitState.orbitSpeed * 10;
                playerShip.mesh.lookAt(playerShip.mesh.position.clone().add(tangent));
                playerShip.euler.setFromQuaternion(playerShip.mesh.quaternion, 'YXZ');
            }
            
            orbitState.orbitBody = null;
            
            // ìë™í•­ë²• í•´ì œ
            if (autopilot.engaged) {
                disableAutopilot();
            }
            
            const orbitEntryBtn = document.getElementById('btn-orbit-entry');
            orbitEntryBtn.style.display = 'none';
            orbitEntryBtn.classList.remove('active');
            
            showMsg(t('msgOrbitExit'));
            updateInteriorButtonState();
        }
        
        function updateOrbitMotion(dt) {
            // ìƒˆë¡œìš´ ì‹œìŠ¤í…œ(active) ë˜ëŠ” ê¸°ì¡´ ì‹œìŠ¤í…œ(inOrbit) ì²´í¬
            if ((!orbitState.active && !orbitState.inOrbit && !orbitState.enteringOrbit) || !orbitState.orbitBody || !playerShip) return;
            
            const body = orbitState.orbitBody;
            const bodyPos = body.mesh.position;
            
            // ê¶¤ë„ ì§„ì… ì „í™˜ (ë¬¼ë¦¬ ê¸°ë°˜ ì ì§„ì  ì „ì´)
            if (orbitState.enteringOrbit) {
                orbitState.orbitTransitionTime += dt;
                const transitionDuration = orbitState.transitionDuration || 5.0;
                const progress = Math.min(orbitState.orbitTransitionTime / transitionDuration, 1);
                
                // ê¶¤ë„ ë°˜ê²½ ì ì§„ì  ì „ì´
                const targetRadius = orbitState.targetOrbitRadius || orbitState.orbitRadius;
                orbitState.orbitRadius += (targetRadius - orbitState.orbitRadius) * dt * 0.5;
                
                // ê¶¤ë„ ì†ë„ ì ì§„ì  ì¦ê°€
                orbitState.currentOrbitSpeed += (orbitState.targetOrbitSpeed - orbitState.currentOrbitSpeed) * dt * 0.8;
                
                // ì§„í–‰ë¥  í‘œì‹œ
                const percent = Math.round(progress * 100);
                document.getElementById('ap-phase').textContent = t('orbitTransfer') + ` ${percent}%`;
                
                if (progress >= 1) {
                    orbitState.enteringOrbit = false;
                    orbitState.inOrbit = true;
                    orbitState.orbitRadius = targetRadius;
                    orbitState.currentOrbitSpeed = orbitState.targetOrbitSpeed;
                    autopilot.phase = 'orbiting';
                    document.getElementById('ap-phase').textContent = t('stableOrbitReached');
                    showMsg(`âœ… ${body.name} - ê¶¤ë„ ì§„ì… ì™„ë£Œ!`);
                }
            }
            
            // ê¶¤ë„ ê°ë„ ì—…ë°ì´íŠ¸
            orbitState.orbitAngle += orbitState.currentOrbitSpeed * dt * CONFIG.timeScale;
            
            // ìƒˆ ìœ„ì¹˜ ê³„ì‚°
            const newX = bodyPos.x + Math.cos(orbitState.orbitAngle) * orbitState.orbitRadius;
            const newZ = bodyPos.z + Math.sin(orbitState.orbitAngle) * orbitState.orbitRadius;
            
            // ìŠ¤ë¬´ìŠ¤í•˜ê²Œ ìœ„ì¹˜ ì´ë™ (ì „ì´ ì¤‘ì—ëŠ” ë” ë¹ ë¥´ê²Œ)
            const lerpFactor = orbitState.enteringOrbit ? dt * 2 : 0.1;
            playerShip.mesh.position.x += (newX - playerShip.mesh.position.x) * lerpFactor;
            playerShip.mesh.position.z += (newZ - playerShip.mesh.position.z) * lerpFactor;
            playerShip.mesh.position.y = bodyPos.y;
            
            // ì ‘ì„  ë°©í–¥ìœ¼ë¡œ íšŒì „ (ê¶¤ë„ ì§„í–‰ ë°©í–¥)
            if (orbitState.enteringOrbit) {
                const tangent = new THREE.Vector3(-Math.sin(orbitState.orbitAngle), 0, Math.cos(orbitState.orbitAngle));
                const targetQuat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, -1), tangent);
                playerShip.mesh.quaternion.slerp(targetQuat, dt * 2);
                playerShip.euler.setFromQuaternion(playerShip.mesh.quaternion, 'YXZ');
            }
            // ì¡°ì„ ê³ ì • (í•­ìƒ í–‰ì„±ì„ ë°”ë¼ë´„) - ì„ ë‚´/ì „ë§ëŒ€ ëª¨ë“œì—ì„œë„ ìš°ì£¼ì„  ìì²´ëŠ” íšŒì „
            else if (orbitState.tidalLocked) {
                // í–‰ì„± ë°©í–¥ ê³„ì‚°
                const dir = new THREE.Vector3().subVectors(bodyPos, playerShip.mesh.position).normalize();
                const targetQuat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, -1), dir);
                // ë¶€ë“œëŸ½ê²Œ íšŒì „
                playerShip.mesh.quaternion.slerp(targetQuat, 0.05);
                playerShip.euler.setFromQuaternion(playerShip.mesh.quaternion, 'YXZ');
            }
            
            // ì†ë„ í‘œì‹œ ì—…ë°ì´íŠ¸
            playerShip.speed = orbitState.currentOrbitSpeed * orbitState.orbitRadius * 10;
        }
        
        function activateBoost() {
            if (playerShip.fuel < 20) {
                showMsg('Insufficient fuel! (20% minimum required)');
                return;
            }
            
            const originalMaxSpeed = SHIP_CONFIG.maxSpeed;
            playerShip.speed = Math.min(playerShip.speed * 2, originalMaxSpeed * 2);
            playerShip.fuel -= 20;
            
            showMsg('ğŸš€ ê¸´ê¸‰ ë¶€ìŠ¤íŠ¸ í™œì„±í™”!');
            
            // 3ì´ˆ í›„ ì†ë„ ì œí•œ ë³µêµ¬
            setTimeout(() => {
                if (playerShip) {
                    playerShip.speed = Math.min(playerShip.speed, originalMaxSpeed);
                    showMsg('Boost ended');
                }
            }, 3000);
            
            // ì¿¨ë‹¤ìš´ ì„¤ì •
            shipAbility.cooldown = currentShipType.specialCooldown || 30;
            updateAbilityCooldown();
        }
        
        function toggleAfterburner() {
            shipAbility.afterburnerActive = !shipAbility.afterburnerActive;
            
            if (shipAbility.afterburnerActive) {
                showMsg('ğŸ”¥ ì• í”„í„°ë²„ë„ˆ ON! (ì—°ë£Œ 3ë°° ì†Œëª¨, ì†ë„ 1.5ë°°)');
                document.getElementById('btn-ability').style.borderColor = '#ff0000';
            } else {
                showMsg('Afterburner OFF');
                document.getElementById('btn-ability').style.borderColor = '#ff6600';
            }
        }
        
        function activateWarp() {
            if (!shipTargetBody || !shipTargetBody.mesh) {
                showMsg('Select warp target first!');
                if (typeof SpaceAudio !== 'undefined') SpaceAudio.playError();
                return;
            }
            
            if (playerShip.fuel < 50) {
                showMsg('Insufficient fuel! (50% minimum required)');
                if (typeof SpaceAudio !== 'undefined') SpaceAudio.playError();
                return;
            }
            
            // ì›Œí”„ íš¨ê³¼ìŒ
            if (typeof SpaceAudio !== 'undefined') SpaceAudio.playWarp();
            
            // ëª©í‘œ ê·¼ì²˜ë¡œ ìˆœê°„ì´ë™
            const targetPos = shipTargetBody.mesh.position.clone();
            const safeDistance = (shipTargetBody.radius || 1) * 3;
            const offset = new THREE.Vector3(safeDistance, safeDistance * 0.5, safeDistance);
            
            playerShip.mesh.position.copy(targetPos).add(offset);
            playerShip.velocity.set(0, 0, 0);
            playerShip.speed = 0;
            playerShip.fuel -= 50;
            
            // ëª©í‘œë¥¼ ë°”ë¼ë³´ë„ë¡ íšŒì „
            const dir = new THREE.Vector3().subVectors(targetPos, playerShip.mesh.position).normalize();
            const targetQuat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, -1), dir);
            playerShip.mesh.quaternion.copy(targetQuat);
            playerShip.euler.setFromQuaternion(targetQuat, 'YXZ');
            
            showMsg(`âš¡ ${shipTargetBody.name}(ìœ¼)ë¡œ ì›Œí”„ ì™„ë£Œ!`);
            
            // ì¿¨ë‹¤ìš´ ì„¤ì •
            shipAbility.cooldown = currentShipType.specialCooldown || 60;
            updateAbilityCooldown();
        }
        
        function updateAbilityCooldown() {
            const cooldownEl = document.getElementById('ability-cooldown');
            const abilityBtn = document.getElementById('btn-ability');
            
            if (shipAbility.cooldown > 0) {
                abilityBtn.classList.add('on-cooldown');
                
                const interval = setInterval(() => {
                    shipAbility.cooldown--;
                    cooldownEl.textContent = `(${shipAbility.cooldown}s)`;
                    
                    if (shipAbility.cooldown <= 0) {
                        clearInterval(interval);
                        cooldownEl.textContent = '';
                        abilityBtn.classList.remove('on-cooldown');
                        showMsg('Special ability ready!');
                    }
                }, 1000);
            }
        }
        
        function toggleAutopilot() {
            if (!shipTargetBody) { showMsg('Select a target first'); return; }
            autopilot.engaged ? disableAutopilot() : enableAutopilot();
        }
        
        function enableAutopilot() {
            if (!shipTargetBody || !playerShip) return;
            
            // â˜… ë©€í‹°ëª¨ë“œ íŠœí† ë¦¬ì–¼ ê°€ì´ë“œ
            if (typeof MultiTutorial !== 'undefined') {
                MultiTutorial.showFeatureGuide('autopilot');
            }
            
            autopilot.engaged = true;
            autopilot.phase = 'accelerating';
            AudioManager.playSFX('sfx_autopilot');  // â˜… ì˜¤í† íŒŒì¼ëŸ¿ íš¨ê³¼ìŒ
            document.getElementById('btn-autopilot').classList.add('engaged');
            document.getElementById('pilot-autopilot-info').classList.remove('inactive');
            document.getElementById('ap-status').textContent = t('on');
            document.getElementById('pilot-eta-box').classList.add('active');
            document.getElementById('eta-target-name').textContent = t('targetPrefix') + translateBodyName(shipTargetBody.name);
            updateInteriorButtonState();
        }
        
        function disableAutopilot() {
            autopilot.engaged = false;
            autopilot.phase = 'idle';
            AudioManager.playSFX('sfx_autopilot');  // â˜… ì˜¤í† íŒŒì¼ëŸ¿ íš¨ê³¼ìŒ
            document.getElementById('btn-autopilot').classList.remove('engaged');
            document.getElementById('pilot-autopilot-info').classList.add('inactive');
            document.getElementById('ap-status').textContent = t('off');
            document.getElementById('ap-phase').textContent = '';
            document.getElementById('warn-decel').classList.remove('active');
            document.getElementById('pilot-eta-box').classList.remove('active');
            updateInteriorButtonState();
            
            if (isInteriorMode || isObservatoryMode) {
                exitInteriorMode();
                showMsg('Autopilot disengaged, returning to cockpit.');
            }
        }
        
        function updateInteriorButtonState() {
            const btn = document.getElementById('btn-interior');
            if (autopilot.engaged) {
                btn.classList.remove('disabled');
                btn.title = 'ìë™í•­ë²• ì¤‘ - ì„ ë‚´ ì´ë™ ê°€ëŠ¥';
            } else {
                btn.classList.add('disabled');
                btn.title = 'ìë™í•­ë²• í™œì„±í™” í›„ ì„ ë‚´ ì´ë™ ê°€ëŠ¥';
            }
        }
        
        function tryEnterInteriorMode() {
            // ì„ ë‚´ ê¸°ëŠ¥ ì—…ë°ì´íŠ¸ ì˜ˆì • ì•Œë¦¼
            showMsg('ğŸš§ ì„ ë‚´ ê¸°ëŠ¥ì€ ì—…ë°ì´íŠ¸ ì˜ˆì •ì…ë‹ˆë‹¤. ì¡°ê¸ˆë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”!');
            return;
            
            /* ì•„ë˜ ì½”ë“œëŠ” ì—…ë°ì´íŠ¸ í›„ í™œì„±í™” ì˜ˆì •
            if (!autopilot.engaged && !orbitState.active) {
                showMsg(t('msgNeedAuto'));
                return;
            }
            enterInteriorMode();
            */
        }
        
        // exitInteriorModeëŠ” ì„ ë‚´ ì‹œìŠ¤í…œ í•¨ìˆ˜ì—ì„œ ì •ì˜ë¨
        
        function emergencyEscape() {
            if (!playerShip || !playerShip.mesh || !isGravityWarning) return;
            
            // ===== ì—°ë£Œ/ì¶©ì „ ì¡°ê±´ ì²´í¬ =====
            const minFuelRequired = SHIP_CONFIG.maxFuel / 3;  // 1/3 í•„ìš”
            
            // ê´‘ê³  ì¶©ì „ì´ ì—†ê³  ì—°ë£Œë„ ë¶€ì¡±í•œ ê²½ìš°
            if (typeof emergencyEscapeCharge !== 'undefined' && !emergencyEscapeCharge.charged && playerShip.fuel < minFuelRequired) {
                showMessage('âŒ Insufficient fuel! (minimum ' + Math.round(minFuelRequired) + '% required)');
                showMessage('ğŸ’¡ ê´‘ê³ ë¥¼ ì‹œì²­í•˜ì—¬ ê¸´ê¸‰íƒˆì¶œì„ ì¶©ì „í•˜ì„¸ìš”!');
                return;
            }
            
            // ì¶©ì „ ì‚¬ìš© ë˜ëŠ” ì—°ë£Œ ì†Œëª¨
            if (typeof emergencyEscapeCharge !== 'undefined' && emergencyEscapeCharge.charged) {
                emergencyEscapeCharge.charged = false;  // ì¶©ì „ ì†Œëª¨
                showMessage('âš¡ Emergency escape charge used!');
                if (typeof updateAdUI === 'function') updateAdUI();
            } else {
                playerShip.fuel -= minFuelRequired;  // ì—°ë£Œ 1/3 ì†Œëª¨
            }
            
            // ê¸´ê¸‰ íƒˆì¶œ - ìœ„í—˜ ì²œì²´ì—ì„œ ë©€ì–´ì§€ëŠ” ë°©í–¥ìœ¼ë¡œ ê°€ì†
            let closestBody = null;
            let minDist = Infinity;
            
            bodies.forEach(b => {
                if (!b || !b.mesh) return;
                if (b.type === 'star' || b.type === 'blackhole' || b.mass > 1) {
                    const d = playerShip.mesh.position.distanceTo(b.mesh.position);
                    if (d < minDist) {
                        minDist = d;
                        closestBody = b;
                    }
                }
            });
            
            if (!closestBody || !closestBody.mesh) return;
            
            // íƒˆì¶œ ë°©í–¥ ê³„ì‚° (í–‰ì„±ì—ì„œ ë©€ì–´ì§€ëŠ” ë°©í–¥)
            const escapeDir = new THREE.Vector3().subVectors(playerShip.mesh.position, closestBody.mesh.position).normalize();
            
            // ìš°ì£¼ì„ ì„ íƒˆì¶œ ë°©í–¥ìœ¼ë¡œ íšŒì „
            const targetQuat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, -1), escapeDir);
            playerShip.mesh.quaternion.copy(targetQuat);
            playerShip.euler.setFromQuaternion(playerShip.mesh.quaternion, 'YXZ');
            
            // ê¸´ê¸‰ íšŒí”¼ ìƒíƒœ í™œì„±í™” (ì¤‘ë ¥ê¶Œ íƒˆì¶œìš©)
            emergencyEvasion.active = true;
            emergencyEvasion.phase = 'escaping';
            emergencyEvasion.targetBody = closestBody;
            emergencyEvasion.escapeRadius = closestBody.radius * 6;  // íƒˆì¶œ ê¸°ì¤€ ê±°ë¦¬
            
            // ì¤‘ë ¥ ì†ë„ ì œê±°í•˜ê³  ì´ˆê¸° íƒˆì¶œ ì†ë„ ë¶€ì—¬
            playerShip.velocity.set(0, 0, 0);
            playerShip.speed = 10;  // ì´ˆê¸° ì†ë„ë§Œ ë¶€ì—¬, ì´í›„ ê°€ì†ì€ updatePilotModeì—ì„œ
            
            // ìë™í•­ë²• í•´ì œ
            if (autopilot.engaged) disableAutopilot();
            
            showMsg('ğŸ†˜ ê¸´ê¸‰ íƒˆì¶œ! ì¤‘ë ¥ê¶Œ ì´íƒˆ ì¤‘... (5ë°° ê°€ì†)');
        }
        
        function startGravityWarning() {
            if (isGravityWarning) return;
            isGravityWarning = true;
            
            document.getElementById('warn-gravity').classList.add('active');
            document.getElementById('btn-escape').classList.add('active');
            
            // ë¹„í”„ìŒ ì‹œì‘
            beepInterval = setInterval(() => {
                playBeep();
            }, 400);
        }
        
        function stopGravityWarning() {
            if (!isGravityWarning) return;
            isGravityWarning = false;
            
            document.getElementById('warn-gravity').classList.remove('active');
            document.getElementById('btn-escape').classList.remove('active');
            
            if (beepInterval) {
                clearInterval(beepInterval);
                beepInterval = null;
            }
        }
        
        function updatePilotMode(dt) {
            if (!playerShip || !playerShip.mesh || isInteriorMode || isObservatoryMode) return;
            
            // â˜… íƒœì–‘ ë°©í–¥ ì¡°ëª… ì—…ë°ì´íŠ¸ (ë¬¼ë¦¬ ê¸°ë°˜)
            const sunLight = playerShip.mesh.getObjectByName('sunLight');
            const fillLight = playerShip.mesh.getObjectByName('fillLight');
            if (sunLight) {
                const sun = bodies.find(b => b.name === 'íƒœì–‘' || b.name === 'Sun');
                if (sun && sun.mesh) {
                    // ìš°ì£¼ì„ ì—ì„œ íƒœì–‘ìœ¼ë¡œì˜ ë°©í–¥ ê³„ì‚° (ë¹›ì´ ì˜¤ëŠ” ë°©í–¥)
                    const sunDir = new THREE.Vector3()
                        .subVectors(sun.mesh.position, playerShip.mesh.position)
                        .normalize();
                    
                    // ì¡°ëª… ìœ„ì¹˜ë¥¼ íƒœì–‘ ë°©í–¥ìœ¼ë¡œ ì„¤ì • (ì›”ë“œ ì¢Œí‘œ)
                    sunLight.position.copy(sunDir.clone().multiplyScalar(20));
                    
                    // ê±°ë¦¬ì— ë”°ë¥¸ ë°ê¸° ì¡°ì ˆ (íƒœì–‘ì—ì„œ ë©€ì–´ì§ˆìˆ˜ë¡ ì•½í•´ì§)
                    const distToSun = playerShip.mesh.position.distanceTo(sun.mesh.position);
                    const intensity = Math.max(0.8, Math.min(3.0, 800 / distToSun));
                    sunLight.intensity = intensity;
                    
                    // ë°˜ëŒ€ìª½ ë³´ì¡°ê´‘ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
                    if (fillLight) {
                        fillLight.position.copy(sunDir.clone().multiplyScalar(-10));
                        fillLight.intensity = Math.max(0.1, 0.3 - intensity * 0.05);  // íƒœì–‘ë¹›ì´ ê°•í•˜ë©´ ë³´ì¡°ê´‘ ì•½í•˜ê²Œ
                    }
                }
            }
            
            // â˜… ë„í‚¹ ì¤‘ì´ê±°ë‚˜ ë„í‚¹ëœ ìƒíƒœë©´ ìš°ì£¼ì„  ì´ë™ ì—†ìŒ
            if (window.isDocking || window.isDockedToStation) {
                updateShipHUD();
                return;
            }
            
            // ê¶¤ë„ ì§„ì… ì¤‘ì´ë©´ ë³„ë„ ì²˜ë¦¬
            if (orbitState.enteringOrbit) {
                updateOrbitInsertion(dt);
                updateShipHUD();
                return;
            }
            
            // ê¶¤ë„ ë¹„í–‰ ì¤‘ì´ë©´ ë³„ë„ ì²˜ë¦¬
            if (orbitState.inOrbit) {
                updateOrbitFlight(dt);
                updateShipHUD();
                return;
            }
            
            // ê¸´ê¸‰ íƒˆì¶œ ì¤‘ì¼ ë•Œ ì²˜ë¦¬
            if (emergencyEvasion.active && emergencyEvasion.phase === 'escaping') {
                const targetBody = emergencyEvasion.targetBody;
                if (targetBody && targetBody.mesh) {
                    const dist = playerShip.mesh.position.distanceTo(targetBody.mesh.position);
                    
                    // ì¤‘ë ¥ê¶Œ ë‚´ì—ì„œë§Œ 5ë°° ê°€ì† (ì—°ë£Œ 5ë°° ì†Œëª¨)
                    if (dist < emergencyEvasion.escapeRadius && playerShip.fuel > 0) {
                        const escapeAccel = SHIP_CONFIG.acceleration * 5;  // 5ë°° ê°€ì†
                        playerShip.speed += escapeAccel * dt;
                        playerShip.fuel -= SHIP_CONFIG.fuelConsumption * dt * SHIP_CONFIG.reverseFuelMult;  // 5ë°° ì—°ë£Œ ì†Œëª¨
                        
                        // íƒˆì¶œ ë°©í–¥ ìœ ì§€
                        const escapeDir = new THREE.Vector3().subVectors(playerShip.mesh.position, targetBody.mesh.position).normalize();
                        const targetQuat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, -1), escapeDir);
                        playerShip.mesh.quaternion.slerp(targetQuat, dt * 2);
                        playerShip.euler.setFromQuaternion(playerShip.mesh.quaternion, 'YXZ');
                        
                        // ì—”ì§„ ë¶ˆê½ƒ í™œì„±í™”
                        playerShip.flame.visible = true;
                        playerShip.flame.scale.setScalar(1.5 + Math.random() * 0.5);
                        
                        document.getElementById('warn-emergency').classList.add('active');
                    } else {
                        // ì¤‘ë ¥ê¶Œ íƒˆì¶œ ì™„ë£Œ - ê´€ì„± ì†ë„ë¡œ ì „í™˜
                        emergencyEvasion.active = false;
                        emergencyEvasion.phase = 'idle';
                        emergencyEvasion.targetBody = null;
                        stopGravityWarning();
                        document.getElementById('warn-emergency').classList.remove('active');
                        showMsg('âœ… Escaped gravity well! Coasting...');
                    }
                } else {
                    // ëŒ€ìƒ ì²œì²´ê°€ ì—†ìœ¼ë©´ íƒˆì¶œ ì¢…ë£Œ
                    emergencyEvasion.active = false;
                    emergencyEvasion.phase = 'idle';
                }
                
                // ê¸´ê¸‰ íƒˆì¶œ ì¤‘ì—ë„ ì´ë™ ì²˜ë¦¬
                playerShip.speed = Math.min(playerShip.speed, SHIP_CONFIG.maxSpeed * 2);  // íƒˆì¶œ ì‹œ ìµœëŒ€ ì†ë„ 2ë°°
                playerShip.fuel = Math.max(0, playerShip.fuel);
                
                const fwd = new THREE.Vector3(0, 0, -1).applyQuaternion(playerShip.mesh.quaternion);
                playerShip.mesh.position.add(fwd.multiplyScalar(playerShip.speed * dt));
                playerShip.mesh.position.add(playerShip.velocity.clone().multiplyScalar(dt));
                
                applyGravityToShip(dt);
                checkShipCollision();
                updateShipHUD();
                updateShipRadar();
                return;
            }
            
            // ìë™í•­ë²•
            if (autopilot.engaged) updateShipAutopilot(dt);
            
            // ë°©í–¥ ì¡°ì¢… (ìë™í•­ë²• ì•„ë‹ ë•Œ, 1ì¸ì¹­ ì¡°ì¢…ì„ ë·°ì—ì„œë§Œ)
            // â˜…â˜…â˜… ì„ íšŒ ì†ë„: ê´€ë¦¬ì í˜ì´ì§€ turnSpeed Ã— ê°ë„ ê³„ìˆ˜ Ã— ëª¨ë“œ ë°°ìœ¨ â˜…â˜…â˜…
            if (!autopilot.engaged && isCockpitView) {
                // ëª¨ë“œë³„ ì„ íšŒ ë°°ìœ¨ ì ìš© (ì‹±ê¸€/ë©€í‹° ëª¨ë‘ 0.5ë¡œ ë™ì¼)
                let turnMult = 1.0;
                if (window.gameMode && window.MODE_CONFIG && window.MODE_CONFIG[window.gameMode]) {
                    turnMult = window.MODE_CONFIG[window.gameMode].turnMultiplier || 1.0;
                }
                // turnSpeed ê°’ì´ í´ìˆ˜ë¡ ë¹ ë¥´ê²Œ íšŒì „ (ê°ë„ 60 = ì ë‹¹í•œ ë°˜ì‘ì„±)
                const turnRate = SHIP_CONFIG.turnSpeed * dt * 60 * turnMult;
                playerShip.euler.y += shipInputs.yaw * turnRate;
                playerShip.euler.x += shipInputs.pitch * turnRate;
                playerShip.euler.x = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, playerShip.euler.x));
                playerShip.mesh.quaternion.setFromEuler(playerShip.euler);
            }
            
            // ìˆ˜ë™ ì†ë„ ì¡°ì ˆ (3ì¸ì¹­ì—ì„œë„ í—ˆìš©, ìë™í•­ë²• ì•„ë‹ ë•Œ)
            if (!autopilot.engaged && shipInputs.throttle !== 0 && playerShip.fuel > 0) {
                // ì—°ë£Œ íš¨ìœ¨ íŠ¹ìˆ˜ëŠ¥ë ¥ í™•ì¸
                const hasFuelEfficiency = currentShipType.special === 'fuelEfficiency' || currentShipType.special === 'allInOne';
                let fuelMult = hasFuelEfficiency ? 0.7 : 1.0;  // 30% ì ˆì•½
                
                // ê²Œì„ ëª¨ë“œ ë°°ìœ¨ (ë©€í‹°: 0.5 = 2ë°° ì ê²Œ ì†Œëª¨)
                if (window.gameMode && window.MODE_CONFIG && window.MODE_CONFIG[window.gameMode]) {
                    fuelMult *= window.MODE_CONFIG[window.gameMode].fuelMultiplier;
                }
                
                // ì• í”„í„°ë²„ë„ˆ íš¨ê³¼ (ì—°ë£Œ 3ë°° ì†Œëª¨)
                if (shipAbility.afterburnerActive) {
                    fuelMult *= 3;
                }
                
                // ê¸°ë³¸ ì—°ë£Œ ì†Œëª¨ëŸ‰ (ëˆˆì— ë„ê²Œ ì¦ê°€)
                const baseFuelConsumption = 1.0;  // â˜… 0.5 â†’ 1.0
                
                if (shipInputs.throttle > 0) {
                    // ì „ì§„ ê°€ì†
                    let accelMult = shipAbility.afterburnerActive ? 1.5 : 1.0;
                    if (typeof adBooster !== 'undefined' && adBooster.active) {
                        accelMult *= adBooster.multiplier;
                    }
                    playerShip.speed += SHIP_CONFIG.acceleration * shipInputs.throttle * dt * accelMult;
                    playerShip.fuel -= baseFuelConsumption * shipInputs.throttle * dt * fuelMult;
                    console.log('ğŸ”¥ ì—°ë£Œ ì†Œëª¨:', baseFuelConsumption * shipInputs.throttle * dt * fuelMult, 'ë‚¨ì€ ì—°ë£Œ:', playerShip.fuel);
                } else if (shipInputs.throttle < 0) {
                    // ì—­ì¶”ì§„
                    const reverseThrust = SHIP_CONFIG.acceleration * Math.abs(shipInputs.throttle) * dt * 0.5;
                    if (playerShip.speed > 0) {
                        playerShip.speed = Math.max(0, playerShip.speed - reverseThrust * 2);
                    } else {
                        playerShip.speed -= reverseThrust;
                        playerShip.speed = Math.max(-SHIP_CONFIG.maxSpeed * 0.3, playerShip.speed);
                    }
                    playerShip.fuel -= baseFuelConsumption * Math.abs(shipInputs.throttle) * dt * fuelMult * 1.5;
                }
            }
            
            // â˜…â˜…â˜… ì†ë„ ìœ ì§€ ì‹œ ì—°ë£Œ ì†Œëª¨ (ìŠ¤ë¡œí‹€ ì•ˆ ëˆŒëŸ¬ë„ ì†Œëª¨) â˜…â˜…â˜…
            if (!autopilot.engaged && Math.abs(playerShip.speed) > 0.1 && playerShip.fuel > 0) {
                const hasFuelEfficiency = currentShipType.special === 'fuelEfficiency' || currentShipType.special === 'allInOne';
                let fuelMult = hasFuelEfficiency ? 0.7 : 1.0;
                if (window.gameMode && window.MODE_CONFIG && window.MODE_CONFIG[window.gameMode]) {
                    fuelMult *= window.MODE_CONFIG[window.gameMode].fuelMultiplier;
                }
                const speedRatio = Math.abs(playerShip.speed) / SHIP_CONFIG.maxSpeed;
                playerShip.fuel -= 0.3 * speedRatio * dt * fuelMult;  // â˜… 0.15*0.3 â†’ 0.3
            }
            
            // ìë™ ìˆ˜ë¦¬ íŠ¹ìˆ˜ëŠ¥ë ¥ (í”„ë¦¬ê¹ƒ, í”Œë˜ê·¸ì‹­)
            const hasAutoRepair = currentShipType.special === 'autoRepair' || currentShipType.special === 'allInOne';
            if (hasAutoRepair) {
                // ì—°ë£Œ ìë™ íšŒë³µ
                if (playerShip.fuel < SHIP_CONFIG.maxFuel) {
                    playerShip.fuel += dt * 0.1;  // 10ì´ˆë‹¹ 1% íšŒë³µ
                }
                // â˜… ë‚´êµ¬ë„ ìë™ íšŒë³µ
                if (playerShip.hull < SHIP_CONFIG.maxHull) {
                    playerShip.hull += dt * 0.05;  // 20ì´ˆë‹¹ 1% íšŒë³µ
                    playerShip.hull = Math.min(playerShip.hull, SHIP_CONFIG.maxHull);
                }
            }
            
            // ê¸´ê¸‰ ì—­ì¶”ì§„ (ì—°ë£Œ 5ë°° ì†Œëª¨, íš¨ìœ¨ 3ë°°)
            if (shipInputs.emergencyReverse) {
                if (playerShip.fuel > 0 && Math.abs(playerShip.speed) > 0.1) {
                    // ì†ë„ë¥¼ 0ìœ¼ë¡œ ìˆ˜ë ´
                    if (playerShip.speed > 0) {
                        playerShip.speed = Math.max(0, playerShip.speed - SHIP_CONFIG.reverseThrust * dt * 3);
                    } else {
                        playerShip.speed = Math.min(0, playerShip.speed + SHIP_CONFIG.reverseThrust * dt * 3);
                    }
                    // ê¸´ê¸‰ ì—­ì¶”ì§„ ì—°ë£Œ ì†Œëª¨ (ê¸°ë³¸ì˜ 5ë°°)
                    playerShip.fuel -= 0.5 * dt;  // ì´ˆë‹¹ 0.5% ì†Œëª¨
                    document.getElementById('warn-emergency').classList.add('active');
                } else {
                    document.getElementById('warn-emergency').classList.remove('active');
                }
            } else {
                document.getElementById('warn-emergency').classList.remove('active');
            }
            
            // ì• í”„í„°ë²„ë„ˆ í™œì„± ì‹œ ìµœëŒ€ ì†ë„ 1.5ë°°
            let maxSpeedMult = shipAbility.afterburnerActive ? 1.5 : 1.0;
            // ê´‘ê³  ë¶€ìŠ¤í„° íš¨ê³¼ (2ë°°)
            if (typeof adBooster !== 'undefined' && adBooster.active) {
                maxSpeedMult *= adBooster.multiplier;
            }
            playerShip.speed = Math.min(playerShip.speed, SHIP_CONFIG.maxSpeed * maxSpeedMult);
            playerShip.fuel = Math.max(0, playerShip.fuel);
            
            // ì—°ë£Œ ë¶€ì¡± ì‹œ ì• í”„í„°ë²„ë„ˆ ìë™ í•´ì œ
            if (shipAbility.afterburnerActive && playerShip.fuel <= 0) {
                shipAbility.afterburnerActive = false;
                document.getElementById('btn-ability').style.borderColor = '#ff6600';
                showMsg(t('lowFuel') + ' ' + t('afterburnerOff'));
            }
            
            // ì¤‘ë ¥ ì˜í–¥ ê³„ì‚°
            applyGravityToShip(dt);
            
            // ì—”ì§„ ì¶”ë ¥ì— ì˜í•œ ì´ë™
            const fwd = new THREE.Vector3(0, 0, -1).applyQuaternion(playerShip.mesh.quaternion);
            playerShip.mesh.position.add(fwd.multiplyScalar(playerShip.speed * dt));
            
            // ì¤‘ë ¥ì— ì˜í•œ ì´ë™
            playerShip.mesh.position.add(playerShip.velocity.clone().multiplyScalar(dt));
            
            // â˜… ê¸°ë³¸ ë¶ˆê½ƒ ì œì–´ (engineConfig ì—†ì„ ë•Œë§Œ)
            var engineFlame = playerShip.mesh.getObjectByName('engineFlame');
            var reverseFlameGroup = playerShip.mesh.getObjectByName('reverseFlameGroup');
            
            // â˜… currentShipType.engineConfigë¡œ ì²´í¬ (GLB ë¡œë“œ ì „ì—ë„ ì‘ë™)
            var shipHasEngineConfig = currentShipType && currentShipType.engineConfig;
            
            if (!shipHasEngineConfig && engineFlame) {
                // engineConfig ì—†ì„ ë•Œë§Œ ê¸°ë³¸ ë¶ˆê½ƒ ì‚¬ìš©
                if (isInteriorMode || isObservatoryMode) {
                    engineFlame.visible = false;
                } else {
                    // ìˆ˜ë™ ì¡°ì‘ ë˜ëŠ” ìë™í•­í•´ ê°€ì† ì¤‘
                    var showFlame = (shipInputs.throttle > 0.1 || autopilot.phase === 'accelerating') && playerShip.fuel > 0;
                    engineFlame.visible = showFlame;
                    if (engineFlame.visible) {
                        var flameThrottle = autopilot.phase === 'accelerating' ? 1.0 : shipInputs.throttle;
                        engineFlame.scale.setScalar(0.5 + flameThrottle * 0.5 + Math.random() * 0.2);
                    }
                }
            } else if (shipHasEngineConfig && engineFlame) {
                // engineConfig ìˆìœ¼ë©´ ê¸°ë³¸ ë¶ˆê½ƒ í•­ìƒ ìˆ¨ê¹€
                engineFlame.visible = false;
            }
            
            // â˜…â˜…â˜… engineConfig ì¶”ì§„ ë¶ˆê½ƒ ì• ë‹ˆë©”ì´ì…˜ â˜…â˜…â˜…
            if (configuredThrustFlames && configuredThrustFlames.children) {
                // ìˆ˜ë™ ì¡°ì‘ ë˜ëŠ” ìë™í•­í•´ ê°€ì† ì¤‘ì¼ ë•Œ ì¶”ì§„ ë¶ˆê½ƒ í‘œì‹œ
                var isThrottling = (shipInputs.throttle > 0.1 || autopilot.phase === 'accelerating') && playerShip.fuel > 0;
                var throttleValue = autopilot.phase === 'accelerating' ? 1.0 : shipInputs.throttle;
                var t = performance.now() * 0.01;
                
                for (var i = 0; i < configuredThrustFlames.children.length; i++) {
                    var flameGroup = configuredThrustFlames.children[i];
                    
                    if (isInteriorMode || isObservatoryMode) {
                        flameGroup.visible = false;
                    } else {
                        flameGroup.visible = isThrottling;
                        
                        if (isThrottling && flameGroup.children && flameGroup.children.length > 0) {
                            // ë¹ ë¥¸ ë–¨ë¦¼ íš¨ê³¼
                            var flicker = 0.7 + Math.sin(t * 10 + i * 100) * 0.2 + Math.random() * 0.3;
                            var lengthMult = 0.8 + throttleValue * 0.8 + Math.sin(t * 8 + i * 50) * 0.2 + Math.random() * 0.3;
                            
                            for (var j = 0; j < flameGroup.children.length; j++) {
                                var flame = flameGroup.children[j];
                                var baseZ = flame.userData.baseScaleZ || 3;
                                
                                flame.scale.x = flicker;
                                flame.scale.y = flicker;
                                flame.scale.z = baseZ * lengthMult;
                                
                                if (flame.material) {
                                    flame.material.opacity = 0.4 + throttleValue * 0.4 + Math.random() * 0.15;
                                }
                            }
                        }
                    }
                }
            }
            
            // â˜…â˜…â˜… engineConfig ì—­ì¶”ì§„ ë¶ˆê½ƒ ì• ë‹ˆë©”ì´ì…˜ â˜…â˜…â˜…
            if (configuredReverseFlames && configuredReverseFlames.children) {
                // ìˆ˜ë™ ì—­ì¶”ì§„ ë˜ëŠ” ìë™í•­í•´ ê°ì† ì¤‘ì¼ ë•Œ ì—­ì¶”ì§„ ë¶ˆê½ƒ í‘œì‹œ
                var showReverse = (shipInputs.throttle < -0.05 || shipInputs.emergencyReverse || autopilot.phase === 'decelerating') && playerShip.fuel > 0;
                var reverseThrottleValue = autopilot.phase === 'decelerating' ? 1.0 : Math.abs(shipInputs.throttle) * 2;
                var t = performance.now() * 0.01;
                
                for (var i = 0; i < configuredReverseFlames.children.length; i++) {
                    var flameGroup = configuredReverseFlames.children[i];
                    
                    if (isInteriorMode || isObservatoryMode) {
                        flameGroup.visible = false;
                    } else {
                        flameGroup.visible = showReverse;
                        
                        if (showReverse && flameGroup.children) {
                            var emergencyMult = shipInputs.emergencyReverse ? 1.5 : 1.0;
                            
                            var flicker = (0.8 + Math.sin(t * 7 + i * 40) * 0.15 + Math.random() * 0.25) * emergencyMult;
                            var lengthMult = (0.9 + reverseThrottleValue * 0.5 + Math.sin(t * 5 + i * 25) * 0.15 + Math.random() * 0.2) * emergencyMult;
                            
                            for (var j = 0; j < flameGroup.children.length; j++) {
                                var flame = flameGroup.children[j];
                                var baseZ = flame.userData.baseScaleZ || 3;
                                
                                flame.scale.x = flicker;
                                flame.scale.y = flicker;
                                flame.scale.z = baseZ * lengthMult;
                                
                                if (flame.material) {
                                    flame.material.opacity = 0.4 + reverseThrottleValue * 0.4 + Math.random() * 0.1;
                                }
                            }
                        }
                    }
                }
            }
            
            // ê¸°ë³¸ ì—­ì¶”ì§„ ë¶ˆê½ƒ (engineConfig ì—†ì„ ë•Œë§Œ)
            if (!shipHasEngineConfig && reverseFlameGroup) {
                // engineConfig ì—†ì„ ë•Œë§Œ ê¸°ë³¸ ë¶ˆê½ƒ ì‚¬ìš©
                // ì„ ë‚´ ëª¨ë“œë‚˜ ì „ë§ëŒ€ ëª¨ë“œì—ì„œëŠ” ì—­ì¶”ì§„ ë¶ˆê½ƒ ìˆ¨ê¹€
                if (isInteriorMode || isObservatoryMode) {
                    reverseFlameGroup.visible = false;
                } else {
                    const showReverse = (shipInputs.throttle < -0.05 || shipInputs.emergencyReverse) && playerShip.fuel > 0;
                    reverseFlameGroup.visible = showReverse;
                    
                    if (reverseFlameGroup.visible) {
                        // ê²Œì´ì§€ ê°•ë„ ê³„ì‚° (0.0 ~ 1.0) - throttleì´ -0.5ê¹Œì§€ ê°€ë¯€ë¡œ
                        // ê¸´ê¸‰ ì—­ì¶”ì§„ ì‹œ ë¶ˆê½ƒ 2ë°°
                        const emergencyMult = shipInputs.emergencyReverse ? 2.0 : 1.0;
                        const throttleStrength = shipInputs.emergencyReverse ? 1.0 : Math.abs(shipInputs.throttle) * 2; // 0~1 ë²”ìœ„ë¡œ
                        const time = performance.now() * 0.001;
                        
                        reverseFlameGroup.children.forEach(child => {
                            // ì™¸ë¶€ ë¶ˆê½ƒ (Outer) - ê°€ì¥ í° ë°˜ì‘
                            if (child.name.includes('Outer')) {
                                const flicker = 0.9 + Math.sin(time * 18) * 0.1 + Math.random() * 0.1;
                                // ê²Œì´ì§€ ì•½í•  ë•Œ ì‘ê²Œ, ê°•í•  ë•Œ í¬ê²Œ, ê¸´ê¸‰ ì—­ì¶”ì§„ ì‹œ 2ë°°
                                const scaleY = (0.3 + throttleStrength * 0.9) * emergencyMult; // 0.3 ~ 1.2 â†’ ê¸´ê¸‰ì‹œ 2ë°°
                                const scaleXZ = (0.5 + throttleStrength * 0.6) * emergencyMult; // 0.5 ~ 1.1 â†’ ê¸´ê¸‰ì‹œ 2ë°°
                                child.scale.set(scaleXZ * flicker, scaleY * flicker, scaleXZ * flicker);
                                child.material.opacity = 0.3 + throttleStrength * 0.4;
                            }
                            // ì¤‘ê°„ ë¶ˆê½ƒ (Middle)
                            else if (child.name.includes('Middle')) {
                                const flicker = 0.92 + Math.sin(time * 22 + 1) * 0.08 + Math.random() * 0.08;
                                const scaleY = 0.4 + throttleStrength * 0.8;
                                const scaleXZ = 0.6 + throttleStrength * 0.5;
                                child.scale.set(scaleXZ * flicker, scaleY * flicker, scaleXZ * flicker);
                                child.material.opacity = 0.4 + throttleStrength * 0.4;
                            }
                            // ì½”ì–´ ë¶ˆê½ƒ (Core) - ê°€ì¥ ì•ˆì •ì ì´ì§€ë§Œ ì—¬ì „íˆ í¬ê¸° ë³€í™”
                            else if (child.name.includes('Core')) {
                                const flicker = 0.95 + Math.sin(time * 25 + 2) * 0.05 + Math.random() * 0.05;
                                const scaleY = 0.5 + throttleStrength * 0.7;
                                const scaleXZ = 0.7 + throttleStrength * 0.4;
                                child.scale.set(scaleXZ, scaleY * flicker, scaleXZ);
                                child.material.opacity = 0.6 + throttleStrength * 0.35;
                            }
                            // ë¶„ì‚¬êµ¬ ë°œê´‘ì²´ (Nozzle) - ê²Œì´ì§€ì— ë”°ë¼ ë°ê¸° ë³€í™”
                            else if (child.name.includes('nozzle')) {
                                const pulse = 0.85 + Math.sin(time * 12) * 0.15 + Math.random() * 0.05;
                                const nozzleScale = 0.6 + throttleStrength * 0.5;
                                child.scale.setScalar(nozzleScale * pulse);
                                child.material.opacity = 0.5 + throttleStrength * 0.5;
                            }
                        });
                    }
                }
            } else if (shipHasEngineConfig && reverseFlameGroup) {
                // engineConfig ìˆìœ¼ë©´ ê¸°ë³¸ ì—­ì¶”ì§„ ë¶ˆê½ƒ í•­ìƒ ìˆ¨ê¹€
                reverseFlameGroup.visible = false;
            }
            
            // ì¶©ëŒ ì²´í¬
            checkShipCollision();
            
            // HUD ì—…ë°ì´íŠ¸
            updateShipHUD();
            updateShipRadar();
            updateShipTargetInfo();
            
            // AI ë¶€ì¡°ì¢…ì‚¬ ì—…ë°ì´íŠ¸
            updateAICopilot(dt);
            
            // ê·¼ì²˜ ì—°ë£Œ ì •ê±°ì¥ ê°ì§€
            checkNearbyFuelStation();
        }
        
        function applyGravityToShip(dt) {
            if (!playerShip || !playerShip.mesh) return;
            
            const shipPos = playerShip.mesh.position;
            let totalForce = new THREE.Vector3();
            let inGravityDanger = false;
            
            // ì¤‘ë ¥ ì €í•­ íŠ¹ìˆ˜ëŠ¥ë ¥ í™•ì¸
            const hasGravityResist = currentShipType.special === 'gravityResist' || currentShipType.special === 'allInOne';
            const gravityMult = hasGravityResist ? 0.5 : 1.0;  // 50% ê°ì†Œ
            
            let nearestBody = null;
            let nearestDist = Infinity;
            
            bodies.forEach(b => {
                if (!b || !b.mesh) return;
                const distVec = new THREE.Vector3().subVectors(b.mesh.position, shipPos);
                const distSq = distVec.lengthSq();
                const dist = Math.sqrt(distSq);
                
                // ì¤‘ë ¥ ê³„ì‚° (ì¤‘ë ¥ ì €í•­ ì ìš©)
                const f = (CONFIG.G * b.mass * playerShip.mass) / (distSq + CONFIG.softening) * gravityMult;
                const fVec = distVec.normalize().multiplyScalar(f);
                totalForce.add(fVec);
                
                // ìœ„í—˜ ê±°ë¦¬ ì²´í¬ (ë°˜ì§€ë¦„ì˜ 5ë°° ì´ë‚´)
                const dangerDist = b.radius * 5;
                if (dist < dangerDist && b.mass > 0.5) {
                    // ì¤‘ë ¥ ê°•ë„ ì²´í¬
                    const gravityStrength = f / playerShip.mass;
                    if (gravityStrength > SHIP_CONFIG.gravityWarningThreshold || dist < b.radius * 2) {
                        inGravityDanger = true;
                    }
                }
                
                // ê¶¤ë„ ì§„ì… ê°€ëŠ¥ ê±°ë¦¬ ì²´í¬ (ë°˜ì§€ë¦„ì˜ 3~10ë°°)
                const orbitMinDist = b.radius * 2;
                const orbitMaxDist = b.radius * 15;
                if (dist > orbitMinDist && dist < orbitMaxDist && b.mass > 0.1 && dist < nearestDist) {
                    nearestBody = b;
                    nearestDist = dist;
                }
            });
            
            // ê¶¤ë„ ì§„ì… ë²„íŠ¼ í‘œì‹œ/ìˆ¨ê¹€ (ë°ìŠ¤í¬í†± + ëª¨ë°”ì¼)
            const orbitEntryBtn = document.getElementById('btn-orbit-entry');
            const mobileOrbitBtn = document.getElementById('mobile-orbit');
            if (nearestBody && !autopilot.engaged && !orbitState.active) {
                if (orbitEntryBtn) {
                    orbitEntryBtn.style.display = 'block';
                    orbitEntryBtn.textContent = 'ğŸŒ ' + translateBodyName(nearestBody.name) + t('orbitSuffixText');
                    orbitEntryBtn.dataset.targetBody = nearestBody.name;
                }
                if (mobileOrbitBtn) {
                    mobileOrbitBtn.style.display = 'block';
                    mobileOrbitBtn.textContent = 'ğŸŒ ' + translateBodyName(nearestBody.name);
                    mobileOrbitBtn.dataset.targetBody = nearestBody.name;
                }
            } else if (!orbitState.active) {
                if (orbitEntryBtn) orbitEntryBtn.style.display = 'none';
                if (mobileOrbitBtn) mobileOrbitBtn.style.display = 'none';
            }
            
            // ì†ë„ì— ì¤‘ë ¥ ì ìš©
            playerShip.velocity.add(totalForce.divideScalar(playerShip.mass).multiplyScalar(dt));
            
            // ì†ë„ ê°ì‡  (ê³µê¸°ì €í•­ ì‹œë®¬ë ˆì´ì…˜ì€ ì—†ì§€ë§Œ, ì•ˆì •ì„±ì„ ìœ„í•´)
            playerShip.velocity.multiplyScalar(0.999);
            
            // ì¤‘ë ¥ ê²½ê³ 
            if (inGravityDanger) {
                startGravityWarning();
            } else {
                stopGravityWarning();
            }
        }
        
        // â˜…â˜…â˜… ì²œì²´ ì ‘ê·¼ ìœ„í—˜ ê²½ê³  ì‹œìŠ¤í…œ â˜…â˜…â˜…
        let crashWarningState = {
            active: false,
            targetBody: null,
            warningLevel: 0  // 0: ì•ˆì „, 1: ê²½ê³ (ê¹œë¹¡ì„), 2: ìœ„í—˜(ì¶”ë½ ì„ë°•)
        };
        
        function checkShipCollision() {
            if (!playerShip || !playerShip.mesh) return;
            
            // bodiesì™€ satellites(moon íƒ€ì…) ëª¨ë‘ ì²´í¬
            const allBodies = [...bodies, ...satellites.filter(s => s.isPhysicsEnabled)];
            
            let closestDanger = null;
            let closestDangerDist = Infinity;
            let closestDangerRadius = 0;
            
            allBodies.forEach(b => {
                if (!b || !b.mesh) return;
                const r = b.radius || 0.5;
                const dist = playerShip.mesh.position.distanceTo(b.mesh.position);
                
                // ì¶©ëŒ íŒŒê´´ ê±°ë¦¬ (ë°˜ì§€ë¦„ì˜ 1.2ë°°)
                if (dist < r * 1.2) {
                    triggerShipCrash(b);  // ì¶”ë½ ì—°ì¶œê³¼ í•¨ê»˜ íŒŒê´´
                    return;
                }
                
                // ìœ„í—˜ ê±°ë¦¬ ì²´í¬ (ë°˜ì§€ë¦„ì˜ 3ë°° ì´ë‚´)
                if (dist < r * 3 && dist < closestDangerDist) {
                    closestDanger = b;
                    closestDangerDist = dist;
                    closestDangerRadius = r;
                }
                
                // ê·¼ì ‘ ë°€ì–´ë‚´ê¸° ê±°ë¦¬ (ë°˜ì§€ë¦„ì˜ 2.5ë°°) - ì˜¤ë¸Œì íŠ¸ê°€ ì¡°ì¢…ì„ìœ¼ë¡œ ëš«ê³  ë“¤ì–´ì˜¤ì§€ ì•Šê²Œ
                const pushDistance = r * 2.5;
                if (dist < pushDistance) {
                    // ì²œì²´ì—ì„œ ë©€ì–´ì§€ëŠ” ë°©í–¥ìœ¼ë¡œ ë°€ì–´ë‚´ê¸°
                    const pushDir = new THREE.Vector3()
                        .subVectors(playerShip.mesh.position, b.mesh.position)
                        .normalize();
                    
                    // ë¶€ì¡±í•œ ê±°ë¦¬ë§Œí¼ ë°€ì–´ë‚´ê¸°
                    const pushAmount = (pushDistance - dist) * 1.2;
                    playerShip.mesh.position.add(pushDir.multiplyScalar(pushAmount));
                    
                    // ì¶©ëŒ ê²½ê³  í‘œì‹œ
                    const warnCollision = document.getElementById('warn-collision');
                    if (warnCollision) {
                        warnCollision.style.display = 'block';
                        setTimeout(() => warnCollision.style.display = 'none', 500);
                    }
                    
                    // ì†ë„ ê°ì†Œ
                    playerShip.speed *= 0.8;
                }
            });
            
            // â˜…â˜…â˜… ìœ„í—˜ ê²½ê³  UI ì—…ë°ì´íŠ¸ â˜…â˜…â˜…
            updateCrashWarning(closestDanger, closestDangerDist, closestDangerRadius);
        }
        
        // â˜…â˜…â˜… ì¶”ë½ ê²½ê³  UI ì—…ë°ì´íŠ¸ â˜…â˜…â˜…
        function updateCrashWarning(dangerBody, dist, radius) {
            let crashWarningUI = document.getElementById('crash-warning-ui');
            
            if (!crashWarningUI) {
                // ê²½ê³  UI ìƒì„±
                crashWarningUI = document.createElement('div');
                crashWarningUI.id = 'crash-warning-ui';
                crashWarningUI.innerHTML = `
                    <div class="crash-warning-content">
                        <div class="crash-icon">âš ï¸</div>
                        <div class="crash-text">
                            <div class="crash-title">${t('crashWarning')}</div>
                            <div class="crash-body-name"></div>
                            <div class="crash-distance"></div>
                        </div>
                        <button class="crash-escape-btn" id="crash-escape-btn" style="display:none;">${t('emergency')}</button>
                    </div>
                `;
                crashWarningUI.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(200, 0, 0, 0.9);
                    border: 3px solid #ff0000;
                    border-radius: 15px;
                    padding: 20px 30px;
                    z-index: 10000;
                    display: none;
                    font-family: 'Orbitron', sans-serif;
                    color: white;
                    text-align: center;
                    box-shadow: 0 0 50px rgba(255, 0, 0, 0.8);
                `;
                
                const style = document.createElement('style');
                style.textContent = `
                    .crash-warning-content { display: flex; flex-direction: column; align-items: center; gap: 10px; }
                    .crash-icon { font-size: 48px; animation: crashBlink 0.3s infinite; }
                    .crash-title { font-size: 24px; font-weight: bold; color: #ffff00; }
                    .crash-body-name { font-size: 18px; color: #ffcccc; }
                    .crash-distance { font-size: 14px; color: #ff8888; }
                    .crash-escape-btn {
                        margin-top: 10px;
                        padding: 10px 25px;
                        background: linear-gradient(135deg, #ff6600, #ff0000);
                        border: 2px solid #ffff00;
                        border-radius: 8px;
                        color: white;
                        font-size: 16px;
                        font-weight: bold;
                        cursor: pointer;
                        animation: crashBlink 0.5s infinite;
                    }
                    .crash-escape-btn:hover { background: linear-gradient(135deg, #ff8800, #ff2200); }
                    @keyframes crashBlink {
                        0%, 100% { opacity: 1; }
                        50% { opacity: 0.5; }
                    }
                    #crash-warning-ui.level1 { background: rgba(200, 100, 0, 0.9); border-color: #ff8800; box-shadow: 0 0 30px rgba(255, 136, 0, 0.6); }
                    #crash-warning-ui.level2 { background: rgba(200, 0, 0, 0.95); border-color: #ff0000; box-shadow: 0 0 50px rgba(255, 0, 0, 0.9); }
                `;
                document.head.appendChild(style);
                document.body.appendChild(crashWarningUI);
                
                // ê¸´ê¸‰ íƒˆì¶œ ë²„íŠ¼ ì´ë²¤íŠ¸
                document.getElementById('crash-escape-btn').onclick = () => {
                    if (typeof emergencyEscape === 'function') {
                        emergencyEscape();
                    }
                };
            }
            
            if (!dangerBody || dist >= radius * 3) {
                // ì•ˆì „ - ê²½ê³  ìˆ¨ê¹€
                crashWarningUI.style.display = 'none';
                crashWarningState.active = false;
                crashWarningState.warningLevel = 0;
                return;
            }
            
            // ê²½ê³  ë ˆë²¨ ê³„ì‚°
            const dangerRatio = dist / radius;
            let level = 0;
            if (dangerRatio < 1.5) {
                level = 2;  // ê·¹ë„ë¡œ ìœ„í—˜
            } else if (dangerRatio < 2.5) {
                level = 1;  // ê²½ê³ 
            }
            
            if (level > 0) {
                crashWarningUI.style.display = 'block';
                crashWarningUI.className = 'level' + level;
                
                crashWarningUI.querySelector('.crash-body-name').textContent = dangerBody.name;
                crashWarningUI.querySelector('.crash-distance').textContent = `ê±°ë¦¬: ${dist.toFixed(1)} (í•œê³„: ${(radius * 1.2).toFixed(1)})`;
                
                // ê¸´ê¸‰ íƒˆì¶œ ë²„íŠ¼ í‘œì‹œ (íƒˆì¶œê¶Œ ìˆì„ ë•Œë§Œ)
                const escapeBtn = document.getElementById('crash-escape-btn');
                const hasEscapeTicket = window.escapeBoosterActive || (window.adRewardItems && window.adRewardItems.escapeTicket > 0);
                if (escapeBtn) {
                    escapeBtn.style.display = hasEscapeTicket ? 'block' : 'none';
                    escapeBtn.textContent = hasEscapeTicket ? t('emergency') : t('noEscapeTicket');
                }
                
                crashWarningState.active = true;
                crashWarningState.targetBody = dangerBody;
                crashWarningState.warningLevel = level;
            } else {
                crashWarningUI.style.display = 'none';
                crashWarningState.active = false;
                crashWarningState.warningLevel = 0;
            }
        }
        
        // â˜…â˜…â˜… ì¶”ë½ ì—°ì¶œê³¼ í•¨ê»˜ ìš°ì£¼ì„  íŒŒê´´ â˜…â˜…â˜…
        function triggerShipCrash(collidedBody) {
            // ì¶”ë½ ì˜¤ë²„ë ˆì´ í‘œì‹œ
            let crashOverlay = document.getElementById('crash-overlay');
            if (!crashOverlay) {
                crashOverlay = document.createElement('div');
                crashOverlay.id = 'crash-overlay';
                crashOverlay.innerHTML = `
                    <div class="crash-overlay-content">
                        <div class="crash-explosion">ğŸ’¥</div>
                        <div class="crash-ship">ğŸš€</div>
                        <div class="crash-message">${t('hullDestroyed')}</div>
                        <div class="crash-body-hit"></div>
                    </div>
                `;
                crashOverlay.style.cssText = `
                    position: fixed;
                    top: 0; left: 0; right: 0; bottom: 0;
                    background: rgba(0, 0, 0, 0.9);
                    z-index: 100000;
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    animation: crashFadeIn 0.3s ease-out;
                `;
                
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes crashFadeIn { from { opacity: 0; } to { opacity: 1; } }
                    @keyframes crashExplosion { 
                        0% { transform: scale(1); opacity: 1; }
                        50% { transform: scale(3); opacity: 1; }
                        100% { transform: scale(5); opacity: 0; }
                    }
                    @keyframes crashShipFall {
                        0% { transform: translateY(0) rotate(0deg); opacity: 1; }
                        100% { transform: translateY(100px) rotate(180deg); opacity: 0; }
                    }
                    .crash-overlay-content { text-align: center; color: white; font-family: 'Orbitron', sans-serif; }
                    .crash-explosion { font-size: 100px; animation: crashExplosion 1s ease-out forwards; }
                    .crash-ship { font-size: 60px; animation: crashShipFall 1s ease-in forwards; margin-top: -50px; }
                    .crash-message { font-size: 36px; color: #ff4444; font-weight: bold; margin-top: 20px; text-shadow: 0 0 20px #ff0000; }
                    .crash-body-hit { font-size: 20px; color: #ffaaaa; margin-top: 10px; }
                `;
                document.head.appendChild(style);
                document.body.appendChild(crashOverlay);
            }
            
            crashOverlay.style.display = 'flex';
            crashOverlay.querySelector('.crash-body-hit').textContent = `${collidedBody.name}ì— ì¶”ë½`;
            
            // ì¶”ë½ ê²½ê³  UI ìˆ¨ê¸°ê¸°
            const crashWarningUI = document.getElementById('crash-warning-ui');
            if (crashWarningUI) crashWarningUI.style.display = 'none';
            
            // 2ì´ˆ í›„ ì‹¤ì œ íŒŒê´´ ì²˜ë¦¬
            setTimeout(() => {
                crashOverlay.style.display = 'none';
                triggerShipDestruction(collidedBody);
            }, 2000);
        }
        
        // â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…
        // â˜…â˜…â˜… ë¬¼ë¦¬ ì¶©ëŒ ì‹œìŠ¤í…œ & ìš°ì£¼ì •ê±°ì¥ ë³´í˜¸ë§‰ ì‹œìŠ¤í…œ â˜…â˜…â˜…
        // â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…
        
        // â˜… ì¶©ëŒ/ë³´í˜¸ë§‰ ë°˜ê²½ ì„¤ì • (1.5km)
        const STATION_COLLISION_RADIUS = 1.5;   // ì¶©ëŒ ë°˜ê²½ 1.5km
        const STATION_SHIELD_RADIUS = 9.0;      // ë³´í˜¸ë§‰ ë°˜ê²½ (5ë°° í™•ëŒ€)
        
        // ì¶©ëŒ ê°€ëŠ¥í•œ ì˜¤ë¸Œì íŠ¸ ëª©ë¡ (í–‰ì„±/í•­ì„±/ë¸”ë™í™€ ì œì™¸)
        function getCollidableObjects() {
            const collidables = [];
            
            // ìš°ì£¼ì •ê±°ì¥ (satellitesì—ì„œ)
            satellites.forEach(sat => {
                if (sat.isSpaceStation && sat.mesh) {
                    collidables.push({
                        mesh: sat.mesh,
                        name: sat.name,
                        type: 'station',
                        mass: 1000,
                        radius: STATION_COLLISION_RADIUS,
                        isStation: true,
                        ref: sat
                    });
                }
            });
            
            // ì—°ë£Œ ì •ê±°ì¥ (bodiesì—ì„œ)
            bodies.forEach(body => {
                if (body.isStation && body.mesh) {
                    collidables.push({
                        mesh: body.mesh,
                        name: body.name,
                        type: 'fuelDepot',
                        mass: 500,
                        radius: STATION_COLLISION_RADIUS * 0.6,
                        isStation: true,
                        ref: body
                    });
                }
            });
            
            // ì£¼ì°¨ëœ ìš°ì£¼ì„ 
            if (parkedShipMesh && !isPilotMode) {
                collidables.push({
                    mesh: parkedShipMesh,
                    name: 'ì£¼ì°¨ëœ ìš°ì£¼ì„ ',
                    type: 'parkedShip',
                    mass: 1,
                    radius: 0.1,
                    isStation: false,
                    ref: parkedShip
                });
            }
            
            return collidables;
        }
        
        // â˜…â˜…â˜… 6ê°í˜• ë²Œì§‘ íŒ¨í„´ ë³´í˜¸ë§‰ ë©”ì‰¬ ìƒì„± (ì‰ì´ë” ë²„ì „) â˜…â˜…â˜…
        function createHexShieldMesh(radius) {
            const shieldGeo = new THREE.SphereGeometry(radius, 64, 32);
            
            // 6ê°í˜• ë²Œì§‘ íŒ¨í„´ ì‰ì´ë”
            const shieldMat = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    impactStrength: { value: 0 },
                    impactPoint: { value: new THREE.Vector3(0, 0, 0) }
                },
                vertexShader: `
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    
                    void main() {
                        vPosition = position;
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float impactStrength;
                    uniform vec3 impactPoint;
                    
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    
                    // 6ê°í˜• ê±°ë¦¬ í•¨ìˆ˜
                    float hexDist(vec2 p) {
                        p = abs(p);
                        return max(dot(p, vec2(0.866, 0.5)), p.x);
                    }
                    
                    // 6ê°í˜• ê·¸ë¦¬ë“œ
                    float hexGrid(vec2 uv, float scale) {
                        vec2 r = vec2(1.0, 1.732);
                        vec2 h = r * 0.5;
                        vec2 a = mod(uv, r) - h;
                        vec2 b = mod(uv - h, r) - h;
                        vec2 gv = length(a) < length(b) ? a : b;
                        float d = hexDist(gv);
                        float line = smoothstep(0.0, 0.05, 0.5 - d);
                        return line;
                    }
                    
                    void main() {
                        // êµ¬ë©´ ì¢Œí‘œ â†’ UV
                        vec3 n = normalize(vPosition);
                        float u = atan(n.x, n.z) / 6.2832 + 0.5;
                        float v = n.y * 0.5 + 0.5;
                        vec2 hexUV = vec2(u * 30.0, v * 18.0);
                        
                        // 6ê°í˜• ë¼ì¸
                        float hex = hexGrid(hexUV, 1.0);
                        
                        // í”„ë ˆë„¬ (ê°€ì¥ìë¦¬ ê°•ì¡°)
                        float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 2.0);
                        
                        // â˜… ì¶©ëŒ íŒŒë™ íš¨ê³¼ (ê°œì„ )
                        float dist = length(vPosition - impactPoint);
                        float radius = length(vPosition);  // ë³´í˜¸ë§‰ ë°˜ê²½
                        
                        // íŒŒë™ì´ ì¶©ëŒ ì§€ì ì—ì„œ í¼ì ¸ë‚˜ê°
                        float waveRadius = time * radius * 0.8;  // ì‹œê°„ì— ë”°ë¼ í™•ì¥
                        float waveWidth = radius * 0.15;  // íŒŒë™ ë‘ê»˜
                        float wave = 1.0 - smoothstep(0.0, waveWidth, abs(dist - waveRadius));
                        
                        // ì—¬ëŸ¬ ê²¹ì˜ íŒŒë™
                        float wave2 = 1.0 - smoothstep(0.0, waveWidth * 0.7, abs(dist - waveRadius * 0.6));
                        float ripple = max(wave, wave2 * 0.5);
                        
                        // ê¸°ë³¸ ìƒíƒœ: ê±°ì˜ íˆ¬ëª…
                        float baseAlpha = hex * 0.015 + fresnel * 0.02;
                        
                        // ì¶©ëŒ ì‹œ: ë°ê²Œ ë°œê´‘
                        float impactAlpha = impactStrength * (hex * 0.85 + ripple * 0.9 + fresnel * 0.4);
                        
                        float alpha = baseAlpha + impactAlpha;
                        
                        // ìƒ‰ìƒ
                        vec3 baseColor = vec3(0.0, 0.3, 0.8);
                        vec3 glowColor = vec3(0.0, 0.8, 1.0);
                        vec3 white = vec3(1.0, 1.0, 1.0);
                        
                        vec3 color = mix(baseColor, glowColor, fresnel + impactStrength * 0.3);
                        color = mix(color, white, ripple * impactStrength * 0.8);
                        color += glowColor * hex * impactStrength * 0.4;
                        
                        gl_FragColor = vec4(color, alpha);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                depthTest: false  // â˜… ê¹Šì´ í…ŒìŠ¤íŠ¸ ë¹„í™œì„±í™”
            });
            
            const shieldMesh = new THREE.Mesh(shieldGeo, shieldMat);
            shieldMesh.name = 'hexShield';
            shieldMesh.renderOrder = 999;  // â˜… ë§¨ ë‚˜ì¤‘ì— ë Œë”ë§ (ë‹¤ë¥¸ ê°ì²´ ìœ„ì—)
            
            return shieldMesh;
        }
        
        // â˜…â˜…â˜… ìš°ì£¼ì •ê±°ì¥ì— ë³´í˜¸ë§‰ ì¶”ê°€ (ì´ˆê¸°í™” ì‹œ í˜¸ì¶œ) â˜…â˜…â˜…
        function addShieldsToStations() {
            console.log('ğŸ›¡ï¸ ë³´í˜¸ë§‰ ì´ˆê¸°í™” ì‹œì‘...');
            let count = 0;
            
            satellites.forEach(sat => {
                if (sat.isSpaceStation && sat.mesh && !sat.shieldMesh) {
                    const shield = createHexShieldMesh(STATION_SHIELD_RADIUS);
                    sat.mesh.add(shield);
                    sat.shieldMesh = shield;
                    sat.shieldImpactTime = 0;
                    count++;
                    console.log('ğŸ›¡ï¸ ë³´í˜¸ë§‰ ì¶”ê°€:', sat.name);
                }
            });
            
            // ì—°ë£Œ ì •ê±°ì¥ì—ë„ ë³´í˜¸ë§‰ ì¶”ê°€
            bodies.forEach(body => {
                if (body.isStation && body.mesh && !body.shieldMesh) {
                    const shield = createHexShieldMesh(STATION_SHIELD_RADIUS * 0.7);
                    body.mesh.add(shield);
                    body.shieldMesh = shield;
                    body.shieldImpactTime = 0;
                    count++;
                    console.log('ğŸ›¡ï¸ ì—°ë£Œê¸°ì§€ ë³´í˜¸ë§‰ ì¶”ê°€:', body.name);
                }
            });
            
            console.log('ğŸ›¡ï¸ ë³´í˜¸ë§‰ ì´ˆê¸°í™” ì™„ë£Œ! ì´', count, 'ê°œ');
        }
        
        // â˜…â˜…â˜… ë³´í˜¸ë§‰ ì¶©ëŒ íš¨ê³¼ â˜…â˜…â˜…
        function triggerShieldImpact(station, impactPoint, impactSpeed) {
            if (!station) {
                console.log('âš ï¸ station ì—†ìŒ');
                return;
            }
            
            // â˜… ë³´í˜¸ë§‰ì´ ì—†ìœ¼ë©´ ì¦‰ì‹œ ìƒì„±!
            if (!station.shieldMesh && station.mesh) {
                console.log('ğŸ›¡ï¸ ë³´í˜¸ë§‰ ì¦‰ì‹œ ìƒì„±:', station.name);
                const shield = createHexShieldMesh(STATION_SHIELD_RADIUS);
                station.mesh.add(shield);
                station.shieldMesh = shield;
                station.shieldImpactTime = 0;
            }
            
            if (!station.shieldMesh) {
                console.log('âš ï¸ ë³´í˜¸ë§‰ ìƒì„± ì‹¤íŒ¨:', station.name);
                return;
            }
            
            const shield = station.shieldMesh;
            const mat = shield.material;
            
            // â˜… ì¶©ëŒ ì§€ì ì„ ë¡œì»¬ ì¢Œí‘œë¡œ ë³€í™˜
            const localImpact = shield.worldToLocal(impactPoint.clone());
            
            // â˜… ì‰ì´ë” uniform ì„¤ì •
            mat.uniforms.impactPoint.value.copy(localImpact);
            mat.uniforms.impactStrength.value = 1.0;
            mat.uniforms.time.value = 0;
            
            // í™”ë©´ í”Œë˜ì‹œ íš¨ê³¼
            const overlay = document.getElementById('shield-impact-overlay');
            if (overlay) {
                overlay.classList.add('active');
                setTimeout(() => overlay.classList.remove('active'), 500);
            }
            
            // í˜ì´ë“œì•„ì›ƒ ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘
            station.shieldImpactTime = Date.now();
            
            // íš¨ê³¼ìŒ
            playShieldSound();
            
            console.log('ğŸ›¡ï¸ ë³´í˜¸ë§‰ ì¶©ëŒ!', station.name);
        }
        
        // â˜… ë³´í˜¸ë§‰ ì¶©ëŒ íš¨ê³¼ìŒ
        function playShieldSound() {
            try {
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                
                osc.frequency.value = 800;
                osc.type = 'sine';
                gain.gain.value = 0.15;
                
                osc.start();
                osc.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.3);
                gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);
                osc.stop(audioCtx.currentTime + 0.5);
            } catch (e) { }
        }
        
        // â˜…â˜…â˜… ë³´í˜¸ë§‰ ì• ë‹ˆë©”ì´ì…˜ ì—…ë°ì´íŠ¸ (ë§¤ í”„ë ˆì„) â˜…â˜…â˜…
        function updateShieldAnimations(dt) {
            const fadeDuration = 1.5;  // 1.5ì´ˆ ë™ì•ˆ í˜ì´ë“œì•„ì›ƒ
            
            satellites.forEach(sat => {
                if (sat.shieldMesh && sat.shieldImpactTime > 0) {
                    const elapsed = (Date.now() - sat.shieldImpactTime) / 1000;
                    const mat = sat.shieldMesh.material;
                    
                    // ì‰ì´ë” uniform ì—…ë°ì´íŠ¸
                    mat.uniforms.time.value = elapsed;
                    mat.uniforms.impactStrength.value = Math.max(0, 1.0 - elapsed / fadeDuration);
                    
                    if (elapsed > fadeDuration) {
                        sat.shieldImpactTime = 0;
                        mat.uniforms.impactStrength.value = 0;
                    }
                }
            });
            
            bodies.forEach(body => {
                if (body.shieldMesh && body.shieldImpactTime > 0) {
                    const elapsed = (Date.now() - body.shieldImpactTime) / 1000;
                    const mat = body.shieldMesh.material;
                    
                    // ì‰ì´ë” uniform ì—…ë°ì´íŠ¸
                    mat.uniforms.time.value = elapsed;
                    mat.uniforms.impactStrength.value = Math.max(0, 1.0 - elapsed / fadeDuration);
                    
                    if (elapsed > fadeDuration) {
                        body.shieldImpactTime = 0;
                        mat.uniforms.impactStrength.value = 0;
                    }
                }
            });
        }

        // â˜…â˜…â˜… ë¬´ê¸° ë°œì‚¬ ì‹œìŠ¤í…œ í•¨ìˆ˜ë“¤ â˜…â˜…â˜…

        // íˆ¬ì‚¬ì²´ ìƒì„±
        function createProjectile(position, direction) {
            const geometry = new THREE.CylinderGeometry(0.02, 0.02, 0.3, 8);
            geometry.rotateX(Math.PI / 2);

            const material = new THREE.MeshBasicMaterial({
                color: 0xff6600,
                transparent: true,
                opacity: 0.9
            });

            const projectile = new THREE.Mesh(geometry, material);
            projectile.position.copy(position);
            projectile.lookAt(position.clone().add(direction));

            // ë°œê´‘ íš¨ê³¼
            const glowGeom = new THREE.SphereGeometry(0.06, 8, 8);
            const glowMat = new THREE.MeshBasicMaterial({
                color: 0xffaa00,
                transparent: true,
                opacity: 0.6
            });
            const glow = new THREE.Mesh(glowGeom, glowMat);
            projectile.add(glow);

            scene.add(projectile);

            return {
                mesh: projectile,
                direction: direction.clone().normalize(),
                speed: weaponSystem.projectileSpeed,
                startPos: position.clone(),
                damage: weaponSystem.damage,
                createdAt: Date.now()
            };
        }

        // ë¬´ê¸° ë°œì‚¬
        function fireWeapon() {
            if (!playerShip || !playerShip.mesh || !isPilotMode) return;
            if (window.isDockedToStation || window.isDocking) return;

            const now = Date.now() / 1000;
            if (now - weaponSystem.lastFireTime < weaponSystem.fireRate) return;

            weaponSystem.lastFireTime = now;
            AudioManager.playSFX('sfx_fire');  // â˜… ë°œì‚¬ íš¨ê³¼ìŒ

            // ìš°ì£¼ì„  ìœ„ì¹˜ì™€ ì „ë°© ë°©í–¥
            const shipPos = playerShip.mesh.position.clone();
            const shipForward = new THREE.Vector3(0, 0, -1).applyQuaternion(playerShip.mesh.quaternion);

            // â˜…â˜…â˜… ì¹´ë©”ë¼ê°€ ë°”ë¼ë³´ëŠ” ë°©í–¥ì„ ì§ì ‘ ì‚¬ìš© (í™”ë©´ ì‹­ìì„ ê³¼ ì •í™•íˆ ì¼ì¹˜) â˜…â˜…â˜…
            const aimDirection = new THREE.Vector3();
            camera.getWorldDirection(aimDirection);

            // íˆ¬ì‚¬ì²´ ë°œì‚¬ ìœ„ì¹˜ (ìš°ì£¼ì„  ì „ë°© ì•½ê°„ ì•)
            const firePos = shipPos.clone().add(shipForward.multiplyScalar(0.5));

            // íˆ¬ì‚¬ì²´ ìƒì„±
            const projectile = createProjectile(firePos, aimDirection);
            weaponSystem.projectiles.push(projectile);

            // ìµœëŒ€ ê°œìˆ˜ ì´ˆê³¼ ì‹œ ì˜¤ë˜ëœ ê²ƒ ì œê±°
            while (weaponSystem.projectiles.length > weaponSystem.maxProjectiles) {
                const old = weaponSystem.projectiles.shift();
                if (old.mesh) scene.remove(old.mesh);
            }

            // ë°œì‚¬ íš¨ê³¼ìŒ
            playWeaponSound();
        }

        // ë°œì‚¬ íš¨ê³¼ìŒ
        function playWeaponSound() {
            try {
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();

                osc.connect(gain);
                gain.connect(audioCtx.destination);

                osc.frequency.value = 600;
                osc.type = 'square';
                gain.gain.value = 0.1;

                osc.start();
                osc.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
                osc.stop(audioCtx.currentTime + 0.15);
            } catch (e) { }
        }

        // íˆ¬ì‚¬ì²´ ì—…ë°ì´íŠ¸ ë° ì¶©ëŒ ê²€ì‚¬
        function updateWeaponSystem(dt) {
            if (!isPilotMode) return;

            // ë°œì‚¬ ë²„íŠ¼ ëˆ„ë¥´ê³  ìˆìœ¼ë©´ ì—°ì‚¬
            if (weaponSystem.isFiring) {
                fireWeapon();
            }

            // íˆ¬ì‚¬ì²´ ì´ë™ ë° ì¶©ëŒ ê²€ì‚¬
            const toRemove = [];

            weaponSystem.projectiles.forEach((proj, idx) => {
                if (!proj.mesh) {
                    toRemove.push(idx);
                    return;
                }

                // ì´ë™
                const moveAmount = proj.direction.clone().multiplyScalar(proj.speed * dt);
                proj.mesh.position.add(moveAmount);

                // ì‚¬ê±°ë¦¬ ì²´í¬
                const traveled = proj.mesh.position.distanceTo(proj.startPos);
                if (traveled > weaponSystem.projectileRange) {
                    scene.remove(proj.mesh);
                    toRemove.push(idx);
                    return;
                }

                // ì‹œê°„ ì´ˆê³¼ (5ì´ˆ)
                if (Date.now() - proj.createdAt > 5000) {
                    scene.remove(proj.mesh);
                    toRemove.push(idx);
                    return;
                }

                // ìš°ì£¼ì •ê±°ì¥ ì¶©ëŒ ê²€ì‚¬
                satellites.forEach(sat => {
                    if (!sat.mesh || !sat.isSpaceStation) return;

                    const dist = proj.mesh.position.distanceTo(sat.mesh.position);
                    const hitRadius = 3;  // ì •ê±°ì¥ í”¼ê²© ë°˜ê²½

                    if (dist < hitRadius) {
                        // ë³´í˜¸ë§‰ íš¨ê³¼ íŠ¸ë¦¬ê±°
                        triggerShieldImpact(sat, proj.mesh.position.clone(), proj.speed);

                        // íˆ¬ì‚¬ì²´ ì œê±°
                        scene.remove(proj.mesh);
                        toRemove.push(idx);

                        // ì •ê±°ì¥ ë°˜ê²© íŠ¸ë¦¬ê±°
                        triggerStationCounterAttack(sat);
                    }
                });

                // ì—°ë£Œ ì •ê±°ì¥ ì¶©ëŒ ê²€ì‚¬
                bodies.forEach(body => {
                    if (!body.mesh || !body.isStation) return;

                    const dist = proj.mesh.position.distanceTo(body.mesh.position);
                    const hitRadius = 1.5;

                    if (dist < hitRadius) {
                        triggerShieldImpact(body, proj.mesh.position.clone(), proj.speed);
                        scene.remove(proj.mesh);
                        toRemove.push(idx);
                        triggerStationCounterAttack(body);
                    }
                });
            });

            // ì œê±°í•  íˆ¬ì‚¬ì²´ ì²˜ë¦¬ (ì—­ìˆœìœ¼ë¡œ)
            toRemove.sort((a, b) => b - a);
            toRemove.forEach(idx => {
                weaponSystem.projectiles.splice(idx, 1);
            });

            // ì •ê±°ì¥ ë°˜ê²© ë¹” ì—…ë°ì´íŠ¸
            updateStationDefenseBeams(dt);
        }

        // â˜…â˜…â˜… ì •ê±°ì¥ ë°˜ê²© ì‹œìŠ¤í…œ â˜…â˜…â˜…
        function triggerStationCounterAttack(station) {
            if (!station || !station.mesh) return;
            if (!playerShip || !playerShip.mesh) return;

            const stationId = station.name || 'unknown';
            const now = Date.now() / 1000;

            // ë°œì‚¬ ê°„ê²© ì²´í¬
            if (stationDefense.lastFireTime[stationId] &&
                now - stationDefense.lastFireTime[stationId] < stationDefense.fireRate) {
                return;
            }

            stationDefense.lastFireTime[stationId] = now;

            // í”Œë ˆì´ì–´ì™€ì˜ ê±°ë¦¬ ì²´í¬
            const dist = station.mesh.position.distanceTo(playerShip.mesh.position);
            if (dist > stationDefense.range) return;

            // ë°˜ê²© ë¹” ìƒì„±
            createStationBeam(station, playerShip.mesh.position.clone());
        }

        // ì •ê±°ì¥ ë°˜ê²© ë¹” ìƒì„±
        function createStationBeam(station, targetPos) {
            const stationPos = station.mesh.position.clone();
            const direction = new THREE.Vector3().subVectors(targetPos, stationPos);
            const length = direction.length();

            // ë¹” ì§€ì˜¤ë©”íŠ¸ë¦¬
            const beamGeom = new THREE.CylinderGeometry(0.05, 0.02, length, 8);
            beamGeom.rotateX(Math.PI / 2);
            beamGeom.translate(0, 0, length / 2);

            const beamMat = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.8
            });

            const beam = new THREE.Mesh(beamGeom, beamMat);
            beam.position.copy(stationPos);
            beam.lookAt(targetPos);

            // ê¸€ë¡œìš° íš¨ê³¼
            const glowGeom = new THREE.CylinderGeometry(0.1, 0.05, length, 8);
            glowGeom.rotateX(Math.PI / 2);
            glowGeom.translate(0, 0, length / 2);

            const glowMat = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.3
            });

            const glow = new THREE.Mesh(glowGeom, glowMat);
            beam.add(glow);

            scene.add(beam);

            // ë¹” ë°ì´í„° ì €ì¥
            const beamData = {
                mesh: beam,
                station: station,
                targetPos: targetPos.clone(),
                createdAt: Date.now(),
                duration: stationDefense.beamDuration * 1000,
                damage: stationDefense.damage,
                hitApplied: false
            };

            stationDefense.beams.push(beamData);

            // ë¹” ë°œì‚¬ ì‚¬ìš´ë“œ
            playBeamSound();
        }

        // ë¹” ì‚¬ìš´ë“œ
        function playBeamSound() {
            try {
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();

                osc.connect(gain);
                gain.connect(audioCtx.destination);

                osc.frequency.value = 1200;
                osc.type = 'sine';
                gain.gain.value = 0.15;

                osc.start();
                osc.frequency.exponentialRampToValueAtTime(400, audioCtx.currentTime + 0.3);
                gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.4);
                osc.stop(audioCtx.currentTime + 0.4);
            } catch (e) { }
        }

        // ì •ê±°ì¥ ë°˜ê²© ë¹” ì—…ë°ì´íŠ¸
        function updateStationDefenseBeams(dt) {
            const toRemove = [];

            stationDefense.beams.forEach((beamData, idx) => {
                const elapsed = Date.now() - beamData.createdAt;

                // ì§€ì†ì‹œê°„ ì¢…ë£Œ
                if (elapsed > beamData.duration) {
                    if (beamData.mesh) scene.remove(beamData.mesh);
                    toRemove.push(idx);
                    return;
                }

                // í˜ì´ë“œì•„ì›ƒ
                const progress = elapsed / beamData.duration;
                if (beamData.mesh && beamData.mesh.material) {
                    beamData.mesh.material.opacity = 0.8 * (1 - progress);
                }

                // í”¼ê²© íŒì • (1íšŒë§Œ)
                if (!beamData.hitApplied && playerShip && playerShip.mesh) {
                    const dist = beamData.targetPos.distanceTo(playerShip.mesh.position);
                    if (dist < 2) {
                        // í”Œë ˆì´ì–´ í”¼ê²©
                        applyDamageToPlayer(beamData.damage);
                        beamData.hitApplied = true;
                    }
                }
            });

            // ì œê±°
            toRemove.sort((a, b) => b - a);
            toRemove.forEach(idx => {
                stationDefense.beams.splice(idx, 1);
            });
        }

        // â˜…â˜…â˜… í”Œë ˆì´ì–´ ë°ë¯¸ì§€ ì²˜ë¦¬ â˜…â˜…â˜…
        function applyDamageToPlayer(damage) {
            if (!playerShip) return;

            // ë‚´êµ¬ë„ ê°ì†Œ
            if (playerShip.hull !== undefined) {
                playerShip.hull = Math.max(0, playerShip.hull - damage);
            }

            // í™”ë©´ í”Œë˜ì‹œ
            const overlay = document.getElementById('weapon-hit-overlay');
            if (overlay) {
                overlay.classList.add('active');
                setTimeout(() => overlay.classList.remove('active'), 200);
            }

            // ê²½ê³  ë©”ì‹œì§€
            showMsg(`âš ï¸ í”¼ê²©! ë‚´êµ¬ë„: ${Math.round(playerShip.hull)}%`);

            // ë‚´êµ¬ë„ 0ì´ë©´ íŒŒê´´
            if (playerShip.hull <= 0) {
                handleShipDestruction();
            }
        }

        // â˜…â˜…â˜… ìš°ì£¼ì„  íŒŒê´´ ì²˜ë¦¬ (ë‚´êµ¬ë„ 0) - ìš°ì£¼ì •ê±°ì¥ ë¦¬ìŠ¤í° â˜…â˜…â˜…
        function handleShipDestruction() {
            // ì´ë¯¸ íŒŒê´´ ì²˜ë¦¬ ì¤‘ì´ë©´ ë¬´ì‹œ
            if (window.isShipDestroying) return;
            window.isShipDestroying = true;

            showMsg('ğŸ’¥ ìš°ì£¼ì„ ì´ íŒŒê´´ë˜ì—ˆìŠµë‹ˆë‹¤!');

            // íŒŒê´´ íš¨ê³¼ (í­ë°œ)
            let explosionPos = new THREE.Vector3(0, 0, 0);
            if (playerShip && playerShip.mesh) {
                explosionPos = playerShip.mesh.position.clone();
                createExplosionEffect(explosionPos);
            }

            // íŒŒê´´ëœ ìš°ì£¼ì„  ì •ë³´ ì €ì¥
            const destroyedShipName = currentShipType ? getShipName(currentShipType) : 'ìš°ì£¼ì„ ';

            // í™”ë©´ í”Œë˜ì‹œ (ë¹¨ê°„ìƒ‰)
            const flashOverlay = document.createElement('div');
            flashOverlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(255, 0, 0, 0.8); z-index: 99999;
                pointer-events: none; transition: opacity 1s;
            `;
            document.body.appendChild(flashOverlay);

            setTimeout(() => {
                flashOverlay.style.opacity = '0';
                setTimeout(() => flashOverlay.remove(), 1000);
            }, 500);

            // 2ì´ˆ í›„ ë¦¬ìŠ¤í° ì²˜ë¦¬
            setTimeout(() => {
                // ì¡°ì¢…ì„ ì œê±°
                if (cockpitGroup && playerShip && playerShip.mesh) {
                    playerShip.mesh.remove(cockpitGroup);
                    cockpitGroup = null;
                }

                // ì¹´ë©”ë¼ ë¶„ë¦¬
                if (playerShip && playerShip.mesh && camera.parent === playerShip.mesh) {
                    playerShip.mesh.remove(camera);
                }

                // ìš°ì£¼ì„  ì œê±°
                if (playerShip && playerShip.mesh) {
                    scene.remove(playerShip.mesh);
                }

                // ì¹´ë©”ë¼ ì¬ë°°ì¹˜
                scene.add(camera);

                // â˜… ê°€ì¥ ê°€ê¹Œìš´ ìš°ì£¼ì •ê±°ì¥ ì°¾ê¸°
                let nearestStation = null;
                let nearestDist = Infinity;
                window.spaceStations?.forEach(station => {
                    if (station && station.mesh) {
                        const dist = explosionPos.distanceTo(station.mesh.position);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestStation = station;
                        }
                    }
                });

                // ì •ê±°ì¥ ê·¼ì²˜ë¡œ ì¹´ë©”ë¼ ì´ë™
                if (nearestStation && nearestStation.mesh) {
                    const stationPos = nearestStation.mesh.position.clone();
                    camera.position.copy(stationPos).add(new THREE.Vector3(5, 3, 5));
                    controls.target.copy(stationPos);

                    // ì •ê±°ì¥ í¬ì»¤ìŠ¤
                    focusObject({ mesh: nearestStation.mesh, name: nearestStation.name, type: 'station' });
                } else {
                    camera.position.copy(explosionPos).add(new THREE.Vector3(10, 5, 10));
                    controls.target.copy(explosionPos);
                }

                camera.near = 0.01;
                camera.updateProjectionMatrix();

                // ì£¼ì°¨ëœ ìš°ì£¼ì„  ì •ë³´ ì‚­ì œ
                clearParkedShip();

                // ì €ì¥ëœ ìƒíƒœ ì´ˆê¸°í™”
                savedShipState = null;
                playerShip = null;

                // ë„í‚¹ëœ ìš°ì£¼ì„  ë‹¤ì‹œ í‘œì‹œ
                if (dockedShipMesh) dockedShipMesh.visible = true;

                // HUD ë¹„í™œì„±í™”
                document.getElementById('cockpit-hud')?.classList.remove('active');
                document.getElementById('interior-hud')?.classList.remove('active');
                document.getElementById('observatory-hud')?.classList.remove('active');

                // ê¸°ë³¸ UI ë³µì›
                document.getElementById('top-bar').style.display = '';
                document.getElementById('nav-container').style.display = '';
                if (window.gameMode !== 'multi') {
                    document.getElementById('spawn-dock').style.display = '';
                }
                document.getElementById('chat-toggle').style.display = '';
                document.getElementById('board-ship-btn').style.display = 'none';

                // ê²½ê³  ë¹„í™œì„±í™”
                stopGravityWarning();

                // íŠ¹ìˆ˜ëŠ¥ë ¥ ìƒíƒœ ì´ˆê¸°í™”
                shipAbility.cooldown = 0;
                shipAbility.shieldActive = false;
                shipAbility.afterburnerActive = false;

                // ëª¨ë“œ ì´ˆê¸°í™”
                isPilotMode = false;
                document.body.classList.remove('pilot-mode');
                isCockpitView = false;
                isInteriorMode = false;
                isObservatoryMode = false;
                controls.enabled = true;

                // íŒŒê´´ í”Œë˜ê·¸ í•´ì œ
                window.isShipDestroying = false;

                // ë¦¬ìŠ¤í° ë©”ì‹œì§€
                showMsg(`âš ï¸ ${destroyedShipName}ì´(ê°€) íŒŒê´´ë˜ì—ˆìŠµë‹ˆë‹¤! ìš°ì£¼ì •ê±°ì¥ì—ì„œ ìƒˆ ìš°ì£¼ì„ ì„ íƒ‘ìŠ¹í•˜ì„¸ìš”.`);

                // ARIA ì•ˆë‚´ ë©”ì‹œì§€
                if (typeof aiTypeMessage === 'function') {
                    setTimeout(() => {
                        aiTypeMessage('íŒŒì¼ëŸ¿ë‹˜, ì•ˆíƒ€ê¹ê²Œë„ ìš°ì£¼ì„ ì´ íŒŒê´´ë˜ì—ˆìŠµë‹ˆë‹¤. ê°€ê¹Œìš´ ìš°ì£¼ì •ê±°ì¥ì—ì„œ ìƒˆ ìš°ì£¼ì„ ì„ ë°›ìœ¼ì‹¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì •ê±°ì¥ì„ í´ë¦­í•˜ì—¬ ë„í‚¹ ë©”ë‰´ì—ì„œ "íƒ‘ìŠ¹"ì„ ì„ íƒí•˜ì„¸ìš”.');
                    }, 2000);
                }
            }, 2000);
        }

        // â˜…â˜…â˜… í­ë°œ íš¨ê³¼ (ê°œì„ ) â˜…â˜…â˜…
        function createExplosionEffect(position) {
            const particleCount = 60;  // ë” ë§ì€ íŒŒí‹°í´
            const particles = [];

            // ì¤‘ì•™ ì„¬ê´‘
            const flashGeo = new THREE.SphereGeometry(0.5, 16, 16);
            const flashMat = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 1
            });
            const flash = new THREE.Mesh(flashGeo, flashMat);
            flash.position.copy(position);
            scene.add(flash);

            // íŒŒí‹°í´ ìƒì„±
            for (let i = 0; i < particleCount; i++) {
                const size = Math.random() * 0.15 + 0.05;
                const geom = new THREE.SphereGeometry(size, 4, 4);

                // ë‹¤ì–‘í•œ ìƒ‰ìƒ (ì£¼í™©, ë…¸ë‘, ë¹¨ê°•, í°ìƒ‰)
                const colors = [0xff6600, 0xffaa00, 0xff3300, 0xffff00, 0xffffff];
                const mat = new THREE.MeshBasicMaterial({
                    color: colors[Math.floor(Math.random() * colors.length)],
                    transparent: true,
                    opacity: 1
                });
                const particle = new THREE.Mesh(geom, mat);
                particle.position.copy(position);

                const speed = Math.random() * 8 + 3;
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2
                ).normalize().multiplyScalar(speed);

                particle.userData.velocity = velocity;
                particle.userData.createdAt = Date.now();
                particle.userData.lifetime = Math.random() * 1.5 + 1;  // 1~2.5ì´ˆ

                scene.add(particle);
                particles.push(particle);
            }

            // íŒŒí¸ (ì”í•´)
            for (let i = 0; i < 15; i++) {
                const geom = new THREE.BoxGeometry(
                    Math.random() * 0.2 + 0.05,
                    Math.random() * 0.2 + 0.05,
                    Math.random() * 0.2 + 0.05
                );
                const mat = new THREE.MeshBasicMaterial({
                    color: 0x444444,
                    transparent: true,
                    opacity: 1
                });
                const debris = new THREE.Mesh(geom, mat);
                debris.position.copy(position);
                debris.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);

                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2
                ).normalize().multiplyScalar(Math.random() * 3 + 1);

                debris.userData.velocity = velocity;
                debris.userData.rotSpeed = new THREE.Vector3(
                    (Math.random() - 0.5) * 5,
                    (Math.random() - 0.5) * 5,
                    (Math.random() - 0.5) * 5
                );
                debris.userData.createdAt = Date.now();
                debris.userData.lifetime = Math.random() * 2 + 2;  // 2~4ì´ˆ

                scene.add(debris);
                particles.push(debris);
            }

            // íŒŒí‹°í´ ì• ë‹ˆë©”ì´ì…˜
            const animateExplosion = () => {
                const now = Date.now();
                let allDone = true;

                // ì„¬ê´‘ ì• ë‹ˆë©”ì´ì…˜
                const flashElapsed = (now - particles[0]?.userData.createdAt) / 1000;
                if (flash && flashElapsed < 0.3) {
                    flash.scale.setScalar(1 + flashElapsed * 10);
                    flash.material.opacity = 1 - flashElapsed / 0.3;
                } else if (flash.parent) {
                    scene.remove(flash);
                }

                particles.forEach(p => {
                    if (!p.userData.createdAt) return;
                    const elapsed = (now - p.userData.createdAt) / 1000;
                    const lifetime = p.userData.lifetime || 1;

                    if (elapsed < lifetime) {
                        allDone = false;
                        p.position.add(p.userData.velocity.clone().multiplyScalar(0.016));
                        p.userData.velocity.multiplyScalar(0.97);
                        p.material.opacity = Math.max(0, 1 - elapsed / lifetime);

                        // íŒŒí¸ íšŒì „
                        if (p.userData.rotSpeed) {
                            p.rotation.x += p.userData.rotSpeed.x * 0.016;
                            p.rotation.y += p.userData.rotSpeed.y * 0.016;
                            p.rotation.z += p.userData.rotSpeed.z * 0.016;
                        } else {
                            p.scale.setScalar(1 + elapsed * 1.5);
                        }
                    } else {
                        if (p.parent) scene.remove(p);
                    }
                });

                if (!allDone) requestAnimationFrame(animateExplosion);
            };

            animateExplosion();

            // í­ë°œìŒ íš¨ê³¼
            try {
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                const noise = audioCtx.createBufferSource();

                // í™”ì´íŠ¸ ë…¸ì´ì¦ˆ ë²„í¼
                const bufferSize = audioCtx.sampleRate * 0.5;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                noise.buffer = buffer;

                const noiseGain = audioCtx.createGain();
                noise.connect(noiseGain);
                noiseGain.connect(audioCtx.destination);

                noiseGain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);

                noise.start();
                noise.stop(audioCtx.currentTime + 0.5);
            } catch (e) { }
        }

        // â˜…â˜…â˜… ìš°ì£¼ì„ ê³¼ ì •ê±°ì¥/ì˜¤ë¸Œì íŠ¸ ê°„ ì¶©ëŒ ë¬¼ë¦¬ â˜…â˜…â˜…
        function checkStationCollisions() {
            if (!playerShip || !playerShip.mesh || !isPilotMode) return;
            if (window.isDockedToStation || window.isDocking) return;  // ë„í‚¹ ì¤‘ì´ë©´ ë¬´ì‹œ
            
            // â˜… ì¶©ëŒ ì¿¨ë‹¤ìš´ (0.5ì´ˆ)
            if (window.lastStationCollision && Date.now() - window.lastStationCollision < 500) {
                return;
            }
            
            const shipPos = playerShip.mesh.position;
            const shipSpeed = Math.abs(playerShip.speed);
            const shipRadius = 0.1 * (playerShip.sizeScale || 1);  // ìš°ì£¼ì„  ì¶©ëŒ ë°˜ê²½
            
            const collidables = getCollidableObjects();
            
            collidables.forEach(obj => {
                if (!obj.mesh) return;
                
                const objPos = obj.mesh.position;
                const dist = shipPos.distanceTo(objPos);
                const collisionDist = shipRadius + obj.radius;
                
                // ì¶©ëŒ ê°ì§€
                if (dist < collisionDist) {
                    // ì¶©ëŒ ì§€ì  ê³„ì‚°
                    const impactPoint = shipPos.clone().add(
                        new THREE.Vector3().subVectors(objPos, shipPos).normalize().multiplyScalar(shipRadius)
                    );
                    
                    // ì •ê±°ì¥ì¸ ê²½ìš° - ë³´í˜¸ë§‰ ë°œë™ + íŠ•ê²¨ë‚˜ê°
                    if (obj.isStation) {
                        // ë³´í˜¸ë§‰ íš¨ê³¼ ë°œë™
                        triggerShieldImpact(obj.ref, impactPoint, shipSpeed);
                        
                        // â˜… ë‚´êµ¬ë„ ê°ì†Œ (ì†ë„ ë¹„ë¡€)
                        const damage = Math.min(shipSpeed * 0.5, 30);  // ìµœëŒ€ 30 ë°ë¯¸ì§€
                        if (damage > 0) {
                            playerShip.hull = Math.max(0, playerShip.hull - damage);
                            showMsg(`ğŸ’¥ ì •ê±°ì¥ ë³´í˜¸ë§‰ ì¶©ëŒ! ë‚´êµ¬ë„ -${damage.toFixed(0)}`);
                            
                            // ë‚´êµ¬ë„ 0ì´ë©´ íŒŒê´´
                            if (playerShip.hull <= 0) {
                                triggerShipDestruction({ name: obj.name, mesh: obj.mesh, radius: obj.radius });
                                return;
                            }
                        }
                        
                        // â˜…â˜…â˜… ë‹¨ìˆœ ë°˜ë°œ ë¬¼ë¦¬ â˜…â˜…â˜…
                        
                        // ì¶©ëŒë©´ ë²•ì„  (ì •ê±°ì¥ â†’ ìš°ì£¼ì„ )
                        const normal = new THREE.Vector3().subVectors(shipPos, objPos).normalize();
                        
                        // ë°˜ë°œ ê³„ìˆ˜
                        const restitution = 0.5;
                        
                        // â˜… ì¶©ë¶„íˆ ë°€ì–´ë‚´ê¸° (ì¶©ëŒ ê±°ë¦¬ + ì—¬ìœ )
                        const safeDistance = collisionDist + 0.5;
                        const pushAmount = safeDistance - dist;
                        playerShip.mesh.position.add(normal.clone().multiplyScalar(pushAmount));
                        
                        // â˜… ì†ë„ë¥¼ ìŒìˆ˜ë¡œ (ë’¤ë¡œ ë°€ë ¤ë‚¨) + ê°ì†
                        playerShip.speed = -Math.abs(playerShip.speed) * restitution;
                        
                        // â˜… ì¶©ëŒ ì¿¨ë‹¤ìš´ (0.5ì´ˆê°„ ì¬ì¶©ëŒ ë°©ì§€)
                        window.lastStationCollision = Date.now();
                        
                    } else {
                        // ì£¼ì°¨ëœ ìš°ì£¼ì„  ë“± - ì¼ë°˜ ì¶©ëŒ ë¬¼ë¦¬
                        const normal = new THREE.Vector3().subVectors(shipPos, objPos).normalize();
                        const overlap = collisionDist - dist;
                        
                        // ì§ˆëŸ‰ ë¹„ìœ¨ì— ë”°ë¥¸ ë°€ì–´ë‚´ê¸°
                        const totalMass = playerShip.mass + obj.mass;
                        const shipPushRatio = obj.mass / totalMass;
                        const objPushRatio = playerShip.mass / totalMass;
                        
                        // ìœ„ì¹˜ ì¡°ì •
                        playerShip.mesh.position.add(normal.clone().multiplyScalar(overlap * shipPushRatio));
                        if (obj.mesh.position) {
                            obj.mesh.position.sub(normal.clone().multiplyScalar(overlap * objPushRatio));
                        }
                        
                        // ë‚´êµ¬ë„ ê°ì†Œ (ì‘ì€ í”¼í•´)
                        const damage = Math.min(shipSpeed * 0.2, 10);
                        if (damage > 0.5) {
                            playerShip.hull = Math.max(0, playerShip.hull - damage);
                            showMsg(`âš ï¸ ì¶©ëŒ! ë‚´êµ¬ë„ -${damage.toFixed(0)}`);
                        }
                        
                        // ì†ë„ ê°ì†Œ
                        playerShip.speed *= 0.5;
                    }
                }
            });
        }
        
        // â˜…â˜…â˜… ë‚´êµ¬ë„ HUD ì—…ë°ì´íŠ¸ â˜…â˜…â˜…
        function updateHullHUD() {
            if (!playerShip) return;
            
            const maxHull = SHIP_CONFIG.maxHull;
            const currentHull = playerShip.hull;
            const percent = (currentHull / maxHull) * 100;
            
            // ê²Œì´ì§€ ì—…ë°ì´íŠ¸
            const hullFill = document.getElementById('hull-fill');
            const hullVal = document.getElementById('hull-val');
            const hullGauge = document.getElementById('hull-gauge');
            
            if (hullFill) {
                hullFill.style.height = percent + '%';
            }
            if (hullVal) {
                hullVal.textContent = Math.round(currentHull);
            }
            
            // ìœ„í—˜ ìƒíƒœ í‘œì‹œ
            if (hullGauge) {
                if (percent < 30) {
                    hullGauge.classList.add('critical');
                } else {
                    hullGauge.classList.remove('critical');
                }
            }
            
            // ê²½ê³  í‘œì‹œ
            const warnHull = document.getElementById('warn-hull');
            if (warnHull) {
                if (percent < 30) {
                    warnHull.style.display = 'block';
                    warnHull.classList.add('active');
                } else {
                    warnHull.style.display = 'none';
                    warnHull.classList.remove('active');
                }
            }
        }
        
        // â˜…â˜…â˜… ì •ê±°ì¥ ë³´í˜¸ë§‰ ì´ˆê¸°í™” í”Œë˜ê·¸ â˜…â˜…â˜…
        window.stationShieldsInitialized = false;
        
        // â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…
        
        function triggerShipDestruction(collidedBody) {
            // ì‰´ë“œê°€ ìˆìœ¼ë©´ ì‰´ë“œë¡œ ë°©ì–´
            if (shipAbility.shieldActive && (currentShipType.special === 'shield' || currentShipType.special === 'allInOne')) {
                shipAbility.shieldActive = false;
                const shield = playerShip.mesh.getObjectByName('shield');
                if (shield) shield.visible = false;
                showMsg(`ğŸ›¡ï¸ ì‰´ë“œë¡œ ${collidedBody.name}ê³¼ì˜ ì¶©ëŒì„ ë°©ì–´í–ˆìŠµë‹ˆë‹¤!`);
                
                // ì¶©ëŒ ë°˜ë°œ
                const pushDir = new THREE.Vector3().subVectors(playerShip.mesh.position, collidedBody.mesh.position).normalize();
                playerShip.mesh.position.add(pushDir.multiplyScalar(collidedBody.radius * 2));
                playerShip.velocity.set(0, 0, 0);
                playerShip.speed = 0;
                return;
            }
            
            // íŒŒê´´ëœ ìš°ì£¼ì„  ì´ë¦„ ì €ì¥
            const destroyedShipName = getShipName(currentShipType);
            const destroyedShipId = currentShipType.id;
            
            // ì¶©ëŒë¡œ ì¸í•œ ìš°ì£¼ì„  íŒŒê´´
            showMsg(`ğŸ’¥ ${collidedBody.name}ê³¼ ì¶©ëŒ! ${destroyedShipName}ì´(ê°€) íŒŒê´´ë˜ì—ˆìŠµë‹ˆë‹¤!`);
            
            // â˜… ì¹´ë©”ë¼ ìœ„ì¹˜ ì €ì¥ í›„ ë¶„ë¦¬
            let cameraTargetPos = new THREE.Vector3();
            if (playerShip && playerShip.mesh) {
                cameraTargetPos = playerShip.mesh.position.clone();
                
                // ì¡°ì¢…ì„ ì œê±°
                if (cockpitGroup) {
                    playerShip.mesh.remove(cockpitGroup);
                    cockpitGroup = null;
                }
                
                // ì¹´ë©”ë¼ ë¶„ë¦¬
                if (camera.parent === playerShip.mesh) {
                    playerShip.mesh.remove(camera);
                }
                
                // ì”¬ì—ì„œ ìš°ì£¼ì„  ì¦‰ì‹œ ì œê±°
                scene.remove(playerShip.mesh);
            }
            
            // ì¹´ë©”ë¼ ì¬ë°°ì¹˜
            scene.add(camera);
            camera.position.copy(cameraTargetPos).add(new THREE.Vector3(10, 5, 10));
            controls.target.copy(cameraTargetPos);
            camera.near = 0.01;
            camera.updateProjectionMatrix();
            
            // í•´ë‹¹ ìš°ì£¼ì„  ì†Œìœ ê¶Œ ì‚­ì œ (ë‹¤ì‹œ êµ¬ë§¤í•´ì•¼ í•¨)
            if (window.mpUser && destroyedShipId !== 'shuttle') {
                const ships = window.mpUser.unlockedShips || [];
                const idx = ships.indexOf(destroyedShipId);
                if (idx > -1) {
                    ships.splice(idx, 1);
                    window.mpUser.unlockedShips = ships;
                    if (window.supabaseClient) {
                        window.supabaseClient
                            .from('profiles')
                            .update({ unlocked_ships: ships })
                            .eq('id', window.mpUserId)
                            .then(() => console.log('ìš°ì£¼ì„  ì†Œìœ ê¶Œ ì‚­ì œë¨'))
                            .catch(e => console.warn('ìš°ì£¼ì„  ì†Œìœ ê¶Œ ì‚­ì œ ì‹¤íŒ¨:', e));
                    }
                }
            }
            
            // ì£¼ì°¨ëœ ìš°ì£¼ì„  ì •ë³´ ì‚­ì œ
            clearParkedShip();
            
            // ì €ì¥ëœ ìƒíƒœ ì´ˆê¸°í™”
            savedShipState = null;
            selectedShipIndex = 0;
            currentShipType = SHIP_TYPES[0];
            window.currentShipType = currentShipType;  // â˜… ì „ì—­ ì—…ë°ì´íŠ¸
            playerShip = null;
            
            // ë„í‚¹ëœ ìš°ì£¼ì„  ë‹¤ì‹œ í‘œì‹œ
            if (dockedShipMesh) dockedShipMesh.visible = true;
            
            // â˜… ì¡°ì¢…ì„ HUD ë¹„í™œì„±í™”
            document.getElementById('cockpit-hud').classList.remove('active');
            document.getElementById('interior-hud').classList.remove('active');
            document.getElementById('observatory-hud').classList.remove('active');
            
            // â˜… ê¸°ë³¸ UI ë³µì›
            document.getElementById('top-bar').style.display = '';
            document.getElementById('nav-container').style.display = '';
            // ë©€í‹°ëª¨ë“œì—ì„œëŠ” ì²œì²´ ìƒì„± ë²„íŠ¼ ìˆ¨ê¹€ ìœ ì§€
            if (window.gameMode !== 'multi') {
                document.getElementById('spawn-dock').style.display = '';
            }
            document.getElementById('chat-toggle').style.display = '';
            document.getElementById('board-ship-btn').style.display = 'none';
            
            // ê²½ê³  ë¹„í™œì„±í™”
            stopGravityWarning();
            
            // íŠ¹ìˆ˜ëŠ¥ë ¥ ìƒíƒœ ì´ˆê¸°í™”
            shipAbility.cooldown = 0;
            shipAbility.shieldActive = false;
            shipAbility.afterburnerActive = false;
            
            // ëª¨ë“œ ì´ˆê¸°í™”
            isPilotMode = false;
            document.body.classList.remove('pilot-mode');
            isCockpitView = false;
            isInteriorMode = false;
            isObservatoryMode = false;
            controls.enabled = true;
            
            // ì¶©ëŒ í”Œë˜ê·¸ ì„¤ì •
            window.lastExitReason = 'collision';
            window.destroyedShipName = destroyedShipName;
            
            // ì¶©ëŒ ë©”ì‹œì§€ í‘œì‹œ
            setTimeout(() => {
                showMsg(`âš ï¸ ${destroyedShipName}ì´(ê°€) íŒŒê´´ë˜ì—ˆìŠµë‹ˆë‹¤! ìš°ì£¼ì •ê±°ì¥ì—ì„œ ìƒˆ ìš°ì£¼ì„ ì„ êµ¬ë§¤í•˜ì„¸ìš”.`);
            }, 1500);
        }
        
        function updateShipAutopilot(dt) {
            if (!autopilot.engaged || !shipTargetBody || !shipTargetBody.mesh || !playerShip || !playerShip.mesh) return;
            
            const targetPos = shipTargetBody.mesh.position.clone();
            const dist = playerShip.mesh.position.distanceTo(targetPos);
            const safeDist = (shipTargetBody.radius || 1) * 1.5;  // ë” ê°€ê¹Œì´ ë„ì°© (1.5ë°° ë°˜ì§€ë¦„)
            const decelDist = (playerShip.speed * playerShip.speed) / (2 * SHIP_CONFIG.deceleration) + safeDist;
            
            // ETA ê³„ì‚° (ì‹¤ì œ ëŒ€ê¸° ì‹œê°„ìœ¼ë¡œ ë³€í™˜)
            const gameTimeETA = playerShip.speed > 0.1 ? dist / playerShip.speed : Infinity;
            // timeScaleì´ 0.1ì´ë©´ ì‹¤ì œë¡œ 10ë°° ë” ê¸°ë‹¤ë ¤ì•¼ í•¨
            currentETA = CONFIG.timeScale > 0 ? gameTimeETA / CONFIG.timeScale : gameTimeETA;
            
            // ëª©í‘œ ë°©í–¥ìœ¼ë¡œ íšŒì „ (ë¹ ë¥¸ ë°©í–¥ ì „í™˜)
            const dir = new THREE.Vector3().subVectors(targetPos, playerShip.mesh.position).normalize();
            const tq = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, -1), dir);
            playerShip.mesh.quaternion.slerp(tq, dt * 5.0);  // 10ë°° ë¹ ë¥¸ íšŒì „
            playerShip.euler.setFromQuaternion(playerShip.mesh.quaternion, 'YXZ');
            
            if (autopilot.phase === 'accelerating') {
                if (playerShip.fuel > 0 && playerShip.speed < SHIP_CONFIG.maxSpeed * 0.9 && dist > decelDist * 1.5) {
                    playerShip.speed += SHIP_CONFIG.acceleration * dt;
                    playerShip.fuel -= SHIP_CONFIG.fuelConsumption * dt;
                    document.getElementById('ap-phase').textContent = t('accelerating');
                } else if (dist > decelDist) {
                    autopilot.phase = 'cruising';
                } else {
                    autopilot.phase = 'decelerating';
                }
            } else if (autopilot.phase === 'cruising') {
                document.getElementById('ap-phase').textContent = t('cruising');
                if (dist <= decelDist) {
                    autopilot.phase = 'decelerating';
                }
            } else if (autopilot.phase === 'decelerating') {
                document.getElementById('ap-phase').textContent = t('decelerating');
                document.getElementById('warn-decel').classList.add('active');
                if (playerShip.speed > 1) {
                    playerShip.speed -= SHIP_CONFIG.deceleration * dt;
                    playerShip.fuel -= SHIP_CONFIG.fuelConsumption * dt * 0.5;
                }
                if (dist <= safeDist || playerShip.speed < 1) {
                    autopilot.phase = 'arrived';
                    playerShip.speed = 0;
                    document.getElementById('warn-decel').classList.remove('active');
                    showMsg(`âœ… ${shipTargetBody.name} ë„ì°©! ì„ ë‚´/ì „ë§ëŒ€ ì´ìš© ê°€ëŠ¥`);
                }
            } else if (autopilot.phase === 'arrived') {
                document.getElementById('ap-phase').textContent = t('arrived');
                playerShip.speed = 0;
            }
            
            updateETADisplay();
        }
        
        function showOrbitPrompt(targetBody) {
            const prompt = document.getElementById('orbit-prompt');
            document.getElementById('orbit-target-name').textContent = targetBody.name;
            prompt.classList.add('active');
            showMsg(`ğŸŒ ${targetBody.name} ê¶¤ë„ ì¡°ì„ ê³ ì • ê°€ëŠ¥!`);
        }
        
        function cancelOrbitPrompt() {
            document.getElementById('orbit-prompt').classList.remove('active');
            autopilot.phase = 'arrived';
            shipInputs.emergencyReverse = true;
            showMsg(t('orbitEntryCanceled'));
        }
        
        function updateOrbitFlight(dt) {
            if (!orbitState.inOrbit || !orbitState.orbitBody || !orbitState.orbitBody.mesh || !playerShip || !playerShip.mesh) return;
            
            // ê°ë„ ì—…ë°ì´íŠ¸
            orbitState.orbitAngle += orbitState.orbitSpeed * dt * CONFIG.timeScale;
            
            // ìƒˆ ìœ„ì¹˜ ê³„ì‚°
            const bodyPos = orbitState.orbitBody.mesh.position;
            const newX = bodyPos.x + Math.cos(orbitState.orbitAngle) * orbitState.orbitRadius;
            const newZ = bodyPos.z + Math.sin(orbitState.orbitAngle) * orbitState.orbitRadius;
            playerShip.mesh.position.set(newX, bodyPos.y, newZ);
            
            // ì¡°ì„ ê³ ì • (í–‰ì„±ì„ ë°”ë¼ë´„) - ë¶€ë“œëŸ½ê²Œ íšŒì „
            if (orbitState.tidalLocked) {
                const dir = new THREE.Vector3().subVectors(bodyPos, playerShip.mesh.position).normalize();
                const targetQuat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, -1), dir);
                playerShip.mesh.quaternion.slerp(targetQuat, 0.1);
                playerShip.euler.setFromQuaternion(playerShip.mesh.quaternion, 'YXZ');
            }
        }
        
        // ë¬¼ë¦¬ ê¸°ë°˜ ê¶¤ë„ ì§„ì… ì—…ë°ì´íŠ¸ (ìë™í•­ë²•ìš©)
        function updateOrbitInsertion(dt) {
            if (!orbitState.enteringOrbit || !orbitState.orbitBody || !playerShip || !playerShip.mesh) return;
            
            orbitState.orbitTransitionTime += dt;
            const transitionDuration = 5.0;  // 5ì´ˆê°„ ì „í™˜
            const progress = Math.min(1, orbitState.orbitTransitionTime / transitionDuration);
            
            // ë¶€ë“œëŸ¬ìš´ ì´ì§•
            const eased = 1 - Math.pow(1 - progress, 3);
            
            // ê¶¤ë„ ì†ë„ ì ì§„ì  ì¦ê°€
            orbitState.currentOrbitSpeed = orbitState.targetOrbitSpeed * eased;
            orbitState.orbitSpeed = orbitState.currentOrbitSpeed;
            
            // ìš°ì£¼ì„  ì§ì§„ ì†ë„ ì ì§„ì  ê°ì†Œ
            if (playerShip.speed > 0.1) {
                playerShip.speed *= (1 - dt * 2);
            } else {
                playerShip.speed = 0;
            }
            
            // ê¶¤ë„ ê°ë„ ì—…ë°ì´íŠ¸ (ì ‘ì„  ë°©í–¥ ì´ë™)
            orbitState.orbitAngle += orbitState.currentOrbitSpeed * dt;
            
            // ìš°ì£¼ì„  ìœ„ì¹˜ ì—…ë°ì´íŠ¸ (ê¶¤ë„ ìƒì—ì„œ)
            const targetCenter = orbitState.orbitBody.mesh.position;
            const newX = targetCenter.x + Math.cos(orbitState.orbitAngle) * orbitState.orbitRadius;
            const newZ = targetCenter.z + Math.sin(orbitState.orbitAngle) * orbitState.orbitRadius;
            
            // í˜„ì¬ ìœ„ì¹˜ì—ì„œ ìƒˆ ìœ„ì¹˜ë¡œ ë¶€ë“œëŸ½ê²Œ ì´ë™
            playerShip.mesh.position.x += (newX - playerShip.mesh.position.x) * dt * 2;
            playerShip.mesh.position.z += (newZ - playerShip.mesh.position.z) * dt * 2;
            playerShip.mesh.position.y = targetCenter.y;
            
            // ì¡°ì„ ê³ ì •: í–‰ì„±ì„ ë°”ë¼ë³´ë„ë¡ íšŒì „
            const lookTarget = targetCenter.clone();
            const shipPos = playerShip.mesh.position.clone();
            const dir = new THREE.Vector3().subVectors(lookTarget, shipPos).normalize();
            const targetQuat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, -1), dir);
            playerShip.mesh.quaternion.slerp(targetQuat, dt * 8);  // ë” ë¹ ë¥¸ íšŒì „
            playerShip.euler.setFromQuaternion(playerShip.mesh.quaternion, 'YXZ');
            
            // ì „í™˜ ì™„ë£Œ
            if (progress >= 1) {
                orbitState.enteringOrbit = false;
                orbitState.inOrbit = true;
                orbitState.orbitSpeed = orbitState.targetOrbitSpeed;
                autopilot.phase = 'orbiting';
                document.getElementById('ap-phase').textContent = 'ğŸŒ ' + t('statusOrbiting');
                showMsg(`âœ… ${orbitState.orbitBody.name} orbit stabilized! Interior/Observatory available`);
            }
        }
        
        function updateETADisplay() {
            const etaStr = formatETATime(currentETA);
            document.getElementById('eta-time-display').textContent = etaStr;
            document.getElementById('interior-eta').textContent = 'â±ï¸ ' + etaStr;
            document.getElementById('obs-eta').textContent = 'â±ï¸ ' + etaStr;
        }
        
        function formatETATime(seconds) {
            if (seconds <= 0 || !isFinite(seconds)) return '--:--:--';
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            if (h > 99) return `${Math.floor(h/24)}ì¼ ${h%24}ì‹œê°„`;
            return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        }
        
        function formatShipDistance(d) {
            // dëŠ” ì‹œë®¬ë ˆì´ì…˜ ë‹¨ìœ„ (AU ê¸°ë°˜)
            // 1 AU = 149,597,870.7 km
            const kmPerAU = 149597870.7;
            const distKm = d * kmPerAU;
            
            if (distKm < 1000000) {
                // 1,000,000 km ë¯¸ë§Œ: km ë‹¨ìœ„ë¡œ ì†Œìˆ˜ì  3ìë¦¬ê¹Œì§€ í‘œì‹œ
                return distKm.toFixed(3).replace(/\B(?=(\d{3})+(?!\d))/g, ',') + ' km';
            } else if (d < 100) {
                // 100 AU ë¯¸ë§Œ: AU ë‹¨ìœ„
                return d.toFixed(4) + ' AU';
            }
            // 100 AU ì´ìƒ: ê´‘ë…„ ë‹¨ìœ„
            return (d / 63241).toFixed(4) + ' ly';
        }
        
        function updateShipHUD() {
            if (!playerShip || !playerShip.mesh) return;
            
            const sp = playerShip.speed;
            const fuel = playerShip.fuel;
            const thr = shipInputs.throttle;
            
            // â˜…â˜…â˜… 3D ì¢Œí‘œ í‘œì‹œ ì—…ë°ì´íŠ¸ â˜…â˜…â˜…
            const coordsDisplay = document.getElementById('pilot-coords-display');
            if (coordsDisplay && playerShip.mesh) {
                const pos = playerShip.mesh.position;
                coordsDisplay.textContent = `X: ${pos.x.toFixed(1)} | Y: ${pos.y.toFixed(1)} | Z: ${pos.z.toFixed(1)}`;
            }
            
            // THR ê²Œì´ì§€ - ì¤‘ì•™ 0 ë°©ì‹ (ê°€ì†: ìœ„, ì—­ì¶”ì§„: ì•„ë˜)
            const thrUpFill = document.getElementById('throttle-up-fill');
            const thrDownFill = document.getElementById('throttle-down-fill');
            if (thrUpFill && thrDownFill) {
                if (thr >= 0) {
                    thrUpFill.style.height = (thr * 50) + '%';
                    thrDownFill.style.height = '0%';
                } else {
                    thrUpFill.style.height = '0%';
                    thrDownFill.style.height = (Math.abs(thr) * 50) + '%';
                }
            }
            const thrPercent = Math.round(thr * 100);
            document.getElementById('throttle-val').textContent = (thrPercent >= 0 ? '+' : '') + thrPercent + '%';
            const fuelPercent = (fuel / SHIP_CONFIG.maxFuel) * 100;
            document.getElementById('fuel-fill').style.height = fuelPercent + '%';
            document.getElementById('fuel-val').textContent = Math.round(fuel) + '/' + SHIP_CONFIG.maxFuel;
            
            // ë©”ì¸ ì†ë„ í‘œì‹œ (ìœ ì¼í•œ ì†ë„ í‘œì‹œ)
            document.getElementById('main-speed-val').textContent = (sp >= 0 ? '' : '-') + Math.abs(sp).toFixed(0);
            
            // km/h ë³€í™˜ í‘œì‹œ
            const speedKmh = Math.abs(sp) * 3600;
            let kmhStr;
            if (speedKmh >= 1e9) {
                kmhStr = (speedKmh / 1e9).toFixed(1) + 'B';
            } else if (speedKmh >= 1e6) {
                kmhStr = (speedKmh / 1e6).toFixed(1) + 'M';
            } else if (speedKmh >= 1e3) {
                kmhStr = (speedKmh / 1e3).toFixed(1) + 'K';
            } else {
                kmhStr = speedKmh.toFixed(0);
            }
            document.getElementById('speed-kmh').textContent = '(' + kmhStr + ' km/h)';
            
            // ì—°ë£Œ ê²½ê³ 
            document.getElementById('warn-fuel').classList.toggle('active', fuel < 15);
            
            // ìƒíƒœ (ì–¸ì–´ë³„ í‘œì‹œ)
            let stKey = 'statusNominal', sc = '#0f0';
            if (shipInputs.emergencyReverse) { stKey = 'statusBraking'; sc = '#f00'; }
            else if (orbitState.active) { stKey = 'statusOrbiting'; sc = '#0ff'; }
            else if (isGravityWarning) { stKey = 'statusNominal'; sc = '#f00'; }
            else if (autopilot.engaged) { stKey = 'statusAuto'; sc = '#0f8'; }
            else if (Math.abs(sp) > 50) { stKey = 'statusCruising'; sc = '#0ff'; }
            else if (fuel < 15) { stKey = 'statusLowFuel'; sc = '#f90'; }
            document.getElementById('info-status').textContent = t(stKey);
            document.getElementById('info-status').style.color = sc;
        }
        
        function updateShipRadar() {
            const r = document.getElementById('pilot-radar');
            if (!r) return;
            r.querySelectorAll('.radar-blip').forEach(b => b.remove());
            if (!playerShip || !playerShip.mesh) return;
            
            const range = 500;
            const sp = playerShip.mesh.position;
            const qi = playerShip.mesh.quaternion.clone().invert();
            
            bodies.forEach(b => {
                if (!b || !b.mesh) return;
                const rp = b.mesh.position.clone().sub(sp);
                const d = rp.length();
                if (d < range && d > 1) {
                    rp.applyQuaternion(qi);
                    const x = (rp.x / range) * 40;
                    const z = (rp.z / range) * 40;  // â˜… ë¶€í˜¸ ìˆ˜ì • (ìƒí•˜ ë°˜ì „ í•´ê²°)
                    const bl = document.createElement('div');
                    bl.className = 'radar-blip';
                    bl.style.left = `calc(50% + ${x}px)`;
                    bl.style.top = `calc(50% + ${z}px)`;
                    bl.style.width = shipTargetBody === b ? '8px' : '5px';
                    bl.style.height = shipTargetBody === b ? '8px' : '5px';
                    bl.style.background = b.type === 'star' ? '#ffaa00' : (shipTargetBody === b ? '#f00' : '#0ff');
                    bl.style.boxShadow = `0 0 4px ${bl.style.background}`;
                    r.appendChild(bl);
                }
            });
        }
        
        function updateShipTargetInfo() {
            if (shipTargetBody && shipTargetBody.mesh && playerShip && playerShip.mesh) {
                const d = playerShip.mesh.position.distanceTo(shipTargetBody.mesh.position);
                document.getElementById('pilot-target-name').textContent = shipTargetBody.name;
                document.getElementById('pilot-target-dist').textContent = formatShipDistance(d);
                if (playerShip.speed > 0.1) {
                    const eta = d / playerShip.speed;
                    const hours = Math.floor(eta / 3600);
                    if (hours > 24) document.getElementById('pilot-target-eta').textContent = `ETA: ${(hours/24).toFixed(1)}ì¼`;
                    else document.getElementById('pilot-target-eta').textContent = `ETA: ${hours}h ${Math.floor((eta % 3600) / 60)}m`;
                } else {
                    document.getElementById('pilot-target-eta').textContent = t('etaLabel') + ': ---';
                }
            } else {
                document.getElementById('pilot-target-name').textContent = t('none');
                document.getElementById('pilot-target-dist').textContent = '---';
                document.getElementById('pilot-target-eta').textContent = '';
            }
        }
        
        // íƒ‘ìŠ¹ ë²„íŠ¼ì€ focusBodyì—ì„œë§Œ ê´€ë¦¬ (í„°ì¹˜/í´ë¦­ ì‹œì—ë§Œ í‘œì‹œ)
        
        function toScreenPosition(obj, cam) {
            if (!obj || !cam) return { x: 0, y: 0 };
            const vector = new THREE.Vector3();
            try {
                obj.getWorldPosition(vector);
                vector.project(cam);
            } catch(e) {
                return { x: 0, y: 0 };
            }
            return {
                x: (vector.x * 0.5 + 0.5) * window.innerWidth,
                y: (-vector.y * 0.5 + 0.5) * window.innerHeight
            };
        }

        // â˜…â˜…â˜… ë°±ê·¸ë¼ìš´ë“œ ì´ë™ ë³´ì • ì‹œìŠ¤í…œ (Web Worker ì‚¬ìš©) â˜…â˜…â˜…
        let backgroundWorker = null;
        let backgroundState = {
            lastActiveTime: Date.now(),
            wasInPilotMode: false,
            lastPosition: null,
            lastDirection: null,
            lastSpeed: 0,
            autopilotTarget: null
        };

        // Web Worker ì´ˆê¸°í™”
        function initBackgroundWorker() {
            if (backgroundWorker) return;
            try {
                backgroundWorker = new Worker('/background-worker.js');
                backgroundWorker.onmessage = function(e) {
                    const { type, data } = e.data;
                    if (type === 'positionUpdate' && !isPageVisible) {
                        // ë°±ê·¸ë¼ìš´ë“œì—ì„œ ìœ„ì¹˜ ì—…ë°ì´íŠ¸ ìˆ˜ì‹ 
                        backgroundState.lastPosition = new THREE.Vector3(data.position.x, data.position.y, data.position.z);
                        backgroundState.lastSpeed = data.speed;
                    } else if (type === 'state') {
                        // ìƒíƒœ ì‘ë‹µ ì²˜ë¦¬
                        if (data.position && playerShip && playerShip.mesh) {
                            playerShip.mesh.position.set(data.position.x, data.position.y, data.position.z);
                            playerShip.speed = data.speed || 0;
                        }
                    }
                };
                console.log('âœ… Background Worker ì´ˆê¸°í™” ì™„ë£Œ');
            } catch (e) {
                console.log('âš ï¸ Background Worker ì´ˆê¸°í™” ì‹¤íŒ¨:', e);
            }
        }

        // Workerì— ìƒíƒœ ì „ì†¡
        function sendToWorker(type, data) {
            if (backgroundWorker) {
                backgroundWorker.postMessage({ type, data });
            }
        }

        // ë°±ê·¸ë¼ìš´ë“œ/í¬ê·¸ë¼ìš´ë“œ ìƒíƒœ ê´€ë¦¬
        let isPageVisible = true;
        document.addEventListener('visibilitychange', () => {
            const wasVisible = isPageVisible;
            isPageVisible = !document.hidden;

            if (!isPageVisible) {
                // â˜… ë°±ê·¸ë¼ìš´ë“œë¡œ ì „í™˜ ì‹œ Workerì— ìƒíƒœ ì „ì†¡
                backgroundState.lastActiveTime = Date.now();
                backgroundState.wasInPilotMode = isPilotMode;

                if (isPilotMode && playerShip && playerShip.mesh) {
                    backgroundState.lastPosition = playerShip.mesh.position.clone();
                    backgroundState.lastSpeed = playerShip.speed || 0;

                    // í˜„ì¬ ì§„í–‰ ë°©í–¥ ì €ì¥
                    const fwd = new THREE.Vector3(0, 0, -1).applyQuaternion(playerShip.mesh.quaternion);
                    backgroundState.lastDirection = fwd.clone();

                    // Workerì— ìƒíƒœ ì „ì†¡ ë° ì‹œì‘
                    const targetPos = (autopilot.engaged && shipTargetBody && shipTargetBody.mesh)
                        ? { x: shipTargetBody.mesh.position.x, y: shipTargetBody.mesh.position.y, z: shipTargetBody.mesh.position.z }
                        : null;

                    sendToWorker('start', {
                        position: { x: playerShip.mesh.position.x, y: playerShip.mesh.position.y, z: playerShip.mesh.position.z },
                        speed: backgroundState.lastSpeed,
                        direction: { x: fwd.x, y: fwd.y, z: fwd.z },
                        autopilot: {
                            engaged: autopilot.engaged,
                            targetPosition: targetPos,
                            targetName: shipTargetBody?.name || null
                        }
                    });
                    
                    // ìë™í•­ë²• ëª©í‘œ ì €ì¥
                    if (autopilot.engaged && shipTargetBody) {
                        backgroundState.autopilotTarget = shipTargetBody.name;
                    } else {
                        backgroundState.autopilotTarget = null;
                    }
                    
                    console.log('ğŸ“± ë°±ê·¸ë¼ìš´ë“œ ì „í™˜ - ìƒíƒœ ì €ì¥:', {
                        speed: backgroundState.lastSpeed,
                        position: backgroundState.lastPosition,
                        autopilot: backgroundState.autopilotTarget
                    });
                }
            } else if (wasVisible === false) {
                // â˜… í¬ê·¸ë¼ìš´ë“œ ë³µê·€ ì‹œ Workerì—ì„œ ìœ„ì¹˜ ê°€ì ¸ì˜¤ê¸°
                const elapsedMs = Date.now() - backgroundState.lastActiveTime;
                const elapsedSec = elapsedMs / 1000;

                // clock ë¦¬ì…‹ (ëˆ„ì ëœ ì‹œê°„ ë²„ë¦¬ê¸°)
                clock.getDelta();

                // Worker ì •ì§€
                sendToWorker('stop');

                // Workerì˜ ìµœì‹  ìœ„ì¹˜ ì ìš©
                if (backgroundState.wasInPilotMode && playerShip && playerShip.mesh && backgroundState.lastPosition) {
                    // Workerê°€ ê³„ì‚°í•œ ìœ„ì¹˜ ì ìš©
                    playerShip.mesh.position.copy(backgroundState.lastPosition);
                    playerShip.speed = backgroundState.lastSpeed;

                    const traveled = backgroundState.lastPosition.distanceTo(
                        new THREE.Vector3(
                            backgroundState.lastPosition.x - backgroundState.lastDirection.x * backgroundState.lastSpeed * elapsedSec,
                            backgroundState.lastPosition.y - backgroundState.lastDirection.y * backgroundState.lastSpeed * elapsedSec,
                            backgroundState.lastPosition.z - backgroundState.lastDirection.z * backgroundState.lastSpeed * elapsedSec
                        )
                    );

                    showMsg(`ğŸ“± ë³µê·€ - ${elapsedSec.toFixed(0)}ì´ˆ ë™ì•ˆ ${Math.round(traveled)} ë‹¨ìœ„ ì´ë™`);
                }

                console.log('ğŸ“± í¬ê·¸ë¼ìš´ë“œ ë³µê·€ - ê²½ê³¼ ì‹œê°„:', elapsedSec.toFixed(1) + 'ì´ˆ');
            }
        });
        
        // â˜…â˜…â˜… ë°±ê·¸ë¼ìš´ë“œ ì´ë™ ë³´ì • í•¨ìˆ˜ â˜…â˜…â˜…
        function compensateBackgroundMovement(elapsedSec) {
            if (!playerShip || !playerShip.mesh || !backgroundState.lastDirection) return;
            
            // ìµœëŒ€ ë³´ì • ì‹œê°„ ì œí•œ (5ë¶„)
            const maxCompensationTime = 300;
            const compensationTime = Math.min(elapsedSec, maxCompensationTime);
            
            // ìë™í•­ë²• ëª¨ë“œ
            if (backgroundState.autopilotTarget && autopilot.engaged) {
                const targetBody = bodies.find(b => b.name === backgroundState.autopilotTarget) ||
                                   satellites.find(s => s.name === backgroundState.autopilotTarget);
                
                if (targetBody && targetBody.mesh) {
                    // ëª©í‘œê¹Œì§€ì˜ ê±°ë¦¬ì™€ ì˜ˆìƒ ì´ë™ ê±°ë¦¬ ê³„ì‚°
                    const toTarget = new THREE.Vector3().subVectors(targetBody.mesh.position, playerShip.mesh.position);
                    const distToTarget = toTarget.length();
                    const expectedTravel = backgroundState.lastSpeed * compensationTime;
                    
                    if (expectedTravel >= distToTarget * 0.9) {
                        // ëª©í‘œì— ê±°ì˜ ë„ì°© - ëª©í‘œ ê·¼ì²˜ì— ë°°ì¹˜
                        const arrivalOffset = toTarget.normalize().multiplyScalar(-50);  // ëª©í‘œ 50 ë‹¨ìœ„ ì•
                        playerShip.mesh.position.copy(targetBody.mesh.position).add(arrivalOffset);
                        playerShip.speed = 5;  // ê°ì† ì™„ë£Œ
                        
                        showMsg(`ğŸ¯ ${backgroundState.autopilotTarget} ê·¼ì²˜ì— ë„ì°©í–ˆìŠµë‹ˆë‹¤! (${Math.round(elapsedSec)}ì´ˆ ê²½ê³¼)`);
                    } else {
                        // ì•„ì§ ì´ë™ ì¤‘ - ì˜ˆìƒ ìœ„ì¹˜ë¡œ ì´ë™
                        const moveDir = toTarget.normalize();
                        playerShip.mesh.position.add(moveDir.multiplyScalar(expectedTravel));
                        
                        const remainingDist = distToTarget - expectedTravel;
                        showMsg(`ğŸš€ ${Math.round(expectedTravel)} ë‹¨ìœ„ ì´ë™ë¨ (ëª©í‘œê¹Œì§€ ${Math.round(remainingDist)} ë‚¨ìŒ)`);
                    }
                    
                    console.log('ìë™í•­ë²• ë³´ì •:', { expectedTravel, distToTarget, compensationTime });
                    return;
                }
            }
            
            // ìˆ˜ë™ ë¹„í–‰ ëª¨ë“œ - ìœ„ì¹˜ ìœ ì§€ (ìˆœê°„ì´ë™ ë°©ì§€)
            // ìë™í•­í•´ê°€ ì•„ë‹ˆë©´ ì•± ë³µê·€ ì‹œ ì œìë¦¬
            if (elapsedSec > 1) {
                showMsg(`ğŸ“± ì•± ë³µê·€ (${Math.round(elapsedSec)}ì´ˆ ê²½ê³¼)`);
            }
            console.log('ìˆ˜ë™ ë¹„í–‰ - ìœ„ì¹˜ ìœ ì§€ (ìˆœê°„ì´ë™ ë°©ì§€)');
            
            // ìœ„ì¹˜ ì €ì¥
            if (typeof ShipPositionManager !== 'undefined') {
                ShipPositionManager.save();
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // íƒ­ì´ ë°±ê·¸ë¼ìš´ë“œë©´ ì‹œë®¬ë ˆì´ì…˜ ì¼ì‹œì •ì§€
            if (!isPageVisible) return;
            
            let rawDt = clock.getDelta();  // ì‹¤ì œ ë¸íƒ€ íƒ€ì„ (ì„ ë‚´ ì´ë™ìš©)
            
            // ë¸íƒ€ ìƒí•œ (ë°±ê·¸ë¼ìš´ë“œ ë³µê·€ ì‹œ ìˆœê°„ì´ë™ ë°©ì§€)
            rawDt = Math.min(rawDt, 0.1);  // ìµœëŒ€ 100ms
            
            const dt = rawDt * CONFIG.timeScale;  // ì‹œë®¬ë ˆì´ì…˜ìš© ë¸íƒ€ íƒ€ì„
            const elapsedTime = clock.getElapsedTime(); 
            const prevPos=(focusedBody && focusedBody.mesh)?focusedBody.mesh.position.clone():null;
            
            // â˜…â˜…â˜… ëŒ€ê¸° ì²œì²´ í„ìŠ¤ ì• ë‹ˆë©”ì´ì…˜ â˜…â˜…â˜…
            if (pendingBodyMesh) {
                const pulse = 0.8 + Math.sin(elapsedTime * 4) * 0.2;
                pendingBodyMesh.material.opacity = 0.4 + Math.sin(elapsedTime * 3) * 0.2;
                
                // ë§ í„ìŠ¤
                const ring = pendingBodyMesh.getObjectByName('pendingRing');
                if (ring) {
                    ring.rotation.z = elapsedTime;
                    ring.scale.setScalar(pulse);
                    ring.material.opacity = 0.3 + Math.sin(elapsedTime * 5) * 0.2;
                }
            }
            
            // â˜…â˜…â˜… í™”ì‚´í‘œ í•¸ë“¤ ì• ë‹ˆë©”ì´ì…˜ (ë¹Œë³´ë“œ + í„ìŠ¤) â˜…â˜…â˜…
            if (velocityHandle) {
                // í•¸ë“¤ ë§ì´ í•­ìƒ ì¹´ë©”ë¼ë¥¼ í–¥í•˜ë„ë¡
                const handleRing = velocityHandle.getObjectByName('handleRing');
                if (handleRing) {
                    handleRing.lookAt(camera.position);
                    handleRing.rotation.z = elapsedTime * 2;  // íšŒì „ íš¨ê³¼
                    const handlePulse = 0.9 + Math.sin(elapsedTime * 6) * 0.2;
                    handleRing.scale.setScalar(handlePulse);
                }
                
                // í•¸ë“¤ ìì²´ í„ìŠ¤
                const basePulse = 1.0 + Math.sin(elapsedTime * 4) * 0.15;
                velocityHandle.scale.setScalar(basePulse);
            }
            
            if(dt>0){ updatePhysics(dt); updateTrails(); }

            // â˜…â˜…â˜… ë©€í‹°í”Œë ˆì´ì–´: ë‹¤ë¥¸ í”Œë ˆì´ì–´ ë¶€ë“œëŸ¬ìš´ ë³´ê°„ â˜…â˜…â˜…
            if (typeof mpInterpolateOtherPlayers === 'function') {
                mpInterpolateOtherPlayers(rawDt);
            }

            // â˜…â˜…â˜… íƒœì–‘ ê·¸ë¦¼ì ì¡°ëª… ì—…ë°ì´íŠ¸ â˜…â˜…â˜…
            if (window.solarShadowLight) {
                const sun = bodies.find(b => b.name === 'íƒœì–‘' || b.name === 'Sun');
                if (sun && sun.mesh) {
                    // íƒœì–‘ ìœ„ì¹˜ì—ì„œ ì¡°ëª… ë°œì‚¬
                    window.solarShadowLight.position.copy(sun.mesh.position);
                    
                    // í¬ì»¤ìŠ¤ëœ ì²œì²´ ë˜ëŠ” ì§€êµ¬ ë°©í–¥ìœ¼ë¡œ íƒ€ê²Ÿ ì„¤ì •
                    let targetBody = focusedBody;
                    if (!targetBody || targetBody === sun) {
                        targetBody = bodies.find(b => b.name === 'ì§€êµ¬' || b.name === 'Earth');
                    }
                    
                    if (targetBody && targetBody.mesh && targetBody !== sun) {
                        window.solarShadowLight.target.position.copy(targetBody.mesh.position);
                        
                        // ê·¸ë¦¼ì ì¹´ë©”ë¼ ë²”ìœ„ë¥¼ ëŒ€ìƒ ê±°ë¦¬ì— ë§ê²Œ ì¡°ì •
                        const dist = sun.mesh.position.distanceTo(targetBody.mesh.position);
                        // ìœ„ì„± ê·¸ë¦¼ìë¥¼ ìœ„í•´ ë²”ìœ„ë¥¼ ë„“ê²Œ ì„¤ì •
                        const range = Math.max(50, Math.min(5000, targetBody.radius * 100));
                        window.solarShadowLight.shadow.camera.left = -range;
                        window.solarShadowLight.shadow.camera.right = range;
                        window.solarShadowLight.shadow.camera.top = range;
                        window.solarShadowLight.shadow.camera.bottom = -range;
                        window.solarShadowLight.shadow.camera.near = Math.max(1, dist - range * 2);
                        window.solarShadowLight.shadow.camera.far = dist + range * 2;
                        window.solarShadowLight.shadow.camera.updateProjectionMatrix();
                    }
                }
            }
            
            // â˜…â˜…â˜… ì •ê±°ì¥ ë³´í˜¸ë§‰ ì´ˆê¸°í™” (ìµœì´ˆ 1íšŒ) â˜…â˜…â˜…
            if (!window.stationShieldsInitialized && satellites.length > 0) {
                const hasStations = satellites.some(s => s.isSpaceStation);
                if (hasStations) {
                    addShieldsToStations();
                    window.stationShieldsInitialized = true;
                }
            }
            
            // â˜…â˜…â˜… ë³´í˜¸ë§‰ ì• ë‹ˆë©”ì´ì…˜ ì—…ë°ì´íŠ¸ â˜…â˜…â˜…
            updateShieldAnimations(dt);
            
            // â˜…â˜…â˜… ì¼ì‹/ì›”ì‹ ê·¸ë¦¼ì ì‹œìŠ¤í…œ ì—…ë°ì´íŠ¸ â˜…â˜…â˜…
            if (typeof EclipseSystem !== 'undefined' && EclipseSystem.update) {
                EclipseSystem.update();
            }

            bodies.forEach(b => { 
                if (!b || !b.mesh) return;
                if(b.rotSpeed && !b.isStatic) { 
                    b.mesh.rotation.y += b.rotSpeed * 0.01 * CONFIG.timeScale; 
                } 
                if(b.type === 'star') { 
                    if(b.mesh.material && b.mesh.material.uniforms) b.mesh.material.uniforms.time.value = elapsedTime; 
                    if(b.corona && b.corona.material && b.corona.material.uniforms) { 
                        b.corona.material.uniforms.time.value = elapsedTime; 
                        b.corona.lookAt(camera.position); 
                    } 
                } 
                
                // â˜…â˜…â˜… ì§€êµ¬ ëŒ€ê¸°/êµ¬ë¦„ ì‰ì´ë” ì—…ë°ì´íŠ¸ â˜…â˜…â˜…
                if (b.mesh.userData.hasAtmosphere) {
                    const sun = bodies.find(s => s.name === 'íƒœì–‘');
                    if (sun && sun.mesh) {
                        // íƒœì–‘ ë°©í–¥ ê³„ì‚°
                        const sunDir = new THREE.Vector3()
                            .subVectors(sun.mesh.position, b.mesh.position)
                            .normalize();
                        
                        // ëŒ€ê¸° ì‰ì´ë” ì—…ë°ì´íŠ¸
                        if (b.mesh.userData.atmosphereMat) {
                            b.mesh.userData.atmosphereMat.uniforms.sunDirection.value.copy(sunDir);
                            b.mesh.userData.atmosphereMat.uniforms.time.value = elapsedTime;
                        }
                        
                        // ë‹¤ì¸µ êµ¬ë¦„ ì‰ì´ë” ì—…ë°ì´íŠ¸
                        if (b.mesh.userData.cloudLayers) {
                            b.mesh.userData.cloudLayers.forEach((cloudMat, idx) => {
                                cloudMat.uniforms.sunDirection.value.copy(sunDir);
                                // ë ˆì´ì–´ë³„ë¡œ ë‹¤ë¥¸ ì†ë„ë¡œ ì‹œê°„ ì§„í–‰ (ì…ì²´ê°)
                                cloudMat.uniforms.time.value = elapsedTime * (1.0 + idx * 0.3) + idx * 100;
                            });
                        }
                        
                        // ì´ì „ ë²„ì „ í˜¸í™˜ (ë‹¨ì¼ êµ¬ë¦„)
                        if (b.mesh.userData.cloudMat) {
                            b.mesh.userData.cloudMat.uniforms.sunDirection.value.copy(sunDir);
                            b.mesh.userData.cloudMat.uniforms.time.value = elapsedTime;
                        }
                    }
                }
                
                if(b.type === 'blackhole') { 
                    // ì œíŠ¸ ì• ë‹ˆë©”ì´ì…˜ (ì€í•˜ ì¤‘ì‹¬ ë¸”ë™í™€ë§Œ)
                    if (b.jets) {
                        const s = 1.0 + Math.random()*0.05; 
                        b.jets.up.scale.y=s; 
                        b.jets.down.scale.y=s;
                    }
                    
                    // â˜… ì‹¬í”Œí•œ ë¶ˆì˜ ê³ ë¦¬ ì• ë‹ˆë©”ì´ì…˜
                    if (b.mesh.userData.fireRings) {
                        b.mesh.userData.fireRings.forEach(ring => {
                            ring.rotation.z += ring.userData.rotationSpeed || 0.003;
                        });
                    }
                    if (b.mesh.userData.innerGlow) {
                        b.mesh.userData.innerGlow.rotation.z += b.mesh.userData.innerGlow.userData.rotationSpeed || 0.01;
                    }
                    
                    // ê¸°ì¡´ ê°•ì°©ì›ë°˜ í˜¸í™˜ (ì€í•˜ ì¤‘ì‹¬)
                    if (b.mesh.userData.diskLayers) {
                        b.mesh.userData.diskLayers.forEach(ring => {
                            ring.rotation.z += ring.userData.rotationSpeed;
                        });
                    }
                    if (b.mesh.userData.mainDisk) {
                        b.mesh.userData.mainDisk.rotation.z += b.mesh.userData.mainDisk.userData.rotationSpeed || 0.002;
                    }
                }
            });

            // â˜…â˜…â˜… ì•ˆë“œë¡œë©”ë‹¤ ì€í•˜ ë¸”ë™í™€ ì…°ì´ë” ì• ë‹ˆë©”ì´ì…˜ â˜…â˜…â˜…
            scene.traverse(obj => {
                if (obj.userData && obj.userData.name === 'andromeda' && obj.userData.blackHole) {
                    const bh = obj.userData.blackHole;
                    if (bh.photonRingMat) bh.photonRingMat.uniforms.time.value = elapsedTime;
                    if (bh.lensMat) bh.lensMat.uniforms.time.value = elapsedTime;
                    if (bh.outerLensMat) bh.outerLensMat.uniforms.time.value = elapsedTime;
                    if (bh.diskMat) bh.diskMat.uniforms.time.value = elapsedTime;
                    if (bh.jetMat) bh.jetMat.uniforms.time.value = elapsedTime;
                    if (bh.jetMatBottom) bh.jetMatBottom.uniforms.time.value = elapsedTime;
                }
            });

            satellites.forEach(sat => {
                if (sat && sat.parentBody && sat.parentBody.mesh && sat.mesh) {
                    // ë¬¼ë¦¬ í™œì„±í™”ëœ ìœ„ì„±(moon)ì€ ê¶¤ë„ ê³„ì‚° ê±´ë„ˆë›°ê¸° - ë¬¼ë¦¬ ë²•ì¹™ìœ¼ë¡œ ì´ë™
                    if (sat.isPhysicsEnabled) {
                        // ìì „ë§Œ ì ìš©
                        sat.mesh.rotation.y += 0.01;
                        return;
                    }

                    // â˜…â˜…â˜… ë©€í‹°ëª¨ë“œ: ì„œë²„ ë™ê¸°í™” ì‹œê°„ ê¸°ì¤€ ê³µì „ â˜…â˜…â˜…
                    if (window.gameMode === 'multi') {
                        // ìœ„ì„±ë³„ ê³ ìœ  ì‹œë“œ (ì´ë¦„ ê¸°ë°˜) + ì„œë²„ ë™ê¸°í™” ì‹œê°„ ê¸°ë°˜ ê³µì „
                        const seed = sat.name ? sat.name.split('').reduce((a, c) => a + c.charCodeAt(0), 0) : 0;
                        const syncedTime = typeof getSyncedTime === 'function' ? getSyncedTime() : Date.now();
                        const baseTime = syncedTime * 0.0000001;  // ëŠë¦° ê³µì „
                        sat.angle = (seed * 0.1 + baseTime * sat.orbitSpeed) % (Math.PI * 2);
                    } else {
                        // ì‹±ê¸€ëª¨ë“œ: ê¸°ì¡´ ë°©ì‹ (ìƒëŒ€ì  ëˆ„ì )
                        const satelliteSpeedMultiplier = CONFIG.timeScale;
                        sat.angle += sat.orbitSpeed * rawDt * satelliteSpeedMultiplier * 0.033;
                    } 
                    
                    // ì‹¤ì œ ê±°ë¦¬ ëª¨ë“œì—ì„œëŠ” ì‹¤ì œ ë¹„ìœ¨ ì‚¬ìš©, ì²´í—˜ ëª¨ë“œì—ì„œëŠ” ê¸°ë³¸ ë¹„ìœ¨
                    const isRealMode = CONFIG.distScale > 1.0;
                    let r;
                    if (isRealMode && sat.realOrbitRadius) {
                        // ì‹¤ì œ ëª¨ë“œ: ëª¨í–‰ì„± ë°˜ì§€ë¦„ Ã— ì‹¤ì œ ë¹„ìœ¨ Ã— visualScale
                        const parentScale = sat.parentBody.visualScale || 1;
                        r = sat.realOrbitRadius * (sat.parentBody.radius || 1) * parentScale;
                    } else {
                        // ì²´í—˜ ëª¨ë“œ: ì´ë¯¸ ê³„ì‚°ëœ orbitRadius ì‚¬ìš©
                        r = sat.orbitRadius;
                    }
                    sat.mesh.position.x = sat.parentBody.mesh.position.x + Math.cos(sat.angle) * r; 
                    sat.mesh.position.z = sat.parentBody.mesh.position.z + Math.sin(sat.angle) * r; 
                    sat.mesh.position.y = sat.parentBody.mesh.position.y; 
                    if (sat.type === 'station') { 
                        sat.mesh.lookAt(sat.parentBody.mesh.position); 
                        sat.mesh.rotateY(Math.PI/2); 
                        
                        // ìš°ì£¼ì •ê±°ì¥ ë§ íšŒì „ ì• ë‹ˆë©”ì´ì…˜
                        if (sat.mesh.userData && sat.mesh.userData.isStation && sat.mesh.userData.ringMesh) {
                            sat.mesh.userData.ringMesh.rotation.z += rawDt * 0.15;  // ë§ ì²œì²œíˆ íšŒì „
                        }
                        
                        // íƒœì–‘ê´‘ íŒ¨ë„ íƒœì–‘ ì¶”ì  (90ë„ í‹¸íŠ¸)
                        const solarArray = sat.mesh.getObjectByName('solarArrayGroup');
                        if (solarArray) {
                            // ì •ê±°ì¥ì—ì„œ íƒœì–‘(ì›ì ) ë°©í–¥ ê³„ì‚°
                            const stationPos = sat.mesh.position.clone();
                            const toSun = new THREE.Vector3(0, 0, 0).sub(stationPos).normalize();
                            
                            // ë¡œì»¬ ì¢Œí‘œê³„ë¡œ ë³€í™˜
                            const invQuat = sat.mesh.quaternion.clone().invert();
                            const localSunDir = toSun.applyQuaternion(invQuat);
                            
                            // Yì¶• íšŒì „ìœ¼ë¡œ íƒœì–‘ ë°©í–¥ ë§ì¶”ê¸°
                            const sunAngle = Math.atan2(localSunDir.x, localSunDir.z);
                            solarArray.rotation.y = sunAngle;
                            
                            // Xì¶• 90ë„ í‹¸íŠ¸ (íŒ¨ë„ ë©´ì´ íƒœì–‘ì„ í–¥í•˜ê²Œ)
                            solarArray.rotation.x = Math.PI / 2;
                        }
                        
                        // ìŠ¤íŠ¸ë¡œë¸Œ ì¡°ëª… ê¹œë¹¡ì„
                        const time = Date.now() * 0.001;
                        sat.mesh.children.forEach(child => {
                            if (child.name && child.name.startsWith('strobe_')) {
                                const strobeIndex = parseInt(child.name.split('_')[1]);
                                const blinkPhase = (time + strobeIndex * 0.5) % 2;
                                child.visible = blinkPhase < 0.1;  // ì§§ê²Œ ê¹œë¹¡ì„
                            }
                        });
                    } else { 
                        sat.mesh.rotation.y += 0.01; 
                    } 
                } 
            });
            
            // â˜…â˜…â˜… ì£¼ì°¨ëœ ìš°ì£¼ì„  ì‹¤ì‹œê°„ ì´ë™ ì—…ë°ì´íŠ¸ â˜…â˜…â˜…
            if (parkedShipMesh && parkedShipMesh.userData.isMoving && !isPilotMode) {
                const velocity = parkedShipMesh.userData.velocity;
                const speed = parkedShipMesh.userData.speed || 0;
                
                if (velocity && speed > 0.01) {
                    // ì‹¤ì‹œê°„ìœ¼ë¡œ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
                    const moveAmount = velocity.clone().multiplyScalar(dt);
                    parkedShipMesh.position.add(moveAmount);
                    
                    // ì—”ì§„ ë¶ˆê½ƒ ì• ë‹ˆë©”ì´ì…˜
                    const flame = parkedShipMesh.getObjectByName('engineFlame');
                    if (flame) {
                        flame.visible = true;
                        const flicker = 0.9 + Math.sin(elapsedTime * 10) * 0.2;
                        flame.scale.z = flicker * (0.5 + speed * 0.1);
                    }
                    
                    // í¬ì»¤ìŠ¤ëœ ìƒíƒœë©´ ì¹´ë©”ë¼ë„ ë”°ë¼ê°€ê¸°
                    if (focusedBody && focusedBody.mesh === parkedShipMesh) {
                        controls.target.copy(parkedShipMesh.position);
                    }
                    
                    // parkedShip ë°ì´í„°ë„ ì—…ë°ì´íŠ¸
                    if (parkedShip) {
                        parkedShip.position = parkedShipMesh.position.clone();
                    }
                }
            }
            
            // â˜…â˜…â˜… SSIL ë¯¸ì…˜ ì²´í¬ (2ì´ˆë§ˆë‹¤) â˜…â˜…â˜…
            if (isPilotMode && playerShip) {
                if (!window.lastMissionCheck) window.lastMissionCheck = 0;
                if (elapsedTime - window.lastMissionCheck > 2) {
                    window.lastMissionCheck = elapsedTime;
                    checkTrainingMissions();
                    checkDailyMission();
                }
            }
            
            // ===== ë„í‚¹ í•´ì œ ì—°ì¶œ =====
            if (undockingState.active && undockingState.phase === 'undocking') {
                if (!playerShip || !playerShip.mesh) {
                    console.error('ì–¸ë„í‚¹ ì¤‘ playerShip ì—†ìŒ!');
                    undockingState.active = false;
                } else {
                    const elapsed = Date.now() - undockingState.startTime;
                    const progress = Math.min(elapsed / undockingState.duration, 1.0);
                    
                    // â˜… ë” ìŠ¤ë¬´ìŠ¤í•œ ì´ì§• í•¨ìˆ˜ (ease-in-out-quart)
                    const easeProgress = progress < 0.5
                        ? 8 * progress * progress * progress * progress
                        : 1 - Math.pow(-2 * progress + 2, 4) / 2;
                    
                    // â˜… ì €ì¥ëœ ì§€êµ¬ ë°˜ëŒ€ ë°©í–¥ ì‚¬ìš©
                    const direction = undockingState.undockDirection ? 
                        undockingState.undockDirection.clone() :
                        new THREE.Vector3().subVectors(
                            undockingState.startPos, 
                            undockingState.stationPos
                        ).normalize();
                    
                    // í˜„ì¬ ìœ„ì¹˜ ê³„ì‚° (0.3 â†’ targetDist) - ì‹œì‘ì ë„ ë” ê°€ê¹ê²Œ
                    const currentDist = 0.3 + (undockingState.targetDist - 0.3) * easeProgress;
                    const newPos = undockingState.stationPos.clone().add(
                        direction.clone().multiplyScalar(currentDist)
                    );
                    playerShip.mesh.position.copy(newPos);
                    
                    // ìš°ì£¼ì„ ì´ ì´íƒˆ ë°©í–¥ ë°”ë¼ë³´ê¸° (ë¶€ë“œëŸ½ê²Œ íšŒì „)
                    const lookTarget = newPos.clone().add(
                        (undockingState.undockDirection || direction).clone().multiplyScalar(10)
                    );
                    
                    // â˜… ë¶€ë“œëŸ¬ìš´ íšŒì „ ë³´ê°„
                    const targetQuat = new THREE.Quaternion();
                    const tempObj = new THREE.Object3D();
                    tempObj.position.copy(newPos);
                    tempObj.lookAt(lookTarget);
                    targetQuat.copy(tempObj.quaternion);
                    playerShip.mesh.quaternion.slerp(targetQuat, 0.05);
                    
                    // ì—­ì¶”ì§„ ë¶ˆê½ƒ íš¨ê³¼ (ë¶€ë“œëŸ¬ìš´ ê¹œë¹¡ì„)
                    const reverseFlame = playerShip.mesh.getObjectByName('reverseFlameGroup');
                    if (reverseFlame) {
                        reverseFlame.visible = true;
                        // ë¶ˆê½ƒ í¬ê¸° ë³€í™” (ë” ë¶€ë“œëŸ½ê²Œ)
                        const flicker = 0.9 + Math.sin(elapsed * 0.02) * 0.2;
                        reverseFlame.scale.setScalar(flicker);
                    }
                    
                    // â˜… 3ì¸ì¹­ ì¹´ë©”ë¼: ë” ìŠ¤ë¬´ìŠ¤í•˜ê²Œ ë”°ë¼ê°€ê¸°
                    const camTarget = playerShip.mesh.position.clone();
                    const idealCamPos = camTarget.clone().add(
                        direction.clone().multiplyScalar(-3)  // ì´ë™ ë°©í–¥ ë’¤ìª½
                    ).add(new THREE.Vector3(0, 1.5, 0));  // ìœ„ìª½
                    
                    // ì¸¡ë©´ ì˜¤í”„ì…‹ ì¶”ê°€
                    const sideDir = new THREE.Vector3().crossVectors(direction, new THREE.Vector3(0, 1, 0)).normalize();
                    idealCamPos.add(sideDir.multiplyScalar(2));
                    
                    camera.position.lerp(idealCamPos, 0.03);  // ë” ë¶€ë“œëŸ½ê²Œ
                    camera.lookAt(camTarget);
                    
                    // ì—°ì¶œ ì™„ë£Œ
                    if (progress >= 1.0) {
                        undockingState.phase = 'complete';
                        undockingState.active = false;
                        
                        // 1ì¸ì¹­ ì¹´ë©”ë¼ë¡œ ì „í™˜
                        scene.remove(camera);
                        playerShip.mesh.add(camera);
                        // â˜… ì¹´ë©”ë¼ ìœ„ì¹˜ëŠ” ìŠ¤ì¼€ì¼ê³¼ ë¬´ê´€í•˜ê²Œ ê³ ì •
                        camera.position.set(0, 0.08, 0.15);
                        camera.rotation.set(0, 0, 0);
                        
                        // ì—­ì¶”ì§„ ë¶ˆê½ƒ ë„ê¸°
                        if (reverseFlame) reverseFlame.visible = false;
                        if (playerShip.flame) playerShip.flame.visible = false;
                        
                        // â˜… ì¡°ì¢…ì„ ë‹¤ì‹œ ë³´ì´ê¸°
                        const cockpit = playerShip.mesh.getObjectByName('cockpitGroup');
                        if (cockpit) cockpit.visible = true;
                        
                        // ì¡°ì¢…ì„ ì‹œì  ì´ˆê¸°í™”
                        cockpitTargetRotY = 0;
                        cockpitTargetRotX = 0;
                        cockpitLookRotY = 0;
                        cockpitLookRotX = 0;
                        
                        // ìƒíƒœ ë³µêµ¬
                        const statusEl = document.getElementById('info-status');
                        if (statusEl) {
                            statusEl.textContent = t('statusNormal');
                            statusEl.style.color = '#00ff00';
                        }
                        
                        // â˜… 1ì¸ì¹­ ì¡°ì¢…ì„ ë·°ë¡œ ë³µê·€
                        isCockpitView = true;
                        
                        console.log('â˜… ì–¸ë„í‚¹ ì™„ë£Œ!');
                        showMsg(`âœ… ë°œì§„ ì¤€ë¹„ ì™„ë£Œ! ${currentShipType.name} ì¡°ì¢…ì„ ì‹œì‘í•˜ì„¸ìš”.`);
                    }
                    
                    // ì–¸ë„í‚¹ ì¤‘ì—ëŠ” ì¡°ì¢… ì…ë ¥ ë¬´ì‹œ
                    // â˜… 3ì¸ì¹­ì´ë¯€ë¡œ ì¡°ì¢…ì„ ìˆ¨ê¸°ê¸°
                    const cockpit = playerShip?.mesh?.getObjectByName('cockpitGroup');
                    if (cockpit) cockpit.visible = false;
                    
                    renderer.render(scene, camera);
                    labelRenderer.render(scene, camera);
                    return;  // ì¡°ì¢… ëª¨ë“œ ì²˜ë¦¬ ê±´ë„ˆë›°ê¸°
                }
            }
            
            // ===== ìš°ì£¼ì„  ì¡°ì¢… ëª¨ë“œ =====
            if (isPilotMode && playerShip) {
                // ìë™í•­ë²• ì—…ë°ì´íŠ¸ (ì„ ë‚´/ì „ë§ëŒ€ì—ì„œë„ ìš°ì£¼ì„  ì´ë™)
                if (autopilot.engaged && playerShip.mesh) {
                    if (isInteriorMode || isObservatoryMode) {
                        updateShipAutopilot(dt);
                        const fwd = new THREE.Vector3(0, 0, -1).applyQuaternion(playerShip.mesh.quaternion);
                        playerShip.mesh.position.add(fwd.multiplyScalar(playerShip.speed * dt));
                        checkShipCollision();
                    }
                }
                
                // ê¶¤ë„ ìš´í–‰ ì—…ë°ì´íŠ¸ (ì„ ë‚´/ì „ë§ëŒ€ì—ì„œë„ ê°€ëŠ¥)
                if (orbitState.active && playerShip.mesh) {
                    updateOrbitMotion(dt);
                    updateShipHUD();
                }
                
                if (isObservatoryMode) {
                    // ì „ë§ëŒ€ ëª¨ë“œ - 360ë„ ìš°ì£¼ ê´€ì°°
                    // â˜… ì¡°ì¢…ì„ ìˆ¨ê¸°ê¸°
                    const cockpit = playerShip?.mesh?.getObjectByName('cockpitGroup');
                    if (cockpit) cockpit.visible = false;
                    
                    updateObservatoryCamera();
                    updateShipHUD();
                    renderer.render(scene, obsCamera);
                    labelRenderer.render(scene, obsCamera);
                } else if (isInteriorMode) {
                    // ì„ ë‚´ ëª¨ë“œ - 1ì¸ì¹­ íƒí—˜
                    updateInteriorPlayer(rawDt);  // ì‹¤ì œ ì‹œê°„ ì‚¬ìš© (ì‹œê°„ë°°ì† ë¬´ê´€)
                    updatePhysicsObjects(rawDt);  // ì‹¤ì œ ì‹œê°„ ì‚¬ìš©
                    
                    // ì—”ì§„/í™€ë¡œê·¸ë¨ ì• ë‹ˆë©”ì´ì…˜
                    engineParts.forEach(part => {
                        if (part.userData && part.userData.animate) part.userData.animate(elapsedTime);
                    });
                    interactableObjects.forEach(obj => {
                        if (obj.userData && obj.userData.animate) obj.userData.animate(elapsedTime);
                    });
                    
                    interiorRenderer.render(interiorScene, interiorCamera);
                } else {
                    // 1ì¸ì¹­ ì¡°ì¢…ì„ ëª¨ë“œ (ë„í‚¹ ì¤‘ì´ ì•„ë‹ ë•Œë§Œ)
                    
                    // â˜… ì •ê±°ì¥ì— ë„í‚¹ëœ ìƒíƒœë©´ í•¨ê»˜ ì´ë™
                    if (window.isDockedToStation) {
                        updateDockedPosition();
                    }
                    
                    updatePilotMode(dt);

                    // â˜…â˜…â˜… ë¬´ê¸° ì‹œìŠ¤í…œ ì—…ë°ì´íŠ¸ â˜…â˜…â˜…
                    updateWeaponSystem(dt);

                    // â˜…â˜…â˜… ì •ê±°ì¥/ì˜¤ë¸Œì íŠ¸ ì¶©ëŒ ì²´í¬ ë° ë‚´êµ¬ë„ ì—…ë°ì´íŠ¸ â˜…â˜…â˜…
                    checkStationCollisions();
                    updateHullHUD();
                    
                    if (!window.isDocking) {
                        updateCockpitView(dt);
                    }
                    
                    // â˜… ì¡°ì¢…ì„ ë Œë”ë§
                    const cockpit = playerShip?.mesh?.getObjectByName('cockpitGroup');
                    if (cockpit) {
                        if (isCockpitView) {
                            // 1ì¸ì¹­ ì¡°ì¢…ì„ ë·° - ë‹¨ìˆœ ë Œë”ë§
                            const shipVisual = playerShip?.mesh?.getObjectByName('shipVisual');
                            if (shipVisual) shipVisual.visible = false;
                            cockpit.visible = true;

                            // ì¡°ì¢…ì„ ì¬ì§ˆ ì •ìƒí™” (HUD íŒ¨ë„ ì œì™¸)
                            cockpit.traverse(obj => {
                                if (obj.isMesh && obj.material) {
                                    // â˜…â˜…â˜… HUD íŒ¨ë„ì€ depthTest: false ìœ ì§€ (í´ë¦¬í•‘ ë°©ì§€)
                                    if (obj.material.blending === THREE.AdditiveBlending) {
                                        // HUD íŒ¨ë„ì€ AdditiveBlending ì‚¬ìš© - ê±´ë“œë¦¬ì§€ ì•ŠìŒ
                                        return;
                                    }
                                    obj.material.depthTest = true;
                                    obj.material.depthWrite = true;
                                }
                            });

                            // ë‹¨ì¼ íŒ¨ìŠ¤ ë Œë”ë§ (ì¡°ì¢…ì‹¤ì´ ì¹´ë©”ë¼ì— ê°€ê¹Œì›Œì„œ ìì—°ìŠ¤ëŸ½ê²Œ ì•ì— ë Œë”ë§ë¨)
                            renderer.render(scene, camera);
                        } else {
                            // 3ì¸ì¹­ ë·° - ìš°ì£¼ì„  ë³¸ì²´ë§Œ í‘œì‹œ (ì¡°ì¢…ì„ ìˆ¨ê¹€)
                            cockpit.visible = false;  // â˜… ì¡°ì¢…ì„ ìˆ¨ê¹€

                            // â˜… shipVisualGroup í‘œì‹œ (ìš°ì£¼ì„  ë³¸ì²´/GLB ëª¨ë¸)
                            const shipVisual = playerShip?.mesh?.getObjectByName('shipVisual');
                            if (shipVisual) shipVisual.visible = true;

                            // â˜…â˜…â˜… 3ì¸ì¹­ ì¹´ë©”ë¼: ìš°ì£¼ì„  ë”°ë¼ê°€ê¸° + ì¤Œ ì§€ì› â˜…â˜…â˜…
                            const shipPos = playerShip.mesh.position.clone();

                            // targetì„ ìš°ì£¼ì„  ìœ„ì¹˜ë¡œ ì„¤ì •
                            controls.target.copy(shipPos);

                            // ìš°ì£¼ì„  ì´ë™ëŸ‰ ê³„ì‚°
                            if (lastShipPosition) {
                                const diff = new THREE.Vector3().subVectors(shipPos, lastShipPosition);
                                // ì¹´ë©”ë¼ë„ ê°™ì´ ì´ë™ (ì¤Œ ê±°ë¦¬ ìœ ì§€)
                                camera.position.add(diff);
                            }
                            lastShipPosition = shipPos.clone();

                            // OrbitControls ì—…ë°ì´íŠ¸ (ì¤Œ/íšŒì „ ì ìš©)
                            controls.update();
                            renderer.render(scene, camera);
                        }
                    } else {
                        renderer.render(scene, camera);
                    }
                    
                    labelRenderer.render(scene, camera);
                }
            } else {
                // ì¼ë°˜ ëª¨ë“œ
                if(focusedBody && focusedBody.mesh && prevPos){ 
                    const diff = new THREE.Vector3().subVectors(focusedBody.mesh.position, prevPos); 
                    camera.position.add(diff); 
                    controls.target.copy(focusedBody.mesh.position); 
                }
                
                // í¬ì»¤ìŠ¤ëœ ì²œì²´ì™€ì˜ ê±°ë¦¬ í‘œì‹œ ì—…ë°ì´íŠ¸
                updateFocusDistance();
                
                // íƒ‘ìŠ¹ ë²„íŠ¼ì€ focusBodyì—ì„œë§Œ ê´€ë¦¬ (ê¹œë°•ì„ ë°©ì§€)
                
                controls.update(); 
                renderer.render(scene, camera); 
                labelRenderer.render(scene, camera);
            }
        }

        function init() {
            try {
                scene = new THREE.Scene();
                // scene.fog ì œê±° - ì•ˆë“œë¡œë©”ë‹¤ ì€í•˜ ê°€ì‹œì„±ì„ ìœ„í•´
                window.scene = scene;  // â˜… ë©€í‹°í”Œë ˆì´ì–´ì—ì„œ ì‚¬ìš©

                camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.001, 30000000000);
                camera.position.set(0, 500, 800);
                window.camera = camera;  // â˜… ë§ì›ê²½ ëª¨ë“œì—ì„œ ì‚¬ìš©

                // ëª¨ë°”ì¼ ê°ì§€
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                
                renderer = new THREE.WebGLRenderer({ 
                    antialias: !isMobile,  // ëª¨ë°”ì¼ì—ì„œ ì•ˆí‹°ì•¨ë¦¬ì–´ì‹± ë¹„í™œì„±í™” (ì„±ëŠ¥)
                    logarithmicDepthBuffer: true,
                    powerPreference: 'high-performance'
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                renderer.toneMapping = THREE.ACESFilmicToneMapping;  // â˜… ì˜í™” ê°™ì€ í†¤ë§¤í•‘
                renderer.toneMappingExposure = 1.2;  // â˜… ë…¸ì¶œ ì¡°ì •
                document.getElementById('canvas-container').appendChild(renderer.domElement);
                
                // â˜… ìš°ì£¼ í™˜ê²½ë§µ ìƒì„± (ë©”íƒˆë¦­ ë°˜ì‚¬ìš©)
                const pmremGenerator = new THREE.PMREMGenerator(renderer);
                pmremGenerator.compileEquirectangularShader();
                
                // ìš°ì£¼ ë°°ê²½ìƒ‰ ê¸°ë°˜ í™˜ê²½ë§µ ìƒì„±
                const spaceEnvScene = new THREE.Scene();
                spaceEnvScene.background = new THREE.Color(0x000510);
                
                // ë³„ë¹› í¬ì¸íŠ¸ ì¶”ê°€
                const starGeom = new THREE.BufferGeometry();
                const starCount = 200;
                const starPositions = new Float32Array(starCount * 3);
                for (let i = 0; i < starCount; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const r = 50;
                    starPositions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                    starPositions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                    starPositions[i * 3 + 2] = r * Math.cos(phi);
                }
                starGeom.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
                const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 2 });
                spaceEnvScene.add(new THREE.Points(starGeom, starMat));
                
                // ì€ì€í•œ ì¡°ëª… ì¶”ê°€
                spaceEnvScene.add(new THREE.AmbientLight(0x334455, 0.5));
                const envSunLight = new THREE.DirectionalLight(0xffffee, 1.5);
                envSunLight.position.set(10, 10, 10);
                spaceEnvScene.add(envSunLight);
                
                // í™˜ê²½ë§µ ìƒì„± ë° ì ìš©
                const spaceEnvMap = pmremGenerator.fromScene(spaceEnvScene, 0.04).texture;
                scene.environment = spaceEnvMap;  // â˜… ì”¬ ì „ì²´ì— í™˜ê²½ë§µ ì ìš©
                pmremGenerator.dispose();

                labelRenderer = new CSS2DRenderer();
                labelRenderer.setSize(window.innerWidth, window.innerHeight);
                labelRenderer.domElement.style.position = 'absolute';
                labelRenderer.domElement.style.top = '0px';
                labelRenderer.domElement.style.pointerEvents = 'none';
                document.getElementById('canvas-container').appendChild(labelRenderer.domElement);

                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.minDistance = 0.05;  // â˜… ìµœì†Œ ê±°ë¦¬ ì¤„ì„ (ì¤Œì¸ ê°€ëŠ¥)
                controls.maxDistance = 300000000;  // 3ì–µ ë‹¨ìœ„ (ì€í•˜ ë°”ê¹¥ê¹Œì§€ ë³¼ ìˆ˜ ìˆê²Œ) - 10ë°° í™•ëŒ€ 
                window.controls = controls;  // â˜… ë§ì›ê²½ ëª¨ë“œì—ì„œ ì‚¬ìš© 

                const ambient = new THREE.AmbientLight(0xffffff, 0.4);  // â˜… 0.05 â†’ 0.4 (ë°ê¸° ì¦ê°€)
                scene.add(ambient);
                
                // â˜…â˜…â˜… íƒœì–‘ ê·¸ë¦¼ì ì¡°ëª… ì‹œìŠ¤í…œ â˜…â˜…â˜…
                const solarShadowLight = new THREE.DirectionalLight(0xfffaf0, 2.0);
                solarShadowLight.name = 'solarShadowLight';
                solarShadowLight.castShadow = true;
                
                // ê·¸ë¦¼ì ë§µ í’ˆì§ˆ ì„¤ì •
                solarShadowLight.shadow.mapSize.width = 2048;
                solarShadowLight.shadow.mapSize.height = 2048;
                solarShadowLight.shadow.camera.near = 1;
                solarShadowLight.shadow.camera.far = 50000;
                solarShadowLight.shadow.camera.left = -5000;
                solarShadowLight.shadow.camera.right = 5000;
                solarShadowLight.shadow.camera.top = 5000;
                solarShadowLight.shadow.camera.bottom = -5000;
                solarShadowLight.shadow.bias = -0.0005;
                solarShadowLight.shadow.normalBias = 0.02;
                
                scene.add(solarShadowLight);
                scene.add(solarShadowLight.target);
                window.solarShadowLight = solarShadowLight;
                
                createDetailedGalaxy();
                loadDataAndInit();
                initUI();
                initChat();
                initBodyInfoSystem();  // â˜… ì²œì²´ ì •ë³´ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
                
                const toggleBtn = document.getElementById('nav-toggle');
                const navContainer = document.getElementById('nav-container');
                toggleBtn.onclick = () => {
                    navContainer.classList.toggle('closed');
                    toggleBtn.textContent = navContainer.classList.contains('closed') ? 'â–¶' : 'â—€';
                };
                
                // ëª¨ë°”ì¼ì—ì„œ ë„¤ë¹„ê²Œì´ì…˜ íŒ¨ë„ ê¸°ë³¸ì ìœ¼ë¡œ ë‹«í˜
                if (window.innerWidth <= 768) {
                    navContainer.classList.add('closed');
                    toggleBtn.textContent = 'â–¶';
                }

                const scaleBtn = document.getElementById('btn-scale-mode');
                scaleBtn.onclick = () => {
                    const isReal = CONFIG.distScale > 1.0;
                    if (isReal) {
                        CONFIG.distScale = 1.0;
                        scaleBtn.textContent = t('distExp');
                        scaleBtn.classList.remove('active');
                        resetSimulation();
                        camera.position.set(0, 500, 800);
                        controls.target.set(0,0,0);
                        showMsg(t('msgExpMode'));
                    } else {
                        CONFIG.distScale = 50.0;
                        scaleBtn.textContent = t('distReal');
                        scaleBtn.classList.add('active');
                        resetSimulation();
                        camera.position.set(0, 5000, 8000);
                        controls.target.set(0,0,0);
                        showMsg(t('msgRealMode'));
                    }
                };

                document.getElementById('btn-station').onclick = () => {
                    openStationModal();
                };
                
                document.getElementById('station-close').onclick = () => {
                    document.getElementById('station-modal').classList.remove('open');
                };
                
                // ì •ê±°ì¥ ëª¨ë‹¬ ì™¸ë¶€ í´ë¦­ ì‹œ ë‹«ê¸°
                document.getElementById('station-modal').onclick = (e) => {
                    if (e.target.id === 'station-modal') {
                        document.getElementById('station-modal').classList.remove('open');
                    }
                };

                const catalogModal = document.getElementById('catalog-modal');
                document.getElementById('btn-catalog').onclick = () => {
                    // â˜… ë©€í‹°ëª¨ë“œ íŠœí† ë¦¬ì–¼ ê°€ì´ë“œ
                    if (typeof MultiTutorial !== 'undefined') {
                        MultiTutorial.showFeatureGuide('catalog-modal');
                    }
                    
                    catalogModal.classList.add('open');
                    renderCatalog();
                    // ë©€í‹°ëª¨ë“œì—ì„œ ë„ê° ì œëª© ë³€ê²½
                    if (typeof updateCatalogTitle === 'function') {
                        updateCatalogTitle();
                    }
                };
                document.getElementById('catalog-close').onclick = () => {
                    catalogModal.classList.remove('open');
                };

                // ì–¸ì–´ ì„ íƒ
                const langSelect = document.getElementById('lang-select');
                const savedLang = localStorage.getItem('milkyway-lang');
                if (savedLang && translations[savedLang]) {
                    langSelect.value = savedLang;
                    setLanguage(savedLang);
                } else {
                    // ì €ì¥ëœ ì–¸ì–´ê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ ì–¸ì–´(ì˜ì–´) ì ìš©
                    setLanguage('en');
                }
                langSelect.onchange = (e) => {
                    setLanguage(e.target.value);
                };

                // ì „ì²´í™”ë©´ ë²„íŠ¼
                const fullscreenBtn = document.getElementById('btn-fullscreen');
                fullscreenBtn.onclick = () => {
                    if (!document.fullscreenElement) {
                        document.documentElement.requestFullscreen().then(() => {
                            fullscreenBtn.textContent = t('windowMode');
                            fullscreenBtn.classList.add('active');
                        }).catch(err => {
                            showMsg('Fullscreen failed: ' + err.message);
                        });
                    } else {
                        document.exitFullscreen().then(() => {
                            fullscreenBtn.textContent = t('fullscreen');
                            fullscreenBtn.classList.remove('active');
                        });
                    }
                };
                
                // â˜…â˜…â˜… íƒœì–‘ê³„ ì´ˆê¸°í™” ë²„íŠ¼ â˜…â˜…â˜…
                const resetSolarBtn = document.getElementById('btn-reset-solar');
                if (resetSolarBtn) {
                    resetSolarBtn.onclick = () => {
                        if (confirm(t('confirmResetSolar') + '\n' + t('resetSolarDesc'))) {
                            resetSolarSystemComplete();
                            showMsg('ğŸ”„ ' + t('resetSolarSystem'));
                        }
                    };
                }
                document.addEventListener('fullscreenchange', () => {
                    if (!document.fullscreenElement) {
                        fullscreenBtn.textContent = t('fullscreen');
                        fullscreenBtn.classList.remove('active');
                    }
                });

                // ê¸´ê¸‰ ì—­ì¶”ì§„ ë²„íŠ¼ (ë°ìŠ¤í¬í†±)
                const emergencyBrakeBtn = document.getElementById('btn-emergency-brake');
                emergencyBrakeBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    shipInputs.emergencyReverse = true;
                });
                emergencyBrakeBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    shipInputs.emergencyReverse = false;
                });
                emergencyBrakeBtn.addEventListener('mousedown', () => { shipInputs.emergencyReverse = true; });
                emergencyBrakeBtn.addEventListener('mouseup', () => { shipInputs.emergencyReverse = false; });
                emergencyBrakeBtn.addEventListener('mouseleave', () => { shipInputs.emergencyReverse = false; });

                // â˜… ê¸´ê¸‰ ì—­ì¶”ì§„ ë²„íŠ¼ (ëª¨ë°”ì¼ íƒ­ íŒ¨ë„ìš©)
                const mobileEmergencyBrakeBtn = document.getElementById('mobile-emergency-brake');
                if (mobileEmergencyBrakeBtn) {
                    mobileEmergencyBrakeBtn.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        shipInputs.emergencyReverse = true;
                    });
                    mobileEmergencyBrakeBtn.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        shipInputs.emergencyReverse = false;
                    });
                    mobileEmergencyBrakeBtn.addEventListener('mousedown', () => { shipInputs.emergencyReverse = true; });
                    mobileEmergencyBrakeBtn.addEventListener('mouseup', () => { shipInputs.emergencyReverse = false; });
                    mobileEmergencyBrakeBtn.addEventListener('mouseleave', () => { shipInputs.emergencyReverse = false; });
                }

                window.addEventListener('resize', onResize);
                window.addEventListener('mousemove', onMouseMove);
                
                // â˜… ë§ˆìš°ìŠ¤ ë“œë˜ê·¸/í´ë¦­ êµ¬ë¶„
                let mouseStartPos = null;
                let mouseStartTime = 0;
                let isMouseDragging = false;
                
                renderer.domElement.addEventListener('mousedown', (e) => {
                    if (isPilotMode) return;
                    mouseStartPos = { x: e.clientX, y: e.clientY };
                    mouseStartTime = Date.now();
                    isMouseDragging = false;
                    
                    // ì²œì²´ ìƒì„± ë“œë˜ê·¸ ì‹œì‘
                    if (isPlacing && ghostMesh) {
                        onMouseDown(e);
                    }
                });
                
                window.addEventListener('mousemove', (e) => {
                    if (!mouseStartPos) return;
                    const dx = e.clientX - mouseStartPos.x;
                    const dy = e.clientY - mouseStartPos.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist > 5) {
                        isMouseDragging = true;
                    }
                });
                
                window.addEventListener('mouseup', (e) => {
                    // ì²œì²´ ìƒì„± ë“œë˜ê·¸ ì™„ë£Œ
                    if (isPlacing && ghostMesh && isDraggingBody) {
                        onMouseUp(e);
                        mouseStartPos = null;
                        isMouseDragging = false;
                        return;
                    }
                });
                
                window.addEventListener('click', (e) => {
                    if (isPilotMode) return;
                    
                    // ì²œì²´ ìƒì„± ëª¨ë“œì—ì„œëŠ” click ë¬´ì‹œ (mousedown/mouseupìœ¼ë¡œ ì²˜ë¦¬)
                    if (isPlacing && ghostMesh) return;
                    
                    // ë“œë˜ê·¸ì˜€ìœ¼ë©´ í´ë¦­ ë¬´ì‹œ
                    if (isMouseDragging) {
                        mouseStartPos = null;
                        isMouseDragging = false;
                        return;
                    }
                    
                    // ì§§ì€ í´ë¦­ë§Œ í—ˆìš© (300ms ì´í•˜)
                    const elapsed = Date.now() - mouseStartTime;
                    if (elapsed > 300) {
                        mouseStartPos = null;
                        isMouseDragging = false;
                        return;
                    }
                    
                    mouseStartPos = null;
                    isMouseDragging = false;
                    onMouseClick(e);
                });
                
                // ëª¨ë°”ì¼ í„°ì¹˜ ì„ íƒ (OrbitControlsì™€ ë¶„ë¦¬)
                let touchStartPos = null;
                let touchStartTime = 0;
                let isTouchDragging = false;
                
                renderer.domElement.addEventListener('touchstart', (e) => {
                    if (isPilotMode || e.touches.length !== 1) return;
                    touchStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    touchStartTime = Date.now();
                    isTouchDragging = false;
                    
                    // â˜…â˜…â˜… 2ë‹¨ê³„ ì²œì²´ ìƒì„±: í™”ì‚´í‘œ í•¸ë“¤ ë˜ëŠ” ì²œì²´ ë“œë˜ê·¸ ì‹œì‘ ì²´í¬ â˜…â˜…â˜…
                    if (pendingBody) {
                        const touchX = e.touches[0].clientX;
                        const touchY = e.touches[0].clientY;
                        if (checkPendingBodyTouch(touchX, touchY)) {
                            isPendingDrag = true;
                            pendingDragStart = touchTo3D(touchX, touchY);
                            if (e.cancelable) e.preventDefault();
                            return;
                        }
                    }
                    
                    // ì²œì²´ ìƒì„± ë“œë˜ê·¸ ì‹œì‘ (ëª¨ë°”ì¼)
                    if (isPlacing && ghostMesh) {
                        const fakeEvent = { 
                            clientX: e.touches[0].clientX, 
                            clientY: e.touches[0].clientY,
                            target: { closest: () => null }
                        };
                        onMouseDown(fakeEvent);
                    }
                }, { passive: false });
                
                renderer.domElement.addEventListener('touchmove', (e) => {
                    // â˜…â˜…â˜… 2ë‹¨ê³„ ì²œì²´ ìƒì„±: í™”ì‚´í‘œ í•¸ë“¤ ë“œë˜ê·¸ ì¤‘ â˜…â˜…â˜…
                    if (isPendingDrag && pendingBody && pendingDragStart) {
                        const touch = e.touches[0];
                        const currentPos = touchTo3D(touch.clientX, touch.clientY);
                        if (currentPos) {
                            // í™”ì‚´í‘œì™€ í•¸ë“¤ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
                            updateArrowAndHandle(currentPos);
                        }
                        if (e.cancelable) e.preventDefault();
                        return;
                    }
                    
                    // ì²œì²´ ìƒì„± ë“œë˜ê·¸ ì¤‘ (ëª¨ë°”ì¼)
                    if (isPlacing && ghostMesh && isDraggingBody) {
                        const touch = e.touches[0];
                        const fakeEvent = { clientX: touch.clientX, clientY: touch.clientY };
                        onMouseMove(fakeEvent);
                    }
                    
                    if (!touchStartPos) return;
                    const touch = e.touches[0];
                    const dx = touch.clientX - touchStartPos.x;
                    const dy = touch.clientY - touchStartPos.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    // 3px ì´ìƒ ì›€ì§ì´ë©´ ë“œë˜ê·¸ë¡œ íŒì • (ë” ë¯¼ê°í•˜ê²Œ)
                    if (dist > 3) {
                        isTouchDragging = true;
                    }
                }, { passive: true });  // passive: trueë¡œ ë³€ê²½í•˜ì—¬ ìŠ¤í¬ë¡¤ ìµœì í™”
                
                renderer.domElement.addEventListener('touchend', (e) => {
                    // â˜…â˜…â˜… 2ë‹¨ê³„ ì²œì²´ ìƒì„±: í™”ì‚´í‘œ í•¸ë“¤ ë“œë˜ê·¸ ì™„ë£Œ â˜…â˜…â˜…
                    if (isPendingDrag && pendingBody && pendingDragStart) {
                        const touch = e.changedTouches[0];
                        const endPos = touchTo3D(touch.clientX, touch.clientY);
                        
                        if (endPos && velocityHandle) {
                            // â˜…â˜…â˜… í™”ì‚´í‘œ í•¸ë“¤ ìœ„ì¹˜ ê¸°ë°˜ìœ¼ë¡œ ì†ë„ ê³„ì‚° â˜…â˜…â˜…
                            const handlePos = velocityHandle.position.clone();
                            const dragVec = new THREE.Vector3().subVectors(handlePos, pendingBody.position);
                            const dragLen = dragVec.length();
                            
                            // â˜…â˜…â˜… ì†ë„ ìŠ¤ì¼€ì¼ ëŒ€í­ ì¦ê°€ (ì¤‘ë ¥ì— ëŒ€ì‘) â˜…â˜…â˜…
                            // ë“œë˜ê·¸ ê¸¸ì´ 50 = ì•½ 0.5 ì†ë„
                            // ë“œë˜ê·¸ ê¸¸ì´ 100 = ì•½ 1.0 ì†ë„
                            // ë“œë˜ê·¸ ê¸¸ì´ 200+ = ì•½ 2.0 ì†ë„ (ìµœëŒ€)
                            const speedScale = Math.min(dragLen * 0.01, 2.0);
                            const velocity = dragVec.clone().normalize().multiplyScalar(speedScale);
                            
                            console.log(`â˜… ì²œì²´ ìƒì„± â˜…`);
                            console.log(`  - í•¸ë“¤ ìœ„ì¹˜: (${handlePos.x.toFixed(2)}, ${handlePos.y.toFixed(2)}, ${handlePos.z.toFixed(2)})`);
                            console.log(`  - ì²œì²´ ìœ„ì¹˜: (${pendingBody.position.x.toFixed(2)}, ${pendingBody.position.y.toFixed(2)}, ${pendingBody.position.z.toFixed(2)})`);
                            console.log(`  - ë“œë˜ê·¸ ê¸¸ì´: ${dragLen.toFixed(2)}`);
                            console.log(`  - ì†ë„ ìŠ¤ì¼€ì¼: ${speedScale.toFixed(6)}`);
                            console.log(`  - ìµœì¢… ì†ë„: (${velocity.x.toFixed(6)}, ${velocity.y.toFixed(6)}, ${velocity.z.toFixed(6)})`);
                            console.log(`  - ì†ë„ í¬ê¸°: ${velocity.length().toFixed(6)}`);
                            
                            // ì²œì²´ í™•ì • ìƒì„±
                            confirmPendingBody(velocity);
                        } else if (endPos) {
                            // í•¸ë“¤ì´ ì—†ìœ¼ë©´ í„°ì¹˜ ìœ„ì¹˜ ì‚¬ìš© (fallback)
                            const dragVec = new THREE.Vector3().subVectors(endPos, pendingBody.position);
                            const dragLen = dragVec.length();
                            const speedScale = Math.min(dragLen * 0.01, 2.0);
                            const velocity = dragVec.clone().normalize().multiplyScalar(speedScale);
                            confirmPendingBody(velocity);
                        }
                        
                        isPendingDrag = false;
                        pendingDragStart = null;
                        touchStartPos = null;
                        isTouchDragging = false;
                        return;
                    }
                    
                    // ì²œì²´ ìƒì„± ë“œë˜ê·¸ ì™„ë£Œ (ëª¨ë°”ì¼)
                    if (isPlacing && ghostMesh && isDraggingBody) {
                        const touch = e.changedTouches[0];
                        const fakeEvent = { clientX: touch.clientX, clientY: touch.clientY };
                        onMouseUp(fakeEvent);
                        touchStartPos = null;
                        isTouchDragging = false;
                        return;
                    }
                    
                    if (isPilotMode || !touchStartPos) {
                        touchStartPos = null;
                        isTouchDragging = false;
                        return;
                    }
                    
                    const touch = e.changedTouches[0];
                    const dx = touch.clientX - touchStartPos.x;
                    const dy = touch.clientY - touchStartPos.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    const elapsed = Date.now() - touchStartTime;
                    
                    // â˜…â˜…â˜… ëŒ€ê¸° ì²œì²´ê°€ ìˆëŠ”ë° ë‹¤ë¥¸ ê³³ íƒ­í•˜ë©´ í˜„ì¬ í™”ì‚´í‘œ ë°©í–¥ìœ¼ë¡œ ìƒì„± â˜…â˜…â˜…
                    if (pendingBody && !isTouchDragging && dist < 5 && elapsed < 150) {
                        const tapPos = touchTo3D(touch.clientX, touch.clientY);
                        if (tapPos) {
                            const distToBody = tapPos.distanceTo(pendingBody.position);
                            const bodyRadius = pendingBody.typeData.r || 1;
                            
                            if (distToBody > bodyRadius * 3) {
                                // ë©€ë¦¬ íƒ­ = í˜„ì¬ í™”ì‚´í‘œ ë°©í–¥ê³¼ ê¸¸ì´ë¡œ ì†ë„ ê³„ì‚°
                                let velocity = new THREE.Vector3(0, 0, 0);
                                
                                if (velocityHandle && pendingBody.position) {
                                    const dragVec = new THREE.Vector3().subVectors(
                                        velocityHandle.position, 
                                        pendingBody.position
                                    );
                                    const dragLen = dragVec.length();
                                    const speedScale = Math.min(dragLen * 0.01, 2.0);
                                    velocity = dragVec.clone().normalize().multiplyScalar(speedScale);
                                }
                                
                                confirmPendingBody(velocity);
                                touchStartPos = null;
                                isTouchDragging = false;
                                return;
                            }
                        }
                    }
                    
                    // ë“œë˜ê·¸ê°€ ì•„ë‹Œ ê²½ìš°ì—ë§Œ í´ë¦­ ì²˜ë¦¬ (ì´ë™ ê±°ë¦¬ 5px ì´í•˜, ì‹œê°„ 150ms ì´í•˜)
                    if (!isTouchDragging && dist < 5 && elapsed < 150) {
                        e.preventDefault();
                        controls.enabled = false;
                        setTimeout(() => { controls.enabled = true; }, 50);
                        
                        // ì²œì²´ ì„ íƒ ì²˜ë¦¬
                        const fakeEvent = {
                            clientX: touch.clientX,
                            clientY: touch.clientY,
                            target: { closest: () => null }
                        };
                        onMouseClick(fakeEvent);
                    }
                    touchStartPos = null;
                    isTouchDragging = false;
                });
                
                document.getElementById('reset-cam').onclick = resetCamera;
                
                const fineSlider = document.getElementById('time-slider-fine');
                const coarseSlider = document.getElementById('time-slider-coarse');
                const timeVal = document.getElementById('time-val');

                fineSlider.oninput = (e) => {
                    const val = parseFloat(e.target.value);
                    CONFIG.timeScale = val;
                    timeVal.innerText = val.toFixed(1) + 'x';
                };

                coarseSlider.oninput = (e) => {
                    const val = parseFloat(e.target.value);
                    CONFIG.timeScale = val;
                    timeVal.innerText = val.toFixed(1) + 'x';
                };

                // ëª¨ë°”ì¼ìš© ì‹œê°„ ì¡°ì ˆ ë²„íŠ¼
                const timeValMobile = document.getElementById('time-val-mobile');
                const timeSteps = [0, 0.1, 0.25, 0.5, 1, 2, 5, 10, 25, 50, 100];
                
                function updateTimeDisplay() {
                    const display = CONFIG.timeScale.toFixed(1) + 'x';
                    timeVal.innerText = display;
                    timeValMobile.innerText = display;
                }
                
                document.getElementById('time-slower').onclick = () => {
                    const currentIdx = timeSteps.findIndex(v => v >= CONFIG.timeScale);
                    const newIdx = Math.max(0, currentIdx - 1);
                    CONFIG.timeScale = timeSteps[newIdx];
                    fineSlider.value = Math.min(CONFIG.timeScale, 2);
                    coarseSlider.value = Math.max(CONFIG.timeScale, 1);
                    updateTimeDisplay();
                };
                
                document.getElementById('time-faster').onclick = () => {
                    const currentIdx = timeSteps.findIndex(v => v > CONFIG.timeScale);
                    const newIdx = Math.min(timeSteps.length - 1, currentIdx === -1 ? timeSteps.length - 1 : currentIdx);
                    CONFIG.timeScale = timeSteps[newIdx];
                    fineSlider.value = Math.min(CONFIG.timeScale, 2);
                    coarseSlider.value = Math.max(CONFIG.timeScale, 1);
                    updateTimeDisplay();
                };

                // ===== ìš°ì£¼ì„  ì‹œìŠ¤í…œ ì´ˆê¸°í™” =====
                document.getElementById('board-ship-btn').onclick = boardShip;
                document.getElementById('btn-select-ship').onclick = confirmShipSelection;
                document.getElementById('btn-cancel-ship').onclick = closeShipSelectModal;
                document.getElementById('btn-buy-ship').onclick = handleBuyShip;
                document.getElementById('btn-armory').onclick = openArmoryModal;
                
                // ===== ë¬´ì¥ ì‹œìŠ¤í…œ ì´ˆê¸°í™” =====
                document.getElementById('btn-armory-close').onclick = closeArmoryModal;
                document.getElementById('btn-armory-buy').onclick = handleArmoryBuy;
                document.getElementById('btn-armory-equip').onclick = handleArmoryEquip;
                document.getElementById('btn-armory-unequip').onclick = handleArmoryUnequip;
                document.querySelectorAll('.armory-tab').forEach(tab => {
                    tab.onclick = () => switchArmoryTab(tab.dataset.tab);
                });
                
                // ===== í•¨ì„  ì²˜ë¶„ ëª¨ë‹¬ =====
                document.getElementById('btn-sell-confirm').onclick = confirmSellShip;
                document.getElementById('btn-sell-cancel').onclick = () => {
                    document.getElementById('sell-ship-modal').classList.remove('open');
                };
                
                // ===== ë¡œê·¸ì¸ ì‹œìŠ¤í…œ ì´ˆê¸°í™” =====
                const loginModal = document.getElementById('login-modal');
                const loginBtn = document.getElementById('btn-login');
                const logoutBtn = document.getElementById('btn-logout');
                const loginClose = document.getElementById('login-close');
                const tabLogin = document.getElementById('tab-login');
                const tabRegister = document.getElementById('tab-register');
                const loginSubmit = document.getElementById('btn-login-submit');
                const emailInput = document.getElementById('input-email');
                const passwordConfirm = document.getElementById('input-password-confirm');
                let isRegisterMode = false;
                
                loginBtn.onclick = () => {
                    openAuthUI();
                };
                loginClose.onclick = () => loginModal.classList.remove('open');
                logoutBtn.onclick = () => {
                    logoutUser();
                    showMsg(t('logout') + '!');
                };
                
                tabLogin.onclick = () => {
                    isRegisterMode = false;
                    tabLogin.classList.add('active');
                    tabRegister.classList.remove('active');
                    loginSubmit.textContent = t('login');
                    emailInput.style.display = 'none';
                    passwordConfirm.style.display = 'none';
                    document.getElementById('terms-agree-section').style.display = 'none';  // â˜… ì•½ê´€ ìˆ¨ê¹€
                    document.getElementById('find-links').style.display = 'flex';
                    document.getElementById('login-error').textContent = '';
                    document.getElementById('login-success').textContent = '';
                };
                tabRegister.onclick = () => {
                    isRegisterMode = true;
                    tabRegister.classList.add('active');
                    tabLogin.classList.remove('active');
                    loginSubmit.textContent = t('register');
                    emailInput.style.display = 'block';
                    passwordConfirm.style.display = 'block';
                    document.getElementById('terms-agree-section').style.display = 'block';  // â˜… ì•½ê´€ í‘œì‹œ
                    document.getElementById('find-links').style.display = 'none';
                    document.getElementById('login-error').textContent = '';
                    document.getElementById('login-success').textContent = '';
                };
                
                loginSubmit.onclick = () => {
                    const username = document.getElementById('input-username').value.trim();
                    const password = document.getElementById('input-password').value;
                    loginUser(username, password, isRegisterMode);
                };
                
                // ì—”í„°í‚¤ë¡œ ë¡œê·¸ì¸
                document.getElementById('input-password').onkeypress = (e) => {
                    if (e.key === 'Enter') loginSubmit.click();
                };
                document.getElementById('input-password-confirm').onkeypress = (e) => {
                    if (e.key === 'Enter') loginSubmit.click();
                };
                
                // â˜… ì•„ì´ë””/ë¹„ë°€ë²ˆí˜¸ ì°¾ê¸° ì´ë²¤íŠ¸
                document.getElementById('link-find-id').onclick = showFindIdForm;
                document.getElementById('link-find-pw').onclick = showFindPwForm;
                document.getElementById('back-from-find-id').onclick = showLoginForm;
                document.getElementById('back-from-find-pw').onclick = showLoginForm;
                
                document.getElementById('btn-find-id').onclick = () => {
                    const email = document.getElementById('find-id-email').value.trim();
                    findUserId(email);
                };
                document.getElementById('btn-find-pw').onclick = () => {
                    const username = document.getElementById('find-pw-username').value.trim();
                    const email = document.getElementById('find-pw-email').value.trim();
                    findUserPassword(username, email);
                };
                
                // ì—”í„°í‚¤ë¡œ ì°¾ê¸°
                document.getElementById('find-id-email').onkeypress = (e) => {
                    if (e.key === 'Enter') document.getElementById('btn-find-id').click();
                };
                document.getElementById('find-pw-email').onkeypress = (e) => {
                    if (e.key === 'Enter') document.getElementById('btn-find-pw').click();
                };
                
                // â˜… Supabase ìë™ ë¡œê·¸ì¸ì€ loadSavedLogin()ì—ì„œ ì²˜ë¦¬ë¨
                // êµ¬í˜• localStorage ë¡œê·¸ì¸ì€ ë” ì´ìƒ ì‚¬ìš©í•˜ì§€ ì•ŠìŒ
                
                // ë„í‚¹ëœ ìš°ì£¼ì„  ìƒì„± (ISS ìƒì„± í›„)
                setTimeout(() => {
                    const station = satellites.find(s => s.name === "ISS ìš°ì£¼ì •ê±°ì¥");
                    if (station) {
                        createDockedShip(station);
                    }
                }, 1000);
                
                // ===== ì„ ë‚´ ì‹œìŠ¤í…œ ì´ˆê¸°í™” =====
                initInteriorScene();
                initInteriorControls();
                initObservatoryControls();

                // ===== ë°±ê·¸ë¼ìš´ë“œ Worker ì´ˆê¸°í™” =====
                initBackgroundWorker();

                animate();
            } catch (err) {
                console.error("Initialization Error:", err);
            }
        }
        
        // ===== ê²Œì„ ëª¨ë“œ ì‹œì‘ í•¨ìˆ˜ (module ë‚´ë¶€) =====
        let gameMode = null;
        const MODE_CONFIG = {
            single: {
                fuelMultiplier: 1.0,
                turnMultiplier: 0.5,      // â˜… ì‹±ê¸€ëª¨ë“œ ì„ íšŒ ì†ë„ ì ˆë°˜ (ë©€í‹°ì™€ ë™ì¼í•˜ê²Œ)
                timeSpeedFixed: false,
                canCreateBodies: true,
                canDisembark: true,
                showChat: false
            },
            multi: {
                fuelMultiplier: 0.5,      // â˜… ì—°ë£Œ 2ë°° ì ê²Œ ì†Œëª¨ (0.2 â†’ 0.5)
                turnMultiplier: 0.5,      // â˜… ë©€í‹°ëª¨ë“œ ì„ íšŒ ì†ë„
                timeSpeedFixed: true,
                canCreateBodies: false,
                canDisembark: false,
                showChat: true
            }
        };
        // ì „ì—­ìœ¼ë¡œ ë…¸ì¶œ
        window.MODE_CONFIG = MODE_CONFIG;
        
        // ë°©ë¬¸í•œ ìœ„ì„± ê¸°ë¡ (localStorageì—ì„œ ë¶ˆëŸ¬ì˜¤ê¸°)
        let visitedSatellites;
        try {
            const savedVisited = localStorage.getItem('visitedStations');
            if (savedVisited) {
                visitedSatellites = new Set(JSON.parse(savedVisited));
                // ISSëŠ” í•­ìƒ í¬í•¨
                visitedSatellites.add('ISS');
                visitedSatellites.add('ISS ìš°ì£¼ì •ê±°ì¥');
            } else {
                visitedSatellites = new Set(['ISS', 'ISS ìš°ì£¼ì •ê±°ì¥']);
            }
        } catch (e) {
            visitedSatellites = new Set(['ISS', 'ISS ìš°ì£¼ì •ê±°ì¥']);
        }
        window.visitedSatellites = visitedSatellites;
        
        // ë°©ë¬¸ ê¸°ë¡ ì €ì¥ í•¨ìˆ˜ (ë¡œê·¸ì¸ ì‹œ ì„œë²„, ì•„ë‹ˆë©´ ë¡œì»¬)
        window.saveVisitedStations = function() {
            var visitedArray = Array.from(visitedSatellites);
            
            // ë¡œì»¬ì—ë„ í•­ìƒ ì €ì¥ (ë°±ì—…)
            localStorage.setItem('visitedStations', JSON.stringify(visitedArray));
            
            // ë¡œê·¸ì¸ëœ ê²½ìš° Supabaseì— ì €ì¥
            var userId = window.mpUserId || (window.mpUser && window.mpUser.id);
            var isGuest = userId && userId.indexOf('guest_') === 0;
            if (userId && supabase && !isGuest) {
                // ëª¨ë“  ë°©ë¬¸ ê¸°ë¡ì„ í•œë²ˆì— ì €ì¥
                var upsertPromises = visitedArray.map(function(bodyName) {
                    return supabase
                        .from('visited_bodies')
                        .upsert({
                            user_id: userId,
                            body_name: bodyName,
                            last_visited_at: new Date().toISOString()
                        }, {
                            onConflict: 'user_id,body_name'
                        });
                });
                
                Promise.all(upsertPromises)
                    .then(function() {
                        console.log('ë°©ë¬¸ ê¸°ë¡ Supabase ì €ì¥ ì™„ë£Œ');
                    })
                    .catch(function(e) {
                        console.warn('Supabase ì €ì¥ ì‹¤íŒ¨, ë¡œì»¬ì—ë§Œ ì €ì¥ë¨:', e);
                    });
            }
        };
        
        // ë°©ë¬¸ ê¸°ë¡ ë¶ˆëŸ¬ì˜¤ê¸° í•¨ìˆ˜ (ë¡œê·¸ì¸ ì‹œ Supabaseì—ì„œ)
        window.loadVisitedStations = function() {
            var userId = window.mpUserId || (window.mpUser && window.mpUser.id);
            var isGuest = userId && userId.indexOf('guest_') === 0;
            
            if (userId && supabase && !isGuest) {
                return supabase
                    .from('visited_bodies')
                    .select('body_name')
                    .eq('user_id', userId)
                    .then(function(result) {
                        var data = result.data;
                        var error = result.error;
                        
                        if (!error && data && data.length > 0) {
                            visitedSatellites = new Set(data.map(function(d) { return d.body_name; }));
                            // ISSëŠ” í•­ìƒ í¬í•¨
                            visitedSatellites.add('ISS');
                            visitedSatellites.add('ISS ìš°ì£¼ì •ê±°ì¥');
                            window.visitedSatellites = visitedSatellites;
                            
                            // ë¡œì»¬ì—ë„ ë™ê¸°í™”
                            localStorage.setItem('visitedStations', JSON.stringify(Array.from(visitedSatellites)));
                            console.log('Supabaseì—ì„œ ë°©ë¬¸ ê¸°ë¡ ë¶ˆëŸ¬ì˜´:', visitedSatellites.size, 'ê°œ');
                            return;
                        }
                        
                        // ì„œë²„ì—ì„œ ëª» ê°€ì ¸ì˜¨ ê²½ìš° ë¡œì»¬ì—ì„œ
                        loadFromLocal();
                    })
                    .catch(function(e) {
                        console.warn('Supabase ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨, ë¡œì»¬ ë°ì´í„° ì‚¬ìš©:', e);
                        loadFromLocal();
                    });
            } else {
                loadFromLocal();
                return Promise.resolve();
            }
            
            function loadFromLocal() {
                try {
                    var savedVisited = localStorage.getItem('visitedStations');
                    if (savedVisited) {
                        visitedSatellites = new Set(JSON.parse(savedVisited));
                        visitedSatellites.add('ISS');
                        visitedSatellites.add('ISS ìš°ì£¼ì •ê±°ì¥');
                        window.visitedSatellites = visitedSatellites;
                    }
                } catch (e) {
                    console.warn('ë¡œì»¬ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨');
                }
            }
        };
        
        window.gameMode = null;
        
        function startGameMode(mode) {
            gameMode = mode;
            window.gameMode = mode;
            const config = MODE_CONFIG[mode];

            console.log('startGameMode í˜¸ì¶œë¨:', mode);

            // â˜…â˜…â˜… ì „ì²´í™”ë©´ + ê°€ë¡œëª¨ë“œ ê°•ì œ â˜…â˜…â˜…
            document.body.classList.add('game-mode');
            document.body.classList.add('game-started');  // â˜… ìƒë‹¨ ë²„íŠ¼ í‘œì‹œìš©

            // â˜…â˜…â˜… ê°•ì œ ê°€ë¡œ ëª¨ë“œ (APK/ëª¨ë°”ì¼ìš©) â˜…â˜…â˜…
            forceGameLandscape();

            // ì „ì²´í™”ë©´ ì§„ì… ì‹œë„ (ì„ íƒì )
            const elem = document.documentElement;
            const requestFS = elem.requestFullscreen || elem.webkitRequestFullscreen || elem.msRequestFullscreen;

            if (requestFS) {
                requestFS.call(elem).then(() => {
                    // ì „ì²´í™”ë©´ ì„±ê³µ ì‹œ ë‹¤ì‹œ ê°€ë¡œëª¨ë“œ ì ê¸ˆ
                    forceGameLandscape();
                }).catch(e => {
                    console.log('ì „ì²´í™”ë©´ ì „í™˜:', e.message);
                    // ì „ì²´í™”ë©´ ì‹¤íŒ¨í•´ë„ ê²Œì„ì€ ì§„í–‰
                });
            }

            // ì˜¤ë²„ë ˆì´ ìˆ¨ê¸°ê¸°
            document.getElementById('mode-select-overlay').style.display = 'none';

            // â˜… BGM ì¬ìƒ ì‹œì‘
            AudioManager.playBGM('bgm_explore');

            // ë©€í‹° ëª¨ë“œ ì„¤ì •
            if (mode === 'multi') {
                // ì‹¤ì œ ê±°ë¦¬ ëª¨ë“œ ê°•ì œ (distScaleì´ ì‹¤ì œ ì‚¬ìš©ë˜ëŠ” ë³€ìˆ˜!)
                CONFIG.distScale = 50;
                CONFIG.timeScale = 0.01;  // â˜… ë©€í‹°ëª¨ë“œ: 0.01ë°°ì† (10ë°° ë” ëŠë¦¬ê²Œ)

                // â˜…â˜…â˜… ë©€í‹°ëª¨ë“œ: ì„œë²„ì—ì„œ ê²Œì„ ë°ì´í„° ë¡œë“œ â˜…â˜…â˜…
                (async function loadMultiplayerData() {
                    console.log('ğŸ”„ ë©€í‹°ëª¨ë“œ: ì„œë²„ì—ì„œ ê²Œì„ ë°ì´í„° ë¡œë”©...');
                    try {
                        // ë¬´ê¸°ê³ , ë¯¸ì…˜, SSIL ë¯¸ì…˜ ë°ì´í„° ë³‘ë ¬ ë¡œë“œ
                        await Promise.all([
                            typeof loadArmoryFromServer === 'function' ? loadArmoryFromServer() : Promise.resolve(),
                            typeof MissionSystem !== 'undefined' && MissionSystem.loadProgressAsync ? MissionSystem.loadProgressAsync() : Promise.resolve(),
                            typeof loadSSILStateAsync === 'function' ? loadSSILStateAsync() : Promise.resolve()
                        ]);
                        console.log('âœ… ë©€í‹°ëª¨ë“œ: ê²Œì„ ë°ì´í„° ë¡œë“œ ì™„ë£Œ');
                    } catch (e) {
                        console.warn('ë©€í‹°ëª¨ë“œ ë°ì´í„° ë¡œë“œ ì¤‘ ì˜¤ë¥˜:', e);
                    }
                })();

                // â˜…â˜…â˜… íƒœì–‘ê³„ ì¬ì´ˆê¸°í™” (ì‹¤ì œ ê±°ë¦¬ë¡œ) â˜…â˜…â˜…
                reinitSolarSystemForMulti();
                
                // ì‹œê°„ ë°°ì† ì»¨íŠ¸ë¡¤ ìˆ¨ê¸°ê¸°
                const mobileTimeControls = document.getElementById('mobile-time-controls');
                if (mobileTimeControls) {
                    mobileTimeControls.style.display = 'none';
                    console.log('ë°°ì† ì»¨íŠ¸ë¡¤ ìˆ¨ê¹€');
                }
                
                // ë°ìŠ¤í¬í†± ìŠ¬ë¼ì´ë” ì»¨í…Œì´ë„ˆë„ ìˆ¨ê¸°ê¸°
                const sliderContainers = document.querySelectorAll('.slider-container');
                sliderContainers.forEach(c => c.style.display = 'none');
                
                // â˜…â˜…â˜… ë°°ì† í‘œì‹œ ìˆ¨ê¸°ê¸° â˜…â˜…â˜…
                const timeVal = document.getElementById('time-val');
                if (timeVal) timeVal.style.display = 'none';
                const timeValMobile = document.getElementById('time-val-mobile');
                if (timeValMobile) timeValMobile.style.display = 'none';
                
                // ê±°ë¦¬ ëª¨ë“œ ë²„íŠ¼ ìˆ¨ê¸°ê¸°
                const distanceBtn = document.getElementById('btn-scale-mode');
                if (distanceBtn) {
                    distanceBtn.style.display = 'none';
                    console.log('ê±°ë¦¬ ë²„íŠ¼ ìˆ¨ê¹€');
                }
                
                // â˜…â˜…â˜… ë©€í‹°ëª¨ë“œ: íƒœì–‘ê³„ ì´ˆê¸°í™” ë²„íŠ¼ ìˆ¨ê¸°ê¸° â˜…â˜…â˜…
                const resetSolarBtn = document.getElementById('btn-reset-solar');
                if (resetSolarBtn) {
                    resetSolarBtn.style.display = 'none';
                    console.log('íƒœì–‘ê³„ ì´ˆê¸°í™” ë²„íŠ¼ ìˆ¨ê¹€ (ë©€í‹°ëª¨ë“œ)');
                }
                
                // ì˜¤ë¥¸ìª½ í–‰ì„± ìƒì„± ë²„íŠ¼ë“¤ ìˆ¨ê¸°ê¸°
                const spawnDock = document.getElementById('spawn-dock');
                if (spawnDock) {
                    spawnDock.style.display = 'none';
                    console.log('í–‰ì„± ìƒì„± ë²„íŠ¼ ìˆ¨ê¹€');
                }
                
                // â˜…â˜…â˜… ë©€í‹°ëª¨ë“œ: ARIA + ë©€í‹° íƒ­ ëª¨ë‘ í‘œì‹œ â˜…â˜…â˜…
                const unifiedChat = document.getElementById('unified-chat-panel');
                if (unifiedChat) {
                    // ì±„íŒ…ì°½ í‘œì‹œ
                    unifiedChat.style.display = 'block';
                    
                    // ARIA íƒ­ê³¼ ë©€í‹° íƒ­ ëª¨ë‘ í‘œì‹œ
                    const ariaTabBtn = unifiedChat.querySelector('[data-tab="aria"]');
                    const multiTabBtn = unifiedChat.querySelector('[data-tab="multi"]');
                    const ariaTab = document.getElementById('aria-tab');
                    const multiTab = document.getElementById('multi-tab');
                    
                    // ë‘ íƒ­ ë²„íŠ¼ ëª¨ë‘ í‘œì‹œ
                    if (ariaTabBtn) ariaTabBtn.style.display = 'block';
                    if (multiTabBtn) multiTabBtn.style.display = 'block';
                    
                    // ë©€í‹° íƒ­ì„ ê¸°ë³¸ í™œì„±í™”
                    if (ariaTabBtn) ariaTabBtn.classList.remove('active');
                    if (multiTabBtn) multiTabBtn.classList.add('active');
                    if (ariaTab) ariaTab.classList.remove('active');
                    if (multiTab) multiTab.classList.add('active');
                    
                    console.log('ë©€í‹°ëª¨ë“œ: ARIA + ë©€í‹° íƒ­ í™œì„±í™”');
                }
                const aiCopilot = document.getElementById('ai-copilot-panel');
                if (aiCopilot) {
                    aiCopilot.style.display = 'none';
                }
                
                // â˜…â˜…â˜… ë©€í‹°ëª¨ë“œ: ìš°ì£¼ ì§€ì‹ ê°€ì´ë“œ (ì‹±ê¸€ëª¨ë“œìš©) ìˆ¨ê¸°ê¸° â˜…â˜…â˜…
                const chatToggle = document.getElementById('chat-toggle');
                const chatPanel = document.getElementById('chat-panel');
                if (chatToggle) {
                    chatToggle.style.display = 'none';
                    console.log('ìš°ì£¼ ì§€ì‹ ê°€ì´ë“œ ë²„íŠ¼ ìˆ¨ê¹€ (ë©€í‹°ëª¨ë“œ)');
                }
                if (chatPanel) {
                    chatPanel.style.display = 'none';
                }
                
                // â˜…â˜…â˜… ë©€í‹°ëª¨ë“œ: ì²œì²´ ëª©ë¡/ìƒë‹¨ë©”ë‰´ ìˆ¨ê¹€ â˜…â˜…â˜…
                const navPanel = document.getElementById('nav-panel');
                const navContainer = document.getElementById('nav-container');
                const topBar = document.getElementById('top-bar');

                if (navPanel) navPanel.style.display = 'none';
                if (navContainer) navContainer.style.display = 'none';
                if (topBar) topBar.style.display = 'none';
                console.log('ë©€í‹°ëª¨ë“œ: ì²œì²´ ëª©ë¡, ìƒë‹¨ ë©”ë‰´ ìˆ¨ê¹€');

                // â˜…â˜…â˜… ê²Œì„ ìƒíƒœ ì„œë²„ ì €ì¥/ë¡œë“œ í•¨ìˆ˜ â˜…â˜…â˜…
                window.loadGameStateFromServer = async function() {
                    try {
                        if (!window.mpUser || typeof supabase === 'undefined') {
                            console.log('ê²Œì„ ìƒíƒœ ë¡œë“œ: ë¡œê·¸ì¸ í•„ìš”');
                            return null;
                        }

                        const { data, error } = await supabase
                            .from('profiles')
                            .select('game_state')
                            .eq('id', window.mpUser.id)
                            .single();

                        if (error) {
                            console.warn('ê²Œì„ ìƒíƒœ ë¡œë“œ ì‹¤íŒ¨:', error);
                            return null;
                        }

                        if (data && data.game_state) {
                            console.log('ğŸ® ì„œë²„ì—ì„œ ê²Œì„ ìƒíƒœ ë¡œë“œ:', data.game_state);
                            return data.game_state;
                        }

                        return null;
                    } catch (e) {
                        console.error('ê²Œì„ ìƒíƒœ ë¡œë“œ ì˜¤ë¥˜:', e);
                        return null;
                    }
                };

                window.saveGameStateToServer = async function(state) {
                    try {
                        if (!window.mpUser || typeof supabase === 'undefined') {
                            console.log('ê²Œì„ ìƒíƒœ ì €ì¥: ë¡œê·¸ì¸ í•„ìš”');
                            return false;
                        }

                        const { error } = await supabase
                            .from('profiles')
                            .update({ game_state: state })
                            .eq('id', window.mpUser.id);

                        if (error) {
                            console.warn('ê²Œì„ ìƒíƒœ ì €ì¥ ì‹¤íŒ¨:', error);
                            return false;
                        }

                        console.log('ğŸ® ì„œë²„ì— ê²Œì„ ìƒíƒœ ì €ì¥:', state);
                        return true;
                    } catch (e) {
                        console.error('ê²Œì„ ìƒíƒœ ì €ì¥ ì˜¤ë¥˜:', e);
                        return false;
                    }
                };

                // â˜…â˜…â˜… ë©€í‹°ëª¨ë“œ: ìë™ ë¡œê·¸ì¸ + ê²Œì„ ìƒíƒœ ë³µì› â˜…â˜…â˜…
                (async function restoreGameState() {
                    // ë¨¼ì € ìë™ ë¡œê·¸ì¸ ì‹œë„
                    if (!window.mpUser && typeof loadSavedLogin === 'function') {
                        console.log('ğŸ” ìë™ ë¡œê·¸ì¸ ì‹œë„...');
                        try {
                            await loadSavedLogin();
                        } catch (e) {
                            console.warn('ìë™ ë¡œê·¸ì¸ ì‹¤íŒ¨:', e);
                        }
                    }

                    // mpUserê°€ ì„¤ì •ë  ë•Œê¹Œì§€ ì¶”ê°€ ëŒ€ê¸° (ìµœëŒ€ 5ì´ˆ)
                    let waitCount = 0;
                    while (!window.mpUser && waitCount < 25) {
                        await new Promise(r => setTimeout(r, 200));
                        waitCount++;
                    }

                    if (!window.mpUser) {
                        console.log('ğŸ® ë¡œê·¸ì¸ í•„ìš”, ë¡œê·¸ì¸ ì°½ í‘œì‹œ');
                        // ë¡œê·¸ì¸ ì°½ í‘œì‹œ
                        const authOverlay = document.getElementById('auth-overlay');
                        if (authOverlay) {
                            authOverlay.style.display = 'flex';
                        } else if (typeof createAuthUI === 'function') {
                            createAuthUI();
                        }
                        return;
                    }

                    console.log('âœ… ìë™ ë¡œê·¸ì¸ ì™„ë£Œ:', window.mpUser.nickname || window.mpUser.email);

                    try {
                        console.log('ğŸ® ë¡œê·¸ì¸ í™•ì¸ë¨, ê²Œì„ ìƒíƒœ ë¡œë“œ ì‹œë„...');
                        const savedState = await loadGameStateFromServer();

                        if (savedState && savedState.isPilotMode) {
                            // ì¡°ì¢…ì„ ëª¨ë“œë¡œ ë°”ë¡œ ì§„ì… (ìš°ì£¼ì„  ì„ íƒ ì—†ì´)
                            console.log('ğŸ® ì €ì¥ëœ ìƒíƒœ: ì¡°ì¢…ì„ ëª¨ë“œ ë³µì›');
                            window.skipShipSelectForRestore = true;  // í”Œë˜ê·¸ ì„¤ì •
                            setTimeout(() => {
                                if (typeof boardShip === 'function') {
                                    boardShip();
                                }
                            }, 1000);
                            return; // íŠœí† ë¦¬ì–¼ ìŠ¤í‚µ
                        }

                        // ì €ì¥ëœ ìƒíƒœê°€ ì—†ìœ¼ë©´ íŠœí† ë¦¬ì–¼ ì²´í¬
                        setTimeout(() => {
                            if (typeof MultiTutorial !== 'undefined') {
                                MultiTutorial.checkAndStart();
                            }
                        }, 500);

                    } catch (e) {
                        console.warn('ê²Œì„ ìƒíƒœ ë³µì› ì‹¤íŒ¨:', e);
                        // ì‹¤íŒ¨í•´ë„ íŠœí† ë¦¬ì–¼ ì²´í¬
                        setTimeout(() => {
                            if (typeof MultiTutorial !== 'undefined') {
                                MultiTutorial.checkAndStart();
                            }
                        }, 500);
                    }
                })();

                // ì¹´ë©”ë¼ ìœ„ì¹˜ ì¡°ì • - ê¸°ì¡´ ìœ ì €ëŠ” ìš°ì£¼ì„ ìœ¼ë¡œ, ì²« ê°€ì…ìë§Œ ì „ì²´ ë·°
                setTimeout(() => {
                    // â˜…â˜…â˜… ì²« ë°©ë¬¸ ì—¬ë¶€ í™•ì¸ â˜…â˜…â˜…
                    const isFirstVisit = !localStorage.getItem('starwalker_visited');

                    if (isFirstVisit) {
                        // ì²« ë°©ë¬¸: ì „ì²´ ë·° + íŠœí† ë¦¬ì–¼
                        camera.position.set(0, 15000, 25000);
                        controls.target.set(0, 0, 0);
                        controls.update();
                        localStorage.setItem('starwalker_visited', 'true');
                        console.log('ğŸ†• ì²« ë°©ë¬¸: ì „ì²´ ë·° í‘œì‹œ');
                    } else {
                        // ê¸°ì¡´ ìœ ì €: ë°”ë¡œ ìš°ì£¼ì„ ìœ¼ë¡œ ì´ë™
                        if (playerShip && playerShip.mesh) {
                            const shipPos = playerShip.mesh.position;
                            camera.position.set(shipPos.x, shipPos.y + 50, shipPos.z + 100);
                            controls.target.copy(shipPos);
                            controls.update();
                            console.log('ğŸš€ ê¸°ì¡´ ìœ ì €: ìš°ì£¼ì„ ìœ¼ë¡œ ì´ë™');
                        } else {
                            // ìš°ì£¼ì„  ìƒì„± ëŒ€ê¸° í›„ ì´ë™
                            setTimeout(() => {
                                if (playerShip && playerShip.mesh) {
                                    const shipPos = playerShip.mesh.position;
                                    camera.position.set(shipPos.x, shipPos.y + 50, shipPos.z + 100);
                                    controls.target.copy(shipPos);
                                    controls.update();
                                }
                            }, 1500);
                        }
                    }
                }, 200);
            } else {
                // ì‹±ê¸€ ëª¨ë“œ: ê¸°ë³¸ ê±°ë¦¬
                CONFIG.distScale = 1.0;
                
                // ì‹±ê¸€ ëª¨ë“œ: ëª¨ë“  UI í‘œì‹œ
                const mobileTimeControls = document.getElementById('mobile-time-controls');
                if (mobileTimeControls) mobileTimeControls.style.display = '';
                
                const sliderContainers = document.querySelectorAll('.slider-container');
                sliderContainers.forEach(c => c.style.display = '');
                
                const distanceBtn = document.getElementById('btn-scale-mode');
                if (distanceBtn) distanceBtn.style.display = '';
                
                const spawnDock = document.getElementById('spawn-dock');
                if (spawnDock) spawnDock.style.display = 'flex';
                
                // â˜…â˜…â˜… ì‹±ê¸€ëª¨ë“œ: í†µí•©ì±„íŒ… ARIAë§Œ í‘œì‹œ, ì±„íŒ… íƒ­ ìˆ¨ê¹€ â˜…â˜…â˜…
                const unifiedChat = document.getElementById('unified-chat-panel');
                if (unifiedChat) {
                    unifiedChat.style.display = 'block';
                    
                    const ariaTabBtn = unifiedChat.querySelector('[data-tab="aria"]');
                    const multiTabBtn = unifiedChat.querySelector('[data-tab="multi"]');
                    const ariaTab = document.getElementById('aria-tab');
                    const multiTab = document.getElementById('multi-tab');
                    
                    // ARIA íƒ­ë§Œ í‘œì‹œ, ì±„íŒ… íƒ­ ìˆ¨ê¹€
                    if (ariaTabBtn) {
                        ariaTabBtn.style.display = 'block';
                        ariaTabBtn.classList.add('active');
                    }
                    if (multiTabBtn) {
                        multiTabBtn.style.display = 'none';  // â˜… ì±„íŒ… íƒ­ ìˆ¨ê¹€
                        multiTabBtn.classList.remove('active');
                    }
                    if (ariaTab) ariaTab.classList.add('active');
                    if (multiTab) multiTab.classList.remove('active');
                    
                    console.log('ì‹±ê¸€ëª¨ë“œ: ARIAë§Œ í‘œì‹œ, ì±„íŒ… íƒ­ ìˆ¨ê¹€');
                }
                
                // â˜…â˜…â˜… ì‹±ê¸€ëª¨ë“œ íŠœí† ë¦¬ì–¼ ì‹œì‘ â˜…â˜…â˜…
                setTimeout(() => {
                    if (typeof MultiTutorial !== 'undefined') {
                        MultiTutorial.checkAndStart();
                    }
                }, 500);

                // â˜…â˜…â˜… ì‹±ê¸€ëª¨ë“œì—ì„œë„ ë¡œê·¸ì¸ ì„¸ì…˜ ë³µì› â˜…â˜…â˜…
                loadSavedLogin().then(function(loggedIn) {
                    if (typeof updateUserUI === 'function') {
                        updateUserUI();
                        setTimeout(updateUserUI, 500);
                    }
                    console.log('ì‹±ê¸€ëª¨ë“œ ì„¸ì…˜ ë³µì›:', loggedIn ? 'ë¡œê·¸ì¸ë¨' : 'ë¹„ë¡œê·¸ì¸');
                });
            }

            // ë©€í‹°í”Œë ˆì´ì–´ ì±„íŒ… íŒ¨ë„ - ì „ì²´ UI ìˆ¨ê¹€/í‘œì‹œ
            const mpUI = document.getElementById('multiplayer-ui');
            if (mpUI) {
                mpUI.style.display = config.showChat ? 'block' : 'none';
            }
            
            // â˜…â˜…â˜… ë©€í‹°ëª¨ë“œ: multiplayer-uiê°€ ì—†ìœ¼ë©´ ìƒì„± â˜…â˜…â˜…
            if (mode === 'multi' && !document.getElementById('multiplayer-ui')) {
                if (typeof createMultiplayerUI === 'function') {
                    createMultiplayerUI();
                    const newMpUI = document.getElementById('multiplayer-ui');
                    if (newMpUI) newMpUI.style.display = 'block';
                    console.log('ë©€í‹°í”Œë ˆì´ì–´ UI ìƒì„±ë¨');
                }
            }
            
            // ë©€í‹° ëª¨ë“œì¼ ë•Œë§Œ ë©€í‹°í”Œë ˆì´ì–´ ì‹œì‘
            if (mode === 'multi') {
                // ë¡œê·¸ì¸ ì²´í¬ (ë¹„ë™ê¸°)
                loadSavedLogin().then(function(loggedIn) {
                    // UI ì—…ë°ì´íŠ¸ (ë¡œê·¸ì¸ ìƒíƒœ ë°˜ì˜) - ì—¬ëŸ¬ ë²ˆ í˜¸ì¶œí•˜ì—¬ í™•ì‹¤í•˜ê²Œ
                    if (typeof updateUserUI === 'function') {
                        updateUserUI();
                        setTimeout(updateUserUI, 500);
                        setTimeout(updateUserUI, 1500);
                    }
                    
                    if (!loggedIn && !mpUserId) {
                        // ë¡œê·¸ì¸ ì•ˆ ë˜ì–´ ìˆìœ¼ë©´ ì¸ì¦ UI í‘œì‹œ
                        if (typeof createAuthUI === 'function') {
                            createAuthUI();
                        }
                    } else {
                        // ë¡œê·¸ì¸ ë˜ì–´ ìˆìœ¼ë©´ ë©€í‹°í”Œë ˆì´ì–´ ì‹œì‘
                        if (typeof startMultiplayer === 'function' && !window.mpStarted) {
                            startMultiplayer();
                            window.mpStarted = true;
                        }
                        
                        // â˜…â˜…â˜… ë¡œê·¸ì¸ í›„ ìš°ì£¼ì„  ìœ„ì¹˜ë¡œ ì¹´ë©”ë¼ ì´ë™ â˜…â˜…â˜…
                        setTimeout(function() {
                            if (playerShip && playerShip.mesh) {
                                const shipPos = playerShip.mesh.position;
                                camera.position.set(shipPos.x + 3, shipPos.y + 2, shipPos.z + 5);
                                controls.target.copy(shipPos);
                                controls.update();
                                console.log('ğŸš€ ìš°ì£¼ì„  ìœ„ì¹˜ë¡œ ì¹´ë©”ë¼ ì´ë™:', shipPos);
                            }
                        }, 2000);
                    }
                });
            }
            
            if (typeof showMessage === 'function') {
                const msgText = currentLang === 'ko' ? `ğŸ® ${mode === 'single' ? 'ì‹±ê¸€' : 'ë©€í‹°'} í”Œë ˆì´ ì‹œì‘!` :
                               currentLang === 'ja' ? `ğŸ® ${mode === 'single' ? 'ã‚·ãƒ³ã‚°ãƒ«' : 'ãƒãƒ«ãƒ'}ãƒ—ãƒ¬ã‚¤é–‹å§‹ï¼` :
                               `ğŸ® ${mode === 'single' ? 'Single' : 'Multi'} Play Started!`;
                showMessage(msgText);
            }
        }
        
        // ì „ì—­ìœ¼ë¡œ ë…¸ì¶œ
        window.startGameMode = startGameMode;

        // â˜…â˜…â˜… ë©”ì¸ ë©”ë‰´ë¡œ ëŒì•„ê°€ê¸° (í™ˆ ë²„íŠ¼) â˜…â˜…â˜…
        function goToMainMenu() {
            const currentLang = localStorage.getItem('solarLang') || 'ko';
            const confirmMsg = currentLang === 'ko' ? 'ê²Œì„ì„ ì¢…ë£Œí•˜ê³  ë©”ì¸ ë©”ë‰´ë¡œ ëŒì•„ê°€ì‹œê² ìŠµë‹ˆê¹Œ?' :
                               currentLang === 'en' ? 'Exit game and return to main menu?' :
                               currentLang === 'ja' ? 'ã‚²ãƒ¼ãƒ ã‚’çµ‚äº†ã—ã¦ãƒ¡ã‚¤ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚Šã¾ã™ã‹ï¼Ÿ' :
                               'Exit game and return to main menu?';

            if (!confirm(confirmMsg)) {
                return; // ì·¨ì†Œ
            }

            // 1. ì¡°ì¢…ì„ ëª¨ë“œ ì¢…ë£Œ
            if (typeof exitPilotMode === 'function' && isPilotMode) {
                exitPilotMode();
            }

            // 2. ë©€í‹°í”Œë ˆì´ì–´ ì—°ê²° ì¢…ë£Œ
            if (window.gameMode === 'multi') {
                if (typeof MultiplayerManager !== 'undefined' && MultiplayerManager.disconnect) {
                    MultiplayerManager.disconnect();
                }
                // ê²Œì„ ìƒíƒœ ì´ˆê¸°í™”
                if (window.saveGameStateToServer) {
                    window.saveGameStateToServer({ isPilotMode: false });
                }
            }

            // 3. ê²Œì„ ëª¨ë“œ í´ë˜ìŠ¤ ì œê±°
            document.body.classList.remove('game-mode');
            document.body.classList.remove('game-started');

            // 4. ë©”ì¸ ë©”ë‰´ ì˜¤ë²„ë ˆì´ í‘œì‹œ
            const overlay = document.getElementById('mode-select-overlay');
            if (overlay) {
                overlay.style.display = 'flex';
            }

            // 5. ê²Œì„ UI ìˆ¨ê¸°ê¸°
            const pilotHud = document.getElementById('pilot-hud');
            if (pilotHud) pilotHud.style.display = 'none';

            const pilotRightBtns = document.getElementById('pilot-right-btns');
            if (pilotRightBtns) pilotRightBtns.style.display = 'none';

            const mobileCombatBtns = document.getElementById('mobile-combat-btns');
            if (mobileCombatBtns) mobileCombatBtns.style.display = 'none';

            // 6. ë©€í‹°ëª¨ë“œì—ì„œ ìˆ¨ê²¼ë˜ UI ë³µì›
            const navPanel = document.getElementById('nav-panel');
            const navContainer = document.getElementById('nav-container');
            const topBar = document.getElementById('top-bar');
            if (navPanel) navPanel.style.display = '';
            if (navContainer) navContainer.style.display = '';
            if (topBar) topBar.style.display = '';

            // 7. BGM ë³€ê²½ (ë©”ë‰´ BGM)
            if (typeof AudioManager !== 'undefined') {
                AudioManager.stopBGM();
            }

            // 8. ê²Œì„ ëª¨ë“œ ì´ˆê¸°í™”
            window.gameMode = null;
            gameMode = null;

            // 9. ì „ì²´í™”ë©´ í•´ì œ (ì„ íƒì )
            if (document.fullscreenElement) {
                document.exitFullscreen().catch(() => {});
            }

            console.log('ğŸ  ë©”ì¸ ë©”ë‰´ë¡œ ëŒì•„ê°');
        }
        window.goToMainMenu = goToMainMenu;

        // ========== ë“œë˜ê·¸ ê°€ëŠ¥ UI ì‹œìŠ¤í…œ ==========
        const draggableUISystem = {
            initialized: false,
            elements: [],
            activeElement: null,
            isDragging: false,
            pressTimer: null,
            startPos: { x: 0, y: 0 },
            elementStartPos: { x: 0, y: 0 },
            
            // ë“œë˜ê·¸ ê°€ëŠ¥í•œ UI ìš”ì†Œ ID ëª©ë¡ (ëª¨ë“  ì¡°ì¢…ì‹¤ UI)
            draggableIds: [
                'pilot-top-bar',           // ìƒë‹¨ ë°” (ìƒíƒœ, ëŠ¥ë ¥)
                'pilot-left-console',      // THR/FUEL ê²Œì´ì§€
                'pilot-center-console',    // ì†ë„ + ë²„íŠ¼ë“¤
                'pilot-right-console',     // â–²â–¼ ë²„íŠ¼
                'pilot-right',             // ë ˆì´ë” + TARGET + AUTOPILOT
                'pilot-radar',             // ë ˆì´ë”
                'pilot-target-info',       // íƒ€ê²Ÿ ì •ë³´
                'pilot-autopilot-info',    // ì˜¤í† íŒŒì¼ëŸ¿ ì •ë³´
                'pilot-eta-box',           // ETA ë°•ìŠ¤
                'pilot-warning-panel',     // ê²½ê³  íŒ¨ë„
                'pilot-target-select',     // ëª©í‘œ ì„ íƒ
                'pilot-coords-panel',      // ì¢Œí‘œ íŒ¨ë„
                'pilot-bottom',            // í•˜ë‹¨ ë²„íŠ¼ë“¤
                'pilot-joystick',          // ì¡°ì´ìŠ¤í‹±
                'cockpit-radio',           // ë¼ë””ì˜¤
                'unified-chat-panel',      // í†µí•© ì±„íŒ…
                'docking-center-btn',      // ë„í‚¹ ë²„íŠ¼
                'docking-menu',            // ë„í‚¹ ë©”ë‰´
                'crosshair',               // ì¡°ì¤€ì„ 
                'status-panel',            // ìƒíƒœ íŒ¨ë„
                'ai-copilot-panel',        // AI ì½”íŒŒì¼ëŸ¿
                'multiplayer-ui',          // ë©€í‹°í”Œë ˆì´ì–´ UI
                'pilot-right-btns',        // â˜… í†µì¼ëœ ìš°ì¸¡ ë²„íŠ¼ ì»¨í…Œì´ë„ˆ
                'ui-settings-btn',         // ì„¤ì • ë²„íŠ¼
                'ssil-mission-panel',      // SSIL í›ˆë ¨ í”„ë¡œê·¸ë¨
                'mission-float-btn',       // ë¯¸ì…˜ í”Œë¡œíŒ… ë²„íŠ¼
                'mission-board-modal',     // ì„ë¬´ ì§€ì‹œì„œ
                'daily-mission-icon',      // â˜… ì—…ë¬´ ì§€ì‹œì„œ (í¸ì§€ë´‰íˆ¬)
                'ad-rewards-panel',        // ê´‘ê³  ë³´ìƒ íŒ¨ë„
                'ad-menu-toggle',          // ê´‘ê³  ë©”ë‰´ ë²„íŠ¼
                'mobile-combat-btns'       // â˜… ë°œì‚¬/ì—­ì¶”ì§„ ë²„íŠ¼ ì»¨í…Œì´ë„ˆ
            ],

            init() {
                if (this.initialized) {
                    console.log('ë“œë˜ê·¸ UI ì´ë¯¸ ì´ˆê¸°í™”ë¨');
                    return;
                }
                
                console.log('ë“œë˜ê·¸ UI ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì‹œì‘...');
                
                // ë“œë˜ê·¸ ê°€ëŠ¥í•œ ìš”ì†Œ ì´ˆê¸°í™”
                this.draggableIds.forEach(id => {
                    const el = document.getElementById(id);
                    if (el) {
                        el.classList.add('draggable-ui');
                        el.dataset.draggable = 'true';
                        this.elements.push(el);
                        this.attachEvents(el);
                        console.log('ë“œë˜ê·¸ ë“±ë¡:', id);
                    } else {
                        console.warn('ìš”ì†Œ ì—†ìŒ:', id);
                    }
                });
                
                // ì €ì¥ëœ ìœ„ì¹˜ ë¶ˆëŸ¬ì˜¤ê¸°
                this.loadSavedPositions();
                
                // UI ì„¤ì • ë²„íŠ¼ ì´ë²¤íŠ¸
                this.initSettingsPanel();
                
                this.initialized = true;
                console.log('ë“œë˜ê·¸ UI ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ, ìš”ì†Œ ìˆ˜:', this.elements.length);
            },
            
            attachEvents(el) {
                // í„°ì¹˜ ì´ë²¤íŠ¸
                el.addEventListener('touchstart', (e) => {
                    if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') {
                        return;
                    }
                    this.onTouchStart(e, el);
                }, { passive: false });
                
                // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ (ë°ìŠ¤í¬í†±)
                el.addEventListener('mousedown', (e) => {
                    if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') {
                        return;
                    }
                    this.onMouseDown(e, el);
                });
            },
            
            onMouseDown(e, el) {
                const startX = e.clientX;
                const startY = e.clientY;
                const rect = el.getBoundingClientRect();
                
                // Ctrl+í´ë¦­ì´ë©´ ì¦‰ì‹œ ë“œë˜ê·¸ ëª¨ë“œ
                if (e.ctrlKey || e.button === 2) {
                    e.preventDefault();
                    this.beginDrag(el, startX, startY, rect);
                    
                    const onMove = (ev) => this.doDrag(el, ev.clientX, ev.clientY);
                    const onUp = () => {
                        document.removeEventListener('mousemove', onMove);
                        document.removeEventListener('mouseup', onUp);
                        this.endDrag(el);
                    };
                    
                    document.addEventListener('mousemove', onMove);
                    document.addEventListener('mouseup', onUp);
                    return;
                }
                
                // ì¼ë°˜ í´ë¦­ - ê¸¸ê²Œ ëˆ„ë¥´ê¸°
                let moved = false;
                
                const checkMove = (ev) => {
                    if (Math.abs(ev.clientX - startX) > 10 || Math.abs(ev.clientY - startY) > 10) {
                        moved = true;
                        clearTimeout(timer);
                        cleanup();
                    }
                };
                
                const cleanup = () => {
                    document.removeEventListener('mousemove', checkMove);
                    document.removeEventListener('mouseup', onMouseUp);
                };
                
                const onMouseUp = () => {
                    clearTimeout(timer);
                    cleanup();
                };
                
                const timer = setTimeout(() => {
                    if (moved) return;
                    cleanup();
                    
                    // ë“œë˜ê·¸ ì‹œì‘
                    const currentRect = el.getBoundingClientRect();
                    this.beginDrag(el, startX, startY, currentRect);
                    
                    const onMove = (ev) => this.doDrag(el, ev.clientX, ev.clientY);
                    const onUp = () => {
                        document.removeEventListener('mousemove', onMove);
                        document.removeEventListener('mouseup', onUp);
                        this.endDrag(el);
                    };
                    
                    document.addEventListener('mousemove', onMove);
                    document.addEventListener('mouseup', onUp);
                }, 600);
                
                document.addEventListener('mousemove', checkMove);
                document.addEventListener('mouseup', onMouseUp);
            },
            
            onTouchStart(e, el) {
                if (e.touches.length !== 1) return;
                
                const touch = e.touches[0];
                const startX = touch.clientX;
                const startY = touch.clientY;
                const rect = el.getBoundingClientRect();
                
                let lastX = startX;
                let lastY = startY;
                let moved = false;
                let dragStarted = false;
                
                const checkMove = (ev) => {
                    if (ev.touches.length !== 1) return;
                    const t = ev.touches[0];
                    lastX = t.clientX;
                    lastY = t.clientY;
                    
                    if (!dragStarted && (Math.abs(lastX - startX) > 15 || Math.abs(lastY - startY) > 15)) {
                        moved = true;
                        clearTimeout(timer);
                    }
                    
                    if (dragStarted) {
                        ev.preventDefault();
                        this.doDrag(el, lastX, lastY);
                    }
                };
                
                const onEnd = () => {
                    clearTimeout(timer);
                    document.removeEventListener('touchmove', checkMove);
                    document.removeEventListener('touchend', onEnd);
                    document.removeEventListener('touchcancel', onEnd);
                    if (dragStarted) {
                        this.endDrag(el);
                    }
                };
                
                const timer = setTimeout(() => {
                    if (moved) return;
                    
                    // ë“œë˜ê·¸ ì‹œì‘ - í˜„ì¬ ìœ„ì¹˜ ê¸°ì¤€
                    const currentRect = el.getBoundingClientRect();
                    this.beginDrag(el, lastX, lastY, currentRect);
                    dragStarted = true;
                }, 600);
                
                document.addEventListener('touchmove', checkMove, { passive: false });
                document.addEventListener('touchend', onEnd);
                document.addEventListener('touchcancel', onEnd);
            },
            
            // ë“œë˜ê·¸ ì‹œì‘
            beginDrag(el, touchX, touchY, rect) {
                this.isDragging = true;
                this.activeElement = el;

                // ì§„ë™ í”¼ë“œë°±
                if (navigator.vibrate) navigator.vibrate([50, 30, 50]);

                // â˜… !importantë¡œ CSS ê°•ì œ ìŠ¤íƒ€ì¼ ì˜¤ë²„ë¼ì´ë“œ
                el.style.setProperty('position', 'fixed', 'important');
                el.style.setProperty('left', rect.left + 'px', 'important');
                el.style.setProperty('top', rect.top + 'px', 'important');
                el.style.setProperty('right', 'auto', 'important');
                el.style.setProperty('bottom', 'auto', 'important');
                el.style.setProperty('transform', 'none', 'important');
                el.style.zIndex = '9999';
                el.style.transition = 'none';
                el.classList.add('dragging');
                
                // ë“œë˜ê·¸ ê¸°ì¤€ì  ì €ì¥ (í˜„ì¬ í„°ì¹˜ ìœ„ì¹˜ì™€ ìš”ì†Œ ìœ„ì¹˜)
                this.dragStartTouch = { x: touchX, y: touchY };
                this.dragStartElement = { x: rect.left, y: rect.top };
                
                if (typeof showMessage === 'function') showMessage('ğŸ”„ UI ì´ë™ ëª¨ë“œ - ë“œë˜ê·¸í•˜ì„¸ìš”');
            },
            
            // ë“œë˜ê·¸ ì¤‘
            doDrag(el, clientX, clientY) {
                if (!this.isDragging) return;

                const dx = clientX - this.dragStartTouch.x;
                const dy = clientY - this.dragStartTouch.y;

                let newX = this.dragStartElement.x + dx;
                let newY = this.dragStartElement.y + dy;

                // í™”ë©´ ê²½ê³„ ì œí•œ
                newX = Math.max(0, Math.min(window.innerWidth - 50, newX));
                newY = Math.max(0, Math.min(window.innerHeight - 50, newY));

                // â˜… !importantë¡œ CSS ê°•ì œ ìŠ¤íƒ€ì¼ ì˜¤ë²„ë¼ì´ë“œ
                el.style.setProperty('left', newX + 'px', 'important');
                el.style.setProperty('top', newY + 'px', 'important');
            },
            
            // ë“œë˜ê·¸ ì¢…ë£Œ
            endDrag(el) {
                if (!this.isDragging) return;
                
                this.isDragging = false;
                this.activeElement = null;
                
                el.classList.remove('dragging');
                el.style.transition = '';
                el.style.zIndex = '';
                
                // ìœ„ì¹˜ ì €ì¥
                this.savePositions();
                
                if (typeof showMessage === 'function') showMessage('âœ“ UI ìœ„ì¹˜ ì €ì¥ë¨');
            },
            
            // ê¸°ì¡´ í•¨ìˆ˜ë“¤ (í˜¸í™˜ì„±)
            startDragging(el) { /* deprecated */ },
            moveElement(el, x, y) { /* deprecated */ },
            stopDragging(el) { /* deprecated */ },
            
            // í˜„ì¬ ìœ„ì¹˜ ê°€ì ¸ì˜¤ê¸°
            getCurrentPositions() {
                const positions = {};
                this.elements.forEach(el => {
                    if (el.style.left || el.style.top) {
                        positions[el.id] = {
                            left: el.style.left,
                            top: el.style.top,
                            position: 'fixed'
                        };
                    }
                });
                return positions;
            },
            
            // ìŠ¬ë¡¯ì— ì €ì¥
            saveToSlot(slotIndex) {
                const slots = this.getSlots();
                const positions = this.getCurrentPositions();
                
                slots[slotIndex] = {
                    positions: positions,
                    date: new Date().toLocaleString('ko-KR'),
                    name: 'UI ë°°ì¹˜ ' + (slotIndex + 1)
                };
                
                localStorage.setItem('cockpitUISlots', JSON.stringify(slots));
                this.renderSlots();
                if (typeof showMessage === 'function') showMessage('ğŸ’¾ ìŠ¬ë¡¯ ' + (slotIndex + 1) + 'ì— ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤');
            },
            
            // ìŠ¬ë¡¯ì—ì„œ ë¶ˆëŸ¬ì˜¤ê¸°
            loadFromSlot(slotIndex) {
                const slots = this.getSlots();
                const slot = slots[slotIndex];
                
                if (!slot || !slot.positions) {
                    if (typeof showMessage === 'function') showMessage('âš ï¸ ë¹ˆ ìŠ¬ë¡¯ì…ë‹ˆë‹¤');
                    return;
                }
                
                this.applyPositions(slot.positions);
                if (typeof showMessage === 'function') showMessage('ğŸ“‚ ìŠ¬ë¡¯ ' + (slotIndex + 1) + 'ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤');
            },
            
            // ìŠ¬ë¡¯ ì‚­ì œ
            deleteSlot(slotIndex) {
                const slots = this.getSlots();
                slots[slotIndex] = null;
                localStorage.setItem('cockpitUISlots', JSON.stringify(slots));
                this.renderSlots();
                if (typeof showMessage === 'function') showMessage('ğŸ—‘ï¸ ìŠ¬ë¡¯ ' + (slotIndex + 1) + 'ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤');
            },
            
            // ëª¨ë“  ìŠ¬ë¡¯ ê°€ì ¸ì˜¤ê¸°
            getSlots() {
                try {
                    const saved = localStorage.getItem('cockpitUISlots');
                    return saved ? JSON.parse(saved) : [null, null, null];
                } catch (e) {
                    return [null, null, null];
                }
            },
            
            // ìœ„ì¹˜ ì ìš©
            applyPositions(positions) {
                Object.keys(positions).forEach(id => {
                    const el = document.getElementById(id);
                    if (el && positions[id]) {
                        const pos = positions[id];
                        el.style.position = 'fixed';
                        el.style.left = pos.left;
                        el.style.top = pos.top;
                        el.style.right = 'auto';
                        el.style.bottom = 'auto';
                        el.style.transform = 'none';
                    }
                });
            },
            
            // ìŠ¬ë¡¯ UI ë Œë”ë§
            renderSlots() {
                const container = document.getElementById('ui-slots-list');
                if (!container) return;
                
                const slots = this.getSlots();
                container.innerHTML = '';
                
                for (let i = 0; i < 3; i++) {
                    const slot = slots[i];
                    const isEmpty = !slot || !slot.positions;
                    
                    const slotEl = document.createElement('div');
                    slotEl.className = 'ui-slot' + (isEmpty ? ' empty' : '');
                    
                    // ë¯¸ë¦¬ë³´ê¸° ìƒì„±
                    const preview = document.createElement('div');
                    preview.className = 'ui-slot-preview';
                    
                    if (!isEmpty && slot.positions) {
                        // ë¯¸ë¦¬ë³´ê¸° ì  ìƒì„±
                        Object.keys(slot.positions).forEach(id => {
                            const pos = slot.positions[id];
                            if (pos.left && pos.top) {
                                const dot = document.createElement('div');
                                dot.className = 'preview-dot';
                                // ë¹„ìœ¨ ê³„ì‚° (í™”ë©´ í¬ê¸° ê¸°ì¤€ìœ¼ë¡œ ì¶•ì†Œ)
                                const leftPercent = (parseFloat(pos.left) / window.innerWidth) * 100;
                                const topPercent = (parseFloat(pos.top) / window.innerHeight) * 100;
                                dot.style.left = Math.min(90, Math.max(5, leftPercent)) + '%';
                                dot.style.top = Math.min(85, Math.max(5, topPercent)) + '%';
                                preview.appendChild(dot);
                            }
                        });
                    }
                    
                    // ìŠ¬ë¡¯ ì •ë³´
                    const info = document.createElement('div');
                    info.className = 'ui-slot-info';
                    info.innerHTML = `
                        <div class="ui-slot-name">${isEmpty ? 'ë¹ˆ ìŠ¬ë¡¯' : slot.name}</div>
                        <div class="ui-slot-date">${isEmpty ? 'ì €ì¥ëœ ë°°ì¹˜ ì—†ìŒ' : slot.date}</div>
                    `;
                    
                    // ë²„íŠ¼ë“¤
                    const actions = document.createElement('div');
                    actions.className = 'ui-slot-actions';
                    
                    if (isEmpty) {
                        const saveBtn = document.createElement('button');
                        saveBtn.className = 'ui-slot-btn save';
                        saveBtn.textContent = t('save');
                        saveBtn.onclick = (e) => {
                            e.stopPropagation();
                            this.saveToSlot(i);
                        };
                        actions.appendChild(saveBtn);
                    } else {
                        const loadBtn = document.createElement('button');
                        loadBtn.className = 'ui-slot-btn load';
                        loadBtn.textContent = t('load');
                        loadBtn.onclick = (e) => {
                            e.stopPropagation();
                            this.loadFromSlot(i);
                        };
                        
                        const saveBtn = document.createElement('button');
                        saveBtn.className = 'ui-slot-btn save';
                        saveBtn.textContent = t('overwrite');
                        saveBtn.onclick = (e) => {
                            e.stopPropagation();
                            this.saveToSlot(i);
                        };
                        
                        const delBtn = document.createElement('button');
                        delBtn.className = 'ui-slot-btn delete';
                        delBtn.textContent = t('delete');
                        delBtn.onclick = (e) => {
                            e.stopPropagation();
                            this.deleteSlot(i);
                        };
                        
                        actions.appendChild(loadBtn);
                        actions.appendChild(saveBtn);
                        actions.appendChild(delBtn);
                    }
                    
                    slotEl.appendChild(preview);
                    slotEl.appendChild(info);
                    slotEl.appendChild(actions);
                    container.appendChild(slotEl);
                }
            },
            
            savePositions() {
                // ìë™ ì €ì¥ìš© (ì²« ë²ˆì§¸ ìŠ¬ë¡¯ ì‚¬ìš©í•˜ê±°ë‚˜ ë§ˆì§€ë§‰ ì‚¬ìš© ìŠ¬ë¡¯)
                const positions = this.getCurrentPositions();
                localStorage.setItem('cockpitUIPositions', JSON.stringify(positions));
            },
            
            loadSavedPositions() {
                const saved = localStorage.getItem('cockpitUIPositions');
                if (!saved) return;
                
                try {
                    const positions = JSON.parse(saved);
                    
                    // ê° ìš”ì†Œë³„ë¡œ ê°œë³„ ì ìš© (ë‹¤ë¥¸ ìš”ì†Œì— ì˜í–¥ ì—†ì´)
                    Object.keys(positions).forEach(id => {
                        const el = document.getElementById(id);
                        if (!el || !positions[id]) return;
                        
                        const pos = positions[id];
                        const left = parseInt(pos.left) || 0;
                        const top = parseInt(pos.top) || 0;
                        
                        // í™”ë©´ ë²”ìœ„ ë‚´ì¸ì§€ í™•ì¸
                        if (left < 0 || left > window.innerWidth - 50 || 
                            top < 0 || top > window.innerHeight - 50) {
                            console.warn('UI ìœ„ì¹˜ê°€ í™”ë©´ ë°–:', id);
                            return; // ì´ ìš”ì†ŒëŠ” ê¸°ë³¸ ìœ„ì¹˜ ìœ ì§€
                        }
                        
                        // â˜… !importantë¡œ CSS ê°•ì œ ìŠ¤íƒ€ì¼ ì˜¤ë²„ë¼ì´ë“œ
                        el.style.setProperty('position', 'fixed', 'important');
                        el.style.setProperty('left', pos.left, 'important');
                        el.style.setProperty('top', pos.top, 'important');
                        el.style.setProperty('right', 'auto', 'important');
                        el.style.setProperty('bottom', 'auto', 'important');
                        el.style.setProperty('transform', 'none', 'important');
                    });

                    console.log('ì €ì¥ëœ UI ìœ„ì¹˜ ë¶ˆëŸ¬ì˜´');
                } catch (e) {
                    console.warn('UI ìœ„ì¹˜ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨:', e);
                    localStorage.removeItem('cockpitUIPositions');
                }
            },
            
            resetToDefault() {
                this.elements.forEach(el => {
                    el.style.position = '';
                    el.style.left = '';
                    el.style.top = '';
                    el.style.right = '';
                    el.style.bottom = '';
                    el.style.transform = '';
                    el.style.zIndex = '';
                });
                localStorage.removeItem('cockpitUIPositions');
                localStorage.removeItem('uiRearrangePositions');  // â˜… ì¬ë°°ì¹˜ ìœ„ì¹˜ë„ ë¦¬ì…‹
                
                // ì¬ë°°ì¹˜ ì‹œìŠ¤í…œì˜ ìš”ì†Œë“¤ë„ ë¦¬ì…‹
                if (typeof uiRearrangeSystem !== 'undefined') {
                    uiRearrangeSystem.rearrangeableIds.forEach(id => {
                        const el = document.getElementById(id);
                        if (el) {
                            el.style.position = '';
                            el.style.left = '';
                            el.style.top = '';
                            el.style.right = '';
                            el.style.bottom = '';
                            el.style.transform = '';
                        }
                    });
                }
                
                if (typeof showMessage === 'function') showMessage('ğŸ”„ UI ë°°ì¹˜ê°€ ê¸°ë³¸ê°’ìœ¼ë¡œ ë¦¬ì…‹ë˜ì—ˆìŠµë‹ˆë‹¤');
            },
            
            initSettingsPanel() {
                const btn = document.getElementById('ui-settings-btn');
                const panel = document.getElementById('ui-settings-panel');
                const closeBtn = document.getElementById('ui-settings-close');

                console.log('âš™ï¸ initSettingsPanel - btn:', !!btn, 'panel:', !!panel);

                if (btn) {
                    btn.onclick = () => {
                        console.log('âš™ï¸ Settings btn clicked, toggling panel');
                        panel?.classList.toggle('open');
                        if (panel?.classList.contains('open')) {
                            this.renderSlots();
                        }
                    };
                }
                
                if (closeBtn) {
                    closeBtn.onclick = () => panel?.classList.remove('open');
                }
                
                document.getElementById('ui-reset-default')?.addEventListener('click', () => {
                    this.resetToDefault();
                    panel?.classList.remove('open');
                });
                
                // â˜… UI ì¬ë°°ì¹˜ ëª¨ë“œ ë²„íŠ¼
                document.getElementById('ui-rearrange-mode')?.addEventListener('click', () => {
                    panel?.classList.remove('open');
                    uiRearrangeSystem.start();
                });
                
                // â˜… ì¬ë°°ì¹˜ ì™„ë£Œ ë²„íŠ¼
                document.getElementById('ui-rearrange-done')?.addEventListener('click', () => {
                    uiRearrangeSystem.stop();
                });
                
                // ì´ˆê¸° ìŠ¬ë¡¯ ë Œë”ë§
                this.renderSlots();
            }
        };
        
        // ========== UI ì¬ë°°ì¹˜ ëª¨ë“œ ì‹œìŠ¤í…œ ==========
        const uiRearrangeSystem = {
            isActive: false,
            elements: [],
            activeElement: null,
            isDragging: false,
            startPos: { x: 0, y: 0 },
            elementStartPos: { x: 0, y: 0 },
            gridSize: 20,  // â˜… ê·¸ë¦¬ë“œ ìŠ¤ëƒ… í¬ê¸° (px)
            
            // ì¬ë°°ì¹˜ ê°€ëŠ¥í•œ UI ìš”ì†Œ ID ëª©ë¡ (ëª¨ë“  ì¡°ì¢…ì‹¤ UI)
            rearrangeableIds: [
                'pilot-top-bar',           // ìƒë‹¨ ë°” (ìƒíƒœ, ëŠ¥ë ¥)
                'pilot-left-console',      // THR/FUEL ê²Œì´ì§€
                'pilot-center-console',    // ì†ë„ + ë²„íŠ¼ë“¤
                'pilot-right-console',     // â–²â–¼ ë²„íŠ¼
                'pilot-right',             // ë ˆì´ë” + TARGET + AUTOPILOT
                'pilot-radar',             // ë ˆì´ë”
                'pilot-target-info',       // íƒ€ê²Ÿ ì •ë³´
                'pilot-autopilot-info',    // ì˜¤í† íŒŒì¼ëŸ¿ ì •ë³´
                'pilot-eta-box',           // ETA ë°•ìŠ¤
                'pilot-warning-panel',     // ê²½ê³  íŒ¨ë„
                'pilot-target-select',     // ëª©í‘œ ì„ íƒ
                'pilot-coords-panel',      // ì¢Œí‘œ íŒ¨ë„
                'pilot-bottom',            // í•˜ë‹¨ ë²„íŠ¼ë“¤
                'pilot-joystick',          // ì¡°ì´ìŠ¤í‹±
                'cockpit-radio',           // ë¼ë””ì˜¤
                'unified-chat-panel',      // í†µí•© ì±„íŒ…
                'docking-center-btn',      // ë„í‚¹ ë²„íŠ¼
                'docking-menu',            // ë„í‚¹ ë©”ë‰´
                'crosshair',               // ì¡°ì¤€ì„ 
                'status-panel',            // ìƒíƒœ íŒ¨ë„
                'ai-copilot-panel',        // AI ì½”íŒŒì¼ëŸ¿
                'multiplayer-ui',          // ë©€í‹°í”Œë ˆì´ì–´ UI
                'pilot-right-btns',        // â˜… í†µì¼ëœ ìš°ì¸¡ ë²„íŠ¼ ì»¨í…Œì´ë„ˆ
                'ui-settings-btn',         // ì„¤ì • ë²„íŠ¼
                'ssil-mission-panel',      // SSIL í›ˆë ¨ í”„ë¡œê·¸ë¨
                'mission-float-btn',       // ë¯¸ì…˜ í”Œë¡œíŒ… ë²„íŠ¼
                'mission-board-modal',     // ì„ë¬´ ì§€ì‹œì„œ
                'daily-mission-icon',      // â˜… ì—…ë¬´ ì§€ì‹œì„œ (í¸ì§€ë´‰íˆ¬)
                'ad-rewards-panel',        // ê´‘ê³  ë³´ìƒ íŒ¨ë„
                'ad-menu-toggle',          // ê´‘ê³  ë©”ë‰´ ë²„íŠ¼
                'mobile-fire-btn',         // â˜… ë°œì‚¬ ë²„íŠ¼
                'mobile-combat-btns'       // â˜… ë°œì‚¬/ì—­ì¶”ì§„ ë²„íŠ¼ ì»¨í…Œì´ë„ˆ
            ],

            start() {
                this.isActive = true;
                document.body.classList.add('ui-rearrange-mode');
                document.getElementById('ui-rearrange-overlay')?.classList.add('active');
                
                // ëª¨ë“  ì¬ë°°ì¹˜ ê°€ëŠ¥ UIì— í´ë˜ìŠ¤ ì¶”ê°€ ë° ì´ë²¤íŠ¸ ë°”ì¸ë”©
                this.elements = [];
                const self = this;
                this.rearrangeableIds.forEach(id => {
                    const el = document.getElementById(id);
                    if (el) {  // ëª¨ë“  ìš”ì†Œ í¬í•¨
                        el.classList.add('rearrangeable-ui');
                        el.style.zIndex = '9999';  // ì¬ë°°ì¹˜ ì¤‘ ë†’ì€ z-index
                        this.elements.push(el);
                        
                        // í„°ì¹˜/ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸
                        el._rearrangeStart = function(e) { self.onDragStart(e, el); };
                        
                        el.addEventListener('mousedown', el._rearrangeStart);
                        el.addEventListener('touchstart', el._rearrangeStart, { passive: false });
                    }
                });
                
                this.boundDragMove = (e) => this.onDragMove(e);
                this.boundDragEnd = (e) => this.onDragEnd(e);
                
                document.addEventListener('mousemove', this.boundDragMove);
                document.addEventListener('mouseup', this.boundDragEnd);
                document.addEventListener('touchmove', this.boundDragMove, { passive: false });
                document.addEventListener('touchend', this.boundDragEnd);
                
                if (typeof showMessage === 'function') showMessage('ğŸ”§ UI ì¬ë°°ì¹˜ ëª¨ë“œ - ë“œë˜ê·¸í•˜ì—¬ ì´ë™');
            },
            
            stop() {
                this.isActive = false;
                document.body.classList.remove('ui-rearrange-mode');
                document.getElementById('ui-rearrange-overlay')?.classList.remove('active');
                
                // ì´ë²¤íŠ¸ ì œê±° ë° í´ë˜ìŠ¤ ì œê±°
                this.elements.forEach(el => {
                    el.classList.remove('rearrangeable-ui', 'dragging');
                    el.style.zIndex = '';  // z-index ë³µì›
                    if (el._rearrangeStart) {
                        el.removeEventListener('mousedown', el._rearrangeStart);
                        el.removeEventListener('touchstart', el._rearrangeStart);
                    }
                });
                
                document.removeEventListener('mousemove', this.boundDragMove);
                document.removeEventListener('mouseup', this.boundDragEnd);
                document.removeEventListener('touchmove', this.boundDragMove);
                document.removeEventListener('touchend', this.boundDragEnd);
                
                // ìœ„ì¹˜ ì €ì¥
                this.savePositions();
                
                if (typeof showMessage === 'function') showMessage('âœ… UI ë°°ì¹˜ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤');
            },
            
            onDragStart(e, el) {
                if (!this.isActive) return;
                
                e.preventDefault();
                e.stopPropagation();
                
                this.isDragging = true;
                this.activeElement = el;
                el.classList.add('dragging');
                
                const touch = e.touches ? e.touches[0] : e;
                this.startPos = { x: touch.clientX, y: touch.clientY };
                
                const rect = el.getBoundingClientRect();
                this.elementStartPos = { x: rect.left, y: rect.top };
            },
            
            onDragMove(e) {
                if (!this.isDragging || !this.activeElement) return;

                e.preventDefault();

                const touch = e.touches ? e.touches[0] : e;
                const dx = touch.clientX - this.startPos.x;
                const dy = touch.clientY - this.startPos.y;

                let newX = this.elementStartPos.x + dx;
                let newY = this.elementStartPos.y + dy;

                // â˜… ê·¸ë¦¬ë“œ ìŠ¤ëƒ… (20px)
                newX = Math.round(newX / this.gridSize) * this.gridSize;
                newY = Math.round(newY / this.gridSize) * this.gridSize;

                // í™”ë©´ ê²½ê³„ ì²´í¬
                const el = this.activeElement;
                const rect = el.getBoundingClientRect();
                newX = Math.max(0, Math.min(window.innerWidth - rect.width, newX));
                newY = Math.max(0, Math.min(window.innerHeight - rect.height, newY));

                // â˜… !importantë¡œ CSS ê°•ì œ ìŠ¤íƒ€ì¼ ì˜¤ë²„ë¼ì´ë“œ
                el.style.setProperty('position', 'fixed', 'important');
                el.style.setProperty('left', newX + 'px', 'important');
                el.style.setProperty('top', newY + 'px', 'important');
                el.style.setProperty('right', 'auto', 'important');
                el.style.setProperty('bottom', 'auto', 'important');
                el.style.setProperty('transform', 'none', 'important');
            },
            
            onDragEnd(e) {
                if (!this.isDragging) return;
                
                this.isDragging = false;
                if (this.activeElement) {
                    this.activeElement.classList.remove('dragging');
                }
                this.activeElement = null;
            },
            
            savePositions() {
                const positions = {};
                this.rearrangeableIds.forEach(id => {
                    const el = document.getElementById(id);
                    if (el) {
                        const rect = el.getBoundingClientRect();
                        positions[id] = {
                            left: rect.left,
                            top: rect.top
                        };
                    }
                });
                localStorage.setItem('uiRearrangePositions', JSON.stringify(positions));
            },
            
            loadPositions() {
                try {
                    const saved = localStorage.getItem('uiRearrangePositions');
                    if (saved) {
                        const positions = JSON.parse(saved);
                        Object.keys(positions).forEach(id => {
                            const el = document.getElementById(id);
                            if (el && positions[id]) {
                                // â˜… !importantë¡œ CSS ê°•ì œ ìŠ¤íƒ€ì¼ ì˜¤ë²„ë¼ì´ë“œ
                                el.style.setProperty('position', 'fixed', 'important');
                                el.style.setProperty('left', positions[id].left + 'px', 'important');
                                el.style.setProperty('top', positions[id].top + 'px', 'important');
                                el.style.setProperty('right', 'auto', 'important');
                                el.style.setProperty('bottom', 'auto', 'important');
                                el.style.setProperty('transform', 'none', 'important');
                            }
                        });
                    }
                } catch (e) {
                    console.warn('UI ìœ„ì¹˜ ë¡œë“œ ì‹¤íŒ¨:', e);
                }
            }
        };
        
        window.uiRearrangeSystem = uiRearrangeSystem;
        
        // ì „ì—­ìœ¼ë¡œ ë…¸ì¶œ
        window.draggableUISystem = draggableUISystem;
        
        // ì¡°ì¢… ëª¨ë“œ ì§„ì… ì‹œ ì´ˆê¸°í™”
        window.initDraggableUI = () => {
            console.log('ğŸ”§ initDraggableUI í˜¸ì¶œë¨');
            // ì•½ê°„ì˜ ì§€ì—° í›„ ì´ˆê¸°í™” (DOMì´ ì¤€ë¹„ë˜ë„ë¡)
            setTimeout(() => {
                console.log('ğŸ”§ draggableUISystem.init() í˜¸ì¶œ ì‹œì‘');
                draggableUISystem.initialized = false; // ì¬ì´ˆê¸°í™” í—ˆìš©
                draggableUISystem.elements = [];
                draggableUISystem.init();

                // â˜… ì €ì¥ëœ UI ìœ„ì¹˜ ë¡œë“œ
                uiRearrangeSystem.loadPositions();
                console.log('ğŸ”§ initDraggableUI ì™„ë£Œ');
            }, 100);
        };

        // ========== í†µí•© ì±„íŒ… ì‹œìŠ¤í…œ ==========
        const unifiedChatSystem = {
            currentTab: 'aria',
            isCollapsed: false,
            transparentTimer: null,
            
            init() {
                const panel = document.getElementById('unified-chat-panel');
                if (!panel) return;
                
                // íƒ­ ì „í™˜ ì´ë²¤íŠ¸
                panel.querySelectorAll('.chat-tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        this.switchTab(tab.dataset.tab);
                        this.showPanel();
                    });
                });
                
                // ì ‘ê¸°/í¼ì¹˜ê¸° ë²„íŠ¼
                document.getElementById('chat-toggle-btn')?.addEventListener('click', () => {
                    this.toggleCollapse();
                });
                
                // ARIA ì „ì†¡
                document.getElementById('aria-send-btn')?.addEventListener('click', () => {
                    this.sendAriaMessage();
                });
                document.getElementById('aria-input')?.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.sendAriaMessage();
                });
                
                // ë©€í‹° ì±„íŒ… ì „ì†¡
                document.getElementById('multi-send-btn')?.addEventListener('click', () => {
                    this.sendMultiMessage();
                });
                document.getElementById('multi-input')?.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.sendMultiMessage();
                });
                
                // ì…ë ¥ì°½ í¬ì»¤ìŠ¤ ì‹œ íŒ¨ë„ í‘œì‹œ
                panel.querySelectorAll('input').forEach(input => {
                    input.addEventListener('focus', () => this.showPanel());
                });
                
                // ì´ˆê¸° íˆ¬ëª…í™” íƒ€ì´ë¨¸ ì‹œì‘
                this.startTransparentTimer();
            },
            
            switchTab(tabName) {
                this.currentTab = tabName;
                
                // íƒ­ ë²„íŠ¼ í™œì„±í™”
                document.querySelectorAll('.chat-tab').forEach(tab => {
                    tab.classList.toggle('active', tab.dataset.tab === tabName);
                });
                
                // íƒ­ ì½˜í…ì¸  í‘œì‹œ
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                document.getElementById(tabName + '-tab')?.classList.add('active');
            },
            
            toggleCollapse() {
                const panel = document.getElementById('unified-chat-panel');
                if (!panel) return;
                
                this.isCollapsed = !this.isCollapsed;
                panel.classList.toggle('collapsed', this.isCollapsed);
                
                if (!this.isCollapsed) {
                    this.showPanel();
                }
            },
            
            showPanel() {
                const panel = document.getElementById('unified-chat-panel');
                if (!panel) return;
                
                panel.classList.remove('transparent');
                this.startTransparentTimer();
            },
            
            startTransparentTimer() {
                if (this.transparentTimer) {
                    clearTimeout(this.transparentTimer);
                }
                this.transparentTimer = setTimeout(() => {
                    const panel = document.getElementById('unified-chat-panel');
                    if (panel && !panel.querySelector('input:focus')) {
                        panel.classList.add('transparent');
                    }
                }, 2000);
            },
            
            addAriaMessage(text, isUser = false) {
                const container = document.getElementById('aria-messages');
                if (!container) return;
                
                const msg = document.createElement('div');
                msg.className = 'aria-msg';
                if (isUser) {
                    msg.innerHTML = `<span class="aria-label" style="color:#0ff;">ë‚˜: </span><span class="aria-text">${text}</span>`;
                } else {
                    msg.innerHTML = `<span class="aria-label">ARIA: </span><span class="aria-text">${text}</span>`;
                }
                container.appendChild(msg);
                container.scrollTop = container.scrollHeight;
                
                this.showPanel();
            },
            
            sendAriaMessage() {
                const input = document.getElementById('aria-input');
                const text = input?.value.trim();
                if (!text) return;
                
                this.addAriaMessage(text, true);
                input.value = '';
                
                // ê¸°ì¡´ ARIA ì‹œìŠ¤í…œ í˜¸ì¶œ
                if (typeof aiSendQuestionWithText === 'function') {
                    aiSendQuestionWithText(text);
                } else if (typeof aiSendQuestion === 'function') {
                    // ê¸°ì¡´ ë°©ì‹ í˜¸ì¶œ
                    const oldInput = document.getElementById('ai-input');
                    if (oldInput) {
                        oldInput.value = text;
                        aiSendQuestion();
                    }
                }
            },
            
            addMultiMessage(nick, text, time, isSystem = false) {
                const container = document.getElementById('multi-messages');
                if (!container) return;
                
                // ì²« ë©”ì‹œì§€ë©´ "Not connected" ì œê±°
                const systemMsg = container.querySelector('.mp-msg.system');
                if (systemMsg && systemMsg.textContent.includes('Not connected')) {
                    systemMsg.remove();
                }
                
                const msg = document.createElement('div');
                msg.className = isSystem ? 'mp-msg system' : 'mp-msg';
                if (isSystem) {
                    msg.textContent = text;
                } else {
                    msg.innerHTML = `<span class="time">${time}</span><span class="nick">${nick}:</span><span class="text">${text}</span>`;
                }
                container.appendChild(msg);
                container.scrollTop = container.scrollHeight;
                
                // ìµœëŒ€ 50ê°œ ë©”ì‹œì§€ ìœ ì§€
                while (container.children.length > 50) {
                    container.removeChild(container.firstChild);
                }
                
                this.showPanel();
            },
            
            sendMultiMessage() {
                const input = document.getElementById('multi-input');
                const text = input?.value.trim();
                if (!text) return;
                
                input.value = '';
                
                // ê¸°ì¡´ ë©€í‹°í”Œë ˆì´ì–´ ì±„íŒ… ì „ì†¡
                if (typeof sendMultiChat === 'function') {
                    sendMultiChat(text);
                } else if (typeof window.supabaseClient !== 'undefined' && window.mpChannel) {
                    // ì§ì ‘ Supabase ì±„ë„ë¡œ ì „ì†¡
                    window.mpChannel.send({
                        type: 'broadcast',
                        event: 'chat',
                        payload: {
                            userId: window.mpUserId || 'guest',
                            nick: window.mpNickname || 'ìµëª…',
                            text: text,
                            time: new Date().toLocaleTimeString('ko-KR', {hour:'2-digit', minute:'2-digit'})
                        }
                    });
                }
            },
            
            setConnected(connected) {
                const container = document.getElementById('multi-messages');
                if (!container) return;
                
                if (connected) {
                    const systemMsg = container.querySelector('.mp-msg.system');
                    if (systemMsg && systemMsg.textContent.includes('Not connected')) {
                        systemMsg.textContent = t('chatConnected');
                    }
                }
            }
        };
        
        window.unifiedChatSystem = unifiedChatSystem;
        
        // ARIA ë©”ì‹œì§€ í‘œì‹œ í•¨ìˆ˜ ì˜¤ë²„ë¼ì´ë“œ
        window.aiShowMessage = function(text) {
            unifiedChatSystem.addAriaMessage(text, false);
        };
        
        // ARIA ì§ˆë¬¸ ì „ì†¡ (í…ìŠ¤íŠ¸ ì§ì ‘ ì „ë‹¬)
        window.aiSendQuestionWithText = function(text) {
            if (!text) return;
            
            // ë¡œë”© í‘œì‹œ
            unifiedChatSystem.addAriaMessage('Thinking...', false);
            
            // Gemini API í˜¸ì¶œ
            if (typeof callGeminiAPI === 'function') {
                callGeminiAPI(text)
                    .then(function(response) {
                        // ë§ˆì§€ë§‰ "Thinking..." ë©”ì‹œì§€ ì œê±°
                        var container = document.getElementById('aria-messages');
                        var lastMsg = container ? container.lastElementChild : null;
                        if (lastMsg && lastMsg.textContent.indexOf('Thinking...') >= 0) {
                            lastMsg.remove();
                        }
                        if (response) {
                            unifiedChatSystem.addAriaMessage(response, false);
                        } else {
                            showLocalAnswer(text);
                        }
                    })
                    .catch(function(e) {
                        console.warn('Gemini API ì˜¤ë¥˜:', e);
                        showLocalAnswer(text);
                    });
            } else {
                showLocalAnswer(text);
            }
            
            function showLocalAnswer(text) {
                // ë¡œì»¬ ë‹µë³€ í´ë°±
                var localAnswers = {
                    'ì¡°ì‘': 'ì¡°ì¢…: WASD ë˜ëŠ” í™”ì‚´í‘œí‚¤\nê°€ì†/ê°ì†: í™”ë©´ ì™¼ìª½ ì¡°ì´ìŠ¤í‹±\nì‹œì  ë³€ê²½: í™”ë©´ ì˜¤ë¥¸ìª½ ë“œë˜ê·¸',
                    'ì—°ë£Œ': 'ì—°ë£ŒëŠ” ì •ê±°ì¥ì— ë„í‚¹í•˜ë©´ ë³´ì¶© ê°€ëŠ¥í•©ë‹ˆë‹¤. ì½”ì¸ 1ê°œë‹¹ ì—°ë£Œ 1ì´ ì¶©ì „ë©ë‹ˆë‹¤.',
                    'ìë™í•­ë²•': 'ëª©í‘œë¥¼ ì„ íƒí•˜ê³  ğŸ¤–ìë™ ë²„íŠ¼ì„ ëˆ„ë¥´ë©´ ìë™ìœ¼ë¡œ ë¹„í–‰í•©ë‹ˆë‹¤.',
                    'ë„í‚¹': 'ì •ê±°ì¥ ê·¼ì²˜ì—ì„œ ğŸ”—ë„í‚¹ ë²„íŠ¼ì´ ë‚˜íƒ€ë‚˜ë©´ ëˆŒëŸ¬ì£¼ì„¸ìš”.'
                };
                
                var answer = 'ì£„ì†¡í•©ë‹ˆë‹¤, ì´í•´í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì§ˆë¬¸í•´ ì£¼ì„¸ìš”.';
                for (var key in localAnswers) {
                    if (text.indexOf(key) >= 0) {
                        answer = localAnswers[key];
                        break;
                    }
                }
                
                // ë§ˆì§€ë§‰ "Thinking..." ë©”ì‹œì§€ ì œê±°
                var container = document.getElementById('aria-messages');
                var lastMsg = container ? container.lastElementChild : null;
                if (lastMsg && lastMsg.textContent.indexOf('Thinking...') >= 0) {
                    lastMsg.remove();
                }
                unifiedChatSystem.addAriaMessage(answer, false);
            }
        };
        
        // ë©€í‹°í”Œë ˆì´ì–´ ì±„íŒ… ìˆ˜ì‹  ì²˜ë¦¬ ì—°ê²°
        window.onMultiChatReceived = function(nick, text, time) {
            unifiedChatSystem.addMultiMessage(nick, text, time);
        };
        
        // ì´ˆê¸°í™”
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(function() { unifiedChatSystem.init(); }, 500);
        });
        
        // ========== ì¡°ì¢…ì‹¤ ë¼ë””ì˜¤ ì‹œìŠ¤í…œ ==========
        const cockpitRadio = {
            audio: null,
            isPlaying: false,
            currentStation: null,
            volume: 0.3,
            
            init() {
                this.audio = new Audio();
                // crossOrigin ì œê±° - CORS ë¬¸ì œ ë°©ì§€
                this.audio.volume = this.volume;
                
                // í† ê¸€ ë²„íŠ¼
                const toggleBtn = document.getElementById('radio-toggle-btn');
                const radioPanel = document.getElementById('cockpit-radio');
                
                if (toggleBtn) {
                    toggleBtn.addEventListener('click', (e) => {
                        e.stopPropagation();  // ì´ë²¤íŠ¸ ì „íŒŒ ë°©ì§€
                        if (radioPanel.classList.contains('collapsed')) {
                            radioPanel.classList.remove('collapsed');
                            toggleBtn.textContent = t('radio');
                        } else {
                            if (this.isPlaying) {
                                // ì¬ìƒ ì¤‘ì´ë©´ ë©ˆì¶¤
                                this.stop();
                            } else {
                                radioPanel.classList.add('collapsed');
                                toggleBtn.textContent = t('radioShort');
                            }
                        }
                    });
                }
                
                // ë‹«ê¸° ë²„íŠ¼ ì´ë²¤íŠ¸
                const closeBtn = document.getElementById('radio-close-btn');
                if (closeBtn) {
                    closeBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        radioPanel.classList.add('collapsed');
                        toggleBtn.textContent = this.isPlaying ? t('stop') : t('radioShort');
                    });
                }
                
                // ë¹ˆ ê³³ í´ë¦­ ì‹œ ë‹«ê¸°
                document.addEventListener('click', (e) => {
                    if (!radioPanel.classList.contains('collapsed') && 
                        !radioPanel.contains(e.target)) {
                        radioPanel.classList.add('collapsed');
                        if (toggleBtn) {
                            toggleBtn.textContent = this.isPlaying ? t('stop') : t('radioShort');
                        }
                    }
                });
                
                // ë¼ë””ì˜¤ íŒ¨ë„ ë‚´ë¶€ í´ë¦­ì€ ì „íŒŒ ë°©ì§€
                radioPanel.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
                
                // ì±„ë„ ì„ íƒ
                document.querySelectorAll('.radio-station').forEach(station => {
                    station.addEventListener('click', () => {
                        const url = station.dataset.url;
                        const name = station.dataset.name;
                        this.play(url, name, station);
                    });
                });
                
                // ë³¼ë¥¨ ì¡°ì ˆ
                const volSlider = document.getElementById('radio-volume');
                if (volSlider) {
                    volSlider.addEventListener('input', (e) => {
                        this.volume = e.target.value / 100;
                        this.audio.volume = this.volume;
                        document.getElementById('radio-vol-val').textContent = e.target.value + '%';
                    });
                }
                
                // ì˜¤ë¥˜ ì²˜ë¦¬ - ì‹¤ì œ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ë§Œ í‘œì‹œ
                this.audio.addEventListener('error', (e) => {
                    // ë¹ˆ src ì„¤ì • ì‹œ ë°œìƒí•˜ëŠ” ì˜¤ë¥˜ëŠ” ë¬´ì‹œ
                    if (!this.audio.src || this.audio.src === '' || this.audio.src === window.location.href) {
                        return;
                    }
                    console.error('ë¼ë””ì˜¤ ìŠ¤íŠ¸ë¦¼ ì˜¤ë¥˜:', e);
                    document.getElementById('radio-now-playing').textContent = t('radioConnectionFailed');
                    this.isPlaying = false;
                    this.updateUI();
                });
                
                // ì¬ìƒ ì‹œì‘
                this.audio.addEventListener('playing', () => {
                    document.getElementById('radio-now-playing').textContent = 'ğŸµ ' + (this.currentStation || t('playing'));
                });
                
                console.log('ì¡°ì¢…ì‹¤ ë¼ë””ì˜¤ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ');
            },
            
            play(url, name, stationEl) {
                // ê°™ì€ ì±„ë„ì´ë©´ ì •ì§€
                if (this.currentStation === name && this.isPlaying) {
                    this.stop();
                    return;
                }
                
                // ê¸°ì¡´ ì¬ìƒ ì¤‘ì§€
                this.audio.pause();
                this.audio.src = '';  // ë¨¼ì € ë¹„ìš°ê¸°
                
                // ì ì‹œ ëŒ€ê¸° í›„ ìƒˆ ì±„ë„ ì¬ìƒ
                this.currentStation = name;
                document.getElementById('radio-now-playing').textContent = t('radioConnecting');
                
                setTimeout(() => {
                    // ìƒˆ ì±„ë„ ì¬ìƒ
                    this.audio.src = url;
                    this.audio.load();
                    
                    this.audio.play().then(() => {
                        this.isPlaying = true;
                        this.updateUI();
                        
                        // í™œì„± ì±„ë„ í‘œì‹œ
                        document.querySelectorAll('.radio-station').forEach(s => s.classList.remove('active'));
                        if (stationEl) stationEl.classList.add('active');
                        
                        if (typeof showMessage === 'function') showMessage('ğŸ“» ' + name + ' ì¬ìƒ ì¤‘');
                    }).catch(err => {
                        console.error('ë¼ë””ì˜¤ ì¬ìƒ ì‹¤íŒ¨:', err);
                        document.getElementById('radio-now-playing').textContent = t('radioPlaybackFailed');
                        this.isPlaying = false;
                        this.updateUI();
                    });
                }, 100);
            },
            
            stop() {
                this.audio.pause();
                this.isPlaying = false;
                this.currentStation = null;
                
                // src ë¹„ìš°ê¸° ì „ì— ìƒíƒœ ë¨¼ì € ì—…ë°ì´íŠ¸
                document.querySelectorAll('.radio-station').forEach(s => s.classList.remove('active'));
                document.getElementById('radio-now-playing').textContent = t('selectChannel');
                this.updateUI();
                
                // ë‚˜ì¤‘ì— src ë¹„ìš°ê¸°
                setTimeout(() => {
                    this.audio.src = '';
                }, 50);
                
                if (typeof showMessage === 'function') showMessage('ğŸ“» ë¼ë””ì˜¤ ì •ì§€');
            },
            
            updateUI() {
                const toggleBtn = document.getElementById('radio-toggle-btn');
                if (toggleBtn) {
                    if (this.isPlaying) {
                        toggleBtn.classList.add('playing');
                        toggleBtn.textContent = t('stop');
                    } else {
                        toggleBtn.classList.remove('playing');
                        const radioPanel = document.getElementById('cockpit-radio');
                        toggleBtn.textContent = radioPanel.classList.contains('collapsed') ? t('radioShort') : t('radio');
                    }
                }
            }
        };
        
        // ì „ì—­ìœ¼ë¡œ ë…¸ì¶œ
        window.cockpitRadio = cockpitRadio;
        
        // í˜ì´ì§€ ë¡œë“œ ì‹œ ë¼ë””ì˜¤ ì´ˆê¸°í™”
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(() => cockpitRadio.init(), 1000);
        });

        // ========== ëª¨ë°”ì¼ íƒ­ ë°” ì‹œìŠ¤í…œ (ë¹„í™œì„±í™”) ==========
        const mobileTabSystem = {
            currentTab: 'control',
            panelOpen: true,
            
            init() {
                // íƒ­ ë²„íŠ¼ ì´ë²¤íŠ¸
                document.querySelectorAll('.mobile-tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        const tabName = tab.dataset.tab;
                        this.switchTab(tabName);
                    });
                });
                
                // ì¡°ì¢… ë²„íŠ¼ë“¤ (ì†ë„ ì¡°ì ˆì€ 3ì¸ì¹­ì—ì„œë„ í—ˆìš©)
                document.getElementById('mobile-accel')?.addEventListener('touchstart', () => {
                    if (window.shipInputs) window.shipInputs.throttle = 1;
                });
                document.getElementById('mobile-accel')?.addEventListener('touchend', () => {
                    if (window.shipInputs) window.shipInputs.throttle = 0;
                });
                document.getElementById('mobile-decel')?.addEventListener('touchstart', () => {
                    if (window.shipInputs) window.shipInputs.throttle = -1;
                });
                document.getElementById('mobile-decel')?.addEventListener('touchend', () => {
                    if (window.shipInputs) window.shipInputs.throttle = 0;
                });

                // â˜… ë°œì‚¬ ë²„íŠ¼ ì´ë²¤íŠ¸
                const fireBtn = document.getElementById('mobile-fire-btn');
                if (fireBtn) {
                    fireBtn.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        weaponSystem.isFiring = true;
                        fireBtn.classList.add('firing');
                    });
                    fireBtn.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        weaponSystem.isFiring = false;
                        fireBtn.classList.remove('firing');
                    });
                    fireBtn.addEventListener('touchcancel', (e) => {
                        weaponSystem.isFiring = false;
                        fireBtn.classList.remove('firing');
                    });
                    // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ (ë°ìŠ¤í¬íƒ‘)
                    fireBtn.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        weaponSystem.isFiring = true;
                        fireBtn.classList.add('firing');
                    });
                    fireBtn.addEventListener('mouseup', (e) => {
                        e.preventDefault();
                        weaponSystem.isFiring = false;
                        fireBtn.classList.remove('firing');
                    });
                    fireBtn.addEventListener('mouseleave', () => {
                        weaponSystem.isFiring = false;
                        fireBtn.classList.remove('firing');
                    });
                }

                // â˜…â˜…â˜… ìƒˆ ëª¨ë°”ì¼ ë°œì‚¬/ì—­ì¶”ì§„ ë²„íŠ¼ ì´ë²¤íŠ¸ â˜…â˜…â˜…
                const newFireBtn = document.getElementById('mobile-fire-btn-new');
                if (newFireBtn) {
                    newFireBtn.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        weaponSystem.isFiring = true;
                        newFireBtn.classList.add('firing');
                    });
                    newFireBtn.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        weaponSystem.isFiring = false;
                        newFireBtn.classList.remove('firing');
                    });
                    newFireBtn.addEventListener('touchcancel', () => {
                        weaponSystem.isFiring = false;
                        newFireBtn.classList.remove('firing');
                    });
                }

                const newBrakeBtn = document.getElementById('mobile-brake-btn-new');
                if (newBrakeBtn) {
                    newBrakeBtn.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        if (window.shipInputs) window.shipInputs.emergencyReverse = true;
                        newBrakeBtn.classList.add('braking');
                    });
                    newBrakeBtn.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        if (window.shipInputs) window.shipInputs.emergencyReverse = false;
                        newBrakeBtn.classList.remove('braking');
                    });
                    newBrakeBtn.addEventListener('touchcancel', () => {
                        if (window.shipInputs) window.shipInputs.emergencyReverse = false;
                        newBrakeBtn.classList.remove('braking');
                    });
                }

                // ê¸°ëŠ¥ ë²„íŠ¼ë“¤
                document.getElementById('mobile-autopilot')?.addEventListener('click', () => {
                    if (typeof toggleAutopilot === 'function') toggleAutopilot();
                });
                document.getElementById('mobile-telescope')?.addEventListener('click', () => {
                    if (typeof enterTelescopeMode === 'function') enterTelescopeMode();
                });
                document.getElementById('mobile-space-mode')?.addEventListener('click', () => {
                    if (typeof toggleSpaceView === 'function') toggleSpaceView();
                });
                
                // ëª¨ë°”ì¼ ë¼ë””ì˜¤
                document.querySelectorAll('.mobile-radio-station').forEach(station => {
                    station.addEventListener('click', () => {
                        const url = station.dataset.url;
                        const name = station.dataset.name;
                        
                        // ê¸°ì¡´ ë¼ë””ì˜¤ ì‹œìŠ¤í…œ ì‚¬ìš©
                        if (window.cockpitRadio) {
                            window.cockpitRadio.play(url, name, station);
                        }
                        
                        // ëª¨ë°”ì¼ UI ì—…ë°ì´íŠ¸
                        document.querySelectorAll('.mobile-radio-station').forEach(s => s.classList.remove('active'));
                        station.classList.add('active');
                    });
                });
                
                // ëª¨ë°”ì¼ ë¼ë””ì˜¤ ë³¼ë¥¨
                document.getElementById('mobile-radio-vol')?.addEventListener('input', (e) => {
                    const vol = e.target.value / 100;
                    document.getElementById('mobile-radio-vol-val').textContent = e.target.value + '%';
                    if (window.cockpitRadio) {
                        window.cockpitRadio.volume = vol;
                        window.cockpitRadio.audio.volume = vol;
                    }
                });
                
                // ëª¨ë°”ì¼ ì±„íŒ…
                document.getElementById('mobile-chat-send')?.addEventListener('click', () => {
                    this.sendMobileChat();
                });
                document.getElementById('mobile-chat-input')?.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.sendMobileChat();
                });
                
                // ëª¨ë°”ì¼ ARIA
                document.getElementById('mobile-aria-send')?.addEventListener('click', () => {
                    this.sendMobileAria();
                });
                document.getElementById('mobile-aria-input')?.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.sendMobileAria();
                });
                
                // ì—…ë°ì´íŠ¸ ì‹œì‘
                setInterval(() => this.updateMobileUI(), 100);
                
                console.log('ëª¨ë°”ì¼ íƒ­ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ');
            },
            
            switchTab(tabName) {
                // ê°™ì€ íƒ­ ëˆ„ë¥´ë©´ íŒ¨ë„ í† ê¸€
                if (this.currentTab === tabName) {
                    this.panelOpen = !this.panelOpen;
                    document.getElementById('mobile-tab-panel')?.classList.toggle('open', this.panelOpen);
                    return;
                }
                
                this.currentTab = tabName;
                this.panelOpen = true;
                
                // íƒ­ ë²„íŠ¼ í™œì„±í™”
                document.querySelectorAll('.mobile-tab').forEach(t => {
                    t.classList.toggle('active', t.dataset.tab === tabName);
                });
                
                // íŒ¨ë„ í‘œì‹œ
                document.querySelectorAll('.mobile-panel-content').forEach(p => {
                    p.classList.remove('active');
                });
                document.getElementById('mobile-tab-panel')?.classList.add('open');
                
                const panelMap = {
                    'control': 'mobile-control-panel',
                    'status': 'mobile-status-panel',
                    'radio': 'mobile-radio-panel',
                    'chat': 'mobile-chat-panel',
                    'aria': 'mobile-aria-panel'
                };
                
                document.getElementById(panelMap[tabName])?.classList.add('active');
            },
            
            updateMobileUI() {
                const ship = window.playerShip;
                if (!ship) return;
                
                const speed = Math.abs(ship.speed || 0);
                const fuel = ship.fuel || 100;
                const throttle = (ship.throttlePercent || 0);
                const maxFuel = SHIP_CONFIG.maxFuel;
                const fuelPercent = (fuel / maxFuel) * 100;
                
                // ë¯¸ë‹ˆ HUD
                const miniSpeed = document.getElementById('mini-speed');
                const miniFuel = document.getElementById('mini-fuel');
                const miniFuelBar = document.getElementById('mini-fuel-bar');
                const miniTarget = document.getElementById('mini-target');
                
                if (miniSpeed) miniSpeed.textContent = speed.toFixed(1);
                if (miniFuel) miniFuel.textContent = Math.round(fuel) + '/' + maxFuel;
                if (miniFuelBar) miniFuelBar.style.width = fuelPercent + '%';
                if (miniTarget) {
                    const targetName = window.autopilotTarget?.name || t('none');
                    miniTarget.textContent = targetName.substring(0, 6);
                }
                
                // ì¡°ì¢… íŒ¨ë„
                const thrFill = document.getElementById('mobile-thr-fill');
                const thrValue = document.getElementById('mobile-thr-value');
                const fuelFill = document.getElementById('mobile-fuel-fill');
                const fuelValue = document.getElementById('mobile-fuel-value');
                const speedVal = document.getElementById('mobile-speed-val');
                const speedKmh = document.getElementById('mobile-speed-kmh');
                
                if (thrFill) thrFill.style.height = Math.abs(throttle) + '%';
                if (thrValue) thrValue.textContent = (throttle >= 0 ? '+' : '') + throttle.toFixed(0) + '%';
                if (fuelFill) fuelFill.style.height = fuelPercent + '%';
                if (fuelValue) fuelValue.textContent = Math.round(fuel) + '/' + maxFuel;
                if (speedVal) speedVal.textContent = speed.toFixed(1);
                if (speedKmh) speedKmh.textContent = '(' + (speed * 3600).toFixed(0) + ' km/h)';
                
                // â˜… ëª¨ë°”ì¼ ë‚´êµ¬ë„ ê²Œì´ì§€ ì—…ë°ì´íŠ¸
                const hullFill = document.getElementById('mobile-hull-fill');
                const hullValue = document.getElementById('mobile-hull-value');
                const maxHull = SHIP_CONFIG.maxHull || 100;
                const currentHull = playerShip ? playerShip.hull : maxHull;
                const hullPercent = (currentHull / maxHull) * 100;
                if (hullFill) hullFill.style.height = hullPercent + '%';
                if (hullValue) hullValue.textContent = Math.round(currentHull);
                const autopilotBtn = document.getElementById('mobile-autopilot');
                if (autopilotBtn && window.autopilotEngaged !== undefined) {
                    autopilotBtn.classList.toggle('engaged', window.autopilotEngaged);
                    autopilotBtn.textContent = window.autopilotEngaged ? 'ğŸ¤– ìë™ ON' : 'ğŸ¤– ìë™';
                }
                
                // ìƒíƒœ íŒ¨ë„
                document.getElementById('mobile-stat-speed')?.textContent && 
                    (document.getElementById('mobile-stat-speed').textContent = speed.toFixed(2) + ' km/s');
                document.getElementById('mobile-stat-fuel')?.textContent && 
                    (document.getElementById('mobile-stat-fuel').textContent = Math.round(fuel) + '/' + maxFuel);
                document.getElementById('mobile-stat-target')?.textContent && 
                    (document.getElementById('mobile-stat-target').textContent = window.autopilotTarget?.name || t('none'));
                document.getElementById('mobile-stat-autopilot')?.textContent && 
                    (document.getElementById('mobile-stat-autopilot').textContent = window.autopilotEngaged ? 'ON' : 'OFF');
            },
            
            sendMobileChat() {
                const input = document.getElementById('mobile-chat-input');
                if (!input || !input.value.trim()) return;
                
                const msg = input.value.trim();
                input.value = '';
                
                // ê¸°ì¡´ ì±„íŒ… ì‹œìŠ¤í…œ ì‚¬ìš©
                if (typeof sendChat === 'function') {
                    // ì„ì‹œë¡œ mp-chat-inputì— ê°’ ë„£ê³  ì „ì†¡
                    const mpInput = document.getElementById('mp-chat-input');
                    if (mpInput) {
                        mpInput.value = msg;
                        sendChat();
                    }
                }
                
                // ëª¨ë°”ì¼ ì±„íŒ…ì—ë„ í‘œì‹œ
                this.addMobileChatMessage('ë‚˜', msg);
            },
            
            addMobileChatMessage(nick, msg) {
                const container = document.getElementById('mobile-chat-messages');
                if (!container) return;
                
                const msgEl = document.createElement('div');
                msgEl.innerHTML = `<span style="color:#ff0;">${nick}:</span> ${msg}`;
                msgEl.style.marginBottom = '5px';
                container.appendChild(msgEl);
                container.scrollTop = container.scrollHeight;
            },
            
            sendMobileAria() {
                const input = document.getElementById('mobile-aria-input');
                if (!input || !input.value.trim()) return;
                
                const question = input.value.trim();
                input.value = '';
                
                // ARIA ë©”ì‹œì§€ ì˜ì—­ì— ì§ˆë¬¸ í‘œì‹œ
                const msgArea = document.getElementById('mobile-aria-messages');
                if (msgArea) {
                    msgArea.innerHTML = `<div style="color:#888;margin-bottom:10px;">ğŸ‘¤ ${question}</div><div style="color:#0ff;">ğŸ¤– Thinking...</div>`;
                }
                
                // ê¸°ì¡´ ARIA ì‹œìŠ¤í…œ ì‚¬ìš©
                if (typeof aiSendQuestion === 'function') {
                    const aiInput = document.getElementById('ai-input');
                    if (aiInput) {
                        aiInput.value = question;
                        aiSendQuestion();
                        
                        // ì‘ë‹µ ëŒ€ê¸° í›„ í‘œì‹œ
                        setTimeout(() => {
                            const aiMsgBox = document.getElementById('ai-message-box');
                            if (aiMsgBox && msgArea) {
                                msgArea.innerHTML = `<div style="color:#888;margin-bottom:10px;">ğŸ‘¤ ${question}</div><div>ğŸ¤– ${aiMsgBox.textContent}</div>`;
                            }
                        }, 2000);
                    }
                }
            }
        };
        
        // ì „ì—­ ë…¸ì¶œ
        window.mobileTabSystem = mobileTabSystem;
        
        // ì¡°ì¢… ëª¨ë“œ ì§„ì… ì‹œ ì´ˆê¸°í™”
        const originalEnterPilotMode = window.enterPilotMode;
        window.enterPilotMode = function() {
            if (originalEnterPilotMode) originalEnterPilotMode.apply(this, arguments);

            // â˜… ë©€í‹°ëª¨ë“œ íŠœí† ë¦¬ì–¼ ê°€ì´ë“œ
            if (typeof MultiTutorial !== 'undefined') {
                setTimeout(() => MultiTutorial.showFeatureGuide('pilot-mode'), 500);
            }

            // ëª¨ë°”ì¼ì—ì„œ ë¯¸ë‹ˆ HUD í‘œì‹œ
            if (window.innerWidth <= 768) {
                document.getElementById('mobile-mini-hud').style.display = 'flex';
            }

            // â˜… ë©€í‹°ëª¨ë“œ: ê²Œì„ ìƒíƒœ ì €ì¥ (ì¡°ì¢…ì„ ì§„ì…)
            console.log('ğŸš€ ì¡°ì¢…ì„ ì§„ì… - ìƒíƒœ ì €ì¥ ì‹œë„', {
                hasFunc: !!window.saveGameStateToServer,
                hasUser: !!window.mpUser,
                gameMode: window.gameMode
            });
            if (window.saveGameStateToServer && window.mpUser) {
                window.saveGameStateToServer({ isPilotMode: true }).then(result => {
                    console.log('ğŸš€ ì¡°ì¢…ì„ ì§„ì… ìƒíƒœ ì €ì¥ ê²°ê³¼:', result);
                });
            }
        };

        // ì¡°ì¢… ëª¨ë“œ í‡´ì¥ ì‹œ ìƒíƒœ ì €ì¥
        const originalExitPilotMode = window.exitPilotMode;
        window.exitPilotMode = function() {
            if (originalExitPilotMode) originalExitPilotMode.apply(this, arguments);

            // â˜… ë©€í‹°ëª¨ë“œ: ê²Œì„ ìƒíƒœ ì €ì¥ (ì¡°ì¢…ì„ í‡´ì¥)
            console.log('ğŸ  ì¡°ì¢…ì„ í‡´ì¥ - ìƒíƒœ ì €ì¥ ì‹œë„', {
                hasFunc: !!window.saveGameStateToServer,
                hasUser: !!window.mpUser,
                gameMode: window.gameMode
            });
            if (window.saveGameStateToServer && window.mpUser) {
                window.saveGameStateToServer({ isPilotMode: false }).then(result => {
                    console.log('ğŸ  ì¡°ì¢…ì„ í‡´ì¥ ìƒíƒœ ì €ì¥ ê²°ê³¼:', result);
                });
            }
        };
        
        // DOM ë¡œë“œ í›„ ì´ˆê¸°í™”
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(() => mobileTabSystem.init(), 1500);
        });
        
        // ë²„íŠ¼ ì´ë²¤íŠ¸ ì—°ê²°
        document.getElementById('btn-single').addEventListener('click', () => startGameMode('single'));
        document.getElementById('btn-multi').addEventListener('click', () => startGameMode('multi'));
        
        // â˜…â˜…â˜… VOYAGER ë©”ë‰´ ì´ë²¤íŠ¸ â˜…â˜…â˜…
        // ë¡œê·¸ì¸ ë²„íŠ¼ (ë©”ì¸ ë©”ë‰´)
        document.getElementById('btn-login-main').addEventListener('click', () => {
            // ë¡œê·¸ì¸ UI ì—´ê¸°
            if (typeof createAuthUI === 'function') {
                createAuthUI();
            }
        });
        
        // ì„¤ì • ë²„íŠ¼
        document.getElementById('btn-settings').addEventListener('click', () => {
            document.getElementById('settings-modal').classList.add('active');
        });
        
        // â˜…â˜…â˜… ê³ ì • í—¤ë” ë²„íŠ¼ ì´ë²¤íŠ¸ â˜…â˜…â˜…
        document.getElementById('global-settings-btn').addEventListener('click', () => {
            document.getElementById('settings-modal').classList.add('active');
        });
        
        document.getElementById('global-profile-btn').addEventListener('click', () => {
            // ë¡œê·¸ì¸ ìƒíƒœ í™•ì¸
            if (window.mpUser || window.currentUser) {
                // ë¡œê·¸ì¸ ë¨ - í”„ë¡œí•„ í‘œì‹œ (ë˜ëŠ” ë¡œê·¸ì•„ì›ƒ)
                const userName = window.mpUser?.user_metadata?.username || 
                                window.currentUser?.name || 
                                window.currentUser?.email || 'User';
                if (confirm(`${userName}\n\nLogout?`)) {
                    if (typeof logoutUser === 'function') logoutUser();
                    showMsg('Logged out');
                }
            } else {
                // ë¡œê·¸ì¸ ì•ˆë¨ - ë¡œê·¸ì¸ ëª¨ë‹¬ ì—´ê¸°
                const authOverlay = document.getElementById('auth-overlay');
                if (authOverlay) {
                    authOverlay.style.display = 'flex';
                } else {
                    document.getElementById('login-modal').classList.add('open');
                }
            }
        });
        
        // ì„¤ì • ë‹«ê¸°
        document.getElementById('settings-close').addEventListener('click', () => {
            document.getElementById('settings-modal').classList.remove('active');
        });
        
        // â˜…â˜…â˜… ì„¤ì • ëª¨ë‹¬ ì–¸ì–´ ë³€ê²½ ì´ë²¤íŠ¸ â˜…â˜…â˜…
        document.getElementById('settings-language').addEventListener('change', (e) => {
            const newLang = e.target.value;
            setLanguage(newLang);
            // ìƒë‹¨ë°” ì–¸ì–´ ì„ íƒë„ ë™ê¸°í™”
            const topLangSelect = document.getElementById('lang-select');
            if (topLangSelect) topLangSelect.value = newLang;
        });
        
        // ë¯¸ì…˜ ë³´ë“œ ë‹«ê¸°
        document.getElementById('mission-board-close').addEventListener('click', () => {
            document.getElementById('mission-board-modal').classList.remove('active');
        });
        
        // ì„¤ì • ìŠ¬ë¼ì´ë” ì´ë²¤íŠ¸
        document.getElementById('settings-volume').addEventListener('input', (e) => {
            document.getElementById('settings-volume-val').textContent = e.target.value + '%';
            if (typeof SpaceAudio !== 'undefined') {
                SpaceAudio.setVolume(e.target.value / 100);
            }
        });
        
        // ë¯¸ì…˜ íƒ­ ì „í™˜
        document.querySelectorAll('.mission-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.mission-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                // ë¯¸ì…˜ ì‹œìŠ¤í…œ ë Œë”ë§
                if (typeof MissionSystem !== 'undefined') {
                    MissionSystem.render(tab.dataset.tab);
                }
            });
        });
        
        // ëª¨ë‹¬ ë°°ê²½ í´ë¦­ ì‹œ ë‹«ê¸°
        document.querySelectorAll('.voyager-modal').forEach(modal => {
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.classList.remove('active');
                }
            });
        });
        
        // â˜…â˜…â˜… í”„ë¡œí•„ íŒ¨ë„ ì´ë²¤íŠ¸ â˜…â˜…â˜…
        setTimeout(() => {
            // â˜…â˜…â˜… í”„ë¡œí•„ íŒ¨ë„ ì´ë²¤íŠ¸ â˜…â˜…â˜…
            const profilePanel = document.getElementById('user-profile-panel');
            const profileMenuBtn = document.getElementById('profile-menu-btn');
            const profileDropdown = document.getElementById('profile-dropdown');
            
            if (profilePanel && profileDropdown) {
                // ë“œë¡­ë‹¤ìš´ í† ê¸€
                profileMenuBtn?.addEventListener('click', (e) => {
                    e.stopPropagation();
                    profileDropdown.style.display = profileDropdown.style.display === 'none' ? 'block' : 'none';
                });
                
                profilePanel.addEventListener('click', (e) => {
                    if (e.target === profileMenuBtn) return;
                    profileDropdown.style.display = profileDropdown.style.display === 'none' ? 'block' : 'none';
                });
                
                // ë“œë¡­ë‹¤ìš´ í•­ëª© í´ë¦­ - í”„ë¡œí•„ ëª¨ë‹¬ ì—´ê¸°
                document.getElementById('dropdown-profile')?.addEventListener('click', () => {
                    profileDropdown.style.display = 'none';
                    openProfileModal();
                });
                
                // ë¯¸ì…˜ ë³´ë“œ
                document.getElementById('dropdown-missions')?.addEventListener('click', () => {
                    profileDropdown.style.display = 'none';
                    if (typeof MissionSystem !== 'undefined') {
                        MissionSystem.init();
                    }
                    document.getElementById('mission-board-modal').classList.add('active');
                });
                
                document.getElementById('dropdown-settings')?.addEventListener('click', () => {
                    profileDropdown.style.display = 'none';
                    document.getElementById('settings-modal').classList.add('active');
                });
                
                document.getElementById('dropdown-logout')?.addEventListener('click', () => {
                    profileDropdown.style.display = 'none';
                    confirmLogout();
                });
                
                // ë°”ê¹¥ í´ë¦­ ì‹œ ë‹«ê¸°
                document.addEventListener('click', (e) => {
                    if (!profilePanel.contains(e.target) && !profileDropdown.contains(e.target)) {
                        profileDropdown.style.display = 'none';
                    }
                });
            }
        }, 1000);
        
        // ë¯¸ì…˜ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
        setTimeout(() => {
            if (typeof MissionSystem !== 'undefined') {
                MissionSystem.init();
            }
        }, 2000);

        init();
