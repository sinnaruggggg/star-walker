<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Solar Explorer v2.1 - 우주 탐험 시뮬레이터</title>
    
    <!-- PWA 설정 -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#0a1628">
    <meta name="description" content="3D 태양계 탐험 시뮬레이션 게임. 우주선을 조종하고 행성을 탐험하세요!">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Solar Explorer">
    <link rel="apple-touch-icon" href="icons/icon-192x192.png">
    <link rel="apple-touch-icon" sizes="152x152" href="icons/icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="icons/icon-192x192.png">
    <link rel="apple-touch-icon" sizes="167x167" href="icons/icon-192x192.png">
    
    <!-- Open Graph / 소셜 미디어 공유 -->
    <meta property="og:title" content="Solar Explorer - 우주 탐험 시뮬레이터">
    <meta property="og:description" content="3D 태양계 탐험 시뮬레이션 게임">
    <meta property="og:type" content="website">
    <meta property="og:image" content="icons/icon-512x512.png">
    
    <!-- MS 타일 -->
    <meta name="msapplication-TileColor" content="#0a1628">
    <meta name="msapplication-TileImage" content="icons/icon-144x144.png">
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&family=Rajdhani:wght@400;500;600;700&display=swap');
        
        /* ===== SF NEBULA DESIGN SYSTEM ===== */
        :root {
            /* 색상 팔레트 */
            --sf-bg-deep: #0a0a14;
            --sf-bg-dark: #0d1117;
            --sf-bg-panel: rgba(10, 15, 25, 0.85);
            --sf-bg-card: rgba(15, 20, 35, 0.9);
            
            --sf-cyan: #00ffff;
            --sf-cyan-dim: #00aaaa;
            --sf-cyan-glow: rgba(0, 255, 255, 0.4);
            --sf-green: #00ff88;
            --sf-green-dim: #00aa66;
            --sf-yellow: #ffd93d;
            --sf-orange: #ff9500;
            --sf-red: #ff4757;
            --sf-purple: #a855f7;
            --sf-pink: #ff6bcb;
            
            --sf-text-bright: #ffffff;
            --sf-text-normal: #c8d6e5;
            --sf-text-dim: #6b7c93;
            
            /* 글로우 효과 */
            --sf-glow-cyan: 0 0 10px rgba(0, 255, 255, 0.5), 0 0 20px rgba(0, 255, 255, 0.3), 0 0 30px rgba(0, 255, 255, 0.1);
            --sf-glow-green: 0 0 10px rgba(0, 255, 136, 0.5), 0 0 20px rgba(0, 255, 136, 0.3);
            --sf-glow-red: 0 0 10px rgba(255, 71, 87, 0.5), 0 0 20px rgba(255, 71, 87, 0.3);
            
            /* UI 레이아웃 변수 */
            --top-bar-height: 60px;
            --nav-width: 160px;
            --spawn-dock-width: 60px;
            --chat-toggle-size: 50px;
            --ui-gap: 10px;
            --ui-padding: 15px;
            --bottom-safe: 80px;
        }
        
        /* 스캔라인 오버레이 */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 255, 255, 0.01) 2px,
                rgba(0, 255, 255, 0.01) 4px
            );
            pointer-events: none;
            z-index: 99999;
        }
        
        /* 그리드 패턴 배경 */
        body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 255, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 255, 0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            pointer-events: none;
            z-index: -1;
        }
        
        body { 
            margin: 0; 
            overflow: hidden; 
            background: linear-gradient(135deg, var(--sf-bg-deep) 0%, var(--sf-bg-dark) 50%, #0a1628 100%);
            font-family: 'Rajdhani', 'Noto Sans KR', sans-serif; 
            user-select: none;
            color: var(--sf-text-normal);
        }
        
        /* ★★★ 모든 스크롤바 숨김 ★★★ */
        * {
            scrollbar-width: none;  /* Firefox */
            -ms-overflow-style: none;  /* IE/Edge */
        }
        *::-webkit-scrollbar {
            display: none;  /* Chrome, Safari, Opera */
            width: 0;
            height: 0;
        }
        
        /* SF 공통 버튼 스타일 */
        .sf-btn {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.1) 0%, rgba(0, 255, 255, 0.05) 100%);
            border: 1px solid var(--sf-cyan);
            color: var(--sf-cyan);
            padding: 10px 20px;
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            position: relative;
            clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
            transition: all 0.3s ease;
            text-shadow: 0 0 10px var(--sf-cyan-glow);
            box-shadow: var(--sf-glow-cyan), inset 0 0 20px rgba(0, 255, 255, 0.1);
        }
        .sf-btn:hover {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.3) 0%, rgba(0, 255, 255, 0.1) 100%);
            box-shadow: var(--sf-glow-cyan), inset 0 0 30px rgba(0, 255, 255, 0.2);
            transform: translateY(-2px);
        }
        .sf-btn:active {
            transform: translateY(0);
        }
        
        /* SF 패널 스타일 */
        .sf-panel {
            background: var(--sf-bg-panel);
            border: 1px solid rgba(0, 255, 255, 0.3);
            backdrop-filter: blur(20px);
            position: relative;
        }
        .sf-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--sf-cyan), transparent);
        }
        
        /* SF 카드 스타일 */
        .sf-card {
            background: var(--sf-bg-card);
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }
        .sf-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.05) 0%, transparent 50%);
            pointer-events: none;
        }
        
        /* 펄스 애니메이션 */
        @keyframes sf-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        @keyframes sf-glow-pulse {
            0%, 100% { box-shadow: 0 0 5px var(--sf-cyan), 0 0 10px var(--sf-cyan-glow); }
            50% { box-shadow: 0 0 15px var(--sf-cyan), 0 0 30px var(--sf-cyan-glow); }
        }
        @keyframes sf-scan {
            0% { transform: translateY(-100%); }
            100% { transform: translateY(100%); }
        }
        
        /* ===== 상단 영역 ===== */
        #top-bar {
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: var(--top-bar-height);
            background: linear-gradient(180deg, rgba(10, 15, 25, 0.95) 0%, rgba(10, 15, 25, 0.7) 70%, transparent 100%);
            border-bottom: 1px solid rgba(0, 255, 255, 0.2);
            display: flex; align-items: center; justify-content: space-between;
            padding: 0 15px; box-sizing: border-box; z-index: 100; pointer-events: none;
        }
        #top-bar::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--sf-cyan), transparent);
        }
        /* 로고 숨김 */
        #top-bar h1 { 
            display: none;
        }

        .control-group { pointer-events: auto; display: flex; align-items: center; gap: 8px; color: var(--sf-text-normal); }
        
        .slider-container { display: flex; flex-direction: column; gap: 2px; }
        .slider-row { display: flex; align-items: center; gap: 6px; font-size: 9px; color: var(--sf-text-dim); font-family: 'Orbitron', sans-serif; }
        .slider-label { width: 45px; text-align: right; text-transform: uppercase; letter-spacing: 0.5px; }
        input[type=range] { 
            width: 80px; 
            cursor: pointer; 
            accent-color: var(--sf-cyan); 
            height: 4px;
            background: rgba(0, 255, 255, 0.2);
            border-radius: 2px;
        }
        
        #time-val { 
            font-family: 'Orbitron', sans-serif;
            font-size: 11px; 
            font-weight: bold; 
            color: var(--sf-cyan); 
            width: 40px; 
            text-align: right;
            text-shadow: 0 0 10px var(--sf-cyan-glow);
        }

        .mode-btn {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.1) 0%, rgba(0, 255, 255, 0.02) 100%);
            border: 1px solid rgba(0, 255, 255, 0.4);
            color: var(--sf-cyan); 
            padding: 5px 10px; 
            border-radius: 4px;
            clip-path: polygon(6px 0, 100% 0, 100% calc(100% - 6px), calc(100% - 6px) 100%, 0 100%, 0 6px);
            cursor: pointer;
            font-family: 'Orbitron', sans-serif;
            font-size: 9px; 
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: all 0.3s ease;
            white-space: nowrap;
            text-shadow: 0 0 10px var(--sf-cyan-glow);
        }
        .mode-btn:hover { 
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.3) 0%, rgba(0, 255, 255, 0.1) 100%);
            box-shadow: 0 0 15px var(--sf-cyan-glow), inset 0 0 20px rgba(0, 255, 255, 0.1);
        }
        .mode-btn.active { 
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.4) 0%, rgba(0, 255, 255, 0.2) 100%);
            border-color: var(--sf-cyan);
            box-shadow: var(--sf-glow-cyan);
            font-weight: bold; 
        }

        #btn-station { 
            border-color: var(--sf-green); 
            color: var(--sf-green);
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.1) 0%, rgba(0, 255, 136, 0.02) 100%);
        }
        #btn-station:hover { 
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.3) 0%, rgba(0, 255, 136, 0.1) 100%);
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.4);
        }

        #btn-catalog { 
            border-color: var(--sf-purple); 
            color: var(--sf-purple);
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.1) 0%, rgba(168, 85, 247, 0.02) 100%);
        }
        #btn-catalog:hover { 
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.3) 0%, rgba(168, 85, 247, 0.1) 100%);
            box-shadow: 0 0 15px rgba(168, 85, 247, 0.4);
        }

        /* ===== 좌측 영역: 네비게이션 ===== */
        #nav-container {
            position: absolute; 
            top: 70px;
            left: 0; 
            bottom: 80px;
            z-index: 90; 
            display: flex; 
            align-items: flex-start;
            transition: transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            transform: translateX(0);
            overflow: hidden;
        }
        #nav-container.closed { transform: translateX(-130px); }

        #nav-panel {
            width: 160px; 
            max-height: calc(100vh - 170px);
            overflow-y: auto;
            background: linear-gradient(180deg, rgba(10, 15, 25, 0.95) 0%, rgba(10, 15, 25, 0.85) 100%);
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-left: none;
            border-radius: 0 8px 8px 0;
            padding: 15px 8px;
            pointer-events: auto;
            backdrop-filter: blur(20px);
            display: flex;
            flex-direction: column;
            gap: 4px;
            position: relative;
        }
        #nav-panel::before {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 2px;
            height: 100%;
            background: linear-gradient(180deg, var(--sf-cyan), transparent);
        }
        #nav-panel::-webkit-scrollbar { width: 3px; }
        #nav-panel::-webkit-scrollbar-thumb { background: var(--sf-cyan-dim); border-radius: 2px; }
        #nav-panel::-webkit-scrollbar-track { background: rgba(0, 255, 255, 0.1); }

        .nav-header { 
            font-family: 'Orbitron', sans-serif;
            font-size: 10px; 
            color: var(--sf-cyan); 
            margin-bottom: 8px; 
            padding-left: 8px; 
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px var(--sf-cyan-glow);
        }
        .nav-item {
            padding: 10px 12px;
            border-radius: 4px;
            font-family: 'Rajdhani', sans-serif;
            font-size: 13px;
            font-weight: 500;
            color: var(--sf-text-normal);
            cursor: pointer;
            transition: all 0.2s ease;
            background: rgba(0, 255, 255, 0.03);
            border: 1px solid transparent;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
            overflow: hidden;
        }
        .nav-item::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            width: 2px;
            height: 100%;
            background: var(--sf-cyan);
            transform: scaleY(0);
            transition: transform 0.2s ease;
        }
        .nav-item:hover {
            background: rgba(0, 255, 255, 0.1);
            border-color: rgba(0, 255, 255, 0.3);
            color: var(--sf-cyan);
            padding-left: 16px;
        }
        .nav-item:hover::before {
            transform: scaleY(1);
        }
        .nav-item.active { 
            background: linear-gradient(90deg, rgba(0, 255, 255, 0.2) 0%, rgba(0, 255, 255, 0.05) 100%);
            border-color: var(--sf-cyan);
            color: var(--sf-cyan);
            font-weight: 600;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
        }
        .nav-item.active::before {
            transform: scaleY(1);
            box-shadow: 0 0 10px var(--sf-cyan);
        }
        .nav-item .type-icon { font-size: 10px; opacity: 0.7; }
        .nav-item.satellite { padding-left: 24px; font-size: 12px; color: var(--sf-text-dim); }

        #nav-toggle {
            width: 24px;
            height: 50px;
            background: linear-gradient(135deg, rgba(10, 15, 25, 0.9) 0%, rgba(10, 15, 25, 0.7) 100%);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-left: none;
            border-radius: 0 8px 8px 0;
            color: var(--sf-cyan);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            pointer-events: auto;
            margin-top: 10px;
            transition: all 0.3s ease;
        }
        #nav-toggle:hover { 
            background: rgba(0, 255, 255, 0.15);
            box-shadow: 0 0 15px var(--sf-cyan-glow);
        }

        /* ===== 우측 상단 영역: 스폰 독 ===== */
        #spawn-dock {
            position: absolute; 
            top: 70px;
            right: 15px; 
            width: 55px;
            max-height: calc(100vh - 150px);
            overflow-y: auto;
            background: linear-gradient(180deg, rgba(10, 15, 25, 0.95) 0%, rgba(10, 15, 25, 0.85) 100%);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 12px;
            padding: 15px 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            z-index: 100;
            pointer-events: auto;
            backdrop-filter: blur(20px);
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5), inset 0 0 30px rgba(0, 255, 255, 0.05);
        }
        #spawn-dock::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 30px;
            height: 2px;
            background: var(--sf-cyan);
            border-radius: 1px;
            box-shadow: 0 0 10px var(--sf-cyan);
        }
        #spawn-dock::-webkit-scrollbar { width: 3px; }
        #spawn-dock::-webkit-scrollbar-thumb { background: var(--sf-cyan-dim); border-radius: 2px; }
        
        .spawn-btn {
            width: 38px;
            height: 38px;
            border-radius: 8px;
            border: 2px solid rgba(0, 255, 255, 0.3);
            cursor: pointer;
            background-size: cover;
            background-position: center;
            transition: all 0.3s ease;
            position: relative;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5), inset 0 0 10px rgba(0, 255, 255, 0.1);
            background-color: rgba(10, 15, 25, 0.8);
        }
        .spawn-btn:hover { 
            transform: scale(1.15);
            border-color: var(--sf-cyan);
            box-shadow: 0 0 20px var(--sf-cyan-glow), inset 0 0 15px rgba(0, 255, 255, 0.2);
            z-index: 10;
        }
        .spawn-btn.active { 
            border-color: var(--sf-cyan);
            box-shadow: var(--sf-glow-cyan);
            animation: sf-glow-pulse 2s infinite;
        }
        .spawn-btn::after {
            content: attr(data-name);
            position: absolute;
            right: 55px;
            top: 50%;
            transform: translateY(-50%);
            background: linear-gradient(135deg, rgba(10, 15, 25, 0.95) 0%, rgba(10, 15, 25, 0.9) 100%);
            border: 1px solid var(--sf-cyan);
            color: var(--sf-cyan);
            padding: 6px 12px;
            border-radius: 4px;
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s ease;
            box-shadow: var(--sf-glow-cyan);
        }
        .spawn-btn:hover::after { opacity: 1; }

        #catalog-modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, rgba(10, 15, 25, 0.95) 0%, rgba(5, 8, 15, 0.98) 100%);
            z-index: 200;
            display: none;
            backdrop-filter: blur(10px);
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            overflow-y: auto;
            padding: 20px 0;
        }
        #catalog-modal.open { display: flex; }
        #catalog-content {
            width: 85%;
            max-height: 85vh;
            margin: auto;
            background: linear-gradient(135deg, rgba(10, 15, 25, 0.95) 0%, rgba(15, 20, 30, 0.9) 100%);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 12px;
            padding: 25px;
            padding-bottom: 40px;
            overflow-y: auto;
            display: grid; 
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 15px;
            align-content: start;
            position: relative;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.1), inset 0 0 50px rgba(0, 255, 255, 0.02);
        }
        #catalog-content::before {
            content: 'CELESTIAL CATALOG';
            position: absolute;
            top: -30px;
            left: 25px;
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            font-weight: 700;
            color: var(--sf-cyan);
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: var(--sf-glow-cyan);
        }
        #catalog-content::-webkit-scrollbar { width: 6px; }
        #catalog-content::-webkit-scrollbar-track { background: rgba(0, 255, 255, 0.05); border-radius: 4px; }
        #catalog-content::-webkit-scrollbar-thumb { background: var(--sf-cyan-dim); border-radius: 4px; }
        #catalog-content::-webkit-scrollbar-thumb:hover { background: #777; }
        
        .catalog-card {
            background: #252530; border-radius: 10px; padding: 12px; cursor: pointer;
            display: flex; flex-direction: column; align-items: center; gap: 8px;
            transition: 0.2s; border: 2px solid transparent;
        }
        .catalog-card:hover { transform: translateY(-3px); background: #303040; border-color: #e74c3c; box-shadow: 0 5px 20px rgba(231, 76, 60, 0.3); }
        .catalog-thumb {
            width: 70px; height: 70px; border-radius: 50%; background-color: #000;
            background-size: cover; background-position: center; border: 3px solid #444;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
        }
        .catalog-card:hover .catalog-thumb { border-color: #e74c3c; }
        .catalog-name { font-size: 11px; color: #ddd; text-align: center; font-weight: bold; }
        
        #catalog-close {
            margin-top: 20px; padding: 10px 30px; background: #e74c3c; color: white; border: none;
            border-radius: 20px; font-weight: bold; cursor: pointer;
        }

        /* 포커스 거리 표시 패널 */
        /* ===== 우측 하단 영역: 거리 패널 ===== */
        #focus-distance-panel {
            position: absolute;
            bottom: 20px;
            right: 90px;  /* spawn-dock 왼쪽 */
            background: rgba(0, 20, 40, 0.9);
            border: 2px solid #4fc3f7;
            border-radius: 12px;
            padding: 12px 18px;
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            z-index: 100;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 20px rgba(79, 195, 247, 0.3);
            min-width: 150px;
        }
        #focus-distance-panel.visible { display: flex; }
        #focus-target-name {
            font-size: 11px;
            color: #4fc3f7;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        #focus-distance-value {
            font-size: 18px;
            font-weight: bold;
            color: #fff;
            font-family: 'Orbitron', monospace;
            text-shadow: 0 0 10px rgba(79, 195, 247, 0.5);
        }

        /* 우주선 선택 모달 */
        #ship-select-modal {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 250; display: none;
            backdrop-filter: blur(10px); align-items: center; justify-content: center;
            pointer-events: auto; overflow-y: auto; padding: 20px 0;
        }
        #ship-select-modal.open { display: flex; }
        #ship-select-content {
            width: 90%; max-width: 900px; max-height: 85vh; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 2px solid #4fc3f7; border-radius: 20px; padding: 25px; overflow-y: auto; margin: auto;
            box-shadow: 0 0 50px rgba(79, 195, 247, 0.3);
        }
        #ship-select-content h2 {
            color: #4fc3f7; text-align: center; margin-bottom: 20px;
            font-family: 'Orbitron', sans-serif; text-shadow: 0 0 10px rgba(79, 195, 247, 0.5);
        }
        #ship-list {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 12px; margin-bottom: 20px; max-height: 200px; overflow-y: auto;
            padding: 5px;
        }
        #ship-list::-webkit-scrollbar { width: 5px; }
        #ship-list::-webkit-scrollbar-thumb { background: #4fc3f7; border-radius: 3px; }
        .ship-card {
            background: rgba(255,255,255,0.05); border: 2px solid rgba(255,255,255,0.1);
            border-radius: 12px; padding: 10px; cursor: pointer; transition: all 0.3s;
            display: flex; flex-direction: column; align-items: center; gap: 6px;
            position: relative; min-height: 120px;
        }
        .ship-card:hover { background: rgba(79, 195, 247, 0.1); border-color: #4fc3f7; transform: translateY(-3px); }
        .ship-card.selected { background: rgba(79, 195, 247, 0.2); border-color: #4fc3f7; box-shadow: 0 0 15px rgba(79, 195, 247, 0.4); }
        .ship-card.locked { opacity: 0.5; cursor: not-allowed; }
        .ship-card.locked:hover { transform: none; border-color: rgba(255,255,255,0.1); }
        .ship-card-icon { width: 100%; height: 70px; border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 32px; overflow: hidden; background: rgba(0,0,0,0.3); }
        .ship-card-icon img { width: 100%; height: 100%; object-fit: contain; }
        .ship-card-name { font-size: 12px; color: #fff; text-align: center; font-weight: bold; }
        .ship-card-tier { font-size: 10px; color: #ffd700; }
        .ship-card-lock { position: absolute; font-size: 20px; }
        .ship-card-dev { font-size: 9px; color: #ff9800; background: rgba(255,152,0,0.2); padding: 2px 6px; border-radius: 8px; margin-top: 2px; }
        .ship-card-owned { position: absolute; top: 5px; left: 5px; background: #27ae60; color: #fff; width: 20px; height: 20px; border-radius: 50%; font-size: 12px; display: flex; align-items: center; justify-content: center; z-index: 1; }
        .ship-card.owned { border-color: #27ae60; }
        
        #ship-detail {
            display: flex; gap: 20px; background: rgba(0,0,0,0.3); border-radius: 15px;
            padding: 20px; margin-bottom: 20px;
        }
        #ship-preview {
            width: 200px; height: 200px; background: radial-gradient(circle, #1a2a3a 0%, #0a1520 100%);
            border-radius: 15px; border: 1px solid #333; display: flex; align-items: center; justify-content: center;
            position: relative; overflow: hidden;
        }
        #ship-preview::before {
            content: ''; position: absolute; width: 100%; height: 100%;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.1) 0%, transparent 50%);
        }
        #ship-preview canvas { max-width: 100%; max-height: 100%; }
        #ship-info { flex: 1; }
        #ship-info h3 { color: #4fc3f7; margin: 0 0 5px 0; font-family: 'Orbitron', sans-serif; font-size: 20px; }
        #ship-detail-desc { color: #aaa; font-size: 13px; margin-bottom: 15px; }
        #ship-stats { display: flex; flex-direction: column; gap: 10px; }
        .stat-row { display: flex; align-items: center; gap: 10px; font-size: 12px; color: #ccc; }
        .stat-row > span:first-child { width: 70px; }
        .stat-bar { flex: 1; height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; overflow: hidden; }
        .stat-fill { height: 100%; border-radius: 4px; transition: width 0.3s; }
        .stat-fill.speed { background: linear-gradient(90deg, #e74c3c, #f39c12); }
        .stat-fill.accel { background: linear-gradient(90deg, #2ecc71, #27ae60); }
        .stat-fill.turn { background: linear-gradient(90deg, #3498db, #2980b9); }
        .stat-fill.fuel { background: linear-gradient(90deg, #9b59b6, #8e44ad); }
        .stat-val { width: 70px; text-align: right; color: #fff; font-weight: bold; }
        #ship-special {
            margin-top: 15px; padding: 10px 15px; background: rgba(79, 195, 247, 0.1);
            border: 1px solid #4fc3f7; border-radius: 8px; color: #4fc3f7; font-size: 12px;
        }
        #ship-special:empty { display: none; }
        
        #ship-select-buttons { display: flex; justify-content: center; gap: 15px; }
        .ship-modal-btn {
            padding: 12px 40px; border-radius: 25px; border: none; font-size: 14px;
            font-weight: bold; cursor: pointer; font-family: 'Orbitron', sans-serif; transition: all 0.3s;
        }
        .ship-modal-btn.confirm { background: linear-gradient(180deg, #4fc3f7, #0288d1); color: #fff; }
        .ship-modal-btn.confirm:hover { background: linear-gradient(180deg, #81d4fa, #4fc3f7); transform: scale(1.05); }
        .ship-modal-btn.cancel { background: rgba(100,100,100,0.5); border: 1px solid #666; color: #aaa; }
        .ship-modal-btn.cancel:hover { background: rgba(150,150,150,0.5); }
        .ship-modal-btn.buy { background: linear-gradient(180deg, #f39c12, #e67e22); color: #fff; }
        .ship-modal-btn.buy:hover { background: linear-gradient(180deg, #f7dc6f, #f39c12); transform: scale(1.05); }
        .ship-modal-btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none !important; }
        .ship-modal-btn.armory { background: linear-gradient(180deg, #e74c3c, #c0392b); color: #fff; }
        .ship-modal-btn.armory:hover { background: linear-gradient(180deg, #ff6b6b, #e74c3c); transform: scale(1.05); }
        
        /* 무장 모달 */
        #armory-modal {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 260; display: none;
            backdrop-filter: blur(10px); align-items: center; justify-content: center;
            overflow-y: auto; padding: 20px 0;
        }
        #armory-modal.open { display: flex; }
        #armory-content {
            width: 95%; max-width: 1000px; max-height: 85vh; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 2px solid #e74c3c; border-radius: 20px; padding: 20px; overflow-y: auto; margin: auto;
            box-shadow: 0 0 50px rgba(231, 76, 60, 0.3);
        }
        #armory-content h2 {
            color: #e74c3c; text-align: center; margin-bottom: 15px;
            font-family: 'Orbitron', sans-serif; text-shadow: 0 0 10px rgba(231, 76, 60, 0.5);
        }
        .armory-tabs { display: flex; justify-content: center; gap: 10px; margin-bottom: 15px; }
        .armory-tab {
            padding: 10px 25px; background: rgba(255,255,255,0.1); border: 1px solid #444;
            border-radius: 20px; color: #aaa; cursor: pointer; font-family: 'Orbitron', sans-serif;
            font-size: 12px; transition: all 0.3s;
        }
        .armory-tab:hover { border-color: #e74c3c; color: #e74c3c; }
        .armory-tab.active { background: rgba(231, 76, 60, 0.3); border-color: #e74c3c; color: #e74c3c; }
        
        .armory-main { display: flex; gap: 15px; }
        .armory-list-container { flex: 1; max-height: 350px; overflow-y: auto; }
        .armory-list { display: flex; flex-direction: column; gap: 8px; }
        .armory-item {
            display: flex; align-items: center; gap: 10px; padding: 10px 12px;
            background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1);
            border-radius: 10px; cursor: pointer; transition: all 0.3s;
        }
        .armory-item:hover { background: rgba(231, 76, 60, 0.1); border-color: #e74c3c; }
        .armory-item.selected { background: rgba(231, 76, 60, 0.2); border-color: #e74c3c; box-shadow: 0 0 10px rgba(231, 76, 60, 0.3); }
        .armory-item.locked { opacity: 0.4; cursor: not-allowed; }
        .armory-item.equipped { border-color: #27ae60; background: rgba(39, 174, 96, 0.15); }
        .armory-item-icon { font-size: 24px; width: 40px; text-align: center; }
        .armory-item-info { flex: 1; }
        .armory-item-name { color: #fff; font-size: 13px; font-weight: bold; }
        .armory-item-tier { font-size: 10px; color: #f39c12; }
        .armory-item-stats { font-size: 10px; color: #888; }
        .armory-item-price { color: #f39c12; font-size: 12px; font-weight: bold; }
        .armory-item-owned { color: #27ae60; font-size: 11px; }
        
        .armory-detail {
            width: 280px; background: rgba(0,0,0,0.3); border-radius: 15px; padding: 15px;
        }
        .armory-detail h3 { color: #e74c3c; margin: 0 0 10px 0; font-size: 16px; font-family: 'Orbitron', sans-serif; }
        .armory-detail-icon { font-size: 48px; text-align: center; margin-bottom: 10px; }
        .armory-detail-desc { color: #aaa; font-size: 11px; margin-bottom: 15px; line-height: 1.5; }
        .armory-detail-stats { display: flex; flex-direction: column; gap: 6px; margin-bottom: 15px; }
        .armory-stat-row { display: flex; justify-content: space-between; font-size: 11px; }
        .armory-stat-row span:first-child { color: #888; }
        .armory-stat-row span:last-child { color: #fff; font-weight: bold; }
        .armory-detail-effect { background: rgba(231, 76, 60, 0.2); border: 1px solid #e74c3c; border-radius: 8px; padding: 8px; font-size: 11px; color: #e74c3c; margin-bottom: 15px; }
        
        .armory-equipped-section { margin-bottom: 15px; padding: 10px; background: rgba(39, 174, 96, 0.1); border: 1px solid #27ae60; border-radius: 10px; }
        .armory-equipped-title { color: #27ae60; font-size: 12px; margin-bottom: 8px; }
        .armory-equipped-slot { display: flex; align-items: center; gap: 8px; padding: 5px; background: rgba(0,0,0,0.3); border-radius: 5px; margin-bottom: 5px; }
        .armory-equipped-slot span { font-size: 11px; color: #ccc; }
        .armory-slot-empty { color: #666 !important; font-style: italic; }
        
        .armory-buttons { display: flex; gap: 10px; justify-content: center; margin-top: 15px; }
        
        /* 가격 표시 */
        #ship-price-display {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 10px 0;
            padding: 8px 15px;
            background: linear-gradient(135deg, rgba(243,156,18,0.3), rgba(230,126,34,0.3));
            border: 1px solid #f39c12;
            border-radius: 20px;
            width: fit-content;
        }
        .price-label { font-size: 18px; }
        #ship-price-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            font-weight: bold;
            color: #f7dc6f;
        }
        #ship-owned-badge {
            background: #27ae60;
            color: #fff;
            padding: 3px 10px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: bold;
        }
        
        /* 우주선 리스트 아이템에 보유 표시 */
        .ship-item.owned::after {
            content: '✓';
            position: absolute;
            top: 3px;
            right: 5px;
            background: #27ae60;
            color: #fff;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .ship-item { position: relative; }
        
        @media (max-width: 600px) {
            #ship-detail { flex-direction: column; }
            #ship-preview { width: 100%; height: 150px; }
            #ship-list { grid-template-columns: repeat(3, 1fr); }
        }

        #msg-box {
            position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%);
            color: #ff6b6b; font-weight: bold; text-shadow: 0 2px 4px black;
            font-size: 16px; pointer-events: none; opacity: 0; transition: opacity 0.3s;
        }

        /* ===== 하단 중앙 영역: 버튼들 ===== */
        #reset-cam {
            position: absolute; 
            bottom: 20px; 
            left: 50%;
            transform: translateX(-50%);
            background: #e67e22; color: white; padding: 10px 25px; border: none;
            border-radius: 50px; cursor: pointer; font-weight: bold; font-size: 13px;
            box-shadow: 0 5px 15px rgba(230, 126, 34, 0.3); display: none; pointer-events: auto;
            z-index: 95;
        }
        /* 조종 모드에서 전체보기 버튼 완전히 숨김 */
        body.pilot-mode #reset-cam {
            display: none !important;
            visibility: hidden !important;
            pointer-events: none !important;
        }
        
        .label {
            color: rgba(255,255,255,0.7); font-size: 10px; text-shadow: 0 0 3px black;
            pointer-events: none; margin-top: -8px;
        }
        .ship-parked-label {
            color: #f39c12 !important;
            font-size: 12px !important;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(243, 156, 18, 0.8);
            cursor: pointer;
            pointer-events: auto !important;
        }
        
        .galaxy-label {
            color: #ff9966; font-size: 14px; font-weight: bold; letter-spacing: 1px;
            text-shadow: 0 0 10px rgba(255, 100, 50, 0.8); opacity: 0.8; pointer-events: none;
        }

        .notify-label {
            font-size: 14px; font-weight: bold; text-shadow: 0 0 5px black;
            pointer-events: none; transition: opacity 1s, transform 1s;
            opacity: 1; transform: translateY(0); white-space: nowrap;
        }
        .notify-label.fade-out { opacity: 0; transform: translateY(-30px); }
        .notify-warn { color: #ffeb3b; }
        .notify-success { color: #ff5722; font-size: 16px; text-shadow: 0 0 10px #ff5722; }

        /* ===== 좌측 하단 영역: 채팅 ===== */
        #chat-toggle {
            position: absolute; 
            bottom: 20px; 
            left: 20px;
            width: 50px; 
            height: 50px;
            background: rgba(30, 30, 40, 0.9);
            border: 2px solid rgba(79, 195, 247, 0.5);
            border-radius: 50%; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            font-size: 24px; color: #4fc3f7;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            transition: all 0.3s; z-index: 101; pointer-events: auto;
        }
        #chat-toggle:hover { transform: scale(1.1); background: rgba(79, 195, 247, 0.2); color: white; border-color: white; }

        #chat-panel {
            position: absolute; 
            bottom: 80px;  /* chat-toggle 위 */
            left: 20px;
            width: 320px; 
            height: 400px;
            max-height: calc(100vh - 160px);
            background: rgba(15, 15, 20, 0.95);
            border: 1px solid rgba(79, 195, 247, 0.3);
            border-radius: 15px;
            display: flex; flex-direction: column;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.8);
            transform: scale(0); transform-origin: bottom left;
            transition: transform 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28);
            z-index: 101; pointer-events: auto; overflow: hidden;
        }
        #chat-panel.open { transform: scale(1); }

        #chat-header {
            padding: 15px; background: rgba(79, 195, 247, 0.1);
            border-bottom: 1px solid rgba(255,255,255,0.1);
            color: #4fc3f7; font-weight: bold; font-size: 14px;
            display: flex; justify-content: space-between; align-items: center;
        }
        #chat-close { cursor: pointer; font-size: 18px; color: #aaa; }
        #chat-close:hover { color: white; }

        #chat-messages {
            flex: 1; padding: 15px; overflow-y: auto;
            display: flex; flex-direction: column; gap: 10px;
            font-size: 13px;
        }
        #chat-messages::-webkit-scrollbar { width: 4px; }
        #chat-messages::-webkit-scrollbar-thumb { background: #444; border-radius: 2px; }

        .msg { max-width: 80%; padding: 8px 12px; border-radius: 12px; line-height: 1.4; word-break: break-word; }
        .msg.user { align-self: flex-end; background: #2c3e50; color: white; border-bottom-right-radius: 2px; }
        .msg.ai { align-self: flex-start; background: rgba(79, 195, 247, 0.15); color: #ddd; border-bottom-left-radius: 2px; border: 1px solid rgba(79, 195, 247, 0.2); }
        .msg.system { align-self: center; font-size: 11px; color: #666; margin: 5px 0; }

        #chat-input-area {
            padding: 10px; border-top: 1px solid rgba(255,255,255,0.1);
            display: flex; gap: 5px;
        }
        #chat-input {
            flex: 1; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.2);
            border-radius: 20px; padding: 8px 12px; color: white; font-size: 13px; outline: none;
        }
        #chat-input:focus { border-color: #4fc3f7; }
        #chat-send {
            background: #4fc3f7; border: none; border-radius: 50%;
            width: 32px; height: 32px; cursor: pointer; color: #000;
            display: flex; align-items: center; justify-content: center; font-weight: bold;
        }
        #chat-send:hover { background: white; }

        /* ===== 우주선 조종 시스템 CSS ===== */
        html { padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left); }
        
        #board-ship-btn {
            position: absolute; 
            bottom: 80px;  /* reset-cam 위 */
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 30px; background: linear-gradient(180deg, #4fc3f7, #0288d1);
            border: 2px solid #81d4fa; color: white; font-size: 16px; font-weight: bold;
            border-radius: 30px; cursor: pointer; z-index: 150; display: none;
            box-shadow: 0 0 30px rgba(79, 195, 247, 0.5); animation: pulse 2s infinite;
            font-family: 'Orbitron', sans-serif; pointer-events: auto;
        }
        @keyframes pulse { 0%, 100% { box-shadow: 0 0 20px rgba(79, 195, 247, 0.5); } 50% { box-shadow: 0 0 40px rgba(79, 195, 247, 0.8); } }
        #board-ship-btn:hover { background: linear-gradient(180deg, #81d4fa, #4fc3f7); transform: translateX(-50%) scale(1.05); }

        #cockpit-hud { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 200; font-family: 'Orbitron', sans-serif; }
        #cockpit-hud.active { display: block; }
        
        /* 콕핏 프레임 (1인칭 시점) */
        #cockpit-frame {
            display: none; /* 3D 조종석 사용으로 2D 프레임 숨김 */
        }
        /* 2D 조종석 요소들 - 비활성화 */
        /*
        #cockpit-frame {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 50;
        }
        */
        #cockpit-frame::before {
            display: none;
        }
        /* 창문 프레임 기둥들 */
        .cockpit-strut {
            display: none;
        }
        .cockpit-strut.left { left: 25%; top: 0; bottom: 0; width: 25px; transform: skewX(-15deg); }
        .cockpit-strut.right { right: 25%; top: 0; bottom: 0; width: 25px; transform: skewX(15deg); }
        .cockpit-strut.top { top: 15%; left: 80px; right: 80px; height: 20px; transform: perspective(500px) rotateX(30deg); }
        /* 대시보드 */
        #cockpit-dashboard {
            display: none;
        }
        #cockpit-dashboard::before {
            display: none;
        }
        /* 사이드 패널 */
        .cockpit-side-panel {
            display: none;
        }
        .cockpit-side-panel.left { left: 0; border-radius: 0 15px 15px 0; border-left: none; }
        .cockpit-side-panel.right { right: 0; border-radius: 15px 0 0 15px; border-right: none; }
        /* 조종 요크/스틱 힌트 */
        .cockpit-indicator {
            display: none;
        }
        .cockpit-indicator.left { left: 150px; }
        .cockpit-indicator.right { right: 150px; }
        /* 콕핏 프레임은 #cockpit-frame에서 구현됨 */
        
        #pilot-top-bar { position: absolute; top: 8px; left: 55%; transform: translateX(-50%); display: flex; gap: 12px; flex-wrap: wrap; justify-content: center; max-width: 55%; }
        .pilot-info-panel { background: rgba(0,40,60,0.9); border: 1px solid #00ffff; padding: 5px 12px; border-radius: 5px; text-align: center; }
        .pilot-info-label { font-size: 8px; color: #00ffff; letter-spacing: 1px; }
        .pilot-info-value { font-size: 12px; color: #fff; }
        .pilot-info-panel.ship-name-panel { border-color: #ffd700; }
        .pilot-info-panel.ship-name-panel .pilot-info-label { color: #ffd700; }
        .pilot-info-panel.ship-name-panel .pilot-info-value { color: #ffd700; }
        .pilot-info-panel.ability-btn {
            cursor: pointer; pointer-events: auto; border-color: #ff6600;
            display: flex; align-items: center; gap: 6px; transition: all 0.3s;
        }
        .pilot-info-panel.ability-btn:hover { background: rgba(255,102,0,0.3); transform: scale(1.05); }
        .pilot-info-panel.ability-btn.on-cooldown { opacity: 0.5; cursor: not-allowed; }
        .pilot-info-panel.ability-btn #ability-icon { font-size: 14px; }
        .pilot-info-panel.ability-btn #ability-name { font-size: 10px; color: #ff6600; }
        .pilot-info-panel.ability-btn #ability-cooldown { font-size: 10px; color: #fff; }
        
        /* 연료보급 버튼 - 제거됨, 도킹 버튼으로 대체 */
        .pilot-info-panel.refuel-btn {
            display: none !important;
        }
        
        /* ★ 화면 중앙 도킹 버튼 */
        #docking-center-btn {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0,100,150,0.9), rgba(0,50,100,0.95));
            border: 3px solid #00ffff;
            color: #00ffff;
            padding: 20px 50px;
            border-radius: 15px;
            font-size: 20px;
            font-family: 'Orbitron', sans-serif;
            cursor: pointer;
            pointer-events: auto;
            display: none;
            z-index: 1500;
            animation: dockingPulse 1.5s infinite;
            box-shadow: 0 0 30px rgba(0,255,255,0.5);
        }
        #docking-center-btn:hover {
            background: linear-gradient(135deg, rgba(0,150,200,0.95), rgba(0,80,130,1));
            transform: translate(-50%, -50%) scale(1.05);
        }
        #docking-center-btn.show { display: block; }
        @keyframes dockingPulse {
            0%, 100% { box-shadow: 0 0 20px rgba(0,255,255,0.5), inset 0 0 10px rgba(0,255,255,0.2); }
            50% { box-shadow: 0 0 40px rgba(0,255,255,0.8), inset 0 0 20px rgba(0,255,255,0.4); }
        }
        
        /* ★ 도킹 완료 후 메뉴 */
        #docking-menu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none;
            flex-direction: column;
            gap: 20px;
            z-index: 1500;
            pointer-events: auto;
        }
        #docking-menu.show { display: flex; }
        .docking-menu-btn {
            background: linear-gradient(135deg, rgba(0,80,60,0.95), rgba(0,40,30,0.98));
            border: 3px solid #00ff88;
            color: #00ff88;
            padding: 25px 60px;
            border-radius: 15px;
            font-size: 18px;
            font-family: 'Orbitron', sans-serif;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 20px rgba(0,255,136,0.4);
        }
        .docking-menu-btn:hover {
            background: linear-gradient(135deg, rgba(0,120,90,0.98), rgba(0,60,45,1));
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(0,255,136,0.6);
        }
        .docking-menu-btn.interior {
            border-color: #ffaa00;
            color: #ffaa00;
            box-shadow: 0 0 20px rgba(255,170,0,0.4);
        }
        .docking-menu-btn.interior:hover {
            box-shadow: 0 0 30px rgba(255,170,0,0.6);
        }
        
        /* ★ 도킹해제 버튼 */
        #undock-btn {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(150,50,0,0.9), rgba(100,30,0,0.95));
            border: 3px solid #ff6600;
            color: #ff6600;
            padding: 20px 50px;
            border-radius: 15px;
            font-size: 20px;
            font-family: 'Orbitron', sans-serif;
            cursor: pointer;
            pointer-events: auto;
            display: none;
            z-index: 1500;
            animation: undockPulse 1.5s infinite;
            box-shadow: 0 0 30px rgba(255,102,0,0.5);
        }
        #undock-btn:hover {
            background: linear-gradient(135deg, rgba(200,70,0,0.95), rgba(130,40,0,1));
            transform: translate(-50%, -50%) scale(1.05);
        }
        #undock-btn.show { display: block; }
        @keyframes undockPulse {
            0%, 100% { box-shadow: 0 0 20px rgba(255,102,0,0.5), inset 0 0 10px rgba(255,102,0,0.2); }
            50% { box-shadow: 0 0 40px rgba(255,102,0,0.8), inset 0 0 20px rgba(255,102,0,0.4); }
        }
        
        /* 연료 보급 진행 오버레이 */
        #refuel-overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,20,40,0.95);
            border: 3px solid #00ff00;
            border-radius: 20px;
            padding: 30px 50px;
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            z-index: 1600;
        }
        #refuel-overlay.show { display: flex; }
        #refuel-overlay .refuel-title {
            color: #00ff00;
            font-size: 20px;
            font-family: 'Orbitron', sans-serif;
        }
        #refuel-overlay .refuel-bar-container {
            width: 300px;
            height: 30px;
            background: rgba(0,50,0,0.8);
            border: 2px solid #00ff00;
            border-radius: 15px;
            overflow: hidden;
        }
        #refuel-overlay .refuel-bar-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #00aa00, #00ff00);
            transition: width 0.1s;
        }
        #refuel-overlay .refuel-amount {
            color: #fff;
            font-size: 24px;
            font-family: 'Orbitron', sans-serif;
        }
        #refuel-overlay .refuel-cost {
            color: #ffcc00;
            font-size: 14px;
        }
        
        /* ★★★ 수리 오버레이 ★★★ */
        #repair-overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(40,20,0,0.95);
            border: 3px solid #ff8800;
            border-radius: 20px;
            padding: 30px 50px;
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            z-index: 1600;
        }
        #repair-overlay.show { display: flex; }
        #repair-overlay .repair-title {
            color: #ff8800;
            font-size: 20px;
            font-family: 'Orbitron', sans-serif;
        }
        #repair-overlay .repair-bar-container {
            width: 300px;
            height: 30px;
            background: rgba(50,30,0,0.8);
            border: 2px solid #ff8800;
            border-radius: 15px;
            overflow: hidden;
        }
        #repair-overlay .repair-bar-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #aa5500, #ff8800);
            transition: width 0.1s;
        }
        #repair-overlay .repair-amount {
            color: #fff;
            font-size: 24px;
            font-family: 'Orbitron', sans-serif;
        }
        #repair-overlay .repair-cost {
            color: #ffcc00;
            font-size: 14px;
        }
        
        /* ★★★ 내구도 게이지 (연료 옆) ★★★ */
        #hull-gauge {
            position: absolute;
            bottom: 150px;
            right: 85px;
            width: 35px;
            height: 140px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #ff6600;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px 4px;
            gap: 5px;
            z-index: 100;
        }
        #hull-gauge .gauge-label {
            font-size: 10px;
            color: #ff6600;
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 1px;
        }
        #hull-gauge .gauge-bar {
            width: 18px;
            height: 100px;
            background: rgba(100,50,0,0.5);
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }
        #hull-gauge .gauge-fill {
            position: absolute;
            bottom: 0;
            width: 100%;
            background: linear-gradient(180deg, #ff8800, #ff4400);
            transition: height 0.3s, background 0.3s;
            border-radius: 2px;
        }
        #hull-gauge .gauge-val {
            font-size: 10px;
            color: #fff;
            font-family: 'Orbitron', sans-serif;
        }
        #hull-gauge.critical .gauge-fill {
            background: linear-gradient(180deg, #ff0000, #aa0000);
            animation: hullCritical 0.5s infinite;
        }
        @keyframes hullCritical {
            50% { opacity: 0.6; }
        }
        
        /* ★★★ 보호막 충돌 경고 ★★★ */
        #shield-impact-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: radial-gradient(ellipse at center, rgba(0,200,255,0) 40%, rgba(0,200,255,0.3) 100%);
            z-index: 1200;
            opacity: 0;
            transition: opacity 0.1s;
        }
        #shield-impact-overlay.active {
            opacity: 1;
            animation: shieldFlash 0.5s ease-out;
        }
        @keyframes shieldFlash {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }
        
        /* ★★★ 내구도 경고 ★★★ */
        .pilot-warning.hull-critical {
            background: rgba(255,100,0,0.3);
            border-color: #ff6600;
            color: #ff6600;
        }
        
        /* 수리 버튼 스타일 */
        .docking-menu-btn.repair {
            border-color: #ff8800;
            color: #ff8800;
            box-shadow: 0 0 20px rgba(255,136,0,0.4);
        }
        .docking-menu-btn.repair:hover {
            box-shadow: 0 0 30px rgba(255,136,0,0.6);
        }
        
        #pilot-target-select { position: absolute; top: 65px; left: 55%; transform: translateX(-50%); pointer-events: auto; }
        #pilot-target-select select { background: rgba(0,30,50,0.95); border: 1px solid #ff6600; color: #ff6600; padding: 6px 12px; border-radius: 15px; font-size: 10px; font-family: 'Orbitron', sans-serif; }
        
        /* ★★★ 3D 좌표 표시 패널 ★★★ */
        #pilot-coords-panel { 
            position: absolute; 
            top: 60px; 
            left: 50%; 
            transform: translateX(-50%); 
            background: linear-gradient(135deg, rgba(0,40,80,0.9) 0%, rgba(0,20,50,0.95) 100%); 
            border: 2px solid #00aaff; 
            padding: 8px 20px; 
            border-radius: 10px; 
            text-align: center;
            font-family: 'Orbitron', monospace;
            box-shadow: 0 0 15px rgba(0,170,255,0.3);
            cursor: pointer;
            transition: all 0.2s;
            z-index: 100;
        }
        #pilot-coords-panel:hover { 
            background: linear-gradient(135deg, rgba(0,60,100,0.95) 0%, rgba(0,40,70,0.95) 100%); 
            box-shadow: 0 0 25px rgba(0,170,255,0.5);
        }
        #pilot-coords-panel:active { transform: translateX(-50%) scale(0.95); }
        #pilot-coords-panel .coords-label { font-size: 9px; color: #00aaff; margin-bottom: 2px; }
        #pilot-coords-panel .coords-value { font-size: 12px; color: #fff; letter-spacing: 1px; }
        #pilot-coords-panel.copied { border-color: #00ff88; box-shadow: 0 0 20px rgba(0,255,136,0.5); }
        #pilot-coords-panel.copied .coords-label { color: #00ff88; }
        
        #pilot-eta-box { position: absolute; top: 110px; left: 55%; transform: translateX(-50%); background: rgba(0,80,60,0.9); border: 2px solid #00ff88; padding: 8px 20px; border-radius: 10px; text-align: center; display: none; }
        #pilot-eta-box.active { display: block; }
        #pilot-eta-box .eta-label { font-size: 9px; color: #00ff88; }
        #pilot-eta-box .eta-time { font-size: 22px; color: #fff; }
        #pilot-eta-box .eta-target { font-size: 10px; color: #00ff88; }
        
        #pilot-warning-panel { position: absolute; top: 150px; left: 55%; transform: translateX(-50%); display: flex; flex-direction: column; gap: 5px; align-items: center; }
        .pilot-warning { background: rgba(255,0,0,0.3); border: 2px solid #f00; padding: 8px 20px; border-radius: 5px; color: #f00; font-size: 12px; animation: blink 0.5s infinite; display: none; }
        .pilot-warning.active { display: block; }
        @keyframes blink { 50% { opacity: 0.5; } }
        .pilot-warning.caution { background: rgba(255,150,0,0.3); border-color: #f90; color: #f90; }
        .pilot-warning.decel { background: rgba(255,100,0,0.4); border: 3px solid #ff6600; color: #ffcc00; font-size: 14px; padding: 10px 25px; animation: decelBlink 0.8s infinite; box-shadow: 0 0 20px rgba(255,100,0,0.5); }
        @keyframes decelBlink { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        .pilot-warning.gravity { 
            background: linear-gradient(135deg, rgba(255, 0, 0, 0.6) 0%, rgba(180, 0, 0, 0.5) 100%);
            border: 2px solid #ff0000;
            color: #fff;
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
            padding: 15px 35px;
            animation: gravityPulse 0.3s infinite;
            box-shadow: var(--sf-glow-red), inset 0 0 30px rgba(255, 0, 0, 0.2);
            clip-path: polygon(15px 0, 100% 0, 100% calc(100% - 15px), calc(100% - 15px) 100%, 0 100%, 0 15px);
        }
        @keyframes gravityPulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
        
        #pilot-left { position: absolute; left: 10px; left: calc(10px + env(safe-area-inset-left)); top: 50%; transform: translateY(-50%); display: flex; flex-direction: column; gap: 10px; }
        .pilot-gauge { 
            width: 90px;
            background: linear-gradient(135deg, rgba(10, 15, 25, 0.95) 0%, rgba(15, 20, 30, 0.9) 100%);
            border: 1px solid rgba(0, 255, 255, 0.4);
            border-radius: 0;
            clip-path: polygon(8px 0, 100% 0, 100% calc(100% - 8px), calc(100% - 8px) 100%, 0 100%, 0 8px);
            padding: 10px;
            text-align: center;
            position: relative;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5), inset 0 0 20px rgba(0, 255, 255, 0.05);
        }
        .pilot-gauge::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--sf-cyan), transparent);
        }
        .pilot-gauge-title { 
            font-family: 'Orbitron', sans-serif;
            font-size: 8px;
            font-weight: 600;
            color: var(--sf-cyan);
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px var(--sf-cyan-glow);
        }
        .pilot-gauge-value { 
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            font-weight: 700;
            color: var(--sf-green);
            text-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
        }
        .pilot-gauge-unit { font-size: 8px; color: var(--sf-text-dim); font-family: 'Orbitron', sans-serif; }
        .pilot-gauge-bar { 
            width: 100%;
            height: 6px;
            background: rgba(0, 255, 255, 0.1);
            border-radius: 3px;
            margin-top: 6px;
            overflow: hidden;
            border: 1px solid rgba(0, 255, 255, 0.2);
        }
        .pilot-gauge-fill { height: 100%; border-radius: 2px; transition: width 0.3s; }
        .pilot-gauge-fill.speed { background: linear-gradient(90deg, var(--sf-green), var(--sf-yellow), var(--sf-red)); }
        
        #pilot-right { position: absolute; right: 10px; right: calc(10px + env(safe-area-inset-right)); top: 50%; transform: translateY(-50%); display: flex; flex-direction: column; gap: 10px; align-items: flex-end; }
        #pilot-radar { 
            width: 100px;
            height: 100px;
            background: linear-gradient(135deg, rgba(0, 30, 50, 0.95) 0%, rgba(0, 20, 40, 0.9) 100%);
            border: 2px solid var(--sf-cyan);
            border-radius: 50%;
            position: relative;
            box-shadow: var(--sf-glow-cyan), inset 0 0 30px rgba(0, 255, 255, 0.1);
        }
        #pilot-radar::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background: var(--sf-cyan);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px var(--sf-cyan);
        }
        #pilot-radar-sweep { 
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50%;
            height: 2px;
            background: linear-gradient(90deg, rgba(0, 255, 255, 0.9), transparent);
            transform-origin: left center;
            animation: sweep 2s linear infinite;
            box-shadow: 0 0 10px var(--sf-cyan);
        }
        @keyframes sweep { to { transform: rotate(360deg); } }
        .radar-ring { position: absolute; top: 50%; left: 50%; border: 1px solid rgba(0, 255, 255, 0.15); border-radius: 50%; transform: translate(-50%,-50%); }
        .radar-blip { position: absolute; border-radius: 50%; transform: translate(-50%,-50%); box-shadow: 0 0 5px currentColor; }
        #pilot-radar-ship { position: absolute; top: 50%; left: 50%; width: 6px; height: 6px; background: var(--sf-green); border-radius: 50%; transform: translate(-50%,-50%); box-shadow: 0 0 10px var(--sf-green); }
        
        #pilot-target-info { 
            background: linear-gradient(135deg, rgba(50, 30, 0, 0.9) 0%, rgba(40, 25, 0, 0.85) 100%);
            border: 1px solid var(--sf-orange);
            padding: 10px;
            border-radius: 0;
            clip-path: polygon(6px 0, 100% 0, 100% calc(100% - 6px), calc(100% - 6px) 100%, 0 100%, 0 6px);
            min-width: 100px;
            font-size: 10px;
            box-shadow: 0 0 15px rgba(255, 149, 0, 0.2);
        }
        .target-label { font-family: 'Orbitron', sans-serif; font-size: 7px; color: var(--sf-orange); text-transform: uppercase; letter-spacing: 1px; }
        .target-name { font-size: 11px; color: var(--sf-text-bright); margin: 4px 0; font-weight: 600; }
        .target-dist, .target-eta { font-size: 9px; color: var(--sf-orange); }
        
        #pilot-autopilot-info { 
            background: linear-gradient(135deg, rgba(0, 60, 40, 0.9) 0%, rgba(0, 50, 35, 0.85) 100%);
            border: 1px solid var(--sf-green);
            padding: 10px;
            border-radius: 0;
            clip-path: polygon(6px 0, 100% 0, 100% calc(100% - 6px), calc(100% - 6px) 100%, 0 100%, 0 6px);
            min-width: 100px;
            font-size: 10px;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.2);
        }
        #pilot-autopilot-info.inactive { 
            background: linear-gradient(135deg, rgba(40, 40, 40, 0.9) 0%, rgba(30, 30, 30, 0.85) 100%);
            border-color: var(--sf-text-dim);
            box-shadow: none;
        }
        .ap-label { font-family: 'Orbitron', sans-serif; font-size: 7px; color: var(--sf-green); text-transform: uppercase; letter-spacing: 1px; }
        #pilot-autopilot-info.inactive .ap-label { color: var(--sf-text-dim); }
        .ap-status { font-size: 11px; color: var(--sf-text-bright); margin: 4px 0; font-weight: 600; }
        .ap-phase { font-size: 9px; color: var(--sf-green); }
        
        /* 조종실 라디오 패널 */
        #cockpit-radio {
            position: fixed;
            top: 50px;
            right: 60px;
            background: linear-gradient(135deg, rgba(10, 15, 25, 0.98) 0%, rgba(15, 20, 30, 0.95) 100%);
            border: 1px solid var(--sf-cyan);
            border-radius: 0;
            clip-path: polygon(12px 0, 100% 0, 100% calc(100% - 12px), calc(100% - 12px) 100%, 0 100%, 0 12px);
            padding: 15px;
            z-index: 1003;
            display: none;
            min-width: 220px;
            font-family: 'Orbitron', sans-serif;
            box-shadow: var(--sf-glow-cyan), 0 0 40px rgba(0, 0, 0, 0.5);
        }
        body.pilot-mode #cockpit-radio { display: block; }
        #cockpit-radio.collapsed {
            width: 40px;
            min-width: 40px;
            height: 40px;
            padding: 0;
            border-radius: 50%;
            overflow: hidden;
            clip-path: none;
        }
        #cockpit-radio.collapsed .radio-content { display: none; }
        #cockpit-radio.collapsed .radio-toggle { 
            width: 100%; 
            height: 100%; 
            border-radius: 50%;
            font-size: 1.2em;
        }
        .radio-toggle {
            background: rgba(0,100,150,0.5);
            border: 1px solid #0ff;
            color: #0ff;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.85em;
            width: 100%;
        }
        .radio-toggle:hover { background: rgba(0,150,200,0.7); }
        .radio-toggle.playing { 
            background: rgba(0,200,100,0.5); 
            border-color: #0f0;
            color: #0f0;
            animation: radioPulse 1s infinite;
        }
        @keyframes radioPulse {
            0%, 100% { box-shadow: 0 0 5px rgba(0,255,100,0.5); }
            50% { box-shadow: 0 0 15px rgba(0,255,100,0.8); }
        }
        .radio-content { margin-top: 10px; }
        .radio-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        .radio-close-btn {
            background: rgba(255,50,50,0.3);
            border: 1px solid rgba(255,100,100,0.5);
            color: #f88;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        .radio-close-btn:hover {
            background: rgba(255,50,50,0.6);
            color: #fff;
        }
        .radio-title {
            color: #0ff;
            font-size: 0.75em;
            text-align: center;
        }
        .radio-station {
            background: rgba(0,50,80,0.5);
            border: 1px solid #444;
            color: #aaa;
            padding: 8px;
            margin: 4px 0;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.7em;
            transition: all 0.2s;
        }
        .radio-station:hover {
            border-color: #0ff;
            color: #fff;
        }
        .radio-station.active {
            border-color: #0f0;
            color: #0f0;
            background: rgba(0,100,50,0.5);
        }
        .radio-station-name { font-weight: bold; }
        .radio-station-desc { font-size: 0.85em; opacity: 0.7; margin-top: 2px; }
        .radio-volume {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
            font-size: 0.7em;
            color: #888;
        }
        .radio-volume input { flex: 1; cursor: pointer; }
        .radio-now-playing {
            margin-top: 8px;
            padding: 6px;
            background: rgba(0,0,0,0.3);
            border-radius: 5px;
            font-size: 0.65em;
            color: #0ff;
            text-align: center;
            min-height: 20px;
        }
        
        /* AI 부조종사 패널 */
        /* ========== 통합 채팅 패널 ========== */
        #unified-chat-panel {
            position: fixed;
            left: 5px;
            left: calc(5px + env(safe-area-inset-left));
            top: 5px;
            width: 280px;
            max-width: 40vw;
            background: rgba(10, 20, 40, 0.95);
            border: 1px solid #0ff;
            border-radius: 10px;
            padding: 8px;
            pointer-events: auto;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
            font-size: 12px;
            z-index: 500;
            transition: background 0.5s, border-color 0.5s, box-shadow 0.5s;
            display: none;  /* 기본 숨김 */
        }
        #unified-chat-panel.transparent {
            background: transparent;
            border-color: transparent;
            box-shadow: none;
        }
        #unified-chat-panel.transparent .chat-tab-bar,
        #unified-chat-panel.transparent .chat-content-box {
            background: transparent;
        }
        #unified-chat-panel.transparent .chat-tab {
            background: transparent;
            border-color: transparent;
        }
        #unified-chat-panel.transparent #chat-toggle-btn {
            background: transparent;
            border-color: transparent;
        }
        
        .chat-tab-bar {
            display: flex;
            gap: 5px;
            margin-bottom: 6px;
            align-items: center;
        }
        .chat-tab {
            flex: 1;
            padding: 6px 8px;
            background: rgba(0, 50, 80, 0.5);
            border: 1px solid #345;
            border-radius: 5px;
            color: #aaa;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }
        .chat-tab.active {
            background: rgba(0, 150, 200, 0.4);
            border-color: #0ff;
            color: #0ff;
        }
        .chat-tab:hover {
            border-color: #0ff;
        }
        #chat-toggle-btn {
            width: 26px;
            height: 26px;
            background: transparent;
            border: 1px solid #0ff;
            border-radius: 5px;
            color: #0ff;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }
        #chat-toggle-btn:hover {
            background: rgba(0, 255, 255, 0.2);
        }
        
        .chat-content-box {
            min-height: 50px;
            max-height: 120px;
            overflow-y: auto;
            font-size: 12px;
            color: #e0e0e0;
            line-height: 1.5;
            padding: 6px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            margin-bottom: 6px;
        }
        .chat-content-box::-webkit-scrollbar { width: 3px; }
        .chat-content-box::-webkit-scrollbar-thumb { background: #0ff; border-radius: 3px; }
        
        .chat-input-area {
            display: flex;
            gap: 5px;
        }
        .chat-input-area input {
            flex: 1;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #345;
            border-radius: 5px;
            padding: 6px 8px;
            color: #fff;
            font-size: 11px;
        }
        .chat-input-area input:focus {
            outline: none;
            border-color: #0ff;
        }
        .chat-input-area button {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #0088aa, #00aacc);
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 14px;
        }
        
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        
        /* 접힌 상태 */
        #unified-chat-panel.collapsed .chat-content,
        #unified-chat-panel.collapsed .chat-content-box,
        #unified-chat-panel.collapsed .chat-input-area {
            display: none;
        }
        #unified-chat-panel.collapsed {
            width: auto;
            padding: 6px 8px;
        }
        #unified-chat-panel.collapsed .chat-tab-bar {
            margin-bottom: 0;
        }
        #unified-chat-panel.collapsed #chat-toggle-btn {
            transform: rotate(180deg);
        }
        
        /* 멀티 채팅 메시지 스타일 */
        .mp-msg { margin: 3px 0; word-break: break-word; }
        .mp-msg .nick { color: #ff0; font-weight: bold; margin-right: 5px; }
        .mp-msg .time { color: #888; font-size: 9px; margin-right: 5px; }
        .mp-msg .text { color: #fff; }
        .mp-msg.system { color: #0ff; font-style: italic; }
        
        /* ARIA 메시지 스타일 */
        .aria-msg { margin: 3px 0; }
        .aria-msg .aria-label { color: #9b59b6; font-weight: bold; }
        .aria-msg .aria-text { color: #e0e0e0; white-space: pre-wrap; }
        
        /* 기존 패널 숨김 */
        #ai-copilot-panel { display: none !important; }
        #multiplayer-ui { display: none !important; }
        
        /* AI 로딩 표시 */
        #ai-copilot-panel.loading #ai-avatar {
            animation: ai-loading 1s linear infinite;
        }
        @keyframes ai-loading {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* 미션 알림 */
        #ai-mission-alert {
            display: none;
            position: absolute;
            top: -8px;
            right: -8px;
            width: 20px;
            height: 20px;
            background: #e74c3c;
            border-radius: 50%;
            font-size: 10px;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: bounce 0.5s infinite;
        }
        @keyframes bounce {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }
        
        /* AI 교신 모달 */
        #ai-comm-modal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 20, 40, 0.98);
            border: 2px solid #9b59b6;
            border-radius: 15px;
            padding: 20px;
            min-width: 300px;
            max-width: 90vw;
            max-height: 85vh;
            overflow-y: auto;
            z-index: 300;
            pointer-events: auto;
        }
        #ai-comm-modal.open { display: block; }
        #ai-comm-portrait {
            font-size: 50px;
            text-align: center;
            margin-bottom: 10px;
        }
        #ai-comm-name {
            text-align: center;
            font-size: 14px;
            color: #9b59b6;
            margin-bottom: 10px;
        }
        #ai-comm-message {
            font-size: 12px;
            color: #e0e0e0;
            line-height: 1.5;
            margin-bottom: 15px;
            min-height: 60px;
        }
        #ai-comm-choices {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .ai-comm-choice {
            padding: 10px 15px;
            background: rgba(155, 89, 182, 0.2);
            border: 1px solid #9b59b6;
            border-radius: 8px;
            color: #fff;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
            font-family: 'Orbitron', sans-serif;
        }
        .ai-comm-choice:hover {
            background: rgba(155, 89, 182, 0.4);
            transform: translateX(5px);
        }
        .ai-comm-choice.danger { border-color: #e74c3c; color: #e74c3c; }
        .ai-comm-choice.success { border-color: #27ae60; color: #27ae60; }
        
        #crosshair { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); width: 60px; height: 60px; pointer-events: none; }
        .ch-line { position: absolute; background: rgba(0,255,255,0.4); }
        .ch-line.h { top: 50%; width: 100%; height: 1px; }
        .ch-line.v { left: 50%; height: 100%; width: 1px; }
        .ch-dot { position: absolute; top: 50%; left: 50%; width: 4px; height: 4px; background: #00ffff; border-radius: 50%; transform: translate(-50%,-50%); }
        
        #pilot-bottom { position: absolute; bottom: 10px; bottom: calc(10px + env(safe-area-inset-bottom)); left: 0; right: 0; display: flex; justify-content: space-between; align-items: flex-end; padding: 0 12px; padding-left: calc(12px + env(safe-area-inset-left)); padding-right: calc(12px + env(safe-area-inset-right)); pointer-events: none; }
        #pilot-left-console { display: flex; gap: 8px; align-items: flex-end; pointer-events: auto; }
        #pilot-center-console { display: flex; flex-direction: column; align-items: center; gap: 8px; pointer-events: auto; }
        #pilot-right-console { display: flex; flex-direction: column; gap: 6px; align-items: center; pointer-events: auto; }
        /* 드래그 시 독립적으로 움직이도록 */
        #pilot-left-console.dragging,
        #pilot-center-console.dragging,
        #pilot-right-console.dragging,
        #mobile-gauge-container.dragging,
        #mobile-speed-container.dragging,
        #mobile-btns-container.dragging,
        #mobile-arrows-container.dragging {
            position: fixed !important;
            z-index: 9999 !important;
        }
        .vertical-gauge { display: flex; flex-direction: column; align-items: center; gap: 2px; }
        .vg-bar { width: 25px; height: 80px; background: rgba(0,30,50,0.9); border: 1px solid #00ffff; border-radius: 5px; padding: 2px; }
        .vg-bg { width: 100%; height: 100%; background: #0a0a0a; border-radius: 3px; position: relative; overflow: hidden; }
        .vg-fill { position: absolute; width: 100%; border-radius: 3px; transition: height 0.2s; }
        .vg-fill.throttle { background: linear-gradient(0deg, #0066ff, #00ffff); bottom: 0; }
        .vg-fill.fuel { background: linear-gradient(0deg, #ff3300, #ffff00, #00ff00); bottom: 0; }
        
        /* THR 게이지 - 중앙 0 */
        .thr-gauge { position: relative; }
        .thr-label-top { font-size: 6px; color: #00ff88; margin-bottom: 2px; }
        .thr-label-bottom { font-size: 6px; color: #ff6600; margin-top: 2px; }
        .thr-bar { height: 100px; }
        .thr-center-line { position: absolute; top: 50%; left: 0; width: 100%; height: 2px; background: #fff; z-index: 5; }
        .vg-fill.throttle-up { bottom: 50%; background: linear-gradient(0deg, #00ff88, #00ffcc); }
        .vg-fill.throttle-down { top: 50%; background: linear-gradient(180deg, #ff6600, #ff3300); }
        .vg-label { font-size: 7px; color: var(--sf-cyan); font-family: 'Orbitron', sans-serif; text-transform: uppercase; letter-spacing: 1px; }
        .vg-value { font-size: 9px; color: var(--sf-text-bright); font-weight: 600; }
        
        #pilot-main-speed .speed-value { 
            font-family: 'Orbitron', sans-serif;
            font-size: 32px; 
            font-weight: 700;
            color: var(--sf-cyan); 
            text-shadow: var(--sf-glow-cyan);
            letter-spacing: 2px;
        }
        #pilot-main-speed .speed-unit { font-size: 10px; color: var(--sf-text-dim); font-family: 'Orbitron', sans-serif; text-transform: uppercase; }
        #pilot-btn-row { display: flex; gap: 8px; flex-wrap: wrap; justify-content: center; }
        
        .pilot-console-btn { 
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.1) 0%, rgba(0, 255, 255, 0.02) 100%);
            border: 1px solid var(--sf-cyan);
            color: var(--sf-cyan);
            padding: 10px 14px;
            border-radius: 0;
            clip-path: polygon(8px 0, 100% 0, 100% calc(100% - 8px), calc(100% - 8px) 100%, 0 100%, 0 8px);
            font-size: 10px;
            font-weight: 600;
            cursor: pointer;
            font-family: 'Orbitron', sans-serif;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            text-shadow: 0 0 10px var(--sf-cyan-glow);
            position: relative;
            overflow: hidden;
        }
        .pilot-console-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }
        .pilot-console-btn:hover::before {
            left: 100%;
        }
        .pilot-console-btn:hover {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.25) 0%, rgba(0, 255, 255, 0.1) 100%);
            box-shadow: 0 0 20px var(--sf-cyan-glow), inset 0 0 15px rgba(0, 255, 255, 0.1);
        }
        .pilot-console-btn:active { 
            background: rgba(0, 255, 255, 0.3);
            transform: scale(0.98);
        }
        .pilot-console-btn.autopilot { 
            border-color: var(--sf-green);
            color: var(--sf-green);
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.1) 0%, rgba(0, 255, 136, 0.02) 100%);
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.4);
        }
        .pilot-console-btn.autopilot.engaged { 
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.3) 0%, rgba(0, 255, 136, 0.15) 100%);
            box-shadow: var(--sf-glow-green);
            animation: sf-glow-pulse 2s infinite;
        }
        .pilot-console-btn.interior { 
            border-color: var(--sf-orange);
            color: var(--sf-orange);
            background: linear-gradient(135deg, rgba(255, 149, 0, 0.1) 0%, rgba(255, 149, 0, 0.02) 100%);
        }
        .pilot-console-btn.interior.disabled { 
            border-color: var(--sf-text-dim);
            color: var(--sf-text-dim);
            opacity: 0.4;
            cursor: not-allowed;
        }
        .pilot-console-btn.danger { 
            border-color: var(--sf-red);
            color: var(--sf-red);
            background: linear-gradient(135deg, rgba(255, 71, 87, 0.1) 0%, rgba(255, 71, 87, 0.02) 100%);
        }
        .pilot-console-btn.emergency { 
            border-color: #ff0000;
            color: #fff;
            background: linear-gradient(135deg, rgba(255, 0, 0, 0.5) 0%, rgba(200, 0, 0, 0.4) 100%);
            animation: emergencyPulse 0.5s infinite;
            display: none;
            box-shadow: var(--sf-glow-red);
        }
        .pilot-console-btn.emergency.active { display: block; }
        .pilot-console-btn.orbit-entry { 
            border-color: var(--sf-green);
            color: var(--sf-green);
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.2) 0%, rgba(0, 255, 136, 0.05) 100%);
        }
        .pilot-console-btn.orbit-entry:hover { 
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.4) 0%, rgba(0, 255, 136, 0.15) 100%);
        }
        
        /* 긴급 역추진 버튼 */
        .pilot-ctrl-btn.emergency-brake {
            background: linear-gradient(145deg, #cc0000, #990000);
            border: 2px solid #ff3333;
            color: white;
            font-size: 10px;
            line-height: 1.1;
            width: 50px;
            height: 50px;
            margin-left: 10px;
            display: none;
            clip-path: polygon(8px 0, 100% 0, 100% calc(100% - 8px), calc(100% - 8px) 100%, 0 100%, 0 8px);
            border-radius: 0;
            box-shadow: var(--sf-glow-red);
        }
        .pilot-ctrl-btn.emergency-brake:active {
            background: #ff0000;
            transform: scale(0.95);
        }
        
        /* 데스크톱 전용 버튼 */
        .desktop-only { display: flex; }
        
        /* 전체화면 버튼 */
        #btn-fullscreen { background: rgba(155, 89, 182, 0.2); border: 1px solid rgba(155, 89, 182, 0.5); color: #9b59b6; }
        #btn-fullscreen:hover { background: #9b59b6; color: #fff; }
        #btn-fullscreen.active { background: #9b59b6; color: #fff; }
        
        /* 언어 선택 */
        #lang-select {
            background: rgba(52, 73, 94, 0.8);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            border-radius: 4px;
            font-size: 9px;
            padding: 4px 6px;
            outline: none;
        }
        #lang-select option {
            background: #2c3e50;
            color: white;
        }
        
        /* 유저 영역 */
        #user-area {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-left: auto;
            margin-right: 60px;  /* 광고버튼 공간 확보 */
            pointer-events: auto;  /* 클릭 가능하게! */
        }
        #user-coins {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            padding: 3px 8px;
            border-radius: 12px;
            font-weight: bold;
            font-size: 10px;
            color: #fff;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        #user-info {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        #user-name {
            color: #3498db;
            font-weight: bold;
            font-size: 10px;
        }
        #btn-login {
            background: linear-gradient(135deg, #3498db, #2980b9);
            border: none;
        }
        #btn-logout {
            background: rgba(231, 76, 60, 0.3);
            border: 1px solid #e74c3c;
            color: #e74c3c;
            font-size: 10px;
            padding: 4px 8px;
        }
        
        /* 로그인 모달 */
        #login-modal {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.8);
            z-index: 3000;
            justify-content: center;
            align-items: center;
            overflow-y: auto;
            padding: 20px 0;
        }
        #login-modal.open { display: flex; }
        #login-content {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border: 2px solid #3498db;
            border-radius: 15px;
            padding: 30px;
            width: 320px;
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
            margin: auto;
        }
        #login-content h2 {
            color: #fff;
            text-align: center;
            margin-bottom: 20px;
        }
        .login-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        .login-tab {
            flex: 1;
            padding: 10px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            color: #888;
            cursor: pointer;
            transition: all 0.3s;
        }
        .login-tab.active {
            background: #3498db;
            border-color: #3498db;
            color: #fff;
        }
        #login-content input {
            width: 100%;
            padding: 12px;
            margin-bottom: 12px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            color: #fff;
            font-size: 14px;
            box-sizing: border-box;
        }
        #login-content input:focus {
            outline: none;
            border-color: #3498db;
        }
        #login-error {
            color: #e74c3c;
            font-size: 12px;
            margin-bottom: 10px;
            text-align: center;
            min-height: 18px;
        }
        .login-submit {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #3498db, #2980b9);
            border: none;
            border-radius: 8px;
            color: #fff;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s;
        }
        .login-submit:hover { transform: scale(1.02); }
        #login-close {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            color: #888;
            font-size: 20px;
            cursor: pointer;
        }
        #login-close:hover { color: #fff; }
        
        /* 아이디/비밀번호 찾기 */
        .login-find-links {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 15px;
            font-size: 12px;
        }
        .login-find-links a {
            color: #888;
            text-decoration: none;
            cursor: pointer;
            transition: color 0.3s;
        }
        .login-find-links a:hover {
            color: #3498db;
            text-decoration: underline;
        }
        #login-success {
            color: #2ecc71;
            font-size: 12px;
            margin-bottom: 10px;
            text-align: center;
            min-height: 18px;
        }
        .find-result {
            background: rgba(46, 204, 113, 0.2);
            border: 1px solid #2ecc71;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            text-align: center;
        }
        .find-result .label {
            color: #888;
            font-size: 11px;
            margin-bottom: 5px;
        }
        .find-result .value {
            color: #2ecc71;
            font-size: 16px;
            font-weight: bold;
        }
        .back-to-login {
            width: 100%;
            padding: 10px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            color: #aaa;
            font-size: 13px;
            cursor: pointer;
            margin-top: 10px;
            transition: all 0.3s;
        }
        .back-to-login:hover {
            background: rgba(255,255,255,0.2);
            color: #fff;
        }
        
        /* 함선 처분 모달 */
        #sell-ship-modal {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9);
            z-index: 3500;
            justify-content: center;
            align-items: center;
            overflow-y: auto;
            padding: 20px 0;
        }
        #sell-ship-modal.open { display: flex; }
        #sell-ship-content {
            background: linear-gradient(135deg, #2c1810, #1a1a2e);
            border: 2px solid #e74c3c;
            border-radius: 15px;
            padding: 30px;
            width: 350px;
            max-width: 90vw;
            max-height: 85vh;
            overflow-y: auto;
            margin: auto;
            text-align: center;
        }
        #sell-ship-content h2 {
            color: #e74c3c;
            margin-bottom: 15px;
        }
        #sell-ship-content p {
            color: #ccc;
            margin-bottom: 20px;
            line-height: 1.5;
        }
        #sell-ship-info {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }
        .sell-info-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            color: #fff;
        }
        .sell-info-row:last-child { border-bottom: none; }
        #sell-price-value {
            color: #f39c12;
            font-weight: bold;
        }
        #sell-ship-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }
        .ship-modal-btn.sell {
            background: linear-gradient(180deg, #e74c3c, #c0392b);
            color: #fff;
        }
        .ship-modal-btn.sell:hover {
            background: linear-gradient(180deg, #ff6b6b, #e74c3c);
            transform: scale(1.05);
        }
        @keyframes emergencyPulse { 0%, 100% { background: rgba(255,0,0,0.5); } 50% { background: rgba(255,0,0,0.8); } }
        
        .pilot-ctrl-btn { width: 45px; height: 45px; border-radius: 50%; background: rgba(0,40,60,0.9); border: 2px solid #00ffff; color: #00ffff; font-size: 16px; cursor: pointer; display: flex; align-items: center; justify-content: center; }
        .pilot-ctrl-btn:active { background: rgba(0,255,255,0.3); }
        .pilot-ctrl-btn.brake { border-color: #f00; color: #f00; font-size: 8px; }
        
        #virtual-joystick { position: absolute; display: none; pointer-events: none; z-index: 300; }
        #joystick-base { width: 100px; height: 100px; background: rgba(0,255,255,0.08); border: 2px solid rgba(0,255,255,0.4); border-radius: 50%; }
        #joystick-knob { position: absolute; top: 50%; left: 50%; width: 40px; height: 40px; background: radial-gradient(circle, rgba(0,255,255,0.7), rgba(0,255,255,0.2)); border-radius: 50%; transform: translate(-50%,-50%); }
        
        /* 모바일용 동적 조이스틱 (터치 시 생성) */
        #pilot-joystick {
            position: absolute;
            width: 80px; height: 150px; 
            pointer-events: none; z-index: 300;
            display: none;
        }
        #pilot-joystick.visible { display: block; }
        @media (min-width: 1024px) { #pilot-joystick { display: none !important; } }
        #pilot-joystick-base {
            width: 100%; height: 100%; background: rgba(0,255,255,0.1);
            border: 3px solid rgba(0,255,255,0.5); border-radius: 40px;
            position: relative;
            display: flex; flex-direction: column; justify-content: space-between;
            align-items: center; padding: 8px 0;
        }
        #pilot-joystick-base::before {
            content: '▲ Accel';
            font-size: 9px; color: #0f0; font-family: 'Orbitron', sans-serif;
        }
        #pilot-joystick-base::after {
            content: '▼ Reverse';
            font-size: 9px; color: #f60; font-family: 'Orbitron', sans-serif;
        }
        #pilot-joystick-knob {
            position: absolute; top: 50%; left: 50%; width: 45px; height: 45px;
            background: radial-gradient(circle, rgba(0,255,255,0.8), rgba(0,255,255,0.3));
            border-radius: 50%; transform: translate(-50%,-50%);
            box-shadow: 0 0 15px rgba(0,255,255,0.5);
        }
        #pilot-joystick-label {
            position: absolute; top: -20px; left: 50%; transform: translateX(-50%);
            font-size: 10px; color: #00ffff; font-family: 'Orbitron', sans-serif;
            text-shadow: 0 0 5px #00ffff;
        }
        
        /* 터치 영역 (화면 하단 왼쪽) */
        #touch-area-left {
            position: absolute;
            left: 0; bottom: 0;
            width: 50%; height: 45%;
            pointer-events: auto;
            z-index: 250;
            display: none;
        }
        #cockpit-hud.active #touch-area-left { display: block; }
        @media (min-width: 1024px) { #touch-area-left { display: none !important; } }
        
        /* 모바일에서 AI 패널이 터치 영역 위에 오도록 */
        #ai-copilot-panel { z-index: 260; }

        /* 선내 모드 */
        #interior-hud { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 260; }
        #interior-hud.active { display: block; }
        #interior-top { position: absolute; top: 12px; left: 50%; transform: translateX(-50%); background: rgba(0,40,60,0.9); border: 1px solid #00ffff; padding: 6px 20px; border-radius: 20px; display: flex; gap: 15px; align-items: center; }
        #interior-location { font-size: 12px; color: #00ffff; font-family: 'Orbitron', sans-serif; }
        #interior-eta { font-size: 11px; color: #00ff88; font-family: 'Orbitron', sans-serif; }
        #interior-bottom { position: absolute; bottom: 15px; bottom: calc(15px + env(safe-area-inset-bottom)); left: 50%; transform: translateX(-50%); display: flex; gap: 10px; pointer-events: auto; }
        #move-joystick { position: absolute; bottom: 70px; bottom: calc(70px + env(safe-area-inset-bottom)); left: 15px; left: calc(15px + env(safe-area-inset-left)); width: 110px; height: 110px; pointer-events: auto; z-index: 270; display: none; }
        #move-joystick.active { display: block; }
        #move-joystick-base { width: 100%; height: 100%; background: rgba(255,255,255,0.1); border: 3px solid rgba(255,255,255,0.4); border-radius: 50%; }
        #move-joystick-knob { position: absolute; top: 50%; left: 50%; width: 45px; height: 45px; background: radial-gradient(circle, rgba(255,255,255,0.7), rgba(255,255,255,0.3)); border-radius: 50%; transform: translate(-50%,-50%); }
        #door-prompt { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,60,100,0.95); border: 2px solid #00ffff; padding: 20px 35px; border-radius: 15px; text-align: center; pointer-events: auto; z-index: 280; }
        #door-prompt.active { display: block; }
        #door-prompt p { color: #aaa; font-size: 11px; margin-bottom: 12px; }
        #door-prompt .door-name { color: #00ffff; font-size: 16px; margin-bottom: 8px; font-family: 'Orbitron', sans-serif; }
        #btn-open-door { background: linear-gradient(180deg, #00ffff, #0088aa); border: none; color: #000; padding: 12px 35px; border-radius: 25px; font-size: 14px; font-weight: bold; cursor: pointer; }
        #interior-crosshair { position: absolute; top: 50%; left: 50%; width: 6px; height: 6px; background: rgba(255,255,255,0.6); border-radius: 50%; transform: translate(-50%,-50%); pointer-events: none; }
        #object-name { display: none; position: absolute; top: 55%; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); border: 1px solid #00ffff; padding: 6px 15px; border-radius: 8px; color: #00ffff; font-size: 12px; font-family: 'Orbitron', sans-serif; pointer-events: none; z-index: 275; }
        #object-name.active { display: block; }
        #interaction-hint { display: none; position: absolute; top: 62%; left: 50%; transform: translateX(-50%); color: #aaa; font-size: 10px; pointer-events: none; z-index: 275; }
        #interaction-hint.active { display: block; }

        /* 전망대 모드 */
        #observatory-hud { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 260; }
        #observatory-hud.active { display: block; }
        #obs-top { position: absolute; top: 12px; left: 50%; transform: translateX(-50%); background: rgba(0,40,60,0.8); border: 1px solid #00ffff; padding: 6px 20px; border-radius: 20px; display: flex; gap: 15px; align-items: center; }
        #obs-title { font-size: 12px; color: #00ffff; font-family: 'Orbitron', sans-serif; }
        #obs-eta { font-size: 11px; color: #00ff88; font-family: 'Orbitron', sans-serif; }
        #obs-bottom { position: absolute; bottom: 15px; bottom: calc(15px + env(safe-area-inset-bottom)); left: 50%; transform: translateX(-50%); display: flex; gap: 10px; pointer-events: auto; }

        /* 궤도 진입 프롬프트 */
        #orbit-prompt { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,60,40,0.95); border: 3px solid #00ff88; padding: 25px 40px; border-radius: 15px; text-align: center; pointer-events: auto; z-index: 350; box-shadow: 0 0 40px rgba(0,255,136,0.4); }
        #orbit-prompt.active { display: block; animation: orbitPulse 1.5s infinite; }
        @keyframes orbitPulse { 0%, 100% { box-shadow: 0 0 40px rgba(0,255,136,0.4); } 50% { box-shadow: 0 0 60px rgba(0,255,136,0.6); } }
        .orbit-prompt-title { font-size: 18px; color: #00ff88; margin-bottom: 8px; font-family: 'Orbitron', sans-serif; }
        .orbit-prompt-target { font-size: 22px; color: #fff; margin-bottom: 15px; font-family: 'Orbitron', sans-serif; }
        #orbit-prompt p { color: #aaa; font-size: 12px; margin-bottom: 20px; line-height: 1.6; }
        .orbit-prompt-buttons { display: flex; gap: 15px; justify-content: center; }
        .orbit-btn { padding: 12px 25px; border-radius: 25px; border: none; font-size: 13px; font-weight: bold; cursor: pointer; font-family: 'Orbitron', sans-serif; }
        .orbit-btn.confirm { background: linear-gradient(180deg, #00ff88, #00aa55); color: #000; }
        .orbit-btn.cancel { background: rgba(100,100,100,0.5); border: 1px solid #666; color: #aaa; }
        .orbit-btn.confirm:hover { background: #00ffaa; }
        .orbit-btn.cancel:hover { background: rgba(150,150,150,0.5); }

        /* 모바일 반응형 */
        @media (max-width: 600px) and (orientation: portrait) {
            #pilot-left, #pilot-right { display: none; }
            /* 2D cockpit 제거됨 */
            #pilot-top-bar { gap: 6px; flex-wrap: wrap; max-width: 95%; }
            .pilot-info-panel { padding: 3px 8px; }
            #pilot-target-select { top: 55px; }
            #pilot-eta-box { top: 85px; padding: 5px 12px; }
            #pilot-warning-panel { top: 125px; }
            .pilot-console-btn { padding: 7px 10px; font-size: 8px; }
            .pilot-ctrl-btn { width: 40px; height: 40px; font-size: 14px; }
            .vg-bar { height: 60px; width: 20px; }
            #pilot-main-speed .speed-value { font-size: 22px; }
        }
        @media (max-height: 500px) and (orientation: landscape) {
            /* 2D cockpit 제거됨 */
            #pilot-left, #pilot-right { transform: translateY(-50%) scale(0.7); }
            #pilot-top-bar { top: 3px; gap: 5px; }
            .pilot-info-panel { padding: 2px 6px; }
            #pilot-target-select { top: 42px; }
            #pilot-eta-box { top: 70px; }
            #pilot-warning-panel { top: 100px; }
            .vg-bar { height: 50px; width: 18px; }
            #pilot-main-speed .speed-value { font-size: 18px; }
            .pilot-console-btn { padding: 5px 8px; font-size: 7px; }
            .pilot-ctrl-btn { width: 35px; height: 35px; font-size: 12px; }
        }

        /* ========== 모바일 반응형 최적화 ========== */
        
        /* 모바일용 시간 조절 버튼 */
        #mobile-time-controls {
            display: none;  /* 기본적으로 숨김 */
            align-items: center;
            gap: 8px;
            background: rgba(0,0,0,0.3);
            padding: 5px 10px;
            border-radius: 20px;
        }
        .time-btn {
            background: #3498db;
            border: none;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .time-btn:active {
            background: #2980b9;
            transform: scale(0.95);
        }
        #time-val-mobile {
            color: #e74c3c;
            font-weight: bold;
            font-size: 12px;
            min-width: 40px;
            text-align: center;
        }
        
        @media (max-width: 768px) {
            /* ===== 모바일 UI 변수 재정의 ===== */
            :root {
                --top-bar-height: 45px;
                --nav-width: 140px;
                --spawn-dock-width: 50px;
                --chat-toggle-size: 45px;
                --ui-gap: 8px;
                --ui-padding: 10px;
            }
            
            /* AI 부조종사 패널 모바일 - 글자 크기 1.5배 */
            #ai-copilot-panel {
                width: 200px;
                max-width: 50vw;
                top: 5px;
                left: 5px;
                padding: 8px;
            }
            #ai-avatar { width: 26px; height: 26px; font-size: 13px; }
            #ai-name { font-size: 12px; }
            #ai-status { font-size: 9px; }
            #ai-message-box { min-height: 50px; max-height: 100px; font-size: 14px; line-height: 1.5; padding: 6px; }
            #ai-message-text { font-size: 14px; }
            #ai-input-area { margin-top: 6px; }
            #ai-input { padding: 8px 10px; font-size: 12px; }
            #ai-input::placeholder { font-size: 11px; }
            #ai-send-btn { width: 30px; height: 30px; font-size: 12px; }
            #ai-expand-btn { width: 24px; height: 24px; font-size: 12px; line-height: 22px; }
            #ai-comm-modal { min-width: 200px; padding: 12px; }
            #ai-comm-portrait { font-size: 30px; }
            
            /* 탑바 */
            #top-bar {
                padding: 8px 10px;
                flex-wrap: wrap;
                gap: 8px;
            }
            #top-bar h1 {
                font-size: 14px;
                width: auto;
                text-align: left;
                margin-bottom: 0;
            }
            .control-group {
                flex: 1;
                justify-content: center;
                flex-wrap: wrap;
                gap: 5px;
            }
            .mode-btn {
                padding: 6px 10px;
                font-size: 10px;
            }
            .slider-container {
                display: none;  /* 모바일에서 슬라이더 숨김 */
            }
            #time-val {
                display: none;  /* 모바일에서 데스크톱 시간 표시 숨김 */
            }
            #mobile-time-controls {
                display: flex;  /* 모바일에서 시간 조절 버튼 표시 */
            }
            /* 유저 영역 모바일 */
            #user-area {
                position: relative;
                gap: 5px;
                pointer-events: auto;  /* 클릭 가능 유지 */
            }
            #user-coins {
                padding: 3px 8px;
                font-size: 11px;
            }
            #user-name {
                display: none;
            }
            
            /* 모바일에서 데스크톱 전용 버튼 숨기기 */
            .desktop-only {
                display: none !important;
            }
            #pilot-right-console {
                display: none;
            }
            
            /* 긴급 역추진 버튼 모바일 표시 */
            .pilot-ctrl-btn.emergency-brake {
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            /* 조종 모드에서 전체보기 버튼 숨기기 */
            #cockpit-hud.active ~ #reset-cam,
            body.pilot-mode #reset-cam {
                display: none !important;
            }
            
            /* ===== UI 영역 체계적 배치 (겹침 방지) ===== */
            
            /* 상단 영역: top-bar */
            #top-bar {
                height: 50px;
                padding: 5px 10px;
            }
            #top-bar h1 {
                font-size: 12px;
            }
            
            /* 좌측 영역: nav-container */
            #nav-container {
                top: 55px;
                left: 0;
                bottom: 70px;
            }
            #nav-panel {
                width: 130px;
                max-height: calc(100vh - 140px);
                font-size: 10px;
            }
            .nav-item {
                padding: 6px 8px;
                font-size: 10px;
            }
            .nav-item.satellite {
                padding-left: 15px;
                font-size: 9px;
            }
            #nav-toggle {
                width: 28px;
                font-size: 12px;
                padding: 15px 5px;
            }
            
            /* 우측 상단 영역: spawn-dock */
            #spawn-dock {
                top: 55px;
                right: 10px;
                width: 45px;
                max-height: calc(100vh - 130px);
            }
            .spawn-btn {
                width: 30px;
                height: 30px;
            }
            
            /* 좌측 하단 영역: chat-toggle, chat-panel */
            #chat-toggle {
                bottom: 15px;
                left: 15px;
                right: auto;
                width: 45px;
                height: 45px;
                font-size: 18px;
            }
            #chat-panel {
                bottom: 70px;
                left: 15px;
                right: auto;
                width: calc(100vw - 80px);
                max-width: 280px;
                height: auto;
                max-height: calc(100vh - 150px);
            }
            
            /* 하단 중앙 영역: 버튼들 */
            #board-ship-btn {
                bottom: 70px;
                left: 50%;
                right: auto;
                transform: translateX(-50%);
                padding: 10px 20px;
                font-size: 12px;
            }
            #reset-cam {
                bottom: 15px;
                left: 50%;
                right: auto;
                transform: translateX(-50%);
            }
            
            /* 메시지, 거리 패널 */
            #msg-box {
                bottom: 130px;
                left: 50%;
                transform: translateX(-50%);
                max-width: 70%;
                font-size: 11px;
            }
            #focus-distance-panel {
                bottom: 15px;
                right: 70px;
                left: auto;
            }
            
            /* ===== 추가 모바일 설정 ===== */
            /* 메시지 박스 */
            #msg-box {
                bottom: 60px;
                font-size: 13px;
                max-width: 90%;
                text-align: center;
            }
            
            /* 리셋 카메라 버튼 */
            #reset-cam {
                bottom: 15px;
                padding: 8px 18px;
                font-size: 11px;
            }
            
            /* 포커스 거리 패널 */
            #focus-distance-panel {
                bottom: 70px;
                right: 10px;
                padding: 8px 12px;
                font-size: 11px;
            }
            #focus-distance-value {
                font-size: 14px;
            }
            
            /* 카탈로그 모달 */
            #catalog-content {
                width: 95%;
                max-height: 60vh;
                padding: 15px;
                padding-bottom: 30px;
                grid-template-columns: repeat(auto-fill, minmax(85px, 1fr));
                gap: 10px;
            }
            .catalog-card {
                padding: 8px;
            }
            .catalog-thumb {
                width: 55px;
                height: 55px;
            }
            .catalog-name {
                font-size: 9px;
            }
            
            /* 우주선 선택 모달 */
            #ship-select-modal {
                padding: 15px;
            }
            #ship-select-modal h2 {
                font-size: 16px;
            }
            #ship-list {
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
                max-height: 35vh;
            }
            .ship-card {
                padding: 8px;
                min-height: 100px;
            }
            .ship-card-icon {
                width: 100%;
                height: 55px;
                font-size: 24px;
            }
            .ship-card-name {
                font-size: 11px;
            }
            .ship-card-class {
                font-size: 9px;
            }
            #ship-detail {
                flex-direction: column;
                gap: 10px;
            }
            #ship-preview {
                width: 100%;
                height: 120px;
            }
            #ship-stats {
                font-size: 11px;
            }
            #btn-select-ship, #btn-cancel-ship {
                padding: 10px 25px;
                font-size: 12px;
            }
        }

        /* 더 작은 화면 (스마트폰) */
        @media (max-width: 480px) {
            /* AI 패널 스마트폰 - 글자 크기 1.5배 */
            #ai-copilot-panel {
                width: 180px;
                max-width: 55vw;
                top: 3px;
                left: 3px;
                padding: 6px;
            }
            #ai-copilot-header { margin-bottom: 5px; padding-bottom: 4px; gap: 6px; }
            #ai-avatar { width: 22px; height: 22px; font-size: 12px; }
            #ai-name { font-size: 11px; letter-spacing: 0; }
            #ai-status { font-size: 8px; }
            #ai-message-box { min-height: 45px; max-height: 90px; font-size: 13px; line-height: 1.4; padding: 5px; }
            #ai-message-text { font-size: 13px; }
            #ai-input-area { margin-top: 5px; }
            #ai-input { padding: 6px 8px; font-size: 11px; }
            #ai-input::placeholder { font-size: 10px; }
            #ai-send-btn { width: 26px; height: 26px; font-size: 11px; }
            #ai-expand-btn { width: 22px; height: 22px; font-size: 11px; line-height: 20px; }
            #ai-comm-modal { min-width: 160px; padding: 10px; }
            #ai-comm-portrait { font-size: 25px; }
            #ai-comm-name { font-size: 10px; }
            #ai-comm-message { font-size: 8px; }
            .ai-comm-choice { padding: 6px 8px; font-size: 8px; }
            
            #top-bar h1 {
                font-size: 12px;
            }
            .mode-btn {
                padding: 5px 8px;
                font-size: 9px;
            }
            
            #nav-panel {
                width: 120px;
                max-height: 35vh;
            }
            .nav-item {
                padding: 5px 6px;
                font-size: 9px;
            }
            
            /* 카탈로그 스마트폰 */
            #catalog-content {
                width: 95%;
                max-height: 55vh;
                padding: 10px;
                padding-bottom: 25px;
                grid-template-columns: repeat(3, 1fr);
                gap: 8px;
            }
            .catalog-card {
                padding: 6px;
            }
            .catalog-thumb {
                width: 45px;
                height: 45px;
                border-width: 2px;
            }
            .catalog-name {
                font-size: 8px;
            }
            
            #chat-panel {
                width: 90vw;
                height: 50vh;
                right: 5vw;
            }
            #chat-toggle {
                width: 40px;
                height: 40px;
                font-size: 18px;
                bottom: 15px;
                right: 15px;
            }
            
            #ship-list {
                grid-template-columns: repeat(2, 1fr);
                gap: 6px;
            }
            .ship-card {
                padding: 6px;
                min-height: 90px;
            }
            .ship-card-icon {
                width: 100%;
                height: 50px;
                font-size: 20px;
            }
            
            #focus-distance-panel {
                bottom: 60px;
                right: 5px;
                padding: 6px 10px;
            }
            
            /* 조종 모드 HUD */
            #pilot-top-bar {
                gap: 4px;
            }
            .pilot-info-panel {
                padding: 3px 6px;
                font-size: 9px;
            }
            .pilot-info-panel .info-value {
                font-size: 11px;
            }
            #pilot-target-select select {
                padding: 4px 8px;
                font-size: 9px;
            }
            
            /* 조이스틱 */
            #pilot-joystick {
                width: 100px;
                height: 100px;
                bottom: 15px;
                left: 15px;
            }
            #joystick-knob {
                width: 40px;
                height: 40px;
            }
            
            /* 조종 버튼 */
            .pilot-ctrl-btn {
                width: 38px;
                height: 38px;
                font-size: 12px;
            }
            #pilot-stop-btn {
                width: 50px;
                height: 50px;
                font-size: 10px;
            }
            #pilot-throttle-up, #pilot-throttle-down {
                width: 45px;
                height: 45px;
            }
            
            /* 게이지 */
            .vg-bar {
                height: 50px;
                width: 18px;
            }
            .vg-label {
                font-size: 8px;
            }
            .vg-value {
                font-size: 9px;
            }
            
            /* 콘솔 버튼 */
            #pilot-console-btns {
                gap: 5px;
            }
            .pilot-console-btn {
                padding: 6px 10px;
                font-size: 8px;
            }
            
            /* 속도 표시 */
            #pilot-main-speed {
                bottom: 55px;
            }
            #pilot-main-speed .speed-value {
                font-size: 20px;
            }
            #pilot-main-speed .speed-unit {
                font-size: 10px;
            }
        }

        /* 가로 모드 모바일 */
        @media (max-height: 450px) and (orientation: landscape) {
            #top-bar {
                padding: 5px 10px;
            }
            #top-bar h1 {
                font-size: 12px;
                width: auto;
                margin-bottom: 0;
            }
            .mode-btn {
                padding: 4px 8px;
                font-size: 9px;
            }
            
            #nav-panel {
                max-height: 80vh;
                width: 130px;
            }
            
            #ship-select-modal {
                padding: 10px;
                max-height: 95vh;
            }
            #ship-list {
                grid-template-columns: repeat(5, 1fr);
                max-height: 25vh;
            }
            #ship-detail {
                flex-direction: row;
            }
            #ship-preview {
                width: 150px;
                height: 100px;
            }
            
            #pilot-joystick {
                width: 80px;
                height: 80px;
                bottom: 10px;
                left: 10px;
            }
            #joystick-knob {
                width: 35px;
                height: 35px;
            }
            
            .pilot-ctrl-btn {
                width: 32px;
                height: 32px;
                font-size: 10px;
            }
            #pilot-stop-btn {
                width: 42px;
                height: 42px;
                font-size: 9px;
            }
            
            #focus-distance-panel {
                bottom: 50px;
                padding: 5px 8px;
            }
        }

        /* 터치 디바이스 최적화 */
        @media (hover: none) and (pointer: coarse) {
            .mode-btn, .pilot-console-btn, .pilot-ctrl-btn, #board-ship-btn, #reset-cam {
                min-height: 44px;  /* 터치 타겟 최소 크기 */
            }
            .ship-card {
                min-height: 80px;
            }
            .nav-item {
                min-height: 40px;
                display: flex;
                align-items: center;
            }
        }
        
        /* 세로 모드 경고 오버레이 */
        #landscape-warning {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 99999;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-family: 'Orbitron', sans-serif;
        }
        #landscape-warning .rotate-icon {
            font-size: 80px;
            margin-bottom: 20px;
            animation: rotate-hint 2s ease-in-out infinite;
        }
        @keyframes rotate-hint {
            0%, 100% { transform: rotate(0deg); }
            50% { transform: rotate(90deg); }
        }
        #landscape-warning .rotate-text {
            font-size: 24px;
            color: #00ffff;
            margin-bottom: 10px;
        }
        #landscape-warning .rotate-sub {
            font-size: 14px;
            color: #888;
        }
        
        /* UI 겹침 방지 - 상단 바 */
        #top-bar {
            position: relative;
            z-index: 100;
            flex-wrap: nowrap;
        }
        #top-bar h1 {
            flex-shrink: 0;
            white-space: nowrap;
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            letter-spacing: 2px;
            color: #00d4ff;
            text-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
        }
        .control-group {
            flex-shrink: 1;
            min-width: 0;
        }
        #user-area {
            flex-shrink: 0;
            z-index: 101;
            pointer-events: auto;  /* 클릭 가능 */
        }
        
        /* 모바일에서 UI 겹침 방지 */
        @media (max-width: 768px) {
            #top-bar {
                flex-wrap: wrap;
                padding: 5px 8px;
                gap: 5px;
            }
            #top-bar h1 {
                order: 1;
                flex: 0 0 auto;
                font-size: 12px !important;
            }
            .control-group {
                order: 3;
                flex: 1 1 100%;
                justify-content: center;
            }
            #user-area {
                order: 2;
                position: static !important;
                margin-left: auto;
                pointer-events: auto;  /* 클릭 가능 */
            }
            #user-coins {
                padding: 3px 8px;
                font-size: 11px;
            }
            #btn-login, #btn-logout, #btn-register {
                padding: 4px 8px;
                font-size: 10px;
            }
        }
        
        @media (max-width: 480px) {
            #top-bar h1 {
                font-size: 10px !important;
            }
            #user-coins {
                padding: 2px 6px;
                font-size: 10px;
            }
            .mode-btn {
                padding: 4px 6px;
                font-size: 8px;
            }
            #btn-login, #btn-logout, #btn-register {
                padding: 3px 6px;
                font-size: 9px;
            }
        }
        
        /* 정거장 선택 모달 */
        #station-modal {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.8);
            z-index: 10000;
            justify-content: center;
            align-items: center;
            overflow-y: auto;
            padding: 20px 0;
        }
        #station-modal.open { display: flex; }
        #station-modal-content {
            background: linear-gradient(135deg, rgba(0,30,60,0.98), rgba(0,50,80,0.95));
            border: 2px solid #4fc3f7;
            border-radius: 15px;
            padding: 20px;
            width: 90%;
            max-width: 500px;
            max-height: 85vh;
            overflow-y: auto;
            margin: auto;
            box-shadow: 0 0 30px rgba(79,195,247,0.3);
        }
        #station-modal h2 {
            color: #4fc3f7;
            margin: 0 0 15px 0;
            font-size: 18px;
            text-align: center;
            border-bottom: 1px solid rgba(79,195,247,0.3);
            padding-bottom: 10px;
        }
        .station-category {
            margin-bottom: 15px;
        }
        .station-category h3 {
            color: #ffd700;
            font-size: 12px;
            margin: 0 0 8px 0;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .station-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .station-item {
            background: rgba(0,60,100,0.5);
            border: 1px solid rgba(79,195,247,0.3);
            border-radius: 8px;
            padding: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        .station-item:hover {
            background: rgba(0,100,150,0.5);
            border-color: #4fc3f7;
            transform: translateX(5px);
        }
        .station-info {
            flex: 1;
        }
        .station-name {
            color: #fff;
            font-size: 13px;
            font-weight: bold;
        }
        .station-desc {
            color: #888;
            font-size: 10px;
            margin-top: 2px;
        }
        .station-item.fuel-depot .station-name {
            color: #ff6600;
        }
        .station-actions {
            display: flex;
            gap: 5px;
        }
        .station-btn {
            padding: 5px 10px;
            border: none;
            border-radius: 5px;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .station-btn.go {
            background: #4fc3f7;
            color: #000;
        }
        .station-btn.go:hover { background: #81d4fa; }
        .station-btn.dock {
            background: #4caf50;
            color: #fff;
        }
        .station-btn.dock:hover { background: #66bb6a; }
        
        /* 잠긴 정거장 스타일 */
        .station-item.locked {
            opacity: 0.6;
            background: rgba(50, 50, 60, 0.5);
            border-color: rgba(150, 100, 50, 0.3);
        }
        .station-item.locked:hover {
            background: rgba(60, 50, 40, 0.5);
            border-color: rgba(200, 150, 50, 0.5);
            transform: none;
        }
        .station-item.locked .station-name {
            color: #a88;
        }
        .station-btn.go.disabled {
            background: rgba(100, 80, 50, 0.5);
            color: #a88;
            cursor: not-allowed;
        }
        .station-btn.go.disabled:hover {
            background: rgba(100, 80, 50, 0.5);
        }
        .station-btn.dock.disabled {
            background: rgba(100, 80, 50, 0.5);
            color: #a88;
            cursor: not-allowed;
        }
        .station-btn.dock.disabled:hover {
            background: rgba(100, 80, 50, 0.5);
        }
        
        #station-close {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            color: #ff6b6b;
            font-size: 24px;
            cursor: pointer;
        }
        #station-modal-content { position: relative; }
        
        /* 연료 충전 UI */
        #refuel-panel {
            display: none;
            position: fixed;
            bottom: 150px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,40,60,0.95);
            border: 2px solid #ff6600;
            border-radius: 10px;
            padding: 15px 25px;
            z-index: 9999;
            text-align: center;
        }
        #refuel-panel.show { display: block; }
        #refuel-panel h3 {
            color: #ff6600;
            margin: 0 0 10px 0;
            font-size: 14px;
        }
        #refuel-bar {
            width: 200px;
            height: 20px;
            background: #222;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        #refuel-progress {
            height: 100%;
            background: linear-gradient(90deg, #ff6600, #ffaa00);
            width: 0%;
            transition: width 0.3s;
        }
        #refuel-text {
            color: #fff;
            font-size: 12px;
        }
        
        /* ========== 드래그 가능 UI 시스템 ========== */
        .draggable-ui {
            cursor: grab;
            transition: transform 0.1s, box-shadow 0.2s;
        }
        .draggable-ui.drag-ready {
            animation: dragReady 0.3s ease;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.8) !important;
            border-color: #0ff !important;
        }
        .draggable-ui.dragging {
            cursor: grabbing;
            opacity: 0.85;
            transform: scale(1.05);
            z-index: 9999 !important;
            box-shadow: 0 0 30px rgba(0, 255, 255, 1) !important;
        }
        
        /* ========== SSIL 미션 시스템 ========== */
        #ssil-mission-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(10, 25, 50, 0.98), rgba(5, 15, 35, 0.98));
            border: 2px solid #0ff;
            border-radius: 15px;
            padding: 25px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 10001;
            display: none;
            font-family: 'Orbitron', sans-serif;
            color: #fff;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.3);
        }
        #ssil-mission-panel.open { display: block; }
        #ssil-mission-panel h2 {
            text-align: center;
            color: #0ff;
            margin: 0 0 15px 0;
            font-size: 1.3em;
            text-shadow: 0 0 10px #0ff;
        }
        .ssil-logo {
            text-align: center;
            font-size: 2em;
            margin-bottom: 10px;
        }
        .ssil-subtitle {
            text-align: center;
            color: #888;
            font-size: 0.7em;
            margin-bottom: 20px;
        }
        .mission-table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        .mission-table th {
            background: rgba(0, 255, 255, 0.2);
            color: #0ff;
            padding: 10px 8px;
            text-align: left;
            font-size: 0.75em;
            border-bottom: 1px solid #0ff;
        }
        .mission-table td {
            padding: 10px 8px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            font-size: 0.7em;
        }
        .mission-table tr.completed {
            background: rgba(0, 255, 136, 0.15);
        }
        .mission-table tr.completed td {
            color: #0f8;
            text-decoration: line-through;
        }
        .mission-status {
            width: 30px;
            text-align: center;
        }
        .mission-reward {
            color: #ffd700;
            text-align: right;
        }
        .mission-close-btn {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            color: #f66;
            font-size: 1.5em;
            cursor: pointer;
        }
        
        /* 일일 미션 이메일 아이콘 */
        #daily-mission-icon {
            position: fixed;
            top: 100px;
            right: 10px;
            width: 45px;
            height: 45px;
            background: linear-gradient(135deg, #2c3e50, #34495e);
            border: 2px solid #f90;
            border-radius: 50%;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 1.3em;
            z-index: 1000;
            animation: emailPulse 2s infinite;
        }
        #daily-mission-icon.has-mission { display: flex; }
        #daily-mission-icon .badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #f00;
            color: #fff;
            font-size: 10px;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        @keyframes emailPulse {
            0%, 100% { box-shadow: 0 0 5px #f90; }
            50% { box-shadow: 0 0 20px #f90; }
        }
        
        /* 일일 미션 모달 */
        #daily-mission-modal {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: none;
            justify-content: center;
            align-items: center;
            overflow-y: auto;
            padding: 20px 0;
            z-index: 10002;
        }
        #daily-mission-modal.open { display: flex; }
        .daily-mission-content {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border: 2px solid #f90;
            border-radius: 15px;
            padding: 25px;
            max-width: 400px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            margin: auto;
            color: #fff;
            font-family: 'Orbitron', sans-serif;
        }
        .daily-mission-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,153,0,0.3);
        }
        .daily-mission-header .icon { font-size: 2em; }
        .daily-mission-header h3 {
            margin: 0;
            color: #f90;
            font-size: 1.1em;
        }
        .daily-mission-header .date {
            margin-left: auto;
            font-size: 0.7em;
            color: #888;
        }
        .daily-mission-body {
            margin: 15px 0;
            line-height: 1.6;
            font-size: 0.85em;
        }
        .daily-mission-rewards {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin: 15px 0;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
        }
        .daily-reward-item {
            text-align: center;
        }
        .daily-reward-item .value {
            font-size: 1.2em;
            color: #ffd700;
        }
        .daily-reward-item .label {
            font-size: 0.65em;
            color: #888;
        }
        .daily-mission-btns {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        .daily-mission-btns button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.8em;
        }
        .daily-btn-accept {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            color: #fff;
        }
        .daily-btn-decline {
            background: rgba(255,255,255,0.1);
            color: #888;
            border: 1px solid #444 !important;
        }
        
        /* 미션 포인트 표시 */
        #mission-points-display {
            position: fixed;
            top: 145px;
            right: 10px;
            background: linear-gradient(135deg, rgba(128, 0, 255, 0.3), rgba(75, 0, 130, 0.3));
            border: 1px solid #a855f7;
            border-radius: 20px;
            padding: 5px 12px;
            color: #a855f7;
            font-size: 11px;
            font-family: 'Orbitron', sans-serif;
            display: none;
            z-index: 999;
        }
        #mission-points-display.visible { display: block; }
        
        /* 미션 완료 알림 */
        .mission-complete-toast {
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.9), rgba(0, 200, 100, 0.9));
            border: 2px solid #0f8;
            border-radius: 15px;
            padding: 20px 40px;
            color: #fff;
            font-family: 'Orbitron', sans-serif;
            text-align: center;
            z-index: 10003;
            animation: missionToastIn 0.5s ease;
        }
        .mission-complete-toast h3 {
            margin: 0 0 10px 0;
            font-size: 1.2em;
        }
        .mission-complete-toast .reward {
            color: #ffd700;
            font-size: 1.5em;
        }
        @keyframes missionToastIn {
            from { opacity: 0; transform: translateX(-50%) translateY(-30px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }
        @keyframes dragReady {
            0%, 100% { box-shadow: 0 0 10px rgba(0, 255, 255, 0.5); }
            50% { box-shadow: 0 0 25px rgba(0, 255, 255, 1); }
        }
        
        /* UI 설정 버튼 */
        #ui-settings-btn {
            position: fixed;
            top: 50px;
            left: 10px;
            width: 36px;
            height: 36px;
            background: rgba(0,0,0,0.8);
            border: 1px solid #666;
            border-radius: 8px;
            color: #aaa;
            font-size: 1.2em;
            cursor: pointer;
            z-index: 1002;
            display: none;
        }
        #ui-settings-btn:hover {
            border-color: #0ff;
            color: #0ff;
        }
        #cockpit-hud.active ~ #ui-settings-btn,
        body.pilot-mode #ui-settings-btn {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        /* 조종 모드에서 통합 채팅 패널 표시 */
        body.pilot-mode #unified-chat-panel {
            display: block;
        }
        
        /* UI 설정 패널 */
        #ui-settings-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 20, 40, 0.95);
            border: 2px solid #0ff;
            border-radius: 15px;
            padding: 20px;
            z-index: 10001;
            min-width: 320px;
            max-width: 90vw;
            max-height: 85vh;
            overflow-y: auto;
            display: none;
            color: white;
            font-family: 'Orbitron', sans-serif;
        }
        #ui-settings-panel.open { display: block; }
        #ui-settings-panel h3 {
            color: #0ff;
            margin: 0 0 15px 0;
            text-align: center;
        }
        .ui-preset-btn {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: rgba(0,100,150,0.5);
            border: 1px solid #0ff;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-size: 0.9em;
        }
        .ui-preset-btn:hover { background: rgba(0,150,200,0.7); }
        .ui-preset-btn.danger { border-color: #f55; color: #f55; }
        .ui-preset-btn.danger:hover { background: rgba(255,50,50,0.3); }
        #ui-settings-close {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: #fff;
            font-size: 1.5em;
            cursor: pointer;
        }
        
        /* UI 슬롯 시스템 */
        .ui-slots-container {
            margin: 15px 0;
        }
        .ui-slots-title {
            font-size: 12px;
            color: #0ff;
            margin-bottom: 10px;
            text-align: center;
        }
        .ui-slot {
            display: flex;
            align-items: center;
            background: rgba(0, 30, 60, 0.8);
            border: 1px solid #345;
            border-radius: 8px;
            padding: 10px;
            margin: 8px 0;
            cursor: pointer;
            transition: all 0.2s;
        }
        .ui-slot:hover {
            border-color: #0ff;
            background: rgba(0, 50, 80, 0.8);
        }
        .ui-slot.empty {
            opacity: 0.5;
        }
        .ui-slot-preview {
            width: 80px;
            height: 50px;
            background: #000;
            border: 1px solid #456;
            border-radius: 4px;
            margin-right: 12px;
            position: relative;
            overflow: hidden;
        }
        .ui-slot-preview .preview-dot {
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 2px;
            background: #0ff;
        }
        .ui-slot-info {
            flex: 1;
        }
        .ui-slot-name {
            font-size: 13px;
            color: #fff;
            margin-bottom: 3px;
        }
        .ui-slot-date {
            font-size: 10px;
            color: #888;
        }
        .ui-slot-actions {
            display: flex;
            gap: 5px;
        }
        .ui-slot-btn {
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid;
            background: transparent;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }
        .ui-slot-btn.load {
            border-color: #0f0;
            color: #0f0;
        }
        .ui-slot-btn.load:hover {
            background: rgba(0, 255, 0, 0.2);
        }
        .ui-slot-btn.save {
            border-color: #0ff;
            color: #0ff;
        }
        .ui-slot-btn.save:hover {
            background: rgba(0, 255, 255, 0.2);
        }
        .ui-slot-btn.delete {
            border-color: #f55;
            color: #f55;
        }
        .ui-slot-btn.delete:hover {
            background: rgba(255, 50, 50, 0.2);
        }
        
        /* ========== UI 재배치 모드 ========== */
        #ui-rearrange-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.3);
            z-index: 9998;
            display: none;
            flex-direction: column;
            align-items: center;
            pointer-events: none;
        }
        #ui-rearrange-overlay.active {
            display: flex;
        }
        .rearrange-header {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(155, 89, 182, 0.9), rgba(142, 68, 173, 0.9));
            border: 2px solid #9b59b6;
            border-radius: 25px;
            padding: 10px 25px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 3px;
            color: white;
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            z-index: 10001;
            pointer-events: auto;
            box-shadow: 0 0 30px rgba(155, 89, 182, 0.5);
        }
        #ui-rearrange-done {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            border: 2px solid #2ecc71;
            border-radius: 25px;
            padding: 15px 40px;
            color: white;
            font-size: 16px;
            font-family: 'Orbitron', sans-serif;
            cursor: pointer;
            z-index: 10001;
            pointer-events: auto;
            box-shadow: 0 0 20px rgba(46, 204, 113, 0.5);
        }
        #ui-rearrange-done:hover {
            background: linear-gradient(135deg, #2ecc71, #27ae60);
            transform: translateX(-50%) scale(1.05);
        }
        
        /* 재배치 모드에서 UI 하이라이트 */
        body.ui-rearrange-mode .rearrangeable-ui {
            outline: 2px dashed #9b59b6 !important;
            outline-offset: 3px;
            cursor: move !important;
            animation: rearrangeGlow 1.5s ease-in-out infinite;
            pointer-events: auto !important;
            touch-action: none !important;
        }
        body.ui-rearrange-mode .rearrangeable-ui:hover {
            outline-color: #0ff !important;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5) !important;
        }
        body.ui-rearrange-mode .rearrangeable-ui.dragging {
            outline-color: #f90 !important;
            z-index: 10000 !important;
            opacity: 0.9;
        }
        /* 재배치 모드에서 다른 터치 이벤트 비활성화 */
        body.ui-rearrange-mode #touch-area-left,
        body.ui-rearrange-mode #touch-area-right,
        body.ui-rearrange-mode canvas {
            pointer-events: none !important;
        }
        @keyframes rearrangeGlow {
            0%, 100% { outline-color: #9b59b6; }
            50% { outline-color: #bb8fce; }
        }
        
        /* ========== 모바일 최적화 CSS ========== */
        /* 터치 친화적 기본 설정 */
        * {
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        
        /* 모바일 세로 모드 */
        @media (max-width: 480px) {
            #top-bar {
                padding: 5px 8px !important;
                flex-wrap: wrap;
                gap: 4px;
            }
            #top-bar h1 {
                font-size: 12px !important;
                width: 100%;
                text-align: center;
                margin-bottom: 5px;
            }
            .mode-btn {
                padding: 6px 8px !important;
                font-size: 10px !important;
                min-width: 50px;
            }
            #nav-container {
                width: 140px !important;
                max-height: 50vh !important;
            }
            .nav-item {
                padding: 10px 8px !important;
                font-size: 11px !important;
            }
            #chat-toggle {
                width: 44px !important;
                height: 44px !important;
                bottom: 15px !important;
                left: 10px !important;
            }
            #chat-panel {
                width: calc(100vw - 20px) !important;
                height: 50vh !important;
                left: 10px !important;
                bottom: 70px !important;
            }
            #msg-box {
                font-size: 12px !important;
                bottom: 60px !important;
            }
            #reset-cam {
                padding: 8px 16px !important;
                font-size: 11px !important;
            }
            /* 광고 버튼 */
            #ad-rewards-panel {
                top: auto !important;
                bottom: 15px !important;
                right: 10px !important;
            }
            #ad-menu-toggle {
                width: 44px !important;
                height: 44px !important;
            }
            /* 사운드 패널 */
            #sound-slide {
                bottom: 70px !important;
            }
        }
        
        /* 모바일 가로 모드 */
        @media (max-height: 500px) and (orientation: landscape) {
            #top-bar {
                padding: 3px 10px !important;
            }
            #top-bar h1 {
                font-size: 11px !important;
            }
            .mode-btn {
                padding: 4px 8px !important;
                font-size: 9px !important;
            }
            #nav-container {
                max-height: 70vh !important;
            }
            #chat-panel {
                height: 80vh !important;
            }
        }
        
        /* 조종석 UI 모바일 최적화 */
        @media (max-width: 768px) {
            #pilot-console {
                padding: 8px !important;
                gap: 6px !important;
            }
            .pilot-console-btn {
                padding: 10px 12px !important;
                font-size: 11px !important;
                min-height: 44px;
            }
            #pilot-fuel, #pilot-speed {
                width: 55px !important;
            }
            #pilot-bottom {
                gap: 8px !important;
                padding: 5px !important;
            }
            #pilot-main-speed {
                font-size: 1.8em !important;
            }
            #touch-area-left {
                width: 140px !important;
                height: 140px !important;
                bottom: 100px !important;
                left: 10px !important;
            }
            /* ETA 박스 */
            #pilot-eta-box {
                font-size: 0.8em !important;
                padding: 6px 10px !important;
            }
            /* 경고 패널 */
            #pilot-warning-panel {
                font-size: 10px !important;
            }
            .pilot-warning {
                padding: 4px 8px !important;
            }
            /* 타겟 선택 */
            #pilot-target-select select {
                font-size: 11px !important;
                padding: 6px !important;
            }
        }
        
        /* 태블릿 */
        @media (min-width: 481px) and (max-width: 1024px) {
            #top-bar {
                padding: 8px 15px;
            }
            .mode-btn {
                padding: 8px 12px;
                font-size: 11px;
            }
            #nav-container {
                width: 180px;
            }
            .nav-item {
                padding: 10px;
            }
        }
        
        /* 터치 스크린 전용 */
        @media (hover: none) and (pointer: coarse) {
            .mode-btn, .pilot-console-btn, .pilot-ctrl-btn, 
            #board-ship-btn, #reset-cam, #chat-toggle,
            .nav-item, .station-btn, .catalog-card {
                min-height: 44px;
                min-width: 44px;
            }
            /* 버튼 활성화 피드백 */
            .mode-btn:active, .pilot-console-btn:active {
                transform: scale(0.95);
                opacity: 0.8;
            }
            /* 스크롤바 숨기기 */
            ::-webkit-scrollbar {
                width: 4px;
                height: 4px;
            }
        }
        
        /* ========== 모바일 하단 탭 바 시스템 ========== */
        #mobile-tab-bar {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 50px;
            background: rgba(0, 15, 30, 0.95);
            border-top: 2px solid #0ff;
            z-index: 10002;
            justify-content: space-around;
            align-items: center;
            padding-bottom: env(safe-area-inset-bottom);
            backdrop-filter: blur(10px);
        }
        
        .mobile-tab {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #888;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
            background: transparent;
            font-family: 'Orbitron', sans-serif;
        }
        
        .mobile-tab-icon {
            font-size: 18px;
            margin-bottom: 2px;
        }
        
        .mobile-tab.active {
            color: #0ff;
            background: rgba(0, 255, 255, 0.1);
        }
        
        .mobile-tab:active {
            transform: scale(0.95);
        }
        
        /* 모바일 탭 패널 */
        #mobile-tab-panel {
            display: none;
            position: fixed;
            bottom: 50px;
            bottom: calc(50px + env(safe-area-inset-bottom));
            left: 0;
            right: 0;
            background: rgba(0, 20, 40, 0.95);
            border-top: 1px solid #0ff;
            z-index: 10001;
            max-height: 200px;
            overflow-y: auto;
            backdrop-filter: blur(10px);
        }
        
        #mobile-tab-panel.open {
            display: block;
        }
        
        .mobile-panel-content {
            display: none;
            padding: 15px;
        }
        
        .mobile-panel-content.active {
            display: block;
        }
        
        /* 모바일 조종 패널 */
        #mobile-control-panel {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            align-items: center;
        }
        
        .mobile-gauge-group {
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }
        
        .mobile-gauge {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(0, 30, 50, 0.9);
            border: 1px solid #0ff;
            border-radius: 8px;
            padding: 8px;
            min-width: 50px;
        }
        
        .mobile-gauge-label {
            font-size: 8px;
            color: #0ff;
            margin-bottom: 5px;
        }
        
        .mobile-gauge-bar {
            width: 30px;
            height: 60px;
            background: #111;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }
        
        .mobile-gauge-fill {
            position: absolute;
            bottom: 0;
            width: 100%;
            border-radius: 4px;
            transition: height 0.2s;
        }
        
        .mobile-gauge-fill.thr {
            background: linear-gradient(0deg, #0066ff, #00ffff);
        }
        
        .mobile-gauge-fill.fuel {
            background: linear-gradient(0deg, #ff3300, #ffff00, #00ff00);
        }
        
        .mobile-gauge-value {
            font-size: 11px;
            color: #fff;
            margin-top: 5px;
        }
        
        .mobile-speed-display {
            text-align: center;
            padding: 10px 20px;
        }
        
        .mobile-speed-value {
            font-size: 36px;
            color: #0ff;
            text-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        }
        
        .mobile-speed-unit {
            font-size: 12px;
            color: #888;
        }
        
        .mobile-speed-secondary {
            font-size: 11px;
            color: #666;
            margin-top: 3px;
        }
        
        .mobile-direction-btns {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .mobile-dir-btn {
            width: 50px;
            height: 40px;
            background: rgba(0, 40, 60, 0.9);
            border: 1px solid #0ff;
            border-radius: 8px;
            color: #0ff;
            font-size: 18px;
            cursor: pointer;
        }
        
        .mobile-dir-btn:active {
            background: rgba(0, 255, 255, 0.3);
        }
        
        .mobile-btn-row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 10px;
            width: 100%;
        }
        
        .mobile-action-btn {
            padding: 10px 15px;
            background: rgba(0, 40, 60, 0.9);
            border: 1px solid #0ff;
            border-radius: 8px;
            color: #0ff;
            font-size: 11px;
            cursor: pointer;
            font-family: 'Orbitron', sans-serif;
        }
        
        .mobile-action-btn:active {
            background: rgba(0, 255, 255, 0.3);
        }
        
        .mobile-action-btn.autopilot {
            border-color: #0f8;
            color: #0f8;
        }
        
        .mobile-action-btn.autopilot.engaged {
            background: rgba(0, 255, 136, 0.3);
        }
        
        /* 모바일 상태 패널 */
        #mobile-status-panel {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        
        .mobile-status-item {
            background: rgba(0, 30, 50, 0.9);
            border: 1px solid #0ff;
            border-radius: 8px;
            padding: 10px;
            text-align: center;
        }
        
        .mobile-status-label {
            font-size: 9px;
            color: #0ff;
            margin-bottom: 5px;
        }
        
        .mobile-status-value {
            font-size: 14px;
            color: #fff;
        }
        
        /* 모바일 라디오 패널 */
        #mobile-radio-panel {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .mobile-radio-station {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgba(0, 30, 50, 0.9);
            border: 1px solid #456;
            border-radius: 8px;
            padding: 12px;
            cursor: pointer;
        }
        
        .mobile-radio-station:active,
        .mobile-radio-station.active {
            border-color: #0f0;
            background: rgba(0, 100, 50, 0.5);
        }
        
        .mobile-radio-name {
            font-size: 13px;
            color: #fff;
        }
        
        .mobile-radio-status {
            font-size: 10px;
            color: #888;
        }
        
        .mobile-radio-volume {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
            padding: 10px;
            background: rgba(0, 30, 50, 0.9);
            border: 1px solid #0ff;
            border-radius: 8px;
        }
        
        .mobile-radio-volume input {
            flex: 1;
        }
        
        /* 모바일 채팅 패널 */
        #mobile-chat-panel {
            display: flex;
            flex-direction: column;
            height: 180px;
        }
        
        .mobile-chat-messages {
            flex: 1;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            font-size: 12px;
        }
        
        .mobile-chat-input-row {
            display: flex;
            gap: 8px;
        }
        
        .mobile-chat-input-row input {
            flex: 1;
            padding: 10px;
            background: rgba(0, 50, 80, 0.8);
            border: 1px solid #0ff;
            border-radius: 8px;
            color: #fff;
            font-size: 14px;
        }
        
        .mobile-chat-input-row button {
            padding: 10px 20px;
            background: #0ff;
            border: none;
            border-radius: 8px;
            color: #000;
            font-weight: bold;
            cursor: pointer;
        }
        
        /* 모바일 ARIA 패널 */
        #mobile-aria-panel {
            display: flex;
            flex-direction: column;
            height: 180px;
        }
        
        .mobile-aria-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .mobile-aria-avatar {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }
        
        .mobile-aria-info {
            flex: 1;
        }
        
        .mobile-aria-name {
            font-size: 14px;
            color: #0ff;
            font-weight: bold;
        }
        
        .mobile-aria-status {
            font-size: 10px;
            color: #0f0;
        }
        
        .mobile-aria-messages {
            flex: 1;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            font-size: 13px;
            color: #fff;
            line-height: 1.4;
        }
        
        .mobile-aria-input-row {
            display: flex;
            gap: 8px;
        }
        
        .mobile-aria-input-row input {
            flex: 1;
            padding: 10px;
            background: rgba(0, 50, 80, 0.8);
            border: 1px solid #0ff;
            border-radius: 8px;
            color: #fff;
            font-size: 14px;
        }
        
        .mobile-aria-input-row button {
            padding: 10px 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 8px;
            color: #fff;
            font-weight: bold;
            cursor: pointer;
        }
        
        /* 모바일에서 기존 UI 숨기기 */
        @media (max-width: 768px) {
            body.pilot-mode #mobile-tab-bar {
                display: flex;
            }
            
            body.pilot-mode #pilot-bottom {
                bottom: calc(60px + env(safe-area-inset-bottom));
            }
            
            body.pilot-mode #ai-copilot-panel {
                display: none !important;
            }
            
            body.pilot-mode #cockpit-radio {
                display: none !important;
            }
            
            body.pilot-mode #multiplayer-ui {
                display: none !important;
            }
            
            body.pilot-mode #pilot-left {
                display: none !important;
            }
            
            body.pilot-mode #pilot-right {
                top: 60px;
                transform: none;
            }
            
            /* 우측 패널 개별 분리 스타일 */
            body.pilot-mode #pilot-radar,
            body.pilot-mode #pilot-target-info,
            body.pilot-mode #pilot-autopilot-info {
                background: rgba(0, 20, 40, 0.9);
                border: 1px solid #0ff;
                border-radius: 8px;
            }
            
            /* 미니 HUD - 상단 */
            #mobile-mini-hud {
                display: flex;
                position: fixed;
                top: 5px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0, 20, 40, 0.9);
                border: 1px solid #0ff;
                border-radius: 20px;
                padding: 5px 15px;
                gap: 15px;
                z-index: 300;
                align-items: center;
            }
            
            .mini-hud-item {
                display: flex;
                align-items: center;
                gap: 5px;
                font-size: 12px;
            }
            
            .mini-hud-icon {
                font-size: 14px;
            }
            
            .mini-hud-value {
                color: #0ff;
                font-weight: bold;
            }
            
            .mini-hud-bar {
                width: 50px;
                height: 6px;
                background: #222;
                border-radius: 3px;
                overflow: hidden;
            }
            
            .mini-hud-bar-fill {
                height: 100%;
                background: linear-gradient(90deg, #f00, #ff0, #0f0);
                transition: width 0.3s;
            }
        }
        
        @media (min-width: 769px) {
            #mobile-tab-bar,
            #mobile-tab-panel,
            #mobile-mini-hud {
                display: none !important;
            }
        }
        
        /* ★★★ 시네마틱 인트로 스타일 ★★★ */
        #intro-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: #000;
            z-index: 999999;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        #intro-overlay.fade-out {
            animation: intro-fadeout 1.5s ease-in-out forwards;
        }
        @keyframes intro-fadeout {
            0% { opacity: 1; }
            100% { opacity: 0; pointer-events: none; }
        }
        #intro-canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
        }
        
        /* 레터박스 (시네마틱 바) */
        .letterbox {
            position: absolute;
            left: 0; width: 100%;
            height: 12%;
            background: #000;
            z-index: 10;
            transform: scaleY(0);
        }
        .letterbox-top { top: 0; transform-origin: top; }
        .letterbox-bottom { bottom: 0; transform-origin: bottom; }
        .letterbox.active {
            animation: letterbox-in 1s ease-out forwards;
        }
        @keyframes letterbox-in {
            0% { transform: scaleY(0); }
            100% { transform: scaleY(1); }
        }
        
        /* 렌즈 플레어 */
        #lens-flare {
            position: absolute;
            top: 30%; left: 50%;
            width: 300px; height: 300px;
            transform: translate(-50%, -50%);
            background: radial-gradient(ellipse, rgba(255,200,100,0.3) 0%, transparent 60%);
            opacity: 0;
            z-index: 5;
            pointer-events: none;
        }
        #lens-flare.active {
            animation: flare-pulse 3s ease-in-out infinite;
        }
        @keyframes flare-pulse {
            0%, 100% { opacity: 0.3; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 0.6; transform: translate(-50%, -50%) scale(1.2); }
        }
        
        /* 메인 컨텐츠 */
        #intro-content {
            position: relative;
            z-index: 20;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 40px;
        }
        
        /* 스튜디오 로고 */
        #studio-logo {
            opacity: 0;
            transform: scale(0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        #studio-logo.visible {
            animation: studio-in 2s ease-out forwards;
        }
        #studio-logo.fadeout {
            animation: studio-out 1s ease-in forwards;
        }
        @keyframes studio-in {
            0% { opacity: 0; transform: scale(0.8); }
            100% { opacity: 1; transform: scale(1); }
        }
        @keyframes studio-out {
            0% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(1.1); }
        }
        .studio-icon {
            font-size: 48px;
            color: #fff;
            text-shadow: 0 0 30px rgba(255,255,255,0.5);
            animation: icon-rotate 10s linear infinite;
        }
        @keyframes icon-rotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .studio-text {
            font-family: 'Rajdhani', sans-serif;
            font-size: 14px;
            font-weight: 600;
            color: rgba(255,255,255,0.7);
            letter-spacing: 8px;
        }
        
        /* 메인 타이틀 */
        #main-title {
            opacity: 0;
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        #main-title.visible {
            display: flex;
            animation: title-in 1.5s ease-out forwards;
        }
        @keyframes title-in {
            0% { opacity: 0; transform: translateY(30px); }
            100% { opacity: 1; transform: translateY(0); }
        }
        .title-line {
            width: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(0,255,255,0.8), transparent);
        }
        .title-line.expand {
            animation: line-expand 1.5s ease-out forwards;
        }
        @keyframes line-expand {
            0% { width: 0; }
            100% { width: 400px; }
        }
        .title-text {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(28px, 8vw, 56px);
            font-weight: 900;
            color: transparent;
            letter-spacing: 6px;
            display: flex;
            gap: 2px;
        }
        .title-text .char {
            opacity: 0;
            color: #fff;
            text-shadow: 0 0 20px rgba(0,255,255,0.5);
        }
        .title-text .char.visible {
            animation: char-in 0.5s ease-out forwards;
        }
        .title-text .char.dot {
            color: #00ffff;
            margin: 0 8px;
        }
        @keyframes char-in {
            0% { opacity: 0; transform: translateY(-20px) scale(1.5); filter: blur(10px); }
            100% { opacity: 1; transform: translateY(0) scale(1); filter: blur(0); }
        }
        .title-tagline {
            font-family: 'Rajdhani', sans-serif;
            font-size: clamp(10px, 2.5vw, 16px);
            color: rgba(0,255,255,0.6);
            letter-spacing: 10px;
            opacity: 0;
        }
        .title-tagline.visible {
            animation: tagline-in 1s ease-out 0.5s forwards;
        }
        @keyframes tagline-in {
            0% { opacity: 0; letter-spacing: 20px; }
            100% { opacity: 1; letter-spacing: 10px; }
        }
        
        /* 원형 로더 */
        #intro-loader {
            display: none;
            position: relative;
            width: 100px;
            height: 100px;
        }
        #intro-loader.visible {
            display: block;
            animation: loader-in 0.5s ease-out forwards;
        }
        @keyframes loader-in {
            0% { opacity: 0; transform: scale(0.5); }
            100% { opacity: 1; transform: scale(1); }
        }
        .loader-ring {
            width: 100%;
            height: 100%;
            transform: rotate(-90deg);
        }
        .loader-bg {
            fill: none;
            stroke: rgba(255,255,255,0.1);
            stroke-width: 2;
        }
        .loader-progress {
            fill: none;
            stroke: url(#loader-gradient);
            stroke-width: 2;
            stroke-linecap: round;
            stroke-dasharray: 283;
            stroke-dashoffset: 283;
            transition: stroke-dashoffset 0.3s ease-out;
            filter: drop-shadow(0 0 6px rgba(0,255,255,0.8));
        }
        .loader-percent {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            color: #fff;
        }
        
        /* 시작 버튼 */
        #intro-start {
            display: none;
        }
        #intro-start.visible {
            display: block;
            animation: start-in 1s ease-out forwards;
        }
        @keyframes start-in {
            0% { opacity: 0; transform: translateY(20px); }
            100% { opacity: 1; transform: translateY(0); }
        }
        #intro-start-btn {
            position: relative;
            background: transparent;
            border: none;
            padding: 20px 50px;
            cursor: pointer;
            overflow: hidden;
        }
        #intro-start-btn .btn-border {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            border: 1px solid rgba(0,255,255,0.4);
            border-radius: 4px;
            transition: all 0.3s;
        }
        #intro-start-btn:hover .btn-border {
            border-color: rgba(0,255,255,0.8);
            box-shadow: 0 0 20px rgba(0,255,255,0.3), inset 0 0 20px rgba(0,255,255,0.1);
        }
        #intro-start-btn .btn-text {
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            color: rgba(255,255,255,0.8);
            letter-spacing: 4px;
            transition: all 0.3s;
        }
        #intro-start-btn:hover .btn-text {
            color: #00ffff;
            text-shadow: 0 0 10px rgba(0,255,255,0.5);
        }
        
        /* 스킵 */
        #intro-skip {
            position: absolute;
            bottom: 14%;
            right: 40px;
            font-family: 'Rajdhani', sans-serif;
            font-size: 12px;
            color: rgba(255,255,255,0.3);
            letter-spacing: 2px;
            cursor: pointer;
            z-index: 30;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        #intro-skip:hover {
            color: rgba(255,255,255,0.7);
        }
        .skip-arrow {
            transition: transform 0.3s;
        }
        #intro-skip:hover .skip-arrow {
            transform: translateX(3px);
        }
        
        /* 하단 텍스트 */
        #intro-bottom-text {
            position: absolute;
            bottom: 14%;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Rajdhani', sans-serif;
            font-size: 10px;
            color: rgba(255,255,255,0.2);
            letter-spacing: 2px;
            z-index: 30;
        }
        
        /* ★★★ 가로모드 회전 안내 ★★★ */
        #rotate-screen-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3a 100%);
            z-index: 9999999;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        .rotate-content {
            text-align: center;
            animation: rotate-float 3s ease-in-out infinite;
        }
        @keyframes rotate-float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        .rotate-icon {
            font-size: 80px;
            animation: rotate-phone 2s ease-in-out infinite;
            display: inline-block;
        }
        @keyframes rotate-phone {
            0%, 100% { transform: rotate(0deg); }
            50% { transform: rotate(90deg); }
        }
        .rotate-arrow {
            font-size: 40px;
            color: #00ffff;
            margin: 20px 0;
            animation: rotate-pulse 1.5s ease-in-out infinite;
        }
        @keyframes rotate-pulse {
            0%, 100% { opacity: 0.5; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.2); }
        }
        .rotate-text {
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            color: #fff;
            letter-spacing: 2px;
            margin-bottom: 10px;
        }
        .rotate-subtext {
            font-family: 'Rajdhani', sans-serif;
            font-size: 14px;
            color: rgba(255,255,255,0.5);
            letter-spacing: 1px;
        }
        
        /* ★★★ 고정 헤더 버튼 스타일 ★★★ */
        #global-header-btns {
            position: fixed;
            top: 15px;
            right: 15px;
            z-index: 100000;
            display: none;  /* ★ 기본 숨김 (메인 메뉴에서) */
            gap: 10px;
        }
        /* ★ 게임 진입 후에만 표시 */
        body.game-started #global-header-btns {
            display: flex;
        }
        .global-header-btn {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: rgba(10, 20, 40, 0.8);
            border: 1px solid rgba(0, 255, 255, 0.3);
            color: #fff;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }
        .global-header-btn:hover {
            background: rgba(0, 150, 200, 0.4);
            border-color: #00ffff;
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
        }
        .global-header-btn .btn-icon {
            line-height: 1;
        }
        /* 조종 모드에서는 숨김 */
        body.pilot-mode #global-header-btns {
            display: none;
        }
        
        /* 게임 모드 진입 시 세로모드면 안내 표시 */
        @media screen and (orientation: portrait) {
            body.game-mode #rotate-screen-overlay {
                display: flex !important;
            }
        }
        @media screen and (orientation: landscape) {
            body.game-mode #rotate-screen-overlay {
                display: none !important;
            }
        }
    </style>
    <!-- Supabase SDK (로컬 파일) -->
    <script src="supabase.min.js"></script>
    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/" } }
    </script>
</head>
<body>
<script>console.log('===== 버전 2.2 로드됨 =====');</script>
<!-- ★★★ 시네마틱 인트로 ★★★ -->
<div id="intro-overlay">
    <canvas id="intro-canvas"></canvas>
    
    <!-- 레터박스 (시네마틱 바) -->
    <div class="letterbox letterbox-top"></div>
    <div class="letterbox letterbox-bottom"></div>
    
    <!-- 렌즈 플레어 -->
    <div id="lens-flare"></div>
    
    <!-- 메인 컨텐츠 -->
    <div id="intro-content">
        <!-- 회사 로고 (Anthropic 스타일) -->
        <div id="studio-logo">
            <div class="studio-icon">◆</div>
            <div class="studio-text">SINNARU STUDIO</div>
        </div>
        
        <!-- 메인 타이틀 -->
        <div id="main-title">
            <div class="title-line"></div>
            <div class="title-text">
                <span class="char">S</span><span class="char">T</span><span class="char">A</span><span class="char">R</span>
                <span class="char dot">·</span>
                <span class="char">S</span><span class="char">T</span><span class="char">R</span><span class="char">I</span><span class="char">D</span><span class="char">E</span><span class="char">R</span>
            </div>
            <div class="title-line"></div>
            <div class="title-tagline">EXPLORE THE UNIVERSE</div>
        </div>
        
        <!-- 원형 로딩 -->
        <div id="intro-loader">
            <svg class="loader-ring" viewBox="0 0 100 100">
                <circle class="loader-bg" cx="50" cy="50" r="45"/>
                <circle class="loader-progress" cx="50" cy="50" r="45"/>
            </svg>
            <div class="loader-percent"><span id="intro-percent">0</span>%</div>
        </div>
        
        <!-- 시작 버튼 -->
        <div id="intro-start">
            <button id="intro-start-btn">
                <span class="btn-border"></span>
                <span class="btn-text">PRESS TO LAUNCH</span>
            </button>
        </div>
    </div>
    
    <!-- 스킵 -->
    <div id="intro-skip">SKIP <span class="skip-arrow">»</span></div>
    
    <!-- 하단 텍스트 -->
    <div id="intro-bottom-text">© 2025 SINNARU STUDIO. ALL RIGHTS RESERVED.</div>
</div>

<!-- ★★★ STAR·WALKER 메인 메뉴 ★★★ -->
<div id="mode-select-overlay" style="display:none;">

<!-- ★★★ 고정 헤더 버튼 (모든 화면에서 표시) ★★★ -->
<div id="global-header-btns">
    <button id="global-profile-btn" class="global-header-btn" title="Profile">
        <span class="btn-icon">👤</span>
    </button>
    <button id="global-settings-btn" class="global-header-btn" title="Settings">
        <span class="btn-icon">⚙️</span>
    </button>
</div>

<!-- ★★★ 가로모드 회전 안내 ★★★ -->
<div id="rotate-screen-overlay">
    <div class="rotate-content">
        <div class="rotate-icon">📱</div>
        <div class="rotate-arrow">↻</div>
        <div class="rotate-text">Please rotate your device</div>
        <div class="rotate-subtext">가로 모드로 전환해주세요</div>
    </div>
</div>
    <!-- 배경 효과 -->
    <div class="voyager-bg-stars"></div>
    <div class="voyager-bg-nebula"></div>
    
    <!-- 메인 컨텐츠 -->
    <div class="voyager-main-content">
        <!-- 로고 -->
        <div class="voyager-logo">
            <div class="voyager-logo-icon">✦</div>
            <div class="voyager-logo-text">STAR<span class="logo-dot">·</span>WALKER</div>
            <div class="voyager-logo-tagline">SPACE EXPLORATION SIMULATOR</div>
        </div>
        
        <!-- 메뉴 버튼들 -->
        <div class="voyager-menu">
            <button id="btn-single" class="voyager-btn primary">
                <div class="btn-icon">🌌</div>
                <div class="btn-content">
                    <div class="btn-title" data-i18n="singlePlay">Single Play</div>
                    <div class="btn-desc" data-i18n="singleDesc">Free space exploration • Create celestial bodies • Unlimited</div>
                </div>
                <div class="btn-arrow">›</div>
            </button>
            
            <button id="btn-multi" class="voyager-btn secondary">
                <div class="btn-icon">🌐</div>
                <div class="btn-content">
                    <div class="btn-title" data-i18n="multiPlay">Multiplayer</div>
                    <div class="btn-desc" data-i18n="multiDesc">Real-time chat • Co-op exploration • Competition</div>
                </div>
                <div class="btn-arrow">›</div>
            </button>
            
            <button id="btn-login-main" class="voyager-btn tertiary">
                <div class="btn-icon">🔑</div>
                <div class="btn-content">
                    <div class="btn-title" data-i18n="loginBtn">Login</div>
                    <div class="btn-desc" data-i18n="loginDesc">Account sync • Save progress • Rankings</div>
                </div>
                <div class="btn-arrow">›</div>
            </button>
            
            <div class="voyager-btn-row" style="justify-content: center;">
                <button id="btn-settings" class="voyager-btn-small">
                    <div class="btn-icon">⚙️</div>
                    <div class="btn-title" data-i18n="settings">Settings</div>
                </button>
            </div>
        </div>
        
        <!-- 하단 정보 -->
        <div class="voyager-footer">
            <div class="voyager-version">v1.0</div>
        </div>
    </div>
</div>

<style>
/* ★★★ STAR·WALKER 메인 메뉴 스타일 ★★★ */
#mode-select-overlay {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: linear-gradient(135deg, #0a0a1a 0%, #0d1b2a 50%, #1b263b 100%);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 99999;
    overflow: hidden;
}

/* 배경 별 효과 */
.voyager-bg-stars {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background-image: 
        radial-gradient(2px 2px at 20px 30px, #fff, transparent),
        radial-gradient(2px 2px at 40px 70px, rgba(255,255,255,0.8), transparent),
        radial-gradient(1px 1px at 90px 40px, #fff, transparent),
        radial-gradient(2px 2px at 160px 120px, rgba(0,255,255,0.6), transparent),
        radial-gradient(1px 1px at 230px 80px, #fff, transparent),
        radial-gradient(2px 2px at 300px 150px, rgba(255,255,255,0.7), transparent);
    background-size: 350px 200px;
    animation: starFloat 60s linear infinite;
    opacity: 0.6;
}

/* 성운 효과 */
.voyager-bg-nebula {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: 
        radial-gradient(ellipse at 20% 80%, rgba(0, 150, 255, 0.15) 0%, transparent 50%),
        radial-gradient(ellipse at 80% 20%, rgba(138, 43, 226, 0.1) 0%, transparent 50%),
        radial-gradient(ellipse at 50% 50%, rgba(0, 255, 200, 0.05) 0%, transparent 70%);
    animation: nebulaShift 30s ease-in-out infinite alternate;
}

@keyframes starFloat {
    0% { transform: translateY(0); }
    100% { transform: translateY(-200px); }
}

@keyframes nebulaShift {
    0% { opacity: 0.8; }
    100% { opacity: 1; }
}

/* 메인 컨텐츠 */
.voyager-main-content {
    position: relative;
    z-index: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
    max-width: 400px;
    width: 100%;
}

/* 로고 */
.voyager-logo {
    text-align: center;
    margin-bottom: 40px;
}

.voyager-logo-icon {
    font-size: 60px;
    margin-bottom: 10px;
    animation: logoFloat 3s ease-in-out infinite;
    filter: drop-shadow(0 0 20px rgba(0, 200, 255, 0.5));
}

@keyframes logoFloat {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-10px); }
}

.voyager-logo-text {
    font-family: 'Orbitron', 'Rajdhani', sans-serif;
    font-size: 42px;
    font-weight: 900;
    letter-spacing: 4px;
    background: linear-gradient(135deg, #00d4ff 0%, #00ff88 50%, #00d4ff 100%);
    background-size: 200% auto;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    animation: logoShine 3s linear infinite;
    text-shadow: 0 0 30px rgba(0, 212, 255, 0.5);
}

.voyager-logo-text .logo-dot {
    color: #fff;
    -webkit-text-fill-color: #fff;
    text-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
    animation: dotPulse 2s ease-in-out infinite;
}

@keyframes dotPulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
}

@keyframes logoShine {
    0% { background-position: 0% center; }
    100% { background-position: 200% center; }
}

.voyager-logo-tagline {
    font-family: 'Orbitron', sans-serif;
    font-size: 10px;
    letter-spacing: 4px;
    color: rgba(0, 212, 255, 0.7);
    margin-top: 8px;
}

/* 메뉴 */
.voyager-menu {
    display: flex;
    flex-direction: column;
    gap: 12px;
    width: 100%;
}

/* 메인 버튼 */
.voyager-btn {
    display: flex;
    align-items: center;
    width: 100%;
    padding: 16px 20px;
    border: none;
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
    text-align: left;
}

.voyager-btn::before {
    content: '';
    position: absolute;
    top: 0; left: -100%;
    width: 100%; height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
    transition: left 0.5s;
}

.voyager-btn:hover::before {
    left: 100%;
}

.voyager-btn:active {
    transform: scale(0.98);
}

/* Primary 버튼 (싱글) */
.voyager-btn.primary {
    background: linear-gradient(135deg, rgba(0, 100, 150, 0.8) 0%, rgba(0, 150, 200, 0.6) 100%);
    border: 2px solid rgba(0, 200, 255, 0.5);
    box-shadow: 0 0 20px rgba(0, 200, 255, 0.2), inset 0 1px 0 rgba(255,255,255,0.1);
}

.voyager-btn.primary:hover {
    border-color: rgba(0, 255, 255, 0.8);
    box-shadow: 0 0 30px rgba(0, 255, 255, 0.4), inset 0 1px 0 rgba(255,255,255,0.2);
}

/* Secondary 버튼 (멀티) */
.voyager-btn.secondary {
    background: linear-gradient(135deg, rgba(100, 50, 150, 0.8) 0%, rgba(150, 80, 200, 0.6) 100%);
    border: 2px solid rgba(180, 100, 255, 0.5);
    box-shadow: 0 0 20px rgba(150, 100, 255, 0.2), inset 0 1px 0 rgba(255,255,255,0.1);
}

.voyager-btn.secondary:hover {
    border-color: rgba(200, 150, 255, 0.8);
    box-shadow: 0 0 30px rgba(180, 100, 255, 0.4), inset 0 1px 0 rgba(255,255,255,0.2);
}

/* Tertiary 버튼 (미션) */
.voyager-btn.tertiary {
    background: linear-gradient(135deg, rgba(150, 100, 0, 0.8) 0%, rgba(200, 150, 50, 0.6) 100%);
    border: 2px solid rgba(255, 200, 100, 0.5);
    box-shadow: 0 0 20px rgba(255, 180, 50, 0.2), inset 0 1px 0 rgba(255,255,255,0.1);
}

.voyager-btn.tertiary:hover {
    border-color: rgba(255, 220, 150, 0.8);
    box-shadow: 0 0 30px rgba(255, 200, 100, 0.4), inset 0 1px 0 rgba(255,255,255,0.2);
}

.voyager-btn .btn-icon {
    font-size: 28px;
    margin-right: 15px;
    filter: drop-shadow(0 0 5px rgba(255,255,255,0.3));
}

.voyager-btn .btn-content {
    flex: 1;
}

.voyager-btn .btn-title {
    font-family: 'Orbitron', sans-serif;
    font-size: 16px;
    font-weight: 700;
    color: #fff;
    margin-bottom: 4px;
}

.voyager-btn .btn-desc {
    font-size: 11px;
    color: rgba(255, 255, 255, 0.7);
}

.voyager-btn .btn-arrow {
    font-size: 24px;
    color: rgba(255, 255, 255, 0.5);
    transition: transform 0.3s;
}

.voyager-btn:hover .btn-arrow {
    transform: translateX(5px);
    color: rgba(255, 255, 255, 0.9);
}

/* 작은 버튼 행 */
.voyager-btn-row {
    display: flex;
    gap: 12px;
    margin-top: 8px;
}

.voyager-btn-small {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 15px;
    background: linear-gradient(135deg, rgba(50, 50, 70, 0.8) 0%, rgba(70, 70, 90, 0.6) 100%);
    border: 2px solid rgba(100, 100, 150, 0.5);
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.voyager-btn-small:hover {
    border-color: rgba(150, 150, 200, 0.8);
    box-shadow: 0 0 20px rgba(100, 100, 200, 0.3);
}

.voyager-btn-small:active {
    transform: scale(0.95);
}

.voyager-btn-small .btn-icon {
    font-size: 24px;
    margin-bottom: 5px;
}

.voyager-btn-small .btn-title {
    font-family: 'Orbitron', sans-serif;
    font-size: 12px;
    color: rgba(255, 255, 255, 0.9);
}

/* 푸터 */
.voyager-footer {
    margin-top: 30px;
    text-align: center;
}

.voyager-version {
    font-family: 'Orbitron', sans-serif;
    font-size: 10px;
    color: rgba(255, 255, 255, 0.3);
    letter-spacing: 2px;
}

/* 모바일 최적화 */
@media (max-width: 480px) {
    .voyager-logo-text {
        font-size: 36px;
        letter-spacing: 5px;
    }
    
    .voyager-logo-icon {
        font-size: 50px;
    }
    
    .voyager-logo-tagline {
        font-size: 8px;
        letter-spacing: 2px;
    }
    
    .voyager-btn {
        padding: 14px 16px;
    }
    
    .voyager-btn .btn-icon {
        font-size: 24px;
        margin-right: 12px;
    }
    
    .voyager-btn .btn-title {
        font-size: 14px;
    }
    
    .voyager-btn .btn-desc {
        font-size: 10px;
    }
}

/* 스캔라인 효과 (선택적) */
#mode-select-overlay::after {
    content: '';
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: repeating-linear-gradient(
        0deg,
        transparent,
        transparent 2px,
        rgba(0, 0, 0, 0.03) 2px,
        rgba(0, 0, 0, 0.03) 4px
    );
    pointer-events: none;
}
</style>

<!-- ★★★ 설정 모달 ★★★ -->
<div id="settings-modal" class="voyager-modal">
    <div class="voyager-modal-content">
        <div class="voyager-modal-header">
            <div class="modal-title" data-i18n="settings">⚙️ 설정</div>
            <button class="modal-close" id="settings-close">✕</button>
        </div>
        <div class="voyager-modal-body">
            <div class="settings-section">
                <div class="settings-label" data-i18n="sound">🔊 소리</div>
                <div class="settings-control">
                    <input type="range" id="settings-volume" min="0" max="100" value="50">
                    <span id="settings-volume-val">50%</span>
                </div>
            </div>
            <div class="settings-section">
                <div class="settings-label" data-i18n="graphics">🎨 그래픽</div>
                <div class="settings-control">
                    <select id="settings-graphics">
                        <option value="low" data-i18n="graphicsLow">낮음</option>
                        <option value="medium" selected data-i18n="graphicsMedium">중간</option>
                        <option value="high" data-i18n="graphicsHigh">높음</option>
                    </select>
                </div>
            </div>
            <div class="settings-section">
                <div class="settings-label" data-i18n="language">🌐 언어</div>
                <div class="settings-control">
                    <select id="settings-language">
                        <option value="en" selected>English</option>
                        <option value="ko">한국어</option>
                        <option value="ja">日本語</option>
                        <option value="zh">中文</option>
                        <option value="fr">Français</option>
                        <option value="la">Latina</option>
                    </select>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- ★★★ 천체 정보 팝업 (터치 시 표시) ★★★ -->
<div id="body-info-popup" class="body-info-popup">
    <div class="popup-header">
        <span class="popup-icon">🌍</span>
        <span class="popup-name">Earth</span>
        <span class="popup-type">Planet</span>
    </div>
    <div class="popup-stats">
        <div class="stat-row"><span class="stat-label" data-i18n="bodyRadius">반지름</span><span class="stat-value" id="popup-radius">6,371 km</span></div>
        <div class="stat-row"><span class="stat-label" data-i18n="bodyMass">질량</span><span class="stat-value" id="popup-mass">5.97×10²⁴ kg</span></div>
        <div class="stat-row"><span class="stat-label" data-i18n="bodyDistance">거리</span><span class="stat-value" id="popup-distance">0 km</span></div>
    </div>
    <button class="popup-detail-btn" id="popup-detail-btn" data-i18n="bodyDetailBtn">📖 상세보기</button>
</div>

<!-- ★★★ 천체 상세보기 모달 ★★★ -->
<div id="body-detail-modal" class="body-detail-modal">
    <div class="detail-modal-content">
        <button class="detail-close-btn" id="body-detail-close">✕</button>
        
        <div class="detail-header">
            <div class="detail-icon-wrap">
                <div class="detail-icon">🌍</div>
            </div>
            <div class="detail-title-wrap">
                <h2 class="detail-name">Earth</h2>
                <span class="detail-type">Rocky Planet</span>
            </div>
        </div>
        
        <div class="detail-body">
            <div class="detail-section">
                <h3 data-i18n="bodyBasicInfo">📊 기본 정보</h3>
                <div class="detail-grid">
                    <div class="detail-item">
                        <span class="item-label" data-i18n="bodyRadius">반지름</span>
                        <span class="item-value" id="detail-radius">6,371 km</span>
                    </div>
                    <div class="detail-item">
                        <span class="item-label" data-i18n="bodyMass">질량</span>
                        <span class="item-value" id="detail-mass">5.97×10²⁴ kg</span>
                    </div>
                    <div class="detail-item">
                        <span class="item-label" data-i18n="bodyRotation">자전 속도</span>
                        <span class="item-value" id="detail-rotation">1 day</span>
                    </div>
                    <div class="detail-item">
                        <span class="item-label" data-i18n="bodySurfaceGravity">표면 중력</span>
                        <span class="item-value" id="detail-gravity">9.8 m/s²</span>
                    </div>
                </div>
            </div>
            
            <div class="detail-section">
                <h3 data-i18n="bodyOrbitInfo">🛰️ 궤도 정보</h3>
                <div class="detail-grid">
                    <div class="detail-item">
                        <span class="item-label" data-i18n="bodyDistance">현재 거리</span>
                        <span class="item-value" id="detail-distance">149.6M km</span>
                    </div>
                    <div class="detail-item">
                        <span class="item-label" data-i18n="bodyOrbitalSpeed">공전 속도</span>
                        <span class="item-value" id="detail-orbital-speed">29.78 km/s</span>
                    </div>
                    <div class="detail-item">
                        <span class="item-label" data-i18n="bodyMoons">위성 수</span>
                        <span class="item-value" id="detail-moons">1</span>
                    </div>
                    <div class="detail-item">
                        <span class="item-label" data-i18n="bodyRings">고리</span>
                        <span class="item-value" id="detail-rings" data-i18n="none">없음</span>
                    </div>
                </div>
            </div>
            
            <div class="detail-section">
                <h3 data-i18n="bodyDescription">📝 설명</h3>
                <p class="detail-description" id="detail-description">
                    지구는 태양계에서 세 번째 행성이며, 알려진 유일한 생명체가 존재하는 천체입니다.
                </p>
            </div>
            
            <div class="detail-actions">
                <button class="detail-action-btn" id="detail-focus-btn" data-i18n="bodyFocusBtn">🎯 추적하기</button>
                <button class="detail-action-btn" id="detail-nav-btn" data-i18n="bodyNavBtn">🧭 항법 목표 설정</button>
            </div>
        </div>
    </div>
</div>

<style>
/* ★★★ 천체 정보 팝업 스타일 ★★★ */
.body-info-popup {
    position: fixed;
    display: none;
    background: linear-gradient(135deg, rgba(10, 20, 40, 0.95) 0%, rgba(5, 15, 35, 0.98) 100%);
    border: 2px solid rgba(0, 200, 255, 0.5);
    border-radius: 12px;
    padding: 12px 15px;
    min-width: 180px;
    max-width: 220px;
    z-index: 2000;
    pointer-events: auto;
    box-shadow: 0 0 30px rgba(0, 200, 255, 0.3), inset 0 0 20px rgba(0, 100, 150, 0.1);
    backdrop-filter: blur(10px);
    animation: popupFadeIn 0.3s ease;
    font-family: 'Rajdhani', sans-serif;
}

.body-info-popup::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 2px;
    background: linear-gradient(90deg, transparent, #00d4ff, transparent);
}

@keyframes popupFadeIn {
    from { opacity: 0; transform: scale(0.9) translateY(10px); }
    to { opacity: 1; transform: scale(1) translateY(0); }
}

.popup-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 10px;
    padding-bottom: 8px;
    border-bottom: 1px solid rgba(0, 200, 255, 0.2);
}

.popup-icon {
    font-size: 24px;
    filter: drop-shadow(0 0 5px currentColor);
}

.popup-name {
    font-family: 'Orbitron', sans-serif;
    font-size: 14px;
    font-weight: 600;
    color: #00d4ff;
    flex: 1;
}

.popup-type {
    font-size: 10px;
    color: #888;
    background: rgba(0, 200, 255, 0.1);
    padding: 2px 6px;
    border-radius: 4px;
    text-transform: uppercase;
}

.popup-stats {
    margin-bottom: 10px;
}

.stat-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 4px 0;
    font-size: 11px;
}

.stat-label {
    color: #888;
}

.stat-value {
    color: #00ff88;
    font-family: 'Orbitron', monospace;
    font-size: 10px;
}

.popup-detail-btn {
    width: 100%;
    padding: 8px;
    background: linear-gradient(135deg, rgba(0, 150, 255, 0.3) 0%, rgba(0, 100, 200, 0.2) 100%);
    border: 1px solid rgba(0, 200, 255, 0.5);
    border-radius: 6px;
    color: #00d4ff;
    font-family: 'Orbitron', sans-serif;
    font-size: 11px;
    cursor: pointer;
    transition: all 0.3s;
}

.popup-detail-btn:hover {
    background: rgba(0, 200, 255, 0.3);
    box-shadow: 0 0 15px rgba(0, 200, 255, 0.4);
}

/* ★★★ 천체 상세보기 모달 스타일 ★★★ */
.body-detail-modal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 5, 15, 0.9);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 10000;
    backdrop-filter: blur(5px);
    animation: modalFadeIn 0.3s ease;
}

.body-detail-modal.open {
    display: flex;
}

@keyframes modalFadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

.detail-modal-content {
    background: linear-gradient(180deg, rgba(10, 25, 50, 0.98) 0%, rgba(5, 15, 35, 0.99) 100%);
    border: 2px solid rgba(0, 200, 255, 0.4);
    border-radius: 16px;
    width: 90%;
    max-width: 450px;
    max-height: 85vh;
    overflow-y: auto;
    position: relative;
    box-shadow: 0 0 50px rgba(0, 150, 255, 0.3);
    animation: contentSlideIn 0.4s ease;
}

@keyframes contentSlideIn {
    from { transform: translateY(30px) scale(0.95); opacity: 0; }
    to { transform: translateY(0) scale(1); opacity: 1; }
}

.detail-close-btn {
    position: absolute;
    top: 15px;
    right: 15px;
    width: 36px;
    height: 36px;
    background: rgba(255, 50, 50, 0.2);
    border: 1px solid rgba(255, 100, 100, 0.4);
    border-radius: 50%;
    color: #ff6666;
    font-size: 18px;
    cursor: pointer;
    transition: all 0.3s;
    z-index: 10;
}

.detail-close-btn:hover {
    background: rgba(255, 50, 50, 0.4);
    transform: rotate(90deg);
}

.detail-header {
    display: flex;
    align-items: center;
    gap: 20px;
    padding: 25px;
    background: linear-gradient(135deg, rgba(0, 100, 150, 0.2) 0%, transparent 100%);
    border-bottom: 1px solid rgba(0, 200, 255, 0.2);
}

.detail-icon-wrap {
    width: 70px;
    height: 70px;
    background: radial-gradient(circle, rgba(0, 150, 255, 0.3) 0%, transparent 70%);
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    border: 2px solid rgba(0, 200, 255, 0.3);
    box-shadow: 0 0 20px rgba(0, 150, 255, 0.3);
}

.detail-icon {
    font-size: 40px;
    filter: drop-shadow(0 0 10px currentColor);
}

.detail-title-wrap {
    flex: 1;
}

.detail-name {
    font-family: 'Orbitron', sans-serif;
    font-size: 22px;
    color: #00d4ff;
    margin: 0 0 5px 0;
    text-shadow: 0 0 10px rgba(0, 200, 255, 0.5);
}

.detail-type {
    font-size: 12px;
    color: #888;
    background: rgba(0, 200, 255, 0.1);
    padding: 3px 10px;
    border-radius: 10px;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.detail-body {
    padding: 20px 25px;
}

.detail-section {
    margin-bottom: 20px;
}

.detail-section h3 {
    font-family: 'Orbitron', sans-serif;
    font-size: 13px;
    color: #00aaff;
    margin: 0 0 12px 0;
    padding-bottom: 8px;
    border-bottom: 1px solid rgba(0, 150, 255, 0.2);
}

.detail-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
}

.detail-item {
    background: rgba(0, 50, 100, 0.2);
    border: 1px solid rgba(0, 150, 255, 0.15);
    border-radius: 8px;
    padding: 10px;
}

.item-label {
    display: block;
    font-size: 10px;
    color: #888;
    margin-bottom: 4px;
    text-transform: uppercase;
}

.item-value {
    display: block;
    font-family: 'Orbitron', monospace;
    font-size: 13px;
    color: #00ff88;
}

.detail-description {
    font-size: 13px;
    line-height: 1.7;
    color: #aaa;
    margin: 0;
    background: rgba(0, 50, 100, 0.15);
    padding: 12px;
    border-radius: 8px;
    border-left: 3px solid rgba(0, 200, 255, 0.4);
}

.detail-actions {
    display: flex;
    gap: 10px;
    margin-top: 20px;
}

.detail-action-btn {
    flex: 1;
    padding: 12px;
    background: linear-gradient(135deg, rgba(0, 150, 255, 0.2) 0%, rgba(0, 100, 200, 0.1) 100%);
    border: 1px solid rgba(0, 200, 255, 0.4);
    border-radius: 8px;
    color: #00d4ff;
    font-family: 'Orbitron', sans-serif;
    font-size: 11px;
    cursor: pointer;
    transition: all 0.3s;
}

.detail-action-btn:hover {
    background: rgba(0, 200, 255, 0.3);
    box-shadow: 0 0 20px rgba(0, 200, 255, 0.3);
    transform: translateY(-2px);
}

/* 스크롤바 스타일 */
.detail-modal-content::-webkit-scrollbar {
    width: 6px;
}
.detail-modal-content::-webkit-scrollbar-track {
    background: rgba(0, 50, 100, 0.2);
}
.detail-modal-content::-webkit-scrollbar-thumb {
    background: rgba(0, 200, 255, 0.4);
    border-radius: 3px;
}

/* 모바일 반응형 */
@media (max-width: 480px) {
    .detail-modal-content {
        width: 95%;
        max-height: 90vh;
    }
    .detail-header {
        padding: 20px;
    }
    .detail-icon-wrap {
        width: 55px;
        height: 55px;
    }
    .detail-icon {
        font-size: 30px;
    }
    .detail-name {
        font-size: 18px;
    }
    .detail-grid {
        grid-template-columns: 1fr;
    }
}
</style>

<!-- ★★★ 미션 보드 모달 ★★★ -->
<div id="mission-board-modal" class="voyager-modal">
    <div class="voyager-modal-content wide">
        <div class="voyager-modal-header">
            <div class="modal-title" data-i18n="missionBoard">📋 Mission Board</div>
            <button class="modal-close" id="mission-board-close">✕</button>
        </div>
        <div class="voyager-modal-body">
            <div class="mission-tabs">
                <button class="mission-tab active" data-tab="active" data-i18n="missionActive">Active</button>
                <button class="mission-tab" data-tab="available" data-i18n="missionAvailable">Available</button>
                <button class="mission-tab" data-tab="completed" data-i18n="missionCompleted">Completed</button>
            </div>
            <div class="mission-list" id="mission-list">
                <!-- 동적으로 채워짐 -->
            </div>
        </div>
    </div>
</div>

<script>
// ★★★ 미션 시스템 ★★★
const MissionSystem = {
    // 다국어 미션 데이터
    getMissionData() {
        const lang = window.currentLang || (typeof currentLang !== 'undefined' ? currentLang : 'en');
        
        if (lang === 'ko') {
            return {
                tutorials: [
                    { id: 'tut_board', name: '우주선 탑승', desc: 'ISS 우주정거장에서 우주선 탑승', icon: '🚀', reward: 50, type: 'tutorial' },
                    { id: 'tut_move', name: '첫 비행', desc: '우주선으로 100 유닛 이상 비행', icon: '✈️', reward: 50, type: 'tutorial', target: 100 },
                    { id: 'tut_target', name: '항법 목표 설정', desc: '항법 목표 설정하기', icon: '🎯', reward: 30, type: 'tutorial' },
                    { id: 'tut_autopilot', name: '자동항법 사용', desc: '자동항법 활성화', icon: '🤖', reward: 50, type: 'tutorial' },
                    { id: 'tut_dock', name: '도킹 성공', desc: '우주 정거장에 도킹', icon: '🔗', reward: 100, type: 'tutorial' },
                    { id: 'tut_refuel', name: '연료 보급', desc: '정거장에서 연료 보급', icon: '⛽', reward: 30, type: 'tutorial' }
                ],
                exploration: [
                    { id: 'exp_earth', name: '지구 궤도', desc: '지구 주위 궤도 진입', icon: '🌍', reward: 100, type: 'exploration', target: '지구' },
                    { id: 'exp_moon', name: '달 탐사', desc: '달에 접근', icon: '🌙', reward: 150, type: 'exploration', target: '달' },
                    { id: 'exp_mars', name: '화성 탐사', desc: '화성에 접근', icon: '🔴', reward: 250, type: 'exploration', target: '화성' },
                    { id: 'exp_jupiter', name: '목성 근접 통과', desc: '목성에 접근', icon: '🪐', reward: 500, type: 'exploration', target: '목성', minLevel: 3 },
                    { id: 'exp_saturn', name: '토성 고리 탐험', desc: '토성에 접근', icon: '💫', reward: 600, type: 'exploration', target: '토성', minLevel: 4 }
                ]
            };
        } else if (lang === 'ja') {
            return {
                tutorials: [
                    { id: 'tut_board', name: '宇宙船搭乗', desc: 'ISS宇宙ステーションで宇宙船に搭乗', icon: '🚀', reward: 50, type: 'tutorial' },
                    { id: 'tut_move', name: '初飛行', desc: '宇宙船で100ユニット以上飛行', icon: '✈️', reward: 50, type: 'tutorial', target: 100 },
                    { id: 'tut_target', name: '航法目標設定', desc: '航法目標を設定', icon: '🎯', reward: 30, type: 'tutorial' },
                    { id: 'tut_autopilot', name: '自動航法使用', desc: '自動航法を有効化', icon: '🤖', reward: 50, type: 'tutorial' },
                    { id: 'tut_dock', name: 'ドッキング成功', desc: '宇宙ステーションにドッキング', icon: '🔗', reward: 100, type: 'tutorial' },
                    { id: 'tut_refuel', name: '燃料補給', desc: 'ステーションで燃料補給', icon: '⛽', reward: 30, type: 'tutorial' }
                ],
                exploration: [
                    { id: 'exp_earth', name: '地球軌道', desc: '地球周回軌道に入る', icon: '🌍', reward: 100, type: 'exploration', target: '지구' },
                    { id: 'exp_moon', name: '月探査', desc: '月に接近', icon: '🌙', reward: 150, type: 'exploration', target: '달' },
                    { id: 'exp_mars', name: '火星探査', desc: '火星に接近', icon: '🔴', reward: 250, type: 'exploration', target: '화성' },
                    { id: 'exp_jupiter', name: '木星近接通過', desc: '木星に接近', icon: '🪐', reward: 500, type: 'exploration', target: '목성', minLevel: 3 },
                    { id: 'exp_saturn', name: '土星リング探検', desc: '土星に接近', icon: '💫', reward: 600, type: 'exploration', target: '토성', minLevel: 4 }
                ]
            };
        } else {
            // English (default) - also used for zh, fr, la
            return {
                tutorials: [
                    { id: 'tut_board', name: 'Board Spaceship', desc: 'Board a spaceship at ISS Space Station', icon: '🚀', reward: 50, type: 'tutorial' },
                    { id: 'tut_move', name: 'First Flight', desc: 'Fly more than 100 units with spaceship', icon: '✈️', reward: 50, type: 'tutorial', target: 100 },
                    { id: 'tut_target', name: 'Set Navigation Target', desc: 'Set a navigation target', icon: '🎯', reward: 30, type: 'tutorial' },
                    { id: 'tut_autopilot', name: 'Use Autopilot', desc: 'Activate autopilot', icon: '🤖', reward: 50, type: 'tutorial' },
                    { id: 'tut_dock', name: 'Docking Success', desc: 'Dock at a space station', icon: '🔗', reward: 100, type: 'tutorial' },
                    { id: 'tut_refuel', name: 'Refuel', desc: 'Refuel at a station', icon: '⛽', reward: 30, type: 'tutorial' }
                ],
                exploration: [
                    { id: 'exp_earth', name: 'Earth Orbit', desc: 'Enter orbit around Earth', icon: '🌍', reward: 100, type: 'exploration', target: '지구' },
                    { id: 'exp_moon', name: 'Moon Exploration', desc: 'Approach the Moon', icon: '🌙', reward: 150, type: 'exploration', target: '달' },
                    { id: 'exp_mars', name: 'Mars Exploration', desc: 'Approach Mars', icon: '🔴', reward: 250, type: 'exploration', target: '화성' },
                    { id: 'exp_jupiter', name: 'Jupiter Flyby', desc: 'Approach Jupiter', icon: '🪐', reward: 500, type: 'exploration', target: '목성', minLevel: 3 },
                    { id: 'exp_saturn', name: 'Saturn Ring Exploration', desc: 'Approach Saturn', icon: '💫', reward: 600, type: 'exploration', target: '토성', minLevel: 4 }
                ]
            };
        }
    },
    
    // 현재 언어의 미션 목록 가져오기
    get tutorials() {
        return this.getMissionData().tutorials;
    },
    
    get exploration() {
        return this.getMissionData().exploration;
    },
    
    // 사용자 미션 진행 상황 (localStorage에서 로드)
    progress: {},
    
    init: function() {
        this.loadProgress();
        this.render();
    },
    
    loadProgress: function() {
        const saved = localStorage.getItem('starwalker-missions');
        if (saved) {
            try {
                this.progress = JSON.parse(saved);
            } catch (e) {
                this.progress = {};
            }
        }
        
        // 기본 진행 상황 초기화
        [...this.tutorials, ...this.exploration].forEach(m => {
            if (!this.progress[m.id]) {
                this.progress[m.id] = { current: 0, completed: false, accepted: m.type === 'tutorial' };
            }
        });
    },
    
    saveProgress: function() {
        localStorage.setItem('starwalker-missions', JSON.stringify(this.progress));
    },
    
    // 미션 진행 업데이트
    updateProgress: function(missionId, value = 1) {
        if (!this.progress[missionId]) return;
        if (this.progress[missionId].completed) return;
        
        this.progress[missionId].current += value;
        
        const mission = this.getMission(missionId);
        if (mission) {
            const target = mission.target ? 1 : (mission.targetValue || 1);
            if (typeof target === 'number' && this.progress[missionId].current >= target) {
                this.completeMission(missionId);
            }
        }
        
        this.saveProgress();
        this.render();
    },
    
    // 미션 완료
    completeMission: function(missionId) {
        if (!this.progress[missionId] || this.progress[missionId].completed) return;
        
        const mission = this.getMission(missionId);
        if (!mission) return;
        
        this.progress[missionId].completed = true;
        this.progress[missionId].current = 1;
        
        // 보상 지급
        if (typeof addCoins === 'function') {
            addCoins(mission.reward);
        }
        
        // 경험치 지급
        if (typeof addExp === 'function') {
            addExp(mission.reward);
        }
        
        this.saveProgress();
        showMsg(`🎉 Mission Complete! "${mission.name}" - ${mission.reward} coins earned!`);
    },
    
    getMission: function(id) {
        return [...this.tutorials, ...this.exploration].find(m => m.id === id);
    },
    
    // 미션 보드 렌더링
    render: function(tab = 'active') {
        const list = document.getElementById('mission-list');
        if (!list) return;
        
        list.innerHTML = '';
        
        const allMissions = [...this.tutorials, ...this.exploration];
        const userLevel = window.userLevel || 1;
        
        allMissions.forEach(mission => {
            const prog = this.progress[mission.id] || { current: 0, completed: false, accepted: false };
            
            // 탭 필터링
            if (tab === 'active' && (!prog.accepted || prog.completed)) return;
            if (tab === 'available' && (prog.accepted || prog.completed)) return;
            if (tab === 'completed' && !prog.completed) return;
            
            // 레벨 잠금
            const isLocked = mission.minLevel && userLevel < mission.minLevel;
            
            const card = document.createElement('div');
            card.className = 'mission-card' + (isLocked ? ' locked' : '') + (prog.completed ? ' completed' : '');
            
            const targetValue = typeof mission.target === 'number' ? mission.target : 1;
            const progressPercent = prog.completed ? 100 : Math.min(100, Math.round((prog.current / targetValue) * 100));
            
            card.innerHTML = `
                <div class="mission-icon">${mission.icon}</div>
                <div class="mission-info">
                    <div class="mission-name">${mission.name}</div>
                    <div class="mission-desc">${mission.desc}</div>
                    ${isLocked ? 
                        `<div class="mission-status">🔒 ${currentLang === 'ko' ? '레벨' : currentLang === 'ja' ? 'レベル' : 'Level'} ${mission.minLevel} ${currentLang === 'ko' ? '필요' : currentLang === 'ja' ? '必要' : 'Required'}</div>` :
                        prog.completed ?
                        `<div class="mission-status completed">✅ ${currentLang === 'ko' ? '완료!' : currentLang === 'ja' ? '完了!' : 'Complete!'}</div>` :
                        `<div class="mission-progress">
                            <div class="progress-bar"><div class="progress-fill" style="width: ${progressPercent}%"></div></div>
                            <span>${progressPercent}%</span>
                        </div>`
                    }
                </div>
                <div class="mission-reward">🪙 ${mission.reward}</div>
            `;
            
            // 수락 가능 미션 클릭 시 수락
            if (tab === 'available' && !isLocked && !prog.accepted) {
                card.style.cursor = 'pointer';
                card.onclick = () => {
                    this.progress[mission.id].accepted = true;
                    this.saveProgress();
                    const acceptMsg = currentLang === 'ko' ? `📋 미션 수락: "${mission.name}"` :
                                     currentLang === 'ja' ? `📋 ミッション受諾: "${mission.name}"` :
                                     `📋 Mission Accepted: "${mission.name}"`;
                    showMsg(acceptMsg);
                    this.render('active');
                    // 활성 탭으로 전환
                    document.querySelectorAll('.mission-tab').forEach(t => t.classList.remove('active'));
                    document.querySelector('.mission-tab[data-tab="active"]').classList.add('active');
                };
            }
            
            list.appendChild(card);
        });
        
        // 빈 목록 메시지
        if (list.children.length === 0) {
            const lang = (typeof currentLang !== 'undefined') ? currentLang : 'en';
            let emptyMsg;
            if (lang === 'ko') {
                emptyMsg = tab === 'active' ? '진행 중인 미션이 없습니다' : 
                          tab === 'available' ? '수락 가능한 미션이 없습니다' : 
                          '완료한 미션이 없습니다';
            } else if (lang === 'ja') {
                emptyMsg = tab === 'active' ? '進行中のミッションがありません' : 
                          tab === 'available' ? '受諾可能なミッションがありません' : 
                          '完了したミッションがありません';
            } else {
                emptyMsg = tab === 'active' ? 'No active missions' : 
                          tab === 'available' ? 'No available missions' : 
                          'No completed missions';
            }
            list.innerHTML = `<div style="text-align: center; color: #666; padding: 20px;">${emptyMsg}</div>`;
        }
    }
};

// 미션 완료 스타일 추가
const missionStyle = document.createElement('style');
missionStyle.textContent = `
    .mission-card.completed { opacity: 0.7; border-color: #00ff88; }
    .mission-card.completed .mission-icon { filter: grayscale(0.5); }
    .mission-status.completed { color: #00ff88; font-weight: bold; }
`;
document.head.appendChild(missionStyle);

// 게임 이벤트에서 미션 업데이트 호출
window.MissionSystem = MissionSystem;
</script>

<style>
/* ★★★ VOYAGER 모달 공통 스타일 ★★★ */
.voyager-modal {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(0, 0, 0, 0.9);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 100000;
    backdrop-filter: blur(5px);
}

.voyager-modal.active {
    display: flex;
}

.voyager-modal-content {
    background: linear-gradient(135deg, #0d1b2a 0%, #1b263b 100%);
    border: 2px solid rgba(0, 200, 255, 0.4);
    border-radius: 16px;
    width: 90%;
    max-width: 380px;
    max-height: 80vh;
    overflow: hidden;
    box-shadow: 0 0 40px rgba(0, 200, 255, 0.2);
    animation: modalSlideIn 0.3s ease;
}

.voyager-modal-content.wide {
    max-width: 500px;
}

@keyframes modalSlideIn {
    from { opacity: 0; transform: translateY(-20px) scale(0.95); }
    to { opacity: 1; transform: translateY(0) scale(1); }
}

.voyager-modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 16px 20px;
    background: rgba(0, 0, 0, 0.3);
    border-bottom: 1px solid rgba(0, 200, 255, 0.2);
}

.voyager-modal-header .modal-title {
    font-family: 'Orbitron', sans-serif;
    font-size: 18px;
    color: #00d4ff;
}

.voyager-modal-header .modal-close {
    background: none;
    border: none;
    color: rgba(255, 255, 255, 0.5);
    font-size: 20px;
    cursor: pointer;
    transition: color 0.2s;
}

.voyager-modal-header .modal-close:hover {
    color: #ff5555;
}

.voyager-modal-body {
    padding: 20px;
    overflow-y: auto;
    max-height: calc(80vh - 60px);
}

/* 설정 스타일 */
.settings-section {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 0;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.settings-label {
    font-size: 14px;
    color: rgba(255, 255, 255, 0.9);
}

.settings-control {
    display: flex;
    align-items: center;
    gap: 10px;
}

.settings-control input[type="range"] {
    width: 100px;
    accent-color: #00d4ff;
}

.settings-control select {
    background: rgba(0, 50, 80, 0.8);
    border: 1px solid rgba(0, 200, 255, 0.4);
    color: #fff;
    padding: 6px 12px;
    border-radius: 6px;
    font-size: 12px;
}

.settings-control span {
    font-size: 12px;
    color: #00d4ff;
    min-width: 35px;
}

/* 토글 스위치 */
.toggle-switch {
    position: relative;
    width: 50px;
    height: 26px;
}

.toggle-switch input {
    opacity: 0;
    width: 0;
    height: 0;
}

.toggle-slider {
    position: absolute;
    cursor: pointer;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(100, 100, 100, 0.5);
    border-radius: 26px;
    transition: 0.3s;
}

.toggle-slider::before {
    content: '';
    position: absolute;
    height: 20px;
    width: 20px;
    left: 3px;
    bottom: 3px;
    background: #fff;
    border-radius: 50%;
    transition: 0.3s;
}

.toggle-switch input:checked + .toggle-slider {
    background: rgba(0, 200, 255, 0.7);
}

.toggle-switch input:checked + .toggle-slider::before {
    transform: translateX(24px);
}

/* 미션 보드 스타일 */
.mission-tabs {
    display: flex;
    gap: 8px;
    margin-bottom: 16px;
}

.mission-tab {
    flex: 1;
    padding: 10px;
    background: rgba(50, 50, 70, 0.5);
    border: 1px solid rgba(100, 100, 150, 0.3);
    border-radius: 8px;
    color: rgba(255, 255, 255, 0.6);
    font-size: 12px;
    cursor: pointer;
    transition: all 0.2s;
}

.mission-tab.active {
    background: rgba(0, 150, 200, 0.4);
    border-color: rgba(0, 200, 255, 0.6);
    color: #fff;
}

.mission-list {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.mission-card {
    display: flex;
    align-items: center;
    padding: 14px;
    background: linear-gradient(135deg, rgba(30, 50, 70, 0.8) 0%, rgba(40, 60, 80, 0.6) 100%);
    border: 1px solid rgba(0, 200, 255, 0.3);
    border-radius: 10px;
    transition: all 0.2s;
}

.mission-card:hover {
    border-color: rgba(0, 255, 255, 0.6);
    box-shadow: 0 0 15px rgba(0, 200, 255, 0.2);
}

.mission-card.locked {
    opacity: 0.5;
    filter: grayscale(0.5);
}

.mission-icon {
    font-size: 32px;
    margin-right: 14px;
}

.mission-info {
    flex: 1;
}

.mission-name {
    font-family: 'Orbitron', sans-serif;
    font-size: 14px;
    color: #fff;
    margin-bottom: 4px;
}

.mission-desc {
    font-size: 11px;
    color: rgba(255, 255, 255, 0.6);
    margin-bottom: 8px;
}

.mission-progress {
    display: flex;
    align-items: center;
    gap: 8px;
}

.progress-bar {
    flex: 1;
    height: 6px;
    background: rgba(0, 0, 0, 0.4);
    border-radius: 3px;
    overflow: hidden;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #00d4ff, #00ff88);
    border-radius: 3px;
    transition: width 0.3s;
}

.mission-progress span {
    font-size: 11px;
    color: #00d4ff;
    min-width: 35px;
}

.mission-status {
    font-size: 11px;
    color: rgba(255, 200, 100, 0.8);
}

.mission-reward {
    font-family: 'Orbitron', sans-serif;
    font-size: 14px;
    color: #ffd700;
    text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
}
</style>

<!-- 광고 보상 패널 -->
<div id="ad-rewards-panel" style="
    position: fixed;
    right: 10px;
    top: 15px;
    z-index: 1001;
    display: flex;
    gap: 8px;
    align-items: center;
">
    <button id="ad-menu-toggle" style="
        width: 42px; height: 42px;
        background: linear-gradient(135deg, #ff6b35, #f7931e);
        color: #fff;
        border: 2px solid #ffaa00;
        border-radius: 50%;
        cursor: pointer;
        font-size: 1.3em;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 0 15px rgba(255, 150, 0, 0.5);
        animation: giftPulse 2s ease-in-out infinite;
    ">🎁</button>
</div>
<style>
@keyframes giftPulse {
    0%, 100% { transform: scale(1); box-shadow: 0 0 15px rgba(255, 150, 0, 0.5); }
    50% { transform: scale(1.1); box-shadow: 0 0 25px rgba(255, 150, 0, 0.8); }
}
</style>

<!-- 광고 보상 모달 -->
<div id="ad-modal-menu" style="
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(0,0,0,0.85);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 10000;
">
    <div style="
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        border: 2px solid #0ff;
        border-radius: 15px;
        padding: 25px;
        max-width: 350px;
        width: 90%;
        color: white;
        font-family: 'Orbitron', sans-serif;
    ">
        <h3 style="text-align:center; margin:0 0 20px 0; color:#0ff;" data-i18n="adRewardsTitle">🎁 Ad Rewards</h3>
        
        <!-- 부스터 -->
        <div id="ad-item-booster" class="ad-reward-item" style="
            background: rgba(0,255,255,0.1);
            border: 1px solid #0ff;
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 10px;
        ">
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <div>
                    <div style="font-size:1.1em;" data-i18n="adBoosterTitle">🚀 2x Booster</div>
                    <div style="font-size:0.75em; color:#aaa; margin-top:3px;" data-i18n="adBoosterDesc">2x acceleration & max speed (5 min)</div>
                </div>
                <div id="booster-status" style="font-size:0.8em; color:#0f0;"></div>
            </div>
            <button id="ad-booster-btn" style="
                width: 100%;
                margin-top: 8px;
                padding: 8px;
                background: linear-gradient(135deg, #0a84ff, #0066cc);
                color: white;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-size: 0.85em;
            " data-i18n="watchAd">📺 Watch Ad</button>
        </div>
        
        <!-- 긴급탈출 -->
        <div id="ad-item-escape" class="ad-reward-item" style="
            background: rgba(255,153,0,0.1);
            border: 1px solid #f90;
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 10px;
        ">
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <div>
                    <div style="font-size:1.1em;" data-i18n="adEscapeTitle">⚡ Emergency Escape</div>
                    <div style="font-size:0.75em; color:#aaa; margin-top:3px;" data-i18n="adEscapeDesc">Free emergency escape x1 (10 min)</div>
                </div>
                <div id="escape-status" style="font-size:0.8em; color:#0f0;"></div>
            </div>
            <button id="ad-escape-btn" style="
                width: 100%;
                margin-top: 8px;
                padding: 8px;
                background: linear-gradient(135deg, #f39c12, #d68910);
                color: white;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-size: 0.85em;
            " data-i18n="watchAd">📺 Watch Ad</button>
        </div>
        
        <!-- 둘러보기 (멀티 전용) -->
        <div id="ad-item-explore" class="ad-reward-item" style="
            background: rgba(155,89,182,0.1);
            border: 1px solid #9b59b6;
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 15px;
            display: none;
        ">
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <div>
                    <div style="font-size:1.1em;" data-i18n="adExploreTitle">🔭 Explore Mode</div>
                    <div style="font-size:0.75em; color:#aaa; margin-top:3px;" data-i18n="adExploreDesc">Free camera exploration (3 min, stackable)</div>
                </div>
                <div id="explore-status" style="font-size:0.8em; color:#0f0;"></div>
            </div>
            <button id="ad-explore-btn" style="
                width: 100%;
                margin-top: 8px;
                padding: 8px;
                background: linear-gradient(135deg, #9b59b6, #8e44ad);
                color: white;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-size: 0.85em;
            " data-i18n="watchAd">📺 Watch Ad</button>
        </div>
        
        <button id="ad-modal-close" style="
            width: 100%;
            padding: 10px;
            background: #555;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
        " data-i18n="close">닫기</button>
    </div>
</div>

<!-- SSIL 훈련 미션 패널 -->
<div id="ssil-mission-panel">
    <button class="mission-close-btn" onclick="closeMissionPanel()">✕</button>
    <div class="ssil-logo">🚀</div>
    <h2 data-i18n="ssilTrainingProgram">SSIL 훈련 프로그램</h2>
    <div class="ssil-subtitle" data-i18n="ssilSubtitle">Solar System Integrated Logistics</div>
    
    <table class="mission-table" id="training-mission-table">
        <thead>
            <tr>
                <th class="mission-status">✓</th>
                <th data-i18n="mission">미션</th>
                <th data-i18n="missionDesc">설명</th>
                <th class="mission-reward" data-i18n="reward">보상</th>
            </tr>
        </thead>
        <tbody id="training-mission-body">
            <!-- JavaScript로 채워짐 -->
        </tbody>
    </table>
    
    <div style="text-align:center; margin-top:20px; padding-top:15px; border-top:1px solid rgba(255,255,255,0.1);">
        <div style="color:#888; font-size:0.7em;" data-i18n="totalReward">총 보상</div>
        <div style="color:#ffd700; font-size:1.2em;" id="total-training-reward">0 코인</div>
    </div>
</div>

<!-- 일일 미션 이메일 아이콘 -->
<div id="daily-mission-icon" onclick="openDailyMission()">
    📧
    <span class="badge" id="daily-mission-badge">1</span>
</div>

<!-- 미션 포인트 표시 -->
<div id="mission-points-display">
    ⭐ <span id="mission-points-value">0</span> MP
</div>

<!-- 일일 미션 모달 -->
<div id="daily-mission-modal">
    <div class="daily-mission-content">
        <div class="daily-mission-header">
            <span class="icon">📧</span>
            <div>
                <h3 data-i18n="ssilWorkOrder">SSIL 업무 지시서</h3>
                <div style="font-size:0.7em; color:#888;" data-i18n="urgentDelivery">긴급 배달 요청</div>
            </div>
            <span class="date" id="daily-mission-date">12/15</span>
        </div>
        
        <div class="daily-mission-body" id="daily-mission-desc">
            화성 정거장으로 긴급 물자를 배달해 주세요.
            제한 시간 내 도착 시 추가 보너스가 지급됩니다.
        </div>
        
        <div class="daily-mission-rewards">
            <div class="daily-reward-item">
                <div class="value" id="daily-reward-coins">300</div>
                <div class="label" data-i18n="coins">코인</div>
            </div>
            <div class="daily-reward-item">
                <div class="value" id="daily-reward-points">+1</div>
                <div class="label">MP</div>
            </div>
        </div>
        
        <div class="daily-mission-btns">
            <button class="daily-btn-accept" onclick="acceptDailyMission()" data-i18n="accept">✓ 수락</button>
            <button class="daily-btn-decline" onclick="closeDailyMission()" data-i18n="later">나중에</button>
        </div>
    </div>
</div>

<!-- 중력 경고 HUD -->
<div id="gravity-hud-warning" style="
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(200, 0, 0, 0.85);
    border: 3px solid #ff0000;
    border-radius: 15px;
    padding: 20px 30px;
    color: white;
    font-family: 'Orbitron', monospace;
    z-index: 9999;
    display: none;
    text-align: center;
    animation: gravityPulse 0.5s ease-in-out infinite alternate;
">
    <div style="font-size: 1.5em; margin-bottom: 10px;" data-i18n="gravityCapture">🚨 중력 위험!</div>
    <div id="gravity-body-name" style="font-size: 1.1em; color: #ff0;"></div>
    <div style="margin: 15px 0; border-top: 1px solid rgba(255,255,255,0.3); padding-top: 15px;">
        <div>⚡ <span data-i18n="escapeVelocity">필요 속도</span>: <span id="gravity-escape-vel" style="color: #0ff;">0</span> km/s</div>
        <div>📊 <span data-i18n="currentVelocity">현재 속도</span>: <span id="gravity-current-vel" style="color: #0f0;">0</span> km/s</div>
        <div>📉 <span data-i18n="deficit">부족</span>: <span id="gravity-deficit" style="color: #f90;">0</span> km/s</div>
    </div>
    <div style="margin-top: 10px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 8px;">
        🔄 <span id="gravity-turn-dir" data-i18n="turnLeft">좌측</span><span data-i18n="gravityWarning">으로</span> <span id="gravity-turn-angle">0</span>° <span data-i18n="avoidText">회피</span>
    </div>
</div>
<style>
@keyframes gravityPulse {
    from { box-shadow: 0 0 20px rgba(255,0,0,0.5); }
    to { box-shadow: 0 0 40px rgba(255,0,0,0.9); }
}
/* 사운드 슬라이드 패널 */
#sound-slide {
    position: fixed;
    left: 0;
    bottom: 140px;
    z-index: 1001;
    display: flex;
    align-items: center;
}
#sound-slide-panel {
    background: rgba(0,0,0,0.9);
    border: 1px solid #0ff;
    border-radius: 0 8px 8px 0;
    padding: 6px 8px;
    display: flex;
    align-items: center;
    gap: 6px;
    transition: all 0.3s ease;
    overflow: hidden;
}
#sound-slide.collapsed #sound-slide-panel {
    width: 0;
    padding: 6px 0;
    border: none;
    opacity: 0;
}
#sound-slide.expanded #sound-slide-panel {
    width: auto;
    opacity: 1;
}
#sound-onoff {
    background: #222;
    border: 1px solid #555;
    color: #666;
    width: 26px; height: 26px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.85em;
    display: flex;
    align-items: center;
    justify-content: center;
}
#sound-onoff.on { 
    background: #0a4; 
    border-color: #0f0; 
    color: #fff;
    box-shadow: 0 0 8px #0f0;
}
#sound-slider { width: 50px; cursor: pointer; }
#sound-val { color: #aaa; font-size: 0.6em; min-width: 26px; text-align: right; }
#sound-arrow {
    background: rgba(0,0,0,0.9);
    border: 1px solid #0ff;
    width: 22px; height: 34px;
    cursor: pointer;
    color: #0ff;
    border-radius: 0 6px 6px 0;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.75em;
    flex-shrink: 0;
}
#sound-arrow:hover { background: rgba(0,255,255,0.1); }
/* 긴급탈출 충전 표시 */
@keyframes escapeFlash {
    from { background: rgba(255,153,0,0.2); box-shadow: none; }
    to { background: rgba(255,153,0,0.6); box-shadow: 0 0 15px #f90; }
}
</style>

<!-- 사운드 슬라이드 패널 -->
<div id="sound-slide" class="collapsed">
    <div id="sound-slide-panel">
        <button id="sound-onoff" title="소리 켜기/끄기" data-i18n-title="soundOnOff">🔇</button>
        <input type="range" id="sound-slider" min="0" max="100" value="40">
        <span id="sound-val">40%</span>
    </div>
    <div id="sound-arrow">◀</div>
</div>

<!-- 망원경 모드 오버레이 -->
<div id="telescope-overlay" style="
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 9000;
    pointer-events: none;
    background: radial-gradient(circle at center, transparent 30%, rgba(0,0,0,0.95) 60%);
">
    <!-- 망원경 렌즈 프레임 (원형 비네팅) -->
    <div id="telescope-lens" style="
        position: absolute;
        width: 100%;
        height: 100%;
        background: radial-gradient(circle at center, 
            transparent 0%, 
            transparent 25%, 
            rgba(0,0,0,0.3) 35%, 
            rgba(0,0,0,0.7) 45%, 
            rgba(0,0,0,0.95) 55%);
        pointer-events: none;
    "></div>
    
    <!-- 십자선 레티클 -->
    <div id="telescope-reticle" style="
        width: 300px; height: 300px;
        border: 2px solid rgba(255,100,100,0.6);
        border-radius: 50%;
        position: relative;
        box-shadow: 0 0 30px rgba(255,100,100,0.3), inset 0 0 50px rgba(0,0,0,0.5);
    ">
        <div style="position:absolute;top:50%;left:0;right:0;height:1px;background:rgba(255,100,100,0.5);"></div>
        <div style="position:absolute;left:50%;top:0;bottom:0;width:1px;background:rgba(255,100,100,0.5);"></div>
        <!-- 눈금선 -->
        <div style="position:absolute;top:50%;left:10%;width:15%;height:1px;background:rgba(255,100,100,0.3);"></div>
        <div style="position:absolute;top:50%;right:10%;width:15%;height:1px;background:rgba(255,100,100,0.3);"></div>
        <div style="position:absolute;left:50%;top:10%;height:15%;width:1px;background:rgba(255,100,100,0.3);"></div>
        <div style="position:absolute;left:50%;bottom:10%;height:15%;width:1px;background:rgba(255,100,100,0.3);"></div>
        <!-- 중앙 점 -->
        <div style="position:absolute;top:50%;left:50%;width:6px;height:6px;background:#ff6666;border-radius:50%;transform:translate(-50%,-50%);"></div>
    </div>
    
    <!-- 상단 정보 패널 -->
    <div id="telescope-info-panel" style="
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0,20,40,0.9);
        padding: 15px 30px;
        border-radius: 10px;
        border: 1px solid #00aaff;
        color: #00ffff;
        font-family: 'Orbitron', monospace;
        text-align: center;
        pointer-events: auto;
    ">
        <div style="font-size: 18px; margin-bottom: 8px;" data-i18n="telescopeMode">🔭 망원경 모드</div>
        <div style="display: flex; gap: 30px; font-size: 14px;">
            <span><span data-i18n="zoomLabel">줌</span>: <strong id="telescope-zoom-display">1.0</strong>x</span>
            <span><span data-i18n="maxZoomLabel">최대</span>: <strong id="telescope-max-zoom-display">20</strong>x</span>
            <span id="telescope-target-info" data-i18n="targetNone">타겟: 없음</span>
        </div>
    </div>
    
    <!-- 우측 컨트롤 패널 -->
    <div id="telescope-control-panel" style="
        position: absolute;
        right: 30px;
        top: 50%;
        transform: translateY(-50%);
        background: rgba(0,20,40,0.95);
        border: 2px solid #00aaff;
        border-radius: 15px;
        padding: 20px;
        pointer-events: auto;
        min-width: 180px;
    ">
        <div style="color:#00ffff;text-align:center;margin-bottom:15px;font-size:16px;font-weight:bold;">🎚️ <span data-i18n="zoomLabel">줌</span></div>
        
        <!-- 줌 프리셋 버튼 -->
        <div id="telescope-zoom-presets" style="display:flex;flex-direction:column;gap:8px;margin-bottom:15px;">
            <button class="telescope-preset-btn" data-zoom="1" style="padding:8px;background:#1a3a5c;color:#fff;border:1px solid #00aaff;border-radius:5px;cursor:pointer;">1x</button>
            <button class="telescope-preset-btn" data-zoom="5" style="padding:8px;background:#1a3a5c;color:#fff;border:1px solid #00aaff;border-radius:5px;cursor:pointer;">5x</button>
            <button class="telescope-preset-btn" data-zoom="10" style="padding:8px;background:#1a3a5c;color:#fff;border:1px solid #00aaff;border-radius:5px;cursor:pointer;">10x</button>
            <button class="telescope-preset-btn" data-zoom="20" style="padding:8px;background:#1a3a5c;color:#fff;border:1px solid #00aaff;border-radius:5px;cursor:pointer;">20x</button>
            <button class="telescope-preset-btn locked" data-zoom="30" style="padding:8px;background:#333;color:#888;border:1px solid #555;border-radius:5px;cursor:not-allowed;">🔒 30x</button>
            <button class="telescope-preset-btn locked" data-zoom="50" style="padding:8px;background:#333;color:#888;border:1px solid #555;border-radius:5px;cursor:not-allowed;">🔒 50x</button>
            <button class="telescope-preset-btn locked" data-zoom="100" style="padding:8px;background:#333;color:#888;border:1px solid #555;border-radius:5px;cursor:not-allowed;">🔒 100x</button>
        </div>
        
        <!-- 슬라이더 -->
        <div style="margin-bottom:15px;">
            <input type="range" id="telescope-zoom-slider" 
                min="1" max="20" value="1" step="0.5"
                style="width:100%;accent-color:#00aaff;">
            <div id="telescope-zoom-value" style="color:#fff;text-align:center;margin-top:5px;font-size:20px;font-weight:bold;">1.0x</div>
        </div>
        
        <!-- 장착된 망원경 정보 -->
        <div id="telescope-equipped-info" style="
            background: rgba(0,50,100,0.5);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 15px;
            font-size: 12px;
            color: #aaddff;
        ">
            <div style="font-weight:bold;margin-bottom:5px;">📡 <span data-i18n="telescope">망원경</span></div>
            <div id="telescope-equipped-name" data-i18n="defaultTelescope">기본 망원경 (20x)</div>
        </div>
        
        <!-- 닫기 버튼 -->
        <button id="btn-telescope-close" style="
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #c0392b, #e74c3c);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
        " data-i18n="telescopeExit">✕ 망원경 종료</button>
    </div>
    
    <!-- 좌측 하단 - 조작 안내 -->
    <div style="
        position: absolute;
        bottom: 30px;
        left: 30px;
        background: rgba(0,20,40,0.8);
        padding: 15px;
        border-radius: 10px;
        color: #88ccff;
        font-size: 12px;
        pointer-events: none;
    ">
        <div style="font-weight:bold;margin-bottom:8px;">📖 조작법</div>
        <div data-i18n="mouseDrag">🖱️ 마우스 드래그: 시점 이동</div>
        <div data-i18n="wheelZoom">🔄 휠 스크롤: 줌 조절</div>
        <div data-i18n="escExit">ESC: 망원경 종료</div>
    </div>
</div>

    <div id="top-bar">
        <!-- 로고 제거됨 -->
        <div class="control-group" style="margin-left: 10px;">
            <select id="lang-select" class="mode-btn" style="padding:5px 8px; cursor:pointer; font-size:11px;">
                <option value="en" selected>🇺🇸 English</option>
                <option value="ko">🇰🇷 한국어</option>
                <option value="ja">🇯🇵 日本語</option>
                <option value="zh">🇨🇳 中文</option>
                <option value="fr">🇫🇷 Français</option>
                <option value="la">🏛️ Latina</option>
            </select>
            <button id="btn-scale-mode" class="mode-btn" data-i18n="distExp" style="font-size:11px; padding:6px 12px;">Dist: Experience</button>
            <button id="btn-reset-solar" class="mode-btn" data-i18n="resetSolarSystem" style="background: linear-gradient(135deg, #ff6b35, #f7931e); border-color: #ff8c00; font-size:11px; padding:6px 12px;">🔄 태양계 초기화</button>
            <button id="btn-station" class="mode-btn" data-i18n="station" style="font-size:11px; padding:6px 12px;">🛰️ 정거장</button>
            <button id="btn-catalog" class="mode-btn" data-i18n="catalog" style="font-size:11px; padding:6px 12px;">📖 Catalog</button>
            <button id="btn-fullscreen" class="mode-btn" data-i18n="fullscreen" style="font-size:11px; padding:6px 12px;">⛶ Fullscreen</button>
            <!-- 모바일용 시간 배속 버튼 -->
            <div id="mobile-time-controls">
                <button id="time-slower" class="time-btn">⏪</button>
                <span id="time-val-mobile">0.1x</span>
                <button id="time-faster" class="time-btn">⏩</button>
            </div>
            <!-- 데스크톱용 슬라이더 -->
            <div class="slider-container">
                <div class="slider-row">
                    <span class="slider-label" data-i18n="fine">정밀(0~2x)</span>
                    <input type="range" id="time-slider-fine" min="0" max="2" step="0.1" value="0.1">
                </div>
                <div class="slider-row">
                    <span class="slider-label" data-i18n="fast">고속(1~100x)</span>
                    <input type="range" id="time-slider-coarse" min="1" max="100" step="1" value="1">
                </div>
            </div>
            <div id="time-val">0.1x</div>
        </div>
        <!-- 유저 정보 영역 -->
        <div id="user-area">
            <!-- ★★★ 멀티모드 사용자 프로필 (로그인 후 표시) ★★★ -->
            <div id="user-profile-panel" style="display:none;">
                <div class="profile-avatar" id="profile-avatar">👤</div>
                <div class="profile-info">
                    <div class="profile-name" id="profile-name">User</div>
                    <div class="profile-stats">
                        <span class="stat-item coins">🪙 <span id="profile-coins">0</span></span>
                        <span class="stat-item level">⭐ Lv.<span id="profile-level">1</span></span>
                    </div>
                    <div class="profile-exp-bar">
                        <div class="exp-fill" id="profile-exp-fill" style="width: 0%"></div>
                    </div>
                </div>
                <button class="profile-menu-btn" id="profile-menu-btn">▼</button>
            </div>
            
            <!-- 프로필 드롭다운 메뉴 -->
            <div id="profile-dropdown" style="display:none;">
                <div class="dropdown-item" id="dropdown-profile" data-i18n="myProfile">👤 My Profile</div>
                <div class="dropdown-item" id="dropdown-missions" data-i18n="dropdownMissions">📋 Mission Board</div>
                <div class="dropdown-item" id="dropdown-settings" data-i18n="dropdownSettings">⚙️ Settings</div>
                <div class="dropdown-item logout" id="dropdown-logout" data-i18n="dropdownLogout">🚪 Logout</div>
            </div>
            
            <div id="user-coins" style="display:none;">🪙 <span id="coin-amount">0</span></div>
            <div id="user-info" style="display:none;">
                <span id="user-name">Guest</span>
                <button id="btn-logout" class="mode-btn" data-i18n="logout" onclick="confirmLogout()">로그아웃</button>
            </div>
            <button id="btn-login" class="mode-btn" data-i18n="login" onclick="openAuthUI()">🔐 로그인</button>
        </div>
    </div>
    
    <style>
    /* ★★★ 사용자 프로필 패널 스타일 (멀티모드용) ★★★ */
    #user-profile-panel {
        position: fixed;
        top: 10px;
        right: 10px;  /* 가장 오른쪽 */
        display: flex;
        align-items: center;
        gap: 10px;
        background: linear-gradient(135deg, rgba(0, 40, 80, 0.95) 0%, rgba(0, 20, 50, 0.98) 100%);
        border: 2px solid rgba(0, 200, 255, 0.4);
        border-radius: 12px;
        padding: 8px 12px;
        cursor: pointer;
        transition: all 0.3s;
        z-index: 1001;
    }
    
    #user-profile-panel:hover {
        border-color: rgba(0, 255, 255, 0.7);
        box-shadow: 0 0 15px rgba(0, 200, 255, 0.3);
    }
    
    .profile-avatar {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: linear-gradient(135deg, #1a5276, #2980b9);
        border: 2px solid #00d4ff;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        overflow: hidden;
    }
    
    .profile-avatar img {
        width: 100%;
        height: 100%;
        object-fit: cover;
    }
    
    .profile-info {
        display: flex;
        flex-direction: column;
        gap: 2px;
    }
    
    .profile-name {
        font-family: 'Orbitron', sans-serif;
        font-size: 12px;
        color: #fff;
        font-weight: 600;
    }
    
    .profile-stats {
        display: flex;
        gap: 10px;
        font-size: 10px;
    }
    
    .stat-item.coins { color: #ffd700; }
    .stat-item.level { color: #00ff88; }
    
    .profile-exp-bar {
        width: 80px;
        height: 4px;
        background: rgba(0, 0, 0, 0.5);
        border-radius: 2px;
        overflow: hidden;
    }
    
    .exp-fill {
        height: 100%;
        background: linear-gradient(90deg, #00d4ff, #00ff88);
        transition: width 0.3s;
    }
    
    .profile-menu-btn {
        background: none;
        border: none;
        color: rgba(255, 255, 255, 0.5);
        font-size: 10px;
        cursor: pointer;
        padding: 5px;
        transition: color 0.2s;
    }
    
    .profile-menu-btn:hover {
        color: #00d4ff;
    }
    
    /* 프로필 드롭다운 */
    #profile-dropdown {
        position: absolute;
        top: 100%;
        right: 0;
        margin-top: 5px;
        background: linear-gradient(135deg, rgba(10, 30, 50, 0.98) 0%, rgba(5, 15, 30, 0.98) 100%);
        border: 2px solid rgba(0, 200, 255, 0.4);
        border-radius: 10px;
        overflow: hidden;
        min-width: 150px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        z-index: 1001;
    }
    
    .dropdown-item {
        padding: 12px 15px;
        font-size: 12px;
        color: rgba(255, 255, 255, 0.8);
        cursor: pointer;
        transition: all 0.2s;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .dropdown-item:last-child {
        border-bottom: none;
    }
    
    .dropdown-item:hover {
        background: rgba(0, 200, 255, 0.2);
        color: #fff;
    }
    
    .dropdown-item.logout:hover {
        background: rgba(255, 50, 50, 0.3);
        color: #ff6666;
    }
    
    /* 모바일 최적화 */
    @media (max-width: 768px) {
        #user-profile-panel {
            padding: 6px 8px;
            gap: 6px;
        }
        
        .profile-avatar {
            width: 32px;
            height: 32px;
            font-size: 16px;
        }
        
        .profile-name {
            font-size: 10px;
        }
        
        .profile-stats {
            font-size: 9px;
            gap: 6px;
        }
        
        .profile-exp-bar {
            width: 60px;
        }
    }
    </style>

    <div id="nav-container">
        <div id="nav-panel">
            <div class="nav-header" data-i18n="bodyList">천체 목록</div>
            <div id="nav-list"></div>
        </div>
        <div id="nav-toggle">◀</div>
    </div>

    <div id="spawn-dock"></div>
    
    <div id="catalog-modal">
        <h2 style="color:white; margin-bottom:15px;" id="catalog-title" data-i18n="catalogTitle">🌌 천체 도감 (클릭하여 생성)</h2>
        <div id="catalog-content"></div>
        <button id="catalog-close" data-i18n="close">닫기</button>
    </div>
    
    <!-- 천체 정보 모달 (멀티모드용) - SF 디자인 -->
    <div id="body-info-modal" style="
        display: none;
        position: fixed;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(5, 15, 30, 0.95);
        backdrop-filter: blur(20px);
        border: 1px solid rgba(0, 200, 255, 0.3);
        border-radius: 20px;
        padding: 0;
        z-index: 10000;
        min-width: 360px;
        max-width: 90vw;
        max-height: 85vh;
        overflow: hidden;
        color: white;
        font-family: 'Orbitron', 'Rajdhani', sans-serif;
        box-shadow: 
            0 0 60px rgba(0, 150, 255, 0.3),
            inset 0 0 60px rgba(0, 100, 200, 0.05),
            0 25px 50px rgba(0, 0, 0, 0.5);
    ">
        <!-- 헤더 바 -->
        <div style="
            background: linear-gradient(90deg, rgba(0,100,150,0.8), rgba(0,50,100,0.4));
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(0, 200, 255, 0.2);
        ">
            <h3 id="body-info-name" style="color:#00d4ff; margin:0; font-size: 1.4em; text-shadow: 0 0 20px rgba(0,200,255,0.5);"></h3>
            <button id="body-info-close" style="
                background: rgba(255,100,100,0.2);
                border: 1px solid rgba(255,100,100,0.5);
                color: #ff6b6b;
                width: 32px;
                height: 32px;
                border-radius: 50%;
                cursor: pointer;
                font-size: 1.1em;
                transition: all 0.3s;
            " onmouseover="this.style.background='rgba(255,100,100,0.4)'" onmouseout="this.style.background='rgba(255,100,100,0.2)'">✕</button>
        </div>
        
        <!-- 스크롤 컨텐츠 -->
        <div style="padding: 20px; overflow-y: auto; max-height: calc(85vh - 140px);">
            
            <!-- 기본 정보 -->
            <div style="
                background: linear-gradient(135deg, rgba(0,80,120,0.3), rgba(0,40,80,0.2));
                border: 1px solid rgba(0,180,255,0.2);
                border-radius: 12px;
                padding: 15px;
                margin-bottom: 15px;
                position: relative;
                overflow: hidden;
            ">
                <div style="
                    position: absolute;
                    top: 0; left: 0;
                    width: 4px;
                    height: 100%;
                    background: linear-gradient(180deg, #00d4ff, #0088ff);
                "></div>
                <div style="color:#00d4ff; font-size: 0.8em; margin-bottom: 12px; letter-spacing: 2px; text-transform: uppercase;">
                    <span style="opacity: 0.7;">▸</span> <span data-i18n="infoBasicInfo">기본 정보</span>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 0.9em;">
                    <div style="display:flex;justify-content:space-between;"><span style="color:#6aa;" data-i18n="infoType">유형</span> <span id="info-type" style="color:#fff;"></span></div>
                    <div style="display:flex;justify-content:space-between;"><span style="color:#6aa;" data-i18n="bodyRadius">반지름</span> <span id="info-radius" style="color:#fff;"></span><span style="color:#6aa;font-size:0.8em;">km</span></div>
                    <div style="display:flex;justify-content:space-between;"><span style="color:#6aa;" data-i18n="bodyMass">질량</span> <span id="info-mass" style="color:#fff;"></span></div>
                    <div style="display:flex;justify-content:space-between;"><span style="color:#6aa;" data-i18n="infoOrbit">공전</span> <span id="info-orbit" style="color:#fff;"></span></div>
                    <div style="display:flex;justify-content:space-between;"><span style="color:#6aa;" data-i18n="infoGravity">중력</span> <span id="info-gravity" style="color:#fff;"></span></div>
                    <div style="display:flex;justify-content:space-between;"><span style="color:#6aa;" data-i18n="infoTemp">기온</span> <span id="info-temp" style="color:#fff;"></span></div>
                </div>
            </div>
            
            <!-- 테라포밍 상태 -->
            <div style="
                background: linear-gradient(135deg, rgba(0,100,60,0.3), rgba(0,60,40,0.2));
                border: 1px solid rgba(0,255,150,0.2);
                border-radius: 12px;
                padding: 15px;
                margin-bottom: 15px;
                position: relative;
                overflow: hidden;
            ">
                <div style="
                    position: absolute;
                    top: 0; left: 0;
                    width: 4px;
                    height: 100%;
                    background: linear-gradient(180deg, #00ff88, #00aa55);
                "></div>
                <div style="color:#00ff88; font-size: 0.8em; margin-bottom: 12px; letter-spacing: 2px; text-transform: uppercase;">
                    <span style="opacity: 0.7;">▸</span> <span data-i18n="terraformingStatus">테라포밍 상태</span>
                </div>
                <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 10px;">
                    <div style="flex: 1; height: 10px; background: rgba(0,0,0,0.5); border-radius: 5px; overflow: hidden; border: 1px solid rgba(0,255,150,0.3);">
                        <div id="info-terraform-bar" style="height: 100%; background: linear-gradient(90deg, #ff4444, #ffaa00, #00ff88); width: 0%; transition: width 0.5s; box-shadow: 0 0 10px rgba(0,255,150,0.5);"></div>
                    </div>
                    <span id="info-terraform-percent" style="font-size: 1em; color: #00ff88; font-weight: bold; min-width: 45px; text-align: right;">0%</span>
                </div>
                <div id="info-terraform-status" style="font-size: 0.8em; color: #8ca;"></div>
            </div>
            
            <!-- 인프라 -->
            <div style="
                background: linear-gradient(135deg, rgba(120,80,0,0.3), rgba(80,50,0,0.2));
                border: 1px solid rgba(255,180,0,0.2);
                border-radius: 12px;
                padding: 15px;
                margin-bottom: 15px;
                position: relative;
                overflow: hidden;
            ">
                <div style="
                    position: absolute;
                    top: 0; left: 0;
                    width: 4px;
                    height: 100%;
                    background: linear-gradient(180deg, #ffaa00, #ff6600);
                "></div>
                <div style="color:#ffaa00; font-size: 0.8em; margin-bottom: 12px; letter-spacing: 2px; text-transform: uppercase;">
                    <span style="opacity: 0.7;">▸</span> <span data-i18n="infrastructure">인프라</span>
                </div>
                <div id="info-infrastructure" style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 0.85em;"></div>
            </div>
            
            <!-- 자원 -->
            <div style="
                background: linear-gradient(135deg, rgba(100,0,100,0.3), rgba(60,0,80,0.2));
                border: 1px solid rgba(255,100,255,0.2);
                border-radius: 12px;
                padding: 15px;
                margin-bottom: 15px;
                position: relative;
                overflow: hidden;
            ">
                <div style="
                    position: absolute;
                    top: 0; left: 0;
                    width: 4px;
                    height: 100%;
                    background: linear-gradient(180deg, #ff66ff, #aa44aa);
                "></div>
                <div style="color:#ff66ff; font-size: 0.8em; margin-bottom: 12px; letter-spacing: 2px; text-transform: uppercase;">
                    <span style="opacity: 0.7;">▸</span> 채취 가능 자원
                </div>
                <div id="info-resources" style="display: flex; flex-wrap: wrap; gap: 8px;"></div>
            </div>
            
            <!-- 식민지 정보 -->
            <div style="
                background: linear-gradient(135deg, rgba(60,60,120,0.3), rgba(40,40,80,0.2));
                border: 1px solid rgba(150,150,255,0.2);
                border-radius: 12px;
                padding: 15px;
                margin-bottom: 15px;
                position: relative;
                overflow: hidden;
            ">
                <div style="
                    position: absolute;
                    top: 0; left: 0;
                    width: 4px;
                    height: 100%;
                    background: linear-gradient(180deg, #8888ff, #5555cc);
                "></div>
                <div style="color:#8888ff; font-size: 0.8em; margin-bottom: 12px; letter-spacing: 2px; text-transform: uppercase;">
                    <span style="opacity: 0.7;">▸</span> 식민지 정보
                </div>
                <div style="font-size: 0.9em; display: grid; gap: 6px;">
                    <div style="display:flex;justify-content:space-between;"><span style="color:#88a;">상태</span> <span id="info-colony" style="color:#fff;"></span></div>
                    <div style="display:flex;justify-content:space-between;"><span style="color:#88a;">인구</span> <span id="info-population" style="color:#fff;"></span></div>
                    <div style="display:flex;justify-content:space-between;"><span style="color:#88a;">인공위성</span> <span><span id="info-satellites"></span><span style="color:#88a;font-size:0.8em;"> 개</span></span></div>
                </div>
            </div>
        </div>
        
        <!-- 하단 버튼 -->
        <div style="padding: 15px 20px; border-top: 1px solid rgba(0,200,255,0.2); background: rgba(0,50,80,0.3);">
            <button id="body-info-goto" style="
                width: 100%;
                padding: 14px;
                background: linear-gradient(135deg, #0088ff, #0055cc);
                color: white;
                border: 1px solid rgba(0,150,255,0.5);
                border-radius: 10px;
                cursor: pointer;
                font-size: 0.95em;
                font-family: 'Orbitron', sans-serif;
                font-weight: bold;
                letter-spacing: 1px;
                transition: all 0.3s;
                box-shadow: 0 0 20px rgba(0,100,255,0.3);
            " onmouseover="this.style.boxShadow='0 0 30px rgba(0,150,255,0.6)';this.style.transform='translateY(-2px)'" onmouseout="this.style.boxShadow='0 0 20px rgba(0,100,255,0.3)';this.style.transform='translateY(0)'">
                🚀 선체 보기
            </button>
        </div>
    </div>
    </div>

    <div id="msg-box" data-i18n="message">메시지</div>
    <button id="reset-cam" data-i18n="viewAll">🔭 전체 보기</button>
    
    <!-- 로그인 모달 -->
    <div id="login-modal">
        <div id="login-content">
            <h2 id="login-title">🔐 <span data-i18n="login">Login</span></h2>
            <div class="login-tabs">
                <button class="login-tab active" id="tab-login" data-i18n="login">Login</button>
                <button class="login-tab" id="tab-register" data-i18n="register">Register</button>
            </div>
            
            <!-- 로그인/회원가입 폼 -->
            <div id="login-form">
                <input type="text" id="input-username" placeholder="사용자명" data-placeholder-i18n="username">
                <input type="email" id="input-email" placeholder="이메일" style="display:none;" data-placeholder-i18n="email">
                <input type="password" id="input-password" placeholder="비밀번호" data-placeholder-i18n="password">
                <input type="password" id="input-password-confirm" placeholder="비밀번호 확인" style="display:none;" data-placeholder-i18n="passwordConfirm">
                
                <!-- 약관 동의 (회원가입 시에만 표시) -->
                <div id="terms-agree-section" style="display:none; margin: 10px 0; font-size: 11px;">
                    <div style="margin-bottom: 8px;">
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                            <input type="checkbox" id="agree-privacy" style="width: 16px; height: 16px;">
                            <span><a href="privacy.html" target="_blank" style="color: #0ff;" data-i18n="privacyPolicy">Privacy Policy</a> <span data-i18n="agreeToTerms">- I agree</span></span>
                        </label>
                    </div>
                    <div>
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                            <input type="checkbox" id="agree-terms" style="width: 16px; height: 16px;">
                            <span><a href="terms.html" target="_blank" style="color: #0ff;" data-i18n="termsOfService">Terms of Service</a> <span data-i18n="agreeToTerms">- I agree</span></span>
                        </label>
                    </div>
                </div>
                
                <div id="login-error"></div>
                <div id="login-success"></div>
                <button id="btn-login-submit" class="login-submit" data-i18n="login">로그인</button>
                <div class="login-find-links" id="find-links">
                    <a id="link-find-id" data-i18n="findId">아이디 찾기</a>
                    <span style="color:#555;">|</span>
                    <a id="link-find-pw" data-i18n="findPassword">비밀번호 찾기</a>
                </div>
            </div>
            
            <!-- 아이디 찾기 폼 -->
            <div id="find-id-form" style="display:none;">
                <p style="color:#aaa; font-size:12px; margin-bottom:15px; text-align:center;" data-i18n="enterRegisteredEmail">가입할 때 등록한 이메일을 입력하세요</p>
                <input type="email" id="find-id-email" placeholder="이메일 주소" data-placeholder-i18n="emailAddress">
                <div id="find-id-error" style="color:#e74c3c; font-size:12px; min-height:18px; text-align:center;"></div>
                <div id="find-id-result" class="find-result" style="display:none;">
                    <div class="label" data-i18n="foundId">찾은 아이디</div>
                    <div class="value" id="found-username"></div>
                </div>
                <button id="btn-find-id" class="login-submit" data-i18n="findIdBtn">아이디 찾기</button>
                <button class="back-to-login" id="back-from-find-id" data-i18n="backToLoginBtn">← 로그인으로 돌아가기</button>
            </div>
            
            <!-- 비밀번호 찾기 폼 -->
            <div id="find-pw-form" style="display:none;">
                <p style="color:#aaa; font-size:12px; margin-bottom:15px; text-align:center;" data-i18n="enterIdAndEmailDesc">아이디와 등록된 이메일을 입력하세요</p>
                <input type="text" id="find-pw-username" placeholder="사용자명" data-placeholder-i18n="username">
                <input type="email" id="find-pw-email" placeholder="이메일 주소" data-placeholder-i18n="emailAddress">
                <div id="find-pw-error" style="color:#e74c3c; font-size:12px; min-height:18px; text-align:center;"></div>
                <div id="find-pw-result" class="find-result" style="display:none;">
                    <div class="label" data-i18n="newPasswordSetMsg">새 비밀번호가 설정되었습니다</div>
                    <div class="value" id="new-password"></div>
                    <p style="color:#888; font-size:10px; margin-top:8px;" data-i18n="changePasswordNote">로그인 후 비밀번호를 변경해주세요</p>
                </div>
                <button id="btn-find-pw" class="login-submit" data-i18n="resetPasswordBtn">비밀번호 재설정</button>
                <button class="back-to-login" id="back-from-find-pw" data-i18n="backToLoginBtn">← 로그인으로 돌아가기</button>
            </div>
            
            <button id="login-close">✕</button>
        </div>
    </div>
    
    <!-- 정거장 선택 모달 -->
    <div id="station-modal">
        <div id="station-modal-content">
            <button id="station-close">✕</button>
            <h2 data-i18n="selectStation">🛸 정거장 선택</h2>
            <div class="station-category">
                <h3 data-i18n="orbitalStations">📍 궤도 정거장</h3>
                <div class="station-list" id="planet-stations"></div>
            </div>
            <div class="station-category">
                <h3 data-i18n="fuelDepots">⛽ 연료 보급소</h3>
                <div class="station-list" id="fuel-stations"></div>
            </div>
        </div>
    </div>
    
    <!-- 연료 충전 패널 -->
    <div id="refuel-panel">
        <h3 data-i18n="refueling">⛽ 연료 충전 중...</h3>
        <div id="refuel-bar">
            <div id="refuel-progress"></div>
        </div>
        <div id="refuel-text">0/100</div>
    </div>
    
    <!-- 포커스 천체 거리 표시 -->
    <div id="focus-distance-panel">
        <div id="focus-target-name">---</div>
        <div id="focus-distance-value">--- km</div>
    </div>

    <div id="chat-toggle">💬</div>
    <div id="chat-panel">
        <div id="chat-header">
            <span data-i18n="spaceKnowledgeGuide">🛸 우주 지식 가이드</span>
            <span id="chat-close">×</span>
        </div>
        <div id="chat-messages">
            <div class="msg ai" data-i18n="aiWelcome">안녕하세요! 천체끼리 충돌하면 흡수되며, 질량이 100을 넘으면 별(항성)이 됩니다.</div>
        </div>
        <div id="chat-input-area">
            <input type="text" id="chat-input" placeholder="질문을 입력하세요..." data-placeholder-i18n="enterQuestion">
            <button id="chat-send">➤</button>
        </div>
    </div>

    <div id="canvas-container"></div>

    <!-- 우주선 탑승 버튼 -->
    <button id="board-ship-btn" data-i18n="boardShip">🚀 우주선 탑승</button>
    
    <!-- ★★★ 운항중 우주선 팝업 ★★★ -->
    <div id="active-ship-popup" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:10000; justify-content:center; align-items:center; overflow-y:auto; padding:20px 0;">
        <div style="background:linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border:2px solid #4fc3f7; border-radius:20px; padding:30px; max-width:400px; width:90%; max-height:85vh; overflow-y:auto; margin:auto; text-align:center; box-shadow:0 0 30px rgba(79,195,247,0.3); position:relative;">
            <div id="active-ship-icon" style="width:80px; height:80px; margin:0 auto 15px; border-radius:12px; background:#0a1628; border:2px solid #4fc3f7; display:flex; justify-content:center; align-items:center; overflow:hidden;">
                <span style="font-size:40px;">🚀</span>
            </div>
            <h2 id="active-ship-title" style="color:#4fc3f7; margin:0 0 20px 0; font-size:20px;">Active Ship Found!</h2>
            <div id="active-ship-info" style="background:rgba(0,0,0,0.3); border-radius:10px; padding:15px; margin-bottom:20px; text-align:left;">
                <div style="color:#fff; font-size:18px; margin-bottom:10px;" id="active-ship-name">Interceptor</div>
                <div style="color:#aaa; font-size:14px;">
                    <div style="margin-bottom:5px;"><span id="active-ship-fuel-label">⛽ Fuel:</span> <span id="active-ship-fuel" style="color:#4fc3f7;">20%</span></div>
                    <div><span id="active-ship-dist-label">📍 From ISS:</span> <span id="active-ship-dist" style="color:#4fc3f7;">11,176km</span></div>
                </div>
            </div>
            <div style="display:flex; gap:15px; justify-content:center;">
                <button id="active-ship-go-btn" style="flex:1; padding:15px 20px; background:linear-gradient(135deg,#4fc3f7,#2196f3); border:none; border-radius:10px; color:#fff; font-size:16px; font-weight:bold; cursor:pointer;">
                    📍 Go to Ship
                </button>
                <button id="active-ship-new-btn" style="flex:1; padding:15px 20px; background:linear-gradient(135deg,#e74c3c,#c0392b); border:none; border-radius:10px; color:#fff; font-size:16px; font-weight:bold; cursor:pointer;">
                    🗑️ New Ship
                </button>
            </div>
            <button id="active-ship-close-btn" style="position:absolute; top:15px; right:15px; background:none; border:none; color:#888; font-size:24px; cursor:pointer;">✕</button>
        </div>
    </div>
    
    <!-- 우주선 위치 마커 (맵에 표시) -->
    <div id="ship-location-marker" style="display:none; position:fixed; z-index:1000; cursor:pointer;" onclick="focusOnParkedShip()">
        <div style="display:flex; flex-direction:column; align-items:center;">
            <div id="ship-marker-box" style="width:60px; height:60px; border-radius:10px; background:#0a1628; border:2px solid #00ff00; box-shadow:0 0 15px rgba(0,255,0,0.5); display:flex; justify-content:center; align-items:center; overflow:hidden;">
                <span style="font-size:30px;">🚀</span>
            </div>
            <div style="width:0; height:0; border-left:10px solid transparent; border-right:10px solid transparent; border-top:15px solid #00ff00; margin-top:-2px;"></div>
            <div id="ship-marker-name" style="color:#00ff00; font-size:12px; font-weight:bold; text-shadow:0 0 5px #000; margin-top:5px; white-space:nowrap;"></div>
        </div>
    </div>
    
    <!-- 우주선 선택 모달 -->
    <div id="ship-select-modal">
        <div id="ship-select-content">
            <h2 data-i18n="selectShip">🚀 우주선 선택</h2>
            <div id="ship-list"></div>
            <div id="ship-detail">
                <div id="ship-preview"></div>
                <div id="ship-info">
                    <h3 id="ship-detail-name" data-i18n="shuttle">셔틀</h3>
                    <p id="ship-detail-desc" data-i18n="shuttleDesc">기본형 왕복선</p>
                    <div id="ship-price-display">
                        <span class="price-label">🪙</span>
                        <span id="ship-price-value">500</span>
                        <span id="ship-owned-badge" style="display:none;" data-i18n="owned">보유중</span>
                    </div>
                    <div id="ship-stats">
                        <div class="stat-row"><span data-i18n="maxSpeed">최대 속도</span><div class="stat-bar"><div class="stat-fill speed"></div></div><span class="stat-val" id="stat-speed">75 km/s</span></div>
                        <div class="stat-row"><span data-i18n="accelStat">가속력</span><div class="stat-bar"><div class="stat-fill accel"></div></div><span class="stat-val" id="stat-accel">1.0</span></div>
                        <div class="stat-row"><span data-i18n="turnRate">선회력</span><div class="stat-bar"><div class="stat-fill turn"></div></div><span class="stat-val" id="stat-turn">0.125</span></div>
                        <div class="stat-row"><span data-i18n="fuel">연료</span><div class="stat-bar"><div class="stat-fill fuel"></div></div><span class="stat-val" id="stat-fuel">250</span></div>
                    </div>
                    <div id="ship-special"></div>
                </div>
            </div>
            <div id="ship-select-buttons">
                <button id="btn-armory" class="ship-modal-btn armory" data-i18n="armory">⚔️ 무장</button>
                <button id="btn-buy-ship" class="ship-modal-btn buy" style="display:none;" data-i18n="buy">🪙 구매</button>
                <button id="btn-select-ship" class="ship-modal-btn confirm" data-i18n="launch">출격</button>
                <button id="btn-cancel-ship" class="ship-modal-btn cancel" data-i18n="cancel">취소</button>
            </div>
        </div>
    </div>
    
    <!-- 함선 처분 확인 모달 -->
    <div id="sell-ship-modal">
        <div id="sell-ship-content">
            <h2>⚠️ <span data-i18n="sellShipTitle">함선 처분</span></h2>
            <p id="sell-ship-message"></p>
            <div id="sell-ship-info">
                <div class="sell-info-row">
                    <span data-i18n="currentShip">현재 함선:</span>
                    <span id="sell-current-ship" data-i18n="shuttle">셔틀</span>
                </div>
                <div class="sell-info-row">
                    <span data-i18n="sellPrice">처분 가격 (50%):</span>
                    <span id="sell-price-value">🪙 250</span>
                </div>
            </div>
            <div id="sell-ship-buttons">
                <button id="btn-sell-confirm" class="ship-modal-btn sell">💰 <span data-i18n="sellAndBoard">처분 후 탑승</span></button>
                <button id="btn-sell-cancel" class="ship-modal-btn cancel" data-i18n="cancel">취소</button>
            </div>
        </div>
    </div>

    <!-- 무장 모달 -->
    <div id="armory-modal">
        <div id="armory-content">
            <h2 data-i18n="armorySystem">⚔️ 무장 시스템</h2>
            <div class="armory-tabs">
                <button class="armory-tab active" data-tab="weapons">🔫 무기</button>
                <button class="armory-tab" data-tab="armors">🛡️ 장갑</button>
            </div>
            <div class="armory-main">
                <div class="armory-list-container">
                    <div id="armory-list" class="armory-list"></div>
                </div>
                <div class="armory-detail">
                    <div class="armory-equipped-section">
                        <div class="armory-equipped-title">📦 Equipped</div>
                        <div id="armory-equipped-slots"></div>
                    </div>
                    <div class="armory-detail-icon" id="armory-detail-icon">🔫</div>
                    <h3 id="armory-detail-name" data-i18n="selectWeapon">Select Weapon</h3>
                    <div class="armory-detail-desc" id="armory-detail-desc" data-i18n="selectWeaponDesc">Select a weapon</div>
                    <div class="armory-detail-stats" id="armory-detail-stats"></div>
                    <div class="armory-detail-effect" id="armory-detail-effect" style="display:none;"></div>
                    <div id="armory-detail-price" style="text-align:center; margin-bottom: 10px;"></div>
                    <div class="armory-buttons">
                        <button id="btn-armory-buy" class="ship-modal-btn buy" style="display:none;" data-i18n="buy">🪙 Buy</button>
                        <button id="btn-armory-equip" class="ship-modal-btn confirm" style="display:none;">Equip</button>
                        <button id="btn-armory-unequip" class="ship-modal-btn cancel" style="display:none;">Unequip</button>
                    </div>
                </div>
            </div>
            <div class="armory-buttons" style="margin-top: 15px;">
                <button id="btn-armory-close" class="ship-modal-btn cancel" data-i18n="close">닫기</button>
            </div>
        </div>
    </div>

    <!-- UI 설정 버튼 (조종 모드에서만 표시) -->
    <button id="ui-settings-btn" title="UI Settings" data-i18n-title="uiSettings">⚙️</button>
    
    <!-- UI 설정 패널 -->
    <div id="ui-settings-panel">
        <button id="ui-settings-close">✕</button>
        <h3 data-i18n="uiSettings">🎛️ UI 설정</h3>
        
        <div style="display:flex;flex-direction:column;gap:10px;margin-bottom:15px;">
            <button class="ui-preset-btn" id="ui-rearrange-mode" style="background:linear-gradient(135deg,#9b59b6,#8e44ad);" data-i18n="uiReposition">
                🔧 UI 재배치 모드
            </button>
            <p style="font-size:10px;color:#888;text-align:center;margin:0;" data-i18n="uiDragToMove">
                재배치 모드에서 UI를 드래그하여 이동
            </p>
        </div>
        
        <div class="ui-slots-container">
            <div class="ui-slots-title" data-i18n="saveSlots">💾 저장 슬롯</div>
            <div id="ui-slots-list">
                <!-- 슬롯들이 여기에 동적으로 생성됩니다 -->
            </div>
        </div>
        
        <button class="ui-preset-btn danger" id="ui-reset-default" data-i18n="resetDefault">🔄 기본값으로 리셋</button>
    </div>
    
    <!-- UI 재배치 모드 오버레이 -->
    <div id="ui-rearrange-overlay">
        <div class="rearrange-header">
            <span data-i18n="uiReposition">🔧 UI 재배치 모드</span>
            <span style="font-size:12px;color:#aaa;" data-i18n="uiDragToMove">UI를 드래그하여 이동하세요</span>
        </div>
        <button id="ui-rearrange-done" data-i18n="done">✓ 완료</button>
    </div>

    <!-- 조종석 HUD -->
    <!-- 조종실 라디오 패널 -->
    <div id="cockpit-radio" class="collapsed draggable-ui">
        <button class="radio-toggle" id="radio-toggle-btn">📻</button>
        <div class="radio-content">
            <div class="radio-header">
                <div class="radio-title" data-i18n="spaceRadio">🛸 우주 라디오</div>
                <button id="radio-close-btn" class="radio-close-btn">✕</button>
            </div>
            <div class="radio-station" data-url="https://ice.somafm.com/spacestation" data-name="Space Station Soma">
                <div class="radio-station-name" data-i18n="spaceStation">🚀 우주 정거장</div>
                <div class="radio-station-desc">Spaced-out ambient electronica</div>
            </div>
            <div class="radio-station" data-url="https://ice.somafm.com/deepspaceone" data-name="Deep Space One">
                <div class="radio-station-name">🌌 Deep Space One</div>
                <div class="radio-station-desc">Deep ambient space music</div>
            </div>
            <div class="radio-station" data-url="https://ice.somafm.com/dronezone" data-name="Drone Zone">
                <div class="radio-station-name">🎧 Drone Zone</div>
                <div class="radio-station-desc">Atmospheric textures</div>
            </div>
            <div class="radio-station" data-url="https://ice.somafm.com/groovesalad" data-name="Groove Salad">
                <div class="radio-station-name">🥗 Groove Salad</div>
                <div class="radio-station-desc">Ambient downtempo beats</div>
            </div>
            <div class="radio-station" data-url="https://ice.somafm.com/defcon" data-name="DEF CON Radio">
                <div class="radio-station-name">💻 DEF CON</div>
                <div class="radio-station-desc">Music for Hacking</div>
            </div>
            <div class="radio-volume">
                <span>🔊</span>
                <input type="range" id="radio-volume" min="0" max="100" value="30">
                <span id="radio-vol-val">30%</span>
            </div>
            <div class="radio-now-playing" id="radio-now-playing" data-i18n="selectChannel">📡 Select a channel</div>
        </div>
    </div>

    <div id="cockpit-hud">
        <!-- 콕핏 프레임 (1인칭 뷰) -->
        <div id="cockpit-frame">
            <div class="cockpit-strut left"></div>
            <div class="cockpit-strut right"></div>
            <div class="cockpit-strut top"></div>
            <div class="cockpit-side-panel left"></div>
            <div class="cockpit-side-panel right"></div>
            <div id="cockpit-dashboard"></div>
            <div class="cockpit-indicator left"></div>
            <div class="cockpit-indicator right"></div>
        </div>
        <div id="pilot-top-bar">
            <div class="pilot-info-panel" id="status-panel" style="border-color:#0f0;display:none;"><div class="pilot-info-label" style="color:#0f0;" data-i18n="status">상태</div><div class="pilot-info-value" id="info-status" style="color:#0f0;">정상</div></div>
            <button class="pilot-info-panel ability-btn" id="btn-ability" style="display:none;"><span id="ability-icon">⚡</span><span id="ability-name">특수능력</span><span id="ability-cooldown"></span></button>
        </div>
        
        <!-- ★ 화면 중앙 도킹 버튼 -->
        <button id="docking-center-btn" data-i18n="docking">🔗 도킹</button>
        
        <!-- ★ 도킹 완료 후 메뉴 -->
        <div id="docking-menu">
            <button class="docking-menu-btn" id="btn-refuel-menu" data-i18n="refuelMenu">⛽ 연료 보충</button>
            <button class="docking-menu-btn repair" id="btn-repair-menu">🔧 선체 수리</button>
            <button class="docking-menu-btn shop" id="btn-station-shop" style="background: linear-gradient(135deg, #f39c12, #e67e22);">🛒 상점</button>
            <button class="docking-menu-btn interior" id="btn-station-interior">🏠 정거장 내부</button>
        </div>
        
        <!-- ★★★ 정거장 상점 모달 ★★★ -->
        <div id="station-shop-modal" style="
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        ">
            <div style="
                background: linear-gradient(135deg, #0a1628, #1a2d4a);
                border: 2px solid #f39c12;
                border-radius: 20px;
                padding: 30px;
                max-width: 700px;
                width: 90%;
                max-height: 80vh;
                overflow-y: auto;
                color: white;
                font-family: 'Orbitron', sans-serif;
            ">
                <h2 style="text-align: center; color: #f39c12; margin-bottom: 25px;">🛒 정거장 상점</h2>
                
                <!-- 보유 코인 표시 -->
                <div style="text-align: center; margin-bottom: 20px; font-size: 18px;">
                    🪙 보유 코인: <span id="shop-user-coins" style="color: #f39c12; font-weight: bold;">0</span>
                </div>
                
                <!-- 탭 메뉴 -->
                <div style="display: flex; gap: 10px; margin-bottom: 20px; justify-content: center;">
                    <button class="shop-tab-btn active" data-tab="telescope" style="padding: 10px 20px; background: #f39c12; color: white; border: none; border-radius: 8px; cursor: pointer;">🔭 망원경</button>
                    <button class="shop-tab-btn" data-tab="equipment" style="padding: 10px 20px; background: #333; color: #aaa; border: none; border-radius: 8px; cursor: pointer;">🛠️ 장비</button>
                    <button class="shop-tab-btn" data-tab="consumables" style="padding: 10px 20px; background: #333; color: #aaa; border: none; border-radius: 8px; cursor: pointer;">📦 소모품</button>
                </div>
                
                <!-- 망원경 탭 -->
                <div id="shop-tab-telescope" class="shop-tab-content">
                    <div style="display: flex; flex-direction: column; gap: 15px;">
                        <!-- 기본 망원경 -->
                        <div class="shop-item" data-item="basic" style="
                            background: rgba(46, 204, 113, 0.2);
                            border: 2px solid #2ecc71;
                            border-radius: 12px;
                            padding: 15px;
                            display: flex;
                            align-items: center;
                            gap: 15px;
                        ">
                            <div style="font-size: 40px;">🔭</div>
                            <div style="flex: 1;">
                                <div style="font-size: 16px; font-weight: bold; color: #2ecc71;">기본 망원경</div>
                                <div style="font-size: 12px; color: #aaa;">20배 줌 | 기본 장착</div>
                            </div>
                            <div style="text-align: right;">
                                <div style="color: #2ecc71; font-weight: bold;">✅ 보유중</div>
                                <button class="shop-equip-btn" data-telescope="basic" style="margin-top: 5px; padding: 5px 15px; background: #2ecc71; color: white; border: none; border-radius: 5px; cursor: pointer;">장착</button>
                            </div>
                        </div>
                        
                        <!-- 표준 망원경 (30x) - 새로 추가 -->
                        <div class="shop-item" data-item="standard" style="
                            background: rgba(241, 196, 15, 0.2);
                            border: 2px solid #f1c40f;
                            border-radius: 12px;
                            padding: 15px;
                            display: flex;
                            align-items: center;
                            gap: 15px;
                        ">
                            <div style="font-size: 40px;">🔭</div>
                            <div style="flex: 1;">
                                <div style="font-size: 16px; font-weight: bold; color: #f1c40f;">표준 망원경</div>
                                <div style="font-size: 12px; color: #aaa;">30배 줌 | 향상된 성능</div>
                            </div>
                            <div id="shop-standard-status" style="text-align: right;">
                                <div style="color: #f39c12; font-weight: bold;">🪙 2,000</div>
                                <button class="shop-buy-btn" data-telescope="standard" data-price="2000" style="margin-top: 5px; padding: 5px 15px; background: #f39c12; color: white; border: none; border-radius: 5px; cursor: pointer;">구매</button>
                            </div>
                        </div>
                        
                        <!-- 고급 망원경 -->
                        <div class="shop-item" data-item="advanced" style="
                            background: rgba(52, 152, 219, 0.2);
                            border: 2px solid #3498db;
                            border-radius: 12px;
                            padding: 15px;
                            display: flex;
                            align-items: center;
                            gap: 15px;
                        ">
                            <div style="font-size: 40px;">🔭</div>
                            <div style="flex: 1;">
                                <div style="font-size: 16px; font-weight: bold; color: #3498db;">고급 망원경</div>
                                <div style="font-size: 12px; color: #aaa;">50배 줌 | 선명한 화질</div>
                            </div>
                            <div id="shop-advanced-status" style="text-align: right;">
                                <div style="color: #f39c12; font-weight: bold;">🪙 5,000</div>
                                <button class="shop-buy-btn" data-telescope="advanced" data-price="5000" style="margin-top: 5px; padding: 5px 15px; background: #f39c12; color: white; border: none; border-radius: 5px; cursor: pointer;">구매</button>
                            </div>
                        </div>
                        
                        <!-- 전문가 망원경 -->
                        <div class="shop-item" data-item="professional" style="
                            background: rgba(155, 89, 182, 0.2);
                            border: 2px solid #9b59b6;
                            border-radius: 12px;
                            padding: 15px;
                            display: flex;
                            align-items: center;
                            gap: 15px;
                        ">
                            <div style="font-size: 40px;">🔭</div>
                            <div style="flex: 1;">
                                <div style="font-size: 16px; font-weight: bold; color: #9b59b6;">전문가 망원경</div>
                                <div style="font-size: 12px; color: #aaa;">100배 줌 | 최고 성능</div>
                            </div>
                            <div id="shop-professional-status" style="text-align: right;">
                                <div style="color: #f39c12; font-weight: bold;">🪙 15,000</div>
                                <button class="shop-buy-btn" data-telescope="professional" data-price="15000" style="margin-top: 5px; padding: 5px 15px; background: #f39c12; color: white; border: none; border-radius: 5px; cursor: pointer;">구매</button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 장비 탭 (준비중) -->
                <div id="shop-tab-equipment" class="shop-tab-content" style="display: none;">
                    <div style="text-align: center; padding: 40px; color: #888;">
                        <div style="font-size: 50px; margin-bottom: 15px;">🔧</div>
                        <div data-i18n="equipmentShopPreparing">장비 상점 준비중...</div>
                    </div>
                </div>
                
                <!-- 소모품 탭 (준비중) -->
                <div id="shop-tab-consumables" class="shop-tab-content" style="display: none;">
                    <div style="text-align: center; padding: 40px; color: #888;">
                        <div style="font-size: 50px; margin-bottom: 15px;">📦</div>
                        <div data-i18n="consumablesShopPreparing">소모품 상점 준비중...</div>
                    </div>
                </div>
                
                <!-- 닫기 버튼 -->
                <button id="btn-close-shop" data-i18n="closeBtn" style="
                    margin-top: 20px;
                    width: 100%;
                    padding: 15px;
                    background: linear-gradient(135deg, #c0392b, #e74c3c);
                    color: white;
                    border: none;
                    border-radius: 10px;
                    font-size: 16px;
                    cursor: pointer;
                ">✕ 닫기</button>
            </div>
        </div>
        
        <!-- ★★★ 수리 오버레이 ★★★ -->
        <div id="repair-overlay">
            <div class="repair-title">🔧 선체 수리 중...</div>
            <div class="repair-bar-container">
                <div class="repair-bar-fill" id="repair-bar-fill"></div>
            </div>
            <div class="repair-amount" id="repair-amount">0/100</div>
            <div class="repair-cost" id="repair-cost">Cost: 0 coins</div>
        </div>
        
        <!-- ★★★ 보호막 충돌 이펙트 ★★★ -->
        <div id="shield-impact-overlay"></div>
        
        <!-- ★ 도킹해제 버튼 -->
        <button id="undock-btn" data-i18n="undock">🚀 Undock</button>
        
        <!-- ★ 연료 보급 오버레이 -->
        <div id="refuel-overlay">
            <div class="refuel-title" data-i18n="refuelingProgress">⛽ 연료 보급 중...</div>
            <div class="refuel-bar-container">
                <div class="refuel-bar-fill" id="refuel-bar-fill"></div>
            </div>
            <div class="refuel-amount" id="refuel-amount">0/100</div>
            <div class="refuel-cost" id="refuel-cost">Cost: 0 coins</div>
        </div>
        <div id="pilot-target-select"><select id="ship-target-select"><option value="" data-i18n="navTargetSelect">🎯 Select Navigation Target...</option></select></div>
        
        <!-- ★★★ 3D 좌표 표시 패널 ★★★ -->
        <div id="pilot-coords-panel">
            <div class="coords-label" data-i18n="currentCoords">📍 Current Coordinates</div>
            <div class="coords-value" id="pilot-coords-display">X: 0 | Y: 0 | Z: 0</div>
        </div>
        
        <div id="pilot-eta-box">
            <div class="eta-label" data-i18n="eta">ETA</div>
            <div class="eta-time" id="eta-time-display">--:--:--</div>
            <div class="eta-target" id="eta-target-name">Target: ---</div>
        </div>
        <div id="pilot-warning-panel">
            <div class="pilot-warning" id="warn-collision" data-i18n="collisionWarning">⚠️ Collision Warning!</div>
            <div class="pilot-warning" id="warn-fuel" data-i18n="lowFuel">⚠️ Low Fuel!</div>
            <div class="pilot-warning hull-critical" id="warn-hull" data-i18n="hullDamage">⚠️ Hull Damage!</div>
            <div class="pilot-warning caution decel" id="warn-decel" data-i18n="autoDecel">🔻 Auto Deceleration</div>
            <div class="pilot-warning" id="warn-emergency" data-i18n="emergencyReverseWarn">🚨 Emergency Reverse!</div>
            <div class="pilot-warning gravity" id="warn-gravity" data-i18n="gravityCapture">⚠️ Gravity Capture! Escape Required!</div>
            <div class="pilot-warning escape-ready" id="warn-escape-ready" style="display:none;background:rgba(255,153,0,0.3);border-color:#f90;color:#f90;" data-i18n="escapeBoosterReady">⚡ Escape Booster Ready</div>
        </div>
        <div id="pilot-left" style="display:none;">
            <!-- ALTITUDE 게이지 제거됨 -->
        </div>
        <div id="pilot-right">
            <div id="pilot-radar"><div class="radar-ring" style="width:30%;height:30%;"></div><div class="radar-ring" style="width:60%;height:60%;"></div><div class="radar-ring" style="width:90%;height:90%;"></div><div id="pilot-radar-sweep"></div><div id="pilot-radar-ship"></div></div>
            <div id="pilot-target-info"><div class="target-label" data-i18n="targetLabel">TARGET</div><div class="target-name" id="pilot-target-name" data-i18n="none">None</div><div class="target-dist" id="pilot-target-dist">---</div><div class="target-eta" id="pilot-target-eta"></div></div>
            <div id="pilot-autopilot-info" class="inactive"><div class="ap-label" data-i18n="autopilotLabel">AUTOPILOT</div><div class="ap-status" id="ap-status" data-i18n="off">OFF</div><div class="ap-phase" id="ap-phase"></div></div>
        </div>
        <div id="crosshair"><div class="ch-line h"></div><div class="ch-line v"></div><div class="ch-dot"></div></div>
        
        <!-- ★ 통합 채팅 패널 (ARIA + 멀티채팅) -->
        <div id="unified-chat-panel">
            <div class="chat-tab-bar">
                <button class="chat-tab active" data-tab="aria" data-i18n="ariaTab">🤖 ARIA</button>
                <button class="chat-tab" data-tab="multi" data-i18n="chatTab">💬 Chat</button>
                <button id="chat-toggle-btn">▼</button>
            </div>
            <div class="chat-content">
                <!-- ARIA 탭 -->
                <div id="aria-tab" class="tab-content active">
                    <div class="chat-content-box" id="aria-messages">
                        <div class="aria-msg"><span class="aria-text" data-i18n="systemInit">System initialized. Fly safe, pilot.</span></div>
                    </div>
                    <div class="chat-input-area">
                        <input type="text" id="aria-input" data-placeholder-i18n="ariaPlaceholder" placeholder="ARIA에게 질문..." maxlength="200">
                        <button id="aria-send-btn">▶</button>
                    </div>
                </div>
                <!-- 멀티 채팅 탭 -->
                <div id="multi-tab" class="tab-content">
                    <div class="chat-content-box" id="multi-messages">
                        <div class="mp-msg system" data-i18n="chatNotConnected">Not connected to chat</div>
                    </div>
                    <div class="chat-input-area">
                        <input type="text" id="multi-input" data-placeholder-i18n="enterMessage" placeholder="메시지 입력..." maxlength="200">
                        <button id="multi-send-btn">▶</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- AI 부조종사 패널 (숨김) -->
        <div id="ai-copilot-panel">
            <div id="ai-copilot-header">
                <div id="ai-avatar">🤖</div>
                <div>
                    <div id="ai-name">ARIA</div>
                    <div id="ai-status" data-i18n="online">● 온라인</div>
                </div>
                <button id="ai-expand-btn" onclick="toggleAIPanel()">▼</button>
            </div>
            <div id="ai-message-box">
                <span id="ai-message-text" data-i18n="aiInitMessage">시스템 초기화 완료. 안전한 비행 되세요, 파일럿.</span>
            </div>
            <div id="ai-input-area">
                <input type="text" id="ai-input" placeholder="ARIA에게 질문하기..." data-placeholder-i18n="ariaPlaceholder" maxlength="200">
                <button id="ai-send-btn" onclick="aiSendQuestion()">▶</button>
            </div>
        </div>
        
        <!-- AI 교신 모달 -->
        <div id="ai-comm-modal">
            <div id="ai-comm-portrait">👽</div>
            <div id="ai-comm-name" data-i18n="unidentifiedSignal">미확인 신호</div>
            <div id="ai-comm-message"></div>
            <div id="ai-comm-choices"></div>
        </div>
        
        <div id="pilot-bottom">
            <div id="pilot-left-console">
                <div class="vertical-gauge thr-gauge">
                    <div class="thr-label-top" data-i18n="accel">가속</div>
                    <div class="vg-bar thr-bar">
                        <div class="vg-bg">
                            <div class="thr-center-line"></div>
                            <div class="vg-fill throttle-up" id="throttle-up-fill"></div>
                            <div class="vg-fill throttle-down" id="throttle-down-fill"></div>
                        </div>
                    </div>
                    <div class="thr-label-bottom" data-i18n="reverse">역추진</div>
                    <div class="vg-label">THR</div>
                    <div class="vg-value" id="throttle-val">0%</div>
                </div>
                <div class="vertical-gauge"><div class="vg-bar"><div class="vg-bg"><div class="vg-fill fuel" id="fuel-fill"></div></div></div><div class="vg-label">FUEL</div><div class="vg-value" id="fuel-val">100/100</div></div>
                <div class="vertical-gauge hull-gauge"><div class="vg-bar"><div class="vg-bg"><div class="vg-fill hull" id="hull-fill" style="height:100%;background:linear-gradient(180deg,#ff8800,#ff4400);"></div></div></div><div class="vg-label" style="color:#ff8800;">HULL</div><div class="vg-value" id="hull-val" style="color:#ff8800;">100</div></div>
                <!-- 긴급 역추진 버튼 -->
                <button class="pilot-ctrl-btn emergency-brake" id="btn-emergency-brake" data-i18n="emergencyReverse">🔥<br>긴급역추진</button>
            </div>
            <div id="pilot-center-console">
                <div id="pilot-main-speed">
                    <span class="speed-value" id="main-speed-val">0</span><span class="speed-unit">km/s</span>
                    <div id="speed-kmh" style="font-size:0.6em;color:#aaa;margin-top:2px;">(0 km/h)</div>
                </div>
                <div id="pilot-btn-row">
                    <button class="pilot-console-btn autopilot" id="btn-autopilot" data-i18n="auto">🤖 Auto</button>
                    <button class="pilot-console-btn orbit-entry" id="btn-orbit-entry" style="display:none;" data-i18n="orbitEntry">🌍 Orbit</button>
                    <button class="pilot-console-btn interior disabled" id="btn-interior" data-i18n="interior">🚪 Interior</button>
                    <button class="pilot-console-btn" id="btn-telescope" style="background:linear-gradient(135deg,#1a5276,#2980b9);" data-i18n="telescope">🔭 Telescope</button>
                    <button class="pilot-console-btn emergency" id="btn-escape" data-i18n="emergency">🆘 Escape</button>
                    <button class="pilot-console-btn danger" id="btn-exit-pilot" style="padding:5px 8px; font-size:8px;" data-i18n="disembark">🌌 Exit</button>
                </div>
            </div>
            <div id="pilot-right-console">
                <!-- 데스크톱용 가속/감속 버튼 -->
                <button class="pilot-ctrl-btn desktop-only" id="btn-accel">▲</button>
                <button class="pilot-ctrl-btn desktop-only" id="btn-decel">▼</button>
            </div>
        </div>
        <div id="virtual-joystick"><div id="joystick-base"><div id="joystick-knob"></div></div></div>
        
        <!-- 3인칭 뷰 전용 플로팅 버튼 (비활성화 - 조종실 UI 사용) -->
        <div id="space-view-controls" style="display:none !important;"></div>
        
        <!-- 터치 영역 (화면 왼쪽 절반) -->
        <div id="touch-area-left"></div>
        
        <!-- 모바일용 동적 조이스틱 -->
        <div id="pilot-joystick">
            <div id="pilot-joystick-base">
                <div id="pilot-joystick-knob"></div>
            </div>
        </div>
        
        <!-- 궤도 진입 프롬프트 -->
        <div id="orbit-prompt">
            <div class="orbit-prompt-title" data-i18n="orbitLock">🌍 Tidal Lock Orbit</div>
            <div class="orbit-prompt-target"><span id="orbit-target-name">Earth</span> <span data-i18n="stableOrbit">Stable Orbit</span></div>
            <p data-i18n="orbitPromptMsg">Enter tidal locked orbit?<br>Ship will naturally orbit while facing the planet.</p>
            <div class="orbit-prompt-buttons">
                <button class="orbit-btn confirm" id="btn-enter-orbit" data-i18n="confirmOrbit">✓ Lock Orbit</button>
                <button class="orbit-btn cancel" id="btn-cancel-orbit" data-i18n="cancel">✕ Cancel</button>
            </div>
        </div>
    </div>

    <!-- 선내 HUD -->
    <div id="interior-hud">
        <div id="interior-top">
            <span id="interior-location">📍 Cockpit</span>
            <span id="interior-eta">⏱️ --:--:--</span>
        </div>
        <div id="move-joystick"><div id="move-joystick-base"><div id="move-joystick-knob"></div></div></div>
        <div id="interior-crosshair"></div>
        <div id="object-name"></div>
        <div id="interaction-hint">[E] 상호작용</div>
        <div id="interior-bottom"><button class="pilot-console-btn" id="btn-int-back">← 조종석</button></div>
        <div id="door-prompt"><div class="door-name" id="door-name" data-i18n="researchLab">🚪 연구실</div><p data-i18n="approachedDoor">문에 접근했습니다</p><button id="btn-open-door" data-i18n="enterDoor">입장 [E]</button></div>
    </div>

    <!-- 전망대 HUD -->
    <div id="observatory-hud">
        <div id="obs-top">
            <span id="obs-title" data-i18n="observatory">🔭 Observatory</span>
            <span id="obs-eta">⏱️ --:--:--</span>
        </div>
        <div id="obs-bottom"><button class="pilot-console-btn" id="btn-obs-back">← Return to Interior</button></div>
    </div>

    <!-- 모바일 미니 HUD -->
    <div id="mobile-mini-hud" style="display: none;">
        <div class="mini-hud-item">
            <span class="mini-hud-icon">🚀</span>
            <span class="mini-hud-value" id="mini-speed">0</span>
            <span style="color:#888;font-size:10px;">km/s</span>
        </div>
        <div class="mini-hud-item">
            <div class="mini-hud-bar">
                <div class="mini-hud-bar-fill" id="mini-fuel-bar" style="width: 100%;"></div>
            </div>
            <span class="mini-hud-value" id="mini-fuel">100/100</span>
        </div>
        <div class="mini-hud-item">
            <span class="mini-hud-icon">🎯</span>
            <span class="mini-hud-value" id="mini-target" style="font-size:10px;" data-i18n="none">None</span>
        </div>
    </div>

    <!-- 모바일 하단 탭 바 -->
    <div id="mobile-tab-bar">
        <button class="mobile-tab active" data-tab="control">
            <span class="mobile-tab-icon">🕹️</span>
            <span data-i18n="control">조종</span>
        </button>
        <button class="mobile-tab" data-tab="status">
            <span class="mobile-tab-icon">📊</span>
            <span data-i18n="statusTab">상태</span>
        </button>
        <button class="mobile-tab" data-tab="radio">
            <span class="mobile-tab-icon">📻</span>
            <span data-i18n="radioTab">라디오</span>
        </button>
        <button class="mobile-tab" data-tab="chat">
            <span class="mobile-tab-icon">💬</span>
            <span data-i18n="chatTab2">채팅</span>
        </button>
        <button class="mobile-tab" data-tab="aria">
            <span class="mobile-tab-icon">🤖</span>
            <span data-i18n="ariaTab2">ARIA</span>
        </button>
    </div>

    <!-- 모바일 탭 패널 -->
    <div id="mobile-tab-panel">
        <!-- 조종 패널 -->
        <div class="mobile-panel-content active" id="mobile-control-panel">
            <div class="mobile-gauge-group" id="mobile-gauge-container">
                <div class="mobile-gauge">
                    <span class="mobile-gauge-label">THR</span>
                    <div class="mobile-gauge-bar">
                        <div class="mobile-gauge-fill thr" id="mobile-thr-fill" style="height: 50%;"></div>
                    </div>
                    <span class="mobile-gauge-value" id="mobile-thr-value">+0%</span>
                </div>
                <div class="mobile-gauge">
                    <span class="mobile-gauge-label">FUEL</span>
                    <div class="mobile-gauge-bar">
                        <div class="mobile-gauge-fill fuel" id="mobile-fuel-fill" style="height: 100%;"></div>
                    </div>
                    <span class="mobile-gauge-value" id="mobile-fuel-value">100/100</span>
                </div>
                <div class="mobile-gauge">
                    <span class="mobile-gauge-label" style="color:#ff8800;">HULL</span>
                    <div class="mobile-gauge-bar" style="border-color:#ff8800;">
                        <div class="mobile-gauge-fill" id="mobile-hull-fill" style="height: 100%;background:linear-gradient(180deg,#ff8800,#ff4400);"></div>
                    </div>
                    <span class="mobile-gauge-value" id="mobile-hull-value" style="color:#ff8800;">100</span>
                </div>
            </div>
            
            <div class="mobile-speed-display" id="mobile-speed-container">
                <div class="mobile-speed-value" id="mobile-speed-val">0</div>
                <div class="mobile-speed-unit">km/s</div>
                <div class="mobile-speed-secondary" id="mobile-speed-kmh">(0 km/h)</div>
            </div>
            
            <div class="mobile-direction-btns" id="mobile-arrows-container">
                <button class="mobile-dir-btn" id="mobile-accel">▲</button>
                <button class="mobile-dir-btn" id="mobile-decel">▼</button>
            </div>
            
            <div class="mobile-btn-row" id="mobile-btns-container">
                <button class="mobile-action-btn autopilot" id="mobile-autopilot">🤖 Auto</button>
                <button class="mobile-action-btn" id="mobile-guide">📍 Guide</button>
                <button class="mobile-action-btn orbit" id="mobile-orbit" style="display:none; background: linear-gradient(135deg, #2ecc71, #27ae60);">🌍 Orbit</button>
                <button class="mobile-action-btn" id="mobile-telescope">🔭 Scope</button>
                <button class="mobile-action-btn" id="mobile-space-mode" style="padding:6px 10px; font-size:11px;">🌌 Space</button>
            </div>
        </div>
        
        <!-- 상태 패널 -->
        <div class="mobile-panel-content" id="mobile-status-panel">
            <div class="mobile-status-item">
                <div class="mobile-status-label">Speed</div>
                <div class="mobile-status-value" id="mobile-stat-speed">0 km/s</div>
            </div>
            <div class="mobile-status-item">
                <div class="mobile-status-label">Fuel</div>
                <div class="mobile-status-value" id="mobile-stat-fuel">100/100</div>
            </div>
            <div class="mobile-status-item">
                <div class="mobile-status-label">Target</div>
                <div class="mobile-status-value" id="mobile-stat-target">None</div>
            </div>
            <div class="mobile-status-item">
                <div class="mobile-status-label">Distance</div>
                <div class="mobile-status-value" id="mobile-stat-distance">-</div>
            </div>
            <div class="mobile-status-item">
                <div class="mobile-status-label">Autopilot</div>
                <div class="mobile-status-value" id="mobile-stat-autopilot">OFF</div>
            </div>
            <div class="mobile-status-item">
                <div class="mobile-status-label">Location</div>
                <div class="mobile-status-value" id="mobile-stat-location">Solar System</div>
            </div>
        </div>
        
        <!-- 라디오 패널 -->
        <div class="mobile-panel-content" id="mobile-radio-panel">
            <div class="mobile-radio-station" data-url="https://ice.somafm.com/spacestation" data-name="Space Station">
                <span class="mobile-radio-name" data-i18n="spaceStation">🚀 우주 정거장</span>
                <span class="mobile-radio-status">Ambient</span>
            </div>
            <div class="mobile-radio-station" data-url="https://ice.somafm.com/deepspaceone" data-name="Deep Space One">
                <span class="mobile-radio-name">🌌 Deep Space One</span>
                <span class="mobile-radio-status">Space Music</span>
            </div>
            <div class="mobile-radio-station" data-url="https://ice.somafm.com/dronezone" data-name="Drone Zone">
                <span class="mobile-radio-name">🎧 Drone Zone</span>
                <span class="mobile-radio-status">Atmospheric</span>
            </div>
            <div class="mobile-radio-station" data-url="https://ice.somafm.com/groovesalad" data-name="Groove Salad">
                <span class="mobile-radio-name">🥗 Groove Salad</span>
                <span class="mobile-radio-status">Downtempo</span>
            </div>
            <div class="mobile-radio-volume">
                <span>🔊</span>
                <input type="range" id="mobile-radio-vol" min="0" max="100" value="30">
                <span id="mobile-radio-vol-val">30%</span>
            </div>
        </div>
        
        <!-- 채팅 패널 -->
        <div class="mobile-panel-content" id="mobile-chat-panel">
            <div class="mobile-chat-messages" id="mobile-chat-messages">
                <div style="color:#888;text-align:center;">채팅 메시지가 여기에 표시됩니다</div>
            </div>
            <div class="mobile-chat-input-row">
                <input type="text" id="mobile-chat-input" placeholder="메시지 입력..." data-placeholder-i18n="enterMessage" maxlength="100">
                <button id="mobile-chat-send" data-i18n="send">전송</button>
            </div>
        </div>
        
        <!-- ARIA 패널 -->
        <div class="mobile-panel-content" id="mobile-aria-panel">
            <div class="mobile-aria-header">
                <div class="mobile-aria-avatar">🤖</div>
                <div class="mobile-aria-info">
                    <div class="mobile-aria-name">ARIA</div>
                    <div class="mobile-aria-status" data-i18n="online">● 온라인</div>
                </div>
            </div>
            <div class="mobile-aria-messages" id="mobile-aria-messages">
                안녕하세요, 파일럿! 무엇을 도와드릴까요? 🚀
            </div>
            <div class="mobile-aria-input-row">
                <input type="text" id="mobile-aria-input" placeholder="ARIA에게 질문..." data-placeholder-i18n="ariaPlaceholder" maxlength="100">
                <button id="mobile-aria-send">▶</button>
            </div>
        </div>
    </div>

    <script id="vertexShader" type="x-shader/x-vertex">
        #include <common>
        #include <logdepthbuf_pars_vertex>
        varying vec2 vUv;
        varying vec3 vPosition;
        void main() {
            vUv = uv;
            vPosition = position;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            #include <logdepthbuf_vertex>
        }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
        #include <common>
        #include <logdepthbuf_pars_fragment>
        uniform float time;
        varying vec2 vUv;
        varying vec3 vPosition;

        vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
        vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}
        float snoise(vec3 v){ 
            const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
            const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
            vec3 i  = floor(v + dot(v, C.yyy) );
            vec3 x0 = v - i + dot(i, C.xxx) ;
            vec3 g = step(x0.yzx, x0.xyz);
            vec3 l = 1.0 - g;
            vec3 i1 = min( g.xyz, l.zxy );
            vec3 i2 = max( g.xyz, l.zxy );
            vec3 x1 = x0 - i1 + 1.0 * C.xxx;
            vec3 x2 = x0 - i2 + 2.0 * C.xxx;
            vec3 x3 = x0 - 1.0 + 3.0 * C.xxx;
            i = mod(i, 289.0 ); 
            vec4 p = permute( permute( permute( 
                        i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                    + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
                    + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
            float n_ = 1.0/7.0; // N=7
            vec3  ns = n_ * D.wyz - D.xzx;
            vec4 j = p - 49.0 * floor(p * ns.z *ns.z);
            vec4 x_ = floor(j * ns.z);
            vec4 y_ = floor(j - 7.0 * x_ );
            vec4 x = x_ *ns.x + ns.yyyy;
            vec4 y = y_ *ns.x + ns.yyyy;
            vec4 h = 1.0 - abs(x) - abs(y);
            vec4 b0 = vec4( x.xy, y.xy );
            vec4 b1 = vec4( x.zw, y.zw );
            vec4 s0 = floor(b0)*2.0 + 1.0;
            vec4 s1 = floor(b1)*2.0 + 1.0;
            vec4 sh = -step(h, vec4(0.0));
            vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
            vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
            vec3 p0 = vec3(a0.xy,h.x);
            vec3 p1 = vec3(a0.zw,h.y);
            vec3 p2 = vec3(a1.xy,h.z);
            vec3 p3 = vec3(a1.zw,h.w);
            vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
            p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
            vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
            m = m * m;
            return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
        }

        void main() {
            #include <logdepthbuf_fragment>
            float noiseVal = snoise(vPosition * 1.65 + vec3(time * 0.2));
            float noiseVal2 = snoise(vPosition * 3.3 - vec3(time * 0.3));
            float intensity = (noiseVal * 0.6 + noiseVal2 * 0.4) + 0.3;
            vec3 darkColor = vec3(1.0, 0.4, 0.0); 
            vec3 baseColor = vec3(1.0, 0.7, 0.0); 
            vec3 brightColor = vec3(1.0, 1.0, 0.9);
            vec3 finalColor = mix(darkColor, baseColor, intensity + 0.2);
            finalColor = mix(finalColor, brightColor, smoothstep(0.4, 0.8, intensity));
            gl_FragColor = vec4(finalColor, 1.0);
        }
    </script>

    <script id="coronaVertexShader" type="x-shader/x-vertex">
        #include <common>
        #include <logdepthbuf_pars_vertex>
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            #include <logdepthbuf_vertex>
        }
    </script>

    <script id="coronaFragmentShader" type="x-shader/x-fragment">
        #include <common>
        #include <logdepthbuf_pars_fragment>
        uniform float time;
        varying vec2 vUv;
        float random(vec2 n) { return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }
        float noise(vec2 p){
            vec2 ip = floor(p);
            vec2 u = fract(p);
            u = u*u*(3.0-2.0*u);
            float res = mix(
                mix(random(ip), random(ip+vec2(1.0,0.0)), u.x),
                mix(random(ip+vec2(0.0,1.0)), random(ip+vec2(1.0,1.0)), u.x), u.y);
            return res*res;
        }
        void main() {
            #include <logdepthbuf_fragment>
            vec2 center = vec2(0.5, 0.5);
            vec2 pos = vUv - center;
            float r = length(pos);
            float angle = atan(pos.y, pos.x);
            float rays = noise(vec2(angle * 10.0 + time * 0.1, r * 2.0 - time * 0.5));
            rays += noise(vec2(angle * 20.0 - time * 0.2, r * 5.0 + time * 0.2)) * 0.5;
            float glow = 1.0 - smoothstep(0.0, 0.5, r);
            glow = pow(glow, 3.0); 
            float rayIntensity = glow * (0.8 + 0.4 * rays);
            vec3 coronaColor = vec3(1.0, 0.6, 0.2); 
            gl_FragColor = vec4(coronaColor, rayIntensity * 0.8);
        }
    </script>

    <!-- ★★★ 지구 대기 쉐이더 (레일리 + 미 산란) ★★★ -->
    <script id="atmosphereVertexShader" type="x-shader/x-vertex">
        varying vec3 vNormal;
        varying vec3 vPosition;
        varying vec3 vWorldPosition;
        
        void main() {
            vNormal = normalize(normalMatrix * normal);
            vPosition = position;
            vec4 worldPos = modelMatrix * vec4(position, 1.0);
            vWorldPosition = worldPos.xyz;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>
    
    <script id="atmosphereFragmentShader" type="x-shader/x-fragment">
        uniform vec3 sunDirection;
        uniform float atmosphereRadius;
        uniform float planetRadius;
        uniform float time;
        
        varying vec3 vNormal;
        varying vec3 vPosition;
        varying vec3 vWorldPosition;
        
        // 레일리 산란 계수 (파장별 - 푸른색이 더 많이 산란)
        const vec3 rayleighCoeff = vec3(5.8e-6, 13.5e-6, 33.1e-6);
        // 미 산란 계수 (모든 파장에서 동일 - 흰색 산란)
        const float mieCoeff = 21e-6;
        
        // 대기 밀도 함수 (고도에 따른 지수 감소)
        float atmosphereDensity(float altitude) {
            float scaleHeight = 8500.0; // 스케일 높이 8.5km
            return exp(-altitude / scaleHeight);
        }
        
        void main() {
            vec3 viewDir = normalize(cameraPosition - vWorldPosition);
            vec3 normal = normalize(vNormal);
            
            // 프레넬 효과 (가장자리에서 더 강하게)
            float fresnel = pow(1.0 - max(dot(viewDir, normal), 0.0), 3.0);
            
            // 태양 방향과의 각도
            float sunAngle = max(dot(normal, sunDirection), 0.0);
            
            // 레일리 산란 (푸른 하늘)
            vec3 rayleigh = rayleighCoeff * (1.0 + pow(sunAngle, 2.0));
            
            // 미 산란 (태양 주변 밝은 글로우)
            float miePhase = pow(max(dot(viewDir, sunDirection), 0.0), 8.0);
            vec3 mie = vec3(mieCoeff) * miePhase;
            
            // 대기 색상 계산
            vec3 dayColor = vec3(0.3, 0.6, 1.0);   // 낮: 푸른색
            vec3 sunsetColor = vec3(1.0, 0.4, 0.1); // 일몰: 주황색
            vec3 nightColor = vec3(0.02, 0.02, 0.05); // 밤: 어두운 파랑
            
            // 일몰 효과 (태양이 수평선에 가까울 때)
            float horizonAngle = dot(normal, sunDirection);
            float sunsetFactor = smoothstep(-0.1, 0.3, horizonAngle) * smoothstep(0.5, 0.1, horizonAngle);
            
            // 낮/밤 혼합
            float dayFactor = smoothstep(-0.1, 0.2, sunAngle);
            vec3 baseColor = mix(nightColor, dayColor, dayFactor);
            baseColor = mix(baseColor, sunsetColor, sunsetFactor * 0.7);
            
            // 최종 대기 색상
            vec3 atmosphere = baseColor * fresnel * 1.5;
            atmosphere += mie * vec3(1.0, 0.9, 0.7) * 2.0;  // 태양 글로우
            
            // 투명도 (가장자리에서 더 불투명)
            float alpha = fresnel * 0.8 + sunsetFactor * 0.2;
            alpha = clamp(alpha, 0.0, 0.85);
            
            gl_FragColor = vec4(atmosphere, alpha);
        }
    </script>
    
    <!-- ★★★ 지구 구름 쉐이더 (볼류메트릭 레이마칭) ★★★ -->
    <script id="cloudVertexShader" type="x-shader/x-vertex">
        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vPosition;
        varying vec3 vWorldPosition;
        varying vec3 vViewDir;
        
        void main() {
            vUv = uv;
            vNormal = normalize(normalMatrix * normal);
            vPosition = position;
            vec4 worldPos = modelMatrix * vec4(position, 1.0);
            vWorldPosition = worldPos.xyz;
            vViewDir = normalize(cameraPosition - worldPos.xyz);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>
    
    <script id="cloudFragmentShader" type="x-shader/x-fragment">
        uniform float time;
        uniform vec3 sunDirection;
        uniform float cloudDensity;
        uniform float cloudSpeed;
        
        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vPosition;
        varying vec3 vWorldPosition;
        varying vec3 vViewDir;
        
        // 해시 함수
        float hash(vec3 p) {
            p = fract(p * 0.3183099 + 0.1);
            p *= 17.0;
            return fract(p.x * p.y * p.z * (p.x + p.y + p.z));
        }
        
        // 3D 노이즈
        float noise(vec3 x) {
            vec3 i = floor(x);
            vec3 f = fract(x);
            f = f * f * (3.0 - 2.0 * f);
            
            return mix(mix(mix(hash(i + vec3(0,0,0)), hash(i + vec3(1,0,0)), f.x),
                          mix(hash(i + vec3(0,1,0)), hash(i + vec3(1,1,0)), f.x), f.y),
                      mix(mix(hash(i + vec3(0,0,1)), hash(i + vec3(1,0,1)), f.x),
                          mix(hash(i + vec3(0,1,1)), hash(i + vec3(1,1,1)), f.x), f.y), f.z);
        }
        
        // 워핑된 FBM - 더 자연스러운 구름 형태
        float fbm(vec3 p) {
            float value = 0.0;
            float amplitude = 0.5;
            float frequency = 1.0;
            
            // 워핑 (구름이 휘어지는 효과)
            p += vec3(noise(p * 2.0), noise(p * 2.0 + 100.0), noise(p * 2.0 + 200.0)) * 0.5;
            
            for (int i = 0; i < 6; i++) {
                value += amplitude * noise(p * frequency);
                amplitude *= 0.5;
                frequency *= 2.0;
                // 각 레이어마다 약간씩 회전 (더 자연스러움)
                p = p.yzx * 1.01;
            }
            return value;
        }
        
        // 구름 밀도 샘플링
        float sampleCloud(vec3 pos, float t) {
            // 시간에 따른 바람 효과
            vec3 windOffset = vec3(t * 0.02, 0.0, t * 0.01);
            
            // 기본 구름 노이즈
            float cloud = fbm((pos + windOffset) * 3.0);
            
            // 세부 노이즈 추가
            cloud += fbm((pos + windOffset * 2.0) * 8.0) * 0.3;
            cloud += fbm((pos + windOffset * 3.0) * 16.0) * 0.15;
            
            // 위도에 따른 구름 분포 (적도와 중위도에 더 많이)
            float latitude = abs(pos.y);
            float latMask = smoothstep(0.9, 0.6, latitude) * smoothstep(0.0, 0.2, latitude);
            latMask = mix(latMask, 1.0, 0.4);  // 완전히 없어지지 않도록
            
            // 구름 형태 조절
            cloud = cloud * latMask;
            cloud = smoothstep(0.35, 0.65, cloud);  // 구름 경계 선명하게
            
            return cloud;
        }
        
        void main() {
            vec3 normal = normalize(vNormal);
            vec3 viewDir = normalize(vViewDir);
            
            // 구면 좌표
            vec3 spherePos = normalize(vPosition);
            
            // 레이마칭 설정
            const int STEPS = 8;
            float stepSize = 0.02;
            
            vec3 rayPos = spherePos;
            float totalDensity = 0.0;
            float transmittance = 1.0;
            vec3 cloudColor = vec3(0.0);
            
            // 태양 조명
            float sunLight = max(dot(normal, sunDirection), 0.0);
            float sunsetFactor = smoothstep(-0.1, 0.3, sunLight) * smoothstep(0.5, 0.1, sunLight);
            
            // 기본 구름 색상
            vec3 dayColor = vec3(1.0, 1.0, 1.0);
            vec3 sunsetColor = vec3(1.0, 0.6, 0.4);
            vec3 nightColor = vec3(0.2, 0.2, 0.25);
            
            vec3 baseColor = mix(nightColor, dayColor, smoothstep(-0.1, 0.3, sunLight));
            baseColor = mix(baseColor, sunsetColor, sunsetFactor * 0.7);
            
            // 간단한 레이마칭 (여러 레이어 샘플링)
            for (int i = 0; i < STEPS; i++) {
                float fi = float(i) / float(STEPS);
                
                // 높이에 따른 레이어
                vec3 samplePos = spherePos * (1.0 + fi * 0.03);
                
                // 구름 밀도 샘플링
                float density = sampleCloud(samplePos, time);
                
                if (density > 0.01) {
                    // 라이트 산란 (태양 방향에서 더 밝게)
                    float lightScatter = 0.5 + 0.5 * max(dot(samplePos, sunDirection), 0.0);
                    
                    // 그림자 효과 (위 레이어가 아래를 가림)
                    float shadow = 1.0 - fi * 0.3;
                    
                    // 색상 누적
                    vec3 stepColor = baseColor * lightScatter * shadow;
                    
                    // 은선 효과 (Silver Lining) - 구름 가장자리가 밝게
                    float edge = smoothstep(0.3, 0.5, density) - smoothstep(0.5, 0.7, density);
                    stepColor += vec3(1.0, 0.95, 0.9) * edge * sunLight * 0.5;
                    
                    cloudColor += stepColor * density * transmittance;
                    transmittance *= 1.0 - density * 0.3;
                }
            }
            
            // 프레넬 효과 (가장자리에서 더 투명)
            float fresnel = pow(1.0 - max(dot(viewDir, normal), 0.0), 2.0);
            float alpha = totalDensity;
            
            // 레이마칭 결과로 알파 계산
            alpha = 1.0 - transmittance;
            alpha = clamp(alpha * 1.5, 0.0, 0.9);
            
            // 밤에는 구름이 덜 보이도록
            alpha *= mix(0.4, 1.0, smoothstep(-0.2, 0.1, sunLight));
            
            // 가장자리 페이드
            alpha *= smoothstep(0.0, 0.3, 1.0 - fresnel * 0.5);
            
            gl_FragColor = vec4(cloudColor / max(1.0 - transmittance, 0.001), alpha);
        }
    </script>

    <script type="module">
        console.log('🚀 Solar Explorer v2.1 로드됨');
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        
        window.THREE = THREE;  // ★ 망원경 모드에서 사용
        window.GLTFLoader = GLTFLoader;  // ★ 멀티플레이어에서 사용
        window.CSS2DObject = CSS2DObject;  // ★ 멀티플레이어 닉네임 라벨
        
        // ★★★ 시네마틱 인트로 시스템 ★★★
        (function initIntro() {
            const canvas = document.getElementById('intro-canvas');
            const overlay = document.getElementById('intro-overlay');
            
            if (!canvas || !overlay) return;
            
            // DOM 요소들
            const letterboxTop = document.querySelector('.letterbox-top');
            const letterboxBottom = document.querySelector('.letterbox-bottom');
            const lensFlare = document.getElementById('lens-flare');
            const studioLogo = document.getElementById('studio-logo');
            const mainTitle = document.getElementById('main-title');
            const titleChars = document.querySelectorAll('.title-text .char');
            const titleLines = document.querySelectorAll('.title-line');
            const titleTagline = document.querySelector('.title-tagline');
            const loader = document.getElementById('intro-loader');
            const loaderProgress = document.querySelector('.loader-progress');
            const percentText = document.getElementById('intro-percent');
            const startDiv = document.getElementById('intro-start');
            const startBtn = document.getElementById('intro-start-btn');
            const skipBtn = document.getElementById('intro-skip');
            
            // Three.js 설정
            const introScene = new THREE.Scene();
            const introCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 3000);
            const introRenderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
            introRenderer.setSize(window.innerWidth, window.innerHeight);
            introRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            introCamera.position.z = 500;
            
            // 별 필드 (은하수 느낌)
            const starCount = 5000;
            const starGeometry = new THREE.BufferGeometry();
            const starPositions = new Float32Array(starCount * 3);
            const starColors = new Float32Array(starCount * 3);
            
            for (let i = 0; i < starCount; i++) {
                const i3 = i * 3;
                const radius = Math.random() * 1500 + 100;
                const theta = Math.random() * Math.PI * 2;
                const phi = (Math.random() - 0.5) * Math.PI * 0.5;
                
                starPositions[i3] = radius * Math.cos(theta) * Math.cos(phi);
                starPositions[i3 + 1] = radius * Math.sin(phi) * 0.3;
                starPositions[i3 + 2] = radius * Math.sin(theta) * Math.cos(phi);
                
                const brightness = Math.random() * 0.5 + 0.5;
                const colorType = Math.random();
                if (colorType < 0.6) {
                    starColors[i3] = brightness;
                    starColors[i3 + 1] = brightness;
                    starColors[i3 + 2] = brightness;
                } else if (colorType < 0.8) {
                    starColors[i3] = brightness * 0.7;
                    starColors[i3 + 1] = brightness * 0.85;
                    starColors[i3 + 2] = brightness;
                } else {
                    starColors[i3] = brightness;
                    starColors[i3 + 1] = brightness * 0.8;
                    starColors[i3 + 2] = brightness * 0.6;
                }
            }
            
            starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
            starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
            
            const starMaterial = new THREE.PointsMaterial({
                size: 2,
                vertexColors: true,
                transparent: true,
                opacity: 0,
                blending: THREE.AdditiveBlending
            });
            
            const stars = new THREE.Points(starGeometry, starMaterial);
            introScene.add(stars);
            
            // 성운 효과 (배경)
            const nebulaTexture = createNebulaTexture();
            const nebulaMaterial = new THREE.SpriteMaterial({
                map: nebulaTexture,
                transparent: true,
                opacity: 0,
                blending: THREE.AdditiveBlending
            });
            const nebula = new THREE.Sprite(nebulaMaterial);
            nebula.scale.set(2000, 1000, 1);
            nebula.position.z = -800;
            introScene.add(nebula);
            
            function createNebulaTexture() {
                const size = 512;
                const canvas2d = document.createElement('canvas');
                canvas2d.width = size;
                canvas2d.height = size;
                const ctx = canvas2d.getContext('2d');
                
                const gradient = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
                gradient.addColorStop(0, 'rgba(0, 100, 150, 0.3)');
                gradient.addColorStop(0.3, 'rgba(50, 0, 100, 0.2)');
                gradient.addColorStop(0.6, 'rgba(0, 50, 80, 0.1)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, size, size);
                
                return new THREE.CanvasTexture(canvas2d);
            }
            
            // 상태 변수
            let phase = 0;
            let time = 0;
            let progress = 0;
            let introComplete = false;
            let charIndex = 0;
            let cameraTargetZ = 500;
            
            // 시네마틱 시퀀스
            const sequence = [
                { time: 0, action: 'fadeInStars' },
                { time: 1, action: 'showLetterbox' },
                { time: 1.5, action: 'showStudioLogo' },
                { time: 4, action: 'hideStudioLogo' },
                { time: 5, action: 'showMainTitle' },
                { time: 5.5, action: 'typeTitle' },
                { time: 8, action: 'showLoader' },
                { time: 8, action: 'startLoading' }
            ];
            
            let currentSequenceIndex = 0;
            
            // 인트로 사운드
            function playWhoosh() {
                try {
                    const ctx = new (window.AudioContext || window.webkitAudioContext)();
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(200, ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(50, ctx.currentTime + 0.5);
                    gain.gain.setValueAtTime(0.1, ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.5);
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.start();
                    osc.stop(ctx.currentTime + 0.5);
                } catch(e) {}
            }
            
            // 애니메이션 루프
            function animate() {
                if (introComplete) return;
                requestAnimationFrame(animate);
                
                time += 0.016;
                
                // 시퀀스 실행
                while (currentSequenceIndex < sequence.length && time >= sequence[currentSequenceIndex].time) {
                    executeAction(sequence[currentSequenceIndex].action);
                    currentSequenceIndex++;
                }
                
                // 별 회전 & 페이드
                stars.rotation.y += 0.0003;
                stars.rotation.x = Math.sin(time * 0.1) * 0.02;
                
                // 카메라 부드러운 이동
                introCamera.position.z += (cameraTargetZ - introCamera.position.z) * 0.02;
                
                // 성운 움직임
                nebula.position.x = Math.sin(time * 0.1) * 50;
                nebula.position.y = Math.cos(time * 0.15) * 30;
                
                introRenderer.render(introScene, introCamera);
            }
            
            function executeAction(action) {
                switch(action) {
                    case 'fadeInStars':
                        gsapTo(starMaterial, 'opacity', 1, 2);
                        gsapTo(nebulaMaterial, 'opacity', 0.5, 3);
                        break;
                    case 'showLetterbox':
                        letterboxTop.classList.add('active');
                        letterboxBottom.classList.add('active');
                        lensFlare.classList.add('active');
                        break;
                    case 'showStudioLogo':
                        studioLogo.classList.add('visible');
                        playWhoosh();
                        break;
                    case 'hideStudioLogo':
                        studioLogo.classList.add('fadeout');
                        cameraTargetZ = 300;
                        break;
                    case 'showMainTitle':
                        mainTitle.classList.add('visible');
                        titleLines.forEach(line => line.classList.add('expand'));
                        playWhoosh();
                        break;
                    case 'typeTitle':
                        typeNextChar();
                        break;
                    case 'showLoader':
                        loader.classList.add('visible');
                        break;
                    case 'startLoading':
                        startLoadingAnimation();
                        break;
                }
            }
            
            // 간단한 트윈 함수
            function gsapTo(obj, prop, target, duration) {
                const start = obj[prop];
                const startTime = time;
                function update() {
                    if (introComplete) return;
                    const elapsed = time - startTime;
                    const t = Math.min(elapsed / duration, 1);
                    obj[prop] = start + (target - start) * easeOutCubic(t);
                    if (t < 1) requestAnimationFrame(update);
                }
                update();
            }
            
            function easeOutCubic(t) {
                return 1 - Math.pow(1 - t, 3);
            }
            
            // 타이핑 효과
            function typeNextChar() {
                if (charIndex < titleChars.length) {
                    titleChars[charIndex].classList.add('visible');
                    charIndex++;
                    setTimeout(typeNextChar, 80);
                } else {
                    titleTagline.classList.add('visible');
                }
            }
            
            // 로딩 애니메이션
            function startLoadingAnimation() {
                function updateProgress() {
                    if (introComplete) return;
                    progress = Math.min(progress + 1.5, 100);
                    const offset = 283 - (283 * progress / 100);
                    loaderProgress.style.strokeDashoffset = offset;
                    percentText.textContent = Math.floor(progress);
                    
                    if (progress >= 100) {
                        loader.style.display = 'none';
                        startDiv.classList.add('visible');
                    } else {
                        setTimeout(updateProgress, 50);
                    }
                }
                updateProgress();
            }
            
            // 인트로 종료
            function endIntro() {
                introComplete = true;
                overlay.classList.add('fade-out');
                
                const mainMenu = document.getElementById('mode-select-overlay');
                if (mainMenu) mainMenu.style.display = 'flex';
                
                setTimeout(() => {
                    overlay.style.display = 'none';
                    introRenderer.dispose();
                    starGeometry.dispose();
                    starMaterial.dispose();
                }, 1500);
            }
            
            // 이벤트
            startBtn.addEventListener('click', endIntro);
            startBtn.addEventListener('touchend', (e) => { e.preventDefault(); endIntro(); });
            skipBtn.addEventListener('click', endIntro);
            
            // 리사이즈
            window.addEventListener('resize', () => {
                if (introComplete) return;
                introCamera.aspect = window.innerWidth / window.innerHeight;
                introCamera.updateProjectionMatrix();
                introRenderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // SVG 그라데이션 추가
            const svgNS = "http://www.w3.org/2000/svg";
            const defs = document.createElementNS(svgNS, 'defs');
            const gradient = document.createElementNS(svgNS, 'linearGradient');
            gradient.setAttribute('id', 'loader-gradient');
            gradient.innerHTML = '<stop offset="0%" stop-color="#00ffff"/><stop offset="50%" stop-color="#00ff88"/><stop offset="100%" stop-color="#00ffff"/>';
            defs.appendChild(gradient);
            document.querySelector('.loader-ring').appendChild(defs);
            
            // 시작
            animate();
        })();

        // ===== 다국어 시스템 =====
        let currentLang = 'en';  // 기본 언어: 영어
        window.currentLang = currentLang;  // 전역으로 노출
        
        const translations = {
            ko: {
                // 설정
                settings: "⚙️ 설정", sound: "🔊 소리", graphics: "🎨 그래픽", language: "🌐 언어",
                graphicsLow: "낮음", graphicsMedium: "중간", graphicsHigh: "높음",
                // 탑바
                distExp: "거리: 체험", distReal: "거리: 실제 (50x)",
                station: "🛰️ 정거장", catalog: "📖 도감", fullscreen: "⛶ 전체화면", windowMode: "⛶ 창모드",
                fine: "정밀(0~2x)", fast: "고속(1~100x)",
                // 네비게이션
                bodyList: "천체 목록", catalogTitle: "🌌 천체 도감 (클릭하여 생성)",
                // 우주선
                boardShip: "🚀 우주선 탑승", selectShip: "🚀 우주선 선택",
                maxSpeed: "최대 속도", accelStat: "가속력", turnRate: "선회력", fuel: "연료",
                launch: "출격", cancel: "✕ 취소",
                // 조종
                accel: "가속", reverse: "역추진", thrust: "추진", emergencyReverse: "🔥<br>긴급역추진",
                auto: "🤖 자동", orbitEntry: "🌍 궤도진입", orbitExit: "🌍 궤도 이탈",
                interior: "🚪 선내", emergency: "🆘 긴급탈출", disembark: "🌌 우주 모드",
                none: "없음", viewAll: "🔭 전체 보기", unknown: "미상",
                // 상태
                status: "상태", statusNominal: "정상", statusAuto: "자동운항중", statusLowFuel: "연료부족",
                statusCruising: "순항중", statusOrbiting: "궤도운항", statusBraking: "긴급제동",
                // 궤도
                orbitLock: "🌍 궤도 조석 고정", stableOrbit: "안정 궤도",
                orbitPromptMsg: "궤도 조석 고정하시겠습니까?<br>행성을 바라보며 자연스럽게 궤도를 돌게 됩니다.",
                confirmOrbit: "✓ 궤도 고정",
                // 메시지
                msgExpMode: "체험 모드: 관찰하기 쉬운 거리입니다.",
                msgRealMode: "실제 모드: 태양계 축소판! 행성들이 멀리 떨어집니다.",
                msgOrbitEntering: "궤도 진입 중... 선내 이동이 가능합니다.",
                msgOrbitStable: "안정 궤도 도달!",
                msgOrbitExit: "궤도 이탈! 수동 조종으로 전환합니다.",
                msgNeedAuto: "⚠️ 자동항법 또는 궤도 운행 모드에서만 선내로 이동할 수 있습니다.",
                // 로그인
                login: "로그인", register: "회원가입", logout: "로그아웃", username: "아이디", password: "비밀번호",
                welcome: "환영합니다", guest: "게스트", loginFirst: "먼저 로그인하세요",
                // 스페이스코인
                spaceCoin: "스페이스코인", price: "가격", buy: "구매", owned: "보유중", freeShip: "기본 지급",
                notEnoughCoins: "코인이 부족합니다!", alreadyOwned: "이미 보유 중입니다!",
                purchased: "구매 완료!", reward: "보상",
                // 무장
                armory: "⚔️ 무장", armorySystem: "⚔️ 무장 시스템",
                // 우주선
                shipParked: "우주선 주차됨", reboard: "재탑승", goToStation: "정거장으로",
                upgradeAtStation: "정거장에서 업그레이드",
                // 처분
                sellShipTitle: "함선 처분", currentShip: "현재 함선", sellPrice: "처분 가격 (50%)",
                sellAndBoard: "처분 후 탑승", sellMessage: "새 우주선을 탑승하려면 기존 함선을 처분해야 합니다.",
                // HUD
                target: "목표", distance: "거리", eta: "도착예정", speed: "속도",
                // HUD 경고
                lowFuel: "⚠️ 연료 부족!", escapeBoosterReady: "⚡ 긴급탈출 준비됨",
                collisionWarning: "⚠️ 충돌 경고!", hullDamage: "⚠️ 선체 손상!",
                autoDecel: "🔻 자동 감속", emergencyReverseWarn: "🚨 긴급 역추진!",
                gravityCapture: "⚠️ 중력 포착! 탈출 필요!",
                targetLabel: "목표", autopilotLabel: "자동항법", off: "꺼짐", on: "켜짐",
                // 천체 이름
                galacticCenter: "은하 중심", sun: "태양", mercury: "수성", venus: "금성", earth: "지구",
                mars: "화성", jupiter: "목성", saturn: "토성", uranus: "천왕성", neptune: "해왕성",
                moon: "달", phobos: "포보스", deimos: "데이모스", io: "이오", europa: "유로파",
                ganymede: "가니메데", callisto: "칼리스토", titan: "타이탄", enceladus: "엔셀라두스",
                titania: "티타니아", oberon: "오베론", triton: "트리톤",
                // 정거장
                fuelDepotAlpha: "연료정거장 알파", fuelDepotBeta: "연료정거장 베타",
                fuelDepotGamma: "연료정거장 감마", fuelDepotDelta: "연료정거장 델타",
                issStation: "ISS 우주정거장", venusPlatform: "비너스 플랫폼", marsStation: "마스 스테이션",
                jupiterOutpost: "주피터 아웃포스트", saturnBase: "새턴 베이스",
                uranusRelay: "우라노스 릴레이", neptuneTerminal: "넵튠 터미널",
                // 메인 메뉴
                singlePlay: "싱글 플레이", multiPlay: "멀티 플레이", loginBtn: "로그인", settings: "설정",
                singleDesc: "자유로운 우주 탐험 • 천체 생성 • 무제한",
                multiDesc: "실시간 채팅 • 공동 탐험 • 경쟁",
                loginDesc: "계정 연동 • 진행 저장 • 랭킹",
                // 미션
                missionBoard: "미션 보드", missionActive: "진행 중", missionAvailable: "수락 가능", missionCompleted: "완료",
                // 드롭다운 메뉴
                myProfile: "👤 내 프로필", dropdownMissions: "📋 미션 보드", dropdownSettings: "⚙️ 설정", dropdownLogout: "🚪 로그아웃",
                // 천체 정보
                bodyRadius: "반지름", bodyMass: "질량", bodyDistance: "거리", bodyRotation: "자전 속도",
                bodySurfaceGravity: "표면 중력", bodyOrbitalSpeed: "공전 속도", bodyMoons: "위성 수", bodyRings: "고리",
                bodyDetailBtn: "📖 상세보기", bodyFocusBtn: "🎯 추적하기", bodyNavBtn: "🧭 항법 목표 설정",
                bodyBasicInfo: "📊 기본 정보", bodyOrbitInfo: "🛰️ 궤도 정보", bodyDescription: "📝 설명",
                // 천체 정보 모달
                infoBasicInfo: "기본 정보", infoType: "유형", infoOrbit: "공전", infoGravity: "중력", infoTemp: "기온",
                terraformingStatus: "테라포밍 상태", infrastructure: "인프라",
                unexplored: "미탐사", unknownValue: "알 수 없음", days: "일",
                infraSpaceport: "우주항", infraFuel: "연료", infraRepair: "수리", infraShop: "상점", infraResearch: "연구", infraMining: "채굴",
                // 광고 보상
                adRewardsTitle: "🎁 광고 보상", watchAd: "📺 광고 보기", close: "닫기",
                adBoosterTitle: "🚀 2배 부스터", adBoosterDesc: "가속 및 최대 속도 2배 (5분)",
                adEscapeTitle: "⚡ 긴급 탈출", adEscapeDesc: "무료 긴급탈출 1회 (10분)",
                adExploreTitle: "🔭 둘러보기 모드", adExploreDesc: "자유 카메라 탐험 (3분, 누적가능)",
                // 천체 생성
                dragToSetVelocity: "👆 화살표 끝을 드래그하여 방향과 속도를 설정하세요",
                // 인증 UI
                email: "이메일", emailAddress: "이메일 주소", passwordConfirm: "비밀번호 확인",
                nickname: "닉네임", nicknameDesc: "(게임에서 표시)", emailRequired: "(인증 필수)",
                emailVerifyNote: "※ 실제 이메일 주소를 입력해주세요. 인증 메일이 발송됩니다.",
                guestStart: "게스트로 시작 (저장 안됨)", backToLogin: "← 로그인으로 돌아가기",
                findPassword: "비밀번호 찾기", findId: "아이디 찾기", resetPassword: "비밀번호 재설정",
                enterEmailForId: "가입 시 등록한 이메일을 입력하세요",
                enterIdAndEmail: "아이디와 가입 시 등록한 이메일을 입력하세요",
                newPasswordSet: "새 비밀번호가 설정되었습니다", changePasswordAfterLogin: "로그인 후 비밀번호를 변경하세요",
                privacyPolicy: "개인정보 처리방침", termsOfService: "이용약관", agreeToTerms: "에 동의합니다",
                // 조종 UI
                currentCoords: "현재 좌표", navTargetSelect: "🎯 항법 목표 선택...",
                telescope: "망원경", telescopeMode: "🔭 망원경 모드", zoomLevel: "줌",
                exitToCorridor: "[E] 복도로 나가기", docking: "도킹 중...", docked: "도킹됨",
                launching: "발진 중...", selectFromList: "목록에서 항목을 선택하세요",
                warp: "워프", accelerating: "🚀 가속 중...", cruising: "✈️ 순항 중...",
                decelerating: "🔻 감속 중...", arrived: "✅ 도착", orbitTransfer: "🔄 궤도 전이",
                stableOrbitReached: "🌍 안정 궤도", targetPrefix: "목표: ", orbitSuffix: " 궤도",
                statusNormal: "정상", save: "저장", load: "불러오기", enterMessage: "메시지 입력...",
                enterQuestion: "질문을 입력하세요...", selectChannel: "📡 채널을 선택하세요",
                andromeda: "안드로메다은하", notVisitedYet: "⚠️ 아직 방문하지 않은 위성입니다. 직접 비행하여 방문하세요!",
                selectStation: "🛸 우주정거장 선택", selectWeapon: "무기 선택", selectWeaponDesc: "무기를 선택하세요",
                // 채팅
                ariaTab: "🤖 ARIA", chatTab: "💬 채팅", ariaPlaceholder: "ARIA에게 질문...",
                chatNotConnected: "채팅 연결 안됨", systemInit: "시스템 초기화 완료. 안전한 비행 되세요, 파일럿.",
                // 조종 모드
                pilotMode: "🎮 조종 모드", spaceMode: "🌌 우주 모드",
                // 추가 UI 텍스트
                overwrite: "덮어쓰기", delete: "삭제", chatConnected: "채팅 연결됨",
                radioConnecting: "📡 연결 중...", radioConnectionFailed: "⚠️ 연결 실패 - 다시 시도해주세요",
                radioPlaybackFailed: "⚠️ 재생 실패 - 다른 채널을 선택하세요", playing: "재생 중...",
                orbitalStations: "📍 궤도 정거장", fuelDepots: "⛽ 연료 보급소", refueling: "⛽ 연료 충전 중...",
                selectArmor: "방어구 선택", specialAbility: "특수능력", warpAbility: "워프",
                etaLabel: "ETA", user: "사용자",
                // 로그인/회원가입 에러
                enterEmailPassword: "이메일과 비밀번호를 입력해주세요",
                passwordsNotMatch: "비밀번호가 일치하지 않습니다",
                enterNickname: "닉네임을 입력해주세요",
                enterEmailRequired: "이메일을 입력해주세요 (인증 필요)",
                invalidEmailFormat: "올바른 이메일 형식을 입력해주세요",
                agreePrivacy: "개인정보처리방침에 동의해주세요",
                agreeTerms: "이용약관에 동의해주세요",
                confirmLogout: "정말 로그아웃 하시겠습니까?",
                // 아이디/비밀번호 찾기
                enterRegisteredEmail: "가입할 때 등록한 이메일을 입력하세요",
                foundId: "찾은 아이디",
                findIdBtn: "아이디 찾기",
                backToLoginBtn: "← 로그인으로 돌아가기",
                enterIdAndEmailDesc: "아이디와 등록된 이메일을 입력하세요",
                newPasswordSetMsg: "새 비밀번호가 설정되었습니다",
                changePasswordNote: "로그인 후 비밀번호를 변경해주세요",
                resetPasswordBtn: "비밀번호 재설정",
                // 소리
                soundOnOff: "소리 켜기/끄기",
                // 라디오
                spaceStation: "우주 정거장",
                radio: "📻 라디오", radioShort: "📻",
                // orbit
                orbitSuffixText: " 궤도",
                // 추가 에러/상태 메시지
                on: "켜짐", off: "꺼짐",
                connectingServer: "서버 연결 중... 다시 시도해주세요",
                emailAlreadyRegistered: "이미 등록된 이메일입니다",
                enterValidEmail: "올바른 이메일 주소를 입력해주세요",
                registrationComplete: "회원가입 완료! 로그인해주세요",
                serverConnectionFailed: "서버 연결 실패: ",
                enterEmailExample: "이메일 주소를 입력해주세요 (예: user@example.com)",
                invalidEmailOrPassword: "이메일 또는 비밀번호가 틀렸습니다",
                loginFailed: "로그인 실패: ",
                stop: "⏹️ 정지",
                // SSIL
                ssilTrainingProgram: "SSIL 훈련 프로그램",
                ssilSubtitle: "Solar System Integrated Logistics",
                mission: "미션", missionDesc: "설명",
                totalReward: "총 보상", coins: "코인",
                ssilWorkOrder: "SSIL 업무 지시서",
                urgentDelivery: "긴급 배달 요청",
                missionComplete: "🎯 미션 완료!",
                confirm: "확인",
                // 망원경
                telescopeExit: "✕ 망원경 종료",
                mouseDrag: "🖱️ 마우스 드래그: 시점 이동",
                wheelZoom: "🔄 휠 스크롤: 줌 조절",
                escExit: "ESC: 망원경 종료",
                telescopeControls: "📖 조작법",
                zoomLabel: "줌", maxZoomLabel: "최대", targetNone: "타겟: 없음",
                defaultTelescope: "기본 망원경",
                // 우주 가이드
                spaceKnowledgeGuide: "🛸 우주 지식 가이드",
                // UI 설정
                uiSettings: "🎛️ UI 설정",
                uiReposition: "🔧 UI 재배치 모드",
                uiDragToMove: "재배치 모드에서 UI를 드래그하여 이동",
                saveSlots: "💾 저장 슬롯",
                resetDefault: "🔄 기본값으로 리셋",
                done: "✓ 완료",
                // 상점
                equipmentShopPreparing: "장비 상점 준비중...",
                consumablesShopPreparing: "소모품 상점 준비중...",
                // 모바일 탭
                control: "조종", statusTab: "상태", radioTab: "라디오", chatTab2: "채팅", ariaTab2: "ARIA",
                // 이메일 인증
                emailVerificationRequired: "이메일 인증이 필요합니다.<br><small>메일함을 확인해주세요 (스팸함도 확인)</small>",
                // 미션 관련
                accept: "✓ 수락", decline: "✕ 거절", later: "나중에",
                // 중력 경고
                gravityWarning: "으로", turnLeft: "좌측", turnRight: "우측", avoidText: "회피",
                escapeVelocity: "필요 속도", currentVelocity: "현재 속도", deficit: "부족",
                // 도킹/정거장
                docking: "도킹", refuelMenu: "⛽ 연료 보충", refuelingProgress: "⛽ 연료 보급 중...",
                goToStationBtn: "이동",
                // 메시지
                message: "메시지",
                // AI
                aiInitMessage: "시스템 초기화 완료. 안전한 비행 되세요, 파일럿.",
                aiWelcome: "안녕하세요! 천체끼리 충돌하면 흡수되며, 질량이 100을 넘으면 별(항성)이 됩니다.",
                unidentifiedSignal: "미확인 신호", online: "● 온라인",
                // 우주선
                shuttle: "셔틀", shuttleDesc: "기본형 왕복선",
                // 선내
                researchLab: "🚪 연구실", approachedDoor: "문에 접근했습니다", enterDoor: "입장 [E]",
                // 채팅
                send: "전송",
                // 라디오
                spaceRadio: "🛸 우주 라디오",
                // 무장
                damage: "데미지", fireRate: "연사속도", range: "사거리", energy: "에너지",
                tier: "티어", defense: "방어력", hpBonus: "HP 보너스", weightFactor: "중량 계수",
                owned: "보유중", ownedMark: "✓ 보유", locked: "장착 불가",
                // 추가
                noEscapeTicket: "탈출권 없음", chargeComplete: "✅ 충전 완료", minutes: "분",
                afterburnerOff: "애프터버너 해제", orbitEntryCanceled: "궤도 진입 취소. 현재 위치에서 정지.",
                trackingMode: "추적 모드", observatory: "🔭 전망대", undock: "🚀 도킹해제",
                // 충돌/추락
                crashWarning: "추락 위험!", hullDestroyed: "선체 파괴!",
                // 회전 안내
                rotateScreen: "화면을 가로로 회전해주세요",
                rotateScreenSub: "조종 모드는 가로 화면에서만 지원됩니다",
                // 저장된 우주선
                savedShipFound: "저장된 우주선 발견!",
                fuelPercent: "⛽ 연료",
                restoreShip: "이 위치에서 탑승",
                newShipStart: "정거장에서 새로 시작",
                // 접속자
                playersOnline: "🟢 접속자",
                playersCount: "명",
                // 광고
                activated: "✅ 활성화됨", watchAdBtn: "📺 광고 보기",
                // 구매 확인
                confirmPurchase: "을(를) 구매하시겠습니까?",
                coinsUnit: "코인",
                // 초기화
                confirmResetSolar: "태양계를 초기화하시겠습니까?",
                resetSolarDesc: "모든 추가된 천체가 삭제되고 원래 상태로 복원됩니다.",
                resetSolarSystem: "🔄 태양계 초기화",
                // 인증 관련
                noAuthInfo: "인증 정보 없음. 다시 로그인해주세요.",
                verifying: "확인 중...",
                emailPending: "❌ 이메일 인증 대기 중. 메일함을 확인해주세요.",
                loginFailedMsg: "❌ 로그인 실패: ",
                verified: "✅ 인증 완료! 로그인 중...",
                serverError: "❌ 서버 오류: ",
                emailNotFound: "이메일 정보를 찾을 수 없습니다.",
                sendingEmail: "메일 발송 중...",
                resendFailed: "❌ 재발송 실패: ",
                resendSuccess: "✅ 인증 메일을 다시 보냈습니다. 메일함을 확인해주세요.",
                // 닫기
                closeBtn: "✕ 닫기"
            },
            en: {
                // Settings
                settings: "⚙️ Settings", sound: "🔊 Sound", graphics: "🎨 Graphics", language: "🌐 Language",
                graphicsLow: "Low", graphicsMedium: "Medium", graphicsHigh: "High",
                distExp: "Dist: Experience", distReal: "Dist: Real (50x)",
                station: "🛰️ Station", catalog: "📖 Catalog", fullscreen: "⛶ Fullscreen", windowMode: "⛶ Window",
                fine: "Fine(0~2x)", fast: "Fast(1~100x)",
                bodyList: "Celestial Bodies", catalogTitle: "🌌 Celestial Catalog (Click to spawn)",
                boardShip: "🚀 Board Ship", selectShip: "🚀 Select Ship",
                maxSpeed: "Max Speed", accelStat: "Acceleration", turnRate: "Turn Rate", fuel: "Fuel",
                launch: "Launch", cancel: "✕ Cancel",
                accel: "Accel", reverse: "Reverse", thrust: "Thrust", emergencyReverse: "🔥<br>E-Reverse",
                auto: "🤖 Auto", orbitEntry: "🌍 Orbit", orbitExit: "🌍 Exit Orbit",
                interior: "🚪 Interior", emergency: "🆘 Escape", disembark: "✕ Exit",
                none: "None", viewAll: "🔭 View All", unknown: "Unknown",
                status: "STATUS", statusNominal: "NOMINAL", statusAuto: "AUTO", statusLowFuel: "LOW FUEL",
                statusCruising: "CRUISING", statusOrbiting: "ORBITING", statusBraking: "BRAKING",
                orbitLock: "🌍 Tidal Lock Orbit", stableOrbit: "Stable Orbit",
                orbitPromptMsg: "Enter tidal locked orbit?<br>Ship will naturally orbit while facing the planet.",
                confirmOrbit: "✓ Lock Orbit",
                msgExpMode: "Experience mode: Easy viewing distance.",
                msgRealMode: "Real mode: Scale solar system! Planets are far apart.",
                msgOrbitEntering: "Entering orbit... Interior access enabled.",
                msgOrbitStable: "Stable orbit achieved!",
                msgOrbitExit: "Left orbit! Manual control enabled.",
                msgNeedAuto: "⚠️ Interior access requires autopilot or orbit mode.",
                login: "Login", register: "Register", logout: "Logout", username: "Username", password: "Password",
                welcome: "Welcome", guest: "Guest", loginFirst: "Please login first",
                spaceCoin: "SpaceCoin", price: "Price", buy: "Buy", owned: "Owned", freeShip: "Starter",
                notEnoughCoins: "Not enough coins!", alreadyOwned: "Already owned!",
                purchased: "Purchased!", reward: "Reward",
                // Armory
                armory: "⚔️ Armory", armorySystem: "⚔️ Armory System",
                shipParked: "Ship parked", reboard: "Reboard", goToStation: "Go to Station",
                upgradeAtStation: "Upgrade at Station",
                sellShipTitle: "Sell Ship", currentShip: "Current Ship", sellPrice: "Sell Price (50%)",
                sellAndBoard: "Sell & Board", sellMessage: "You must sell your current ship to board a new one.",
                target: "Target", distance: "Distance", eta: "ETA", speed: "Speed",
                // HUD Warnings
                lowFuel: "⚠️ Low Fuel!", escapeBoosterReady: "⚡ Escape Booster Ready",
                collisionWarning: "⚠️ Collision Warning!", hullDamage: "⚠️ Hull Damage!",
                autoDecel: "🔻 Auto Deceleration", emergencyReverseWarn: "🚨 Emergency Reverse!",
                gravityCapture: "⚠️ Gravity Capture! Escape Required!",
                targetLabel: "TARGET", autopilotLabel: "AUTOPILOT", off: "OFF", on: "ON",
                // Celestial Bodies
                galacticCenter: "Galactic Center", sun: "Sun", mercury: "Mercury", venus: "Venus", earth: "Earth",
                mars: "Mars", jupiter: "Jupiter", saturn: "Saturn", uranus: "Uranus", neptune: "Neptune",
                moon: "Moon", phobos: "Phobos", deimos: "Deimos", io: "Io", europa: "Europa",
                ganymede: "Ganymede", callisto: "Callisto", titan: "Titan", enceladus: "Enceladus",
                titania: "Titania", oberon: "Oberon", triton: "Triton",
                // Stations
                fuelDepotAlpha: "Fuel Depot Alpha", fuelDepotBeta: "Fuel Depot Beta",
                fuelDepotGamma: "Fuel Depot Gamma", fuelDepotDelta: "Fuel Depot Delta",
                issStation: "ISS Space Station", venusPlatform: "Venus Platform", marsStation: "Mars Station",
                jupiterOutpost: "Jupiter Outpost", saturnBase: "Saturn Base",
                uranusRelay: "Uranus Relay", neptuneTerminal: "Neptune Terminal",
                // Main Menu
                singlePlay: "Single Play", multiPlay: "Multiplayer", loginBtn: "Login", settings: "Settings",
                singleDesc: "Free space exploration • Create celestial bodies • Unlimited",
                multiDesc: "Real-time chat • Co-op exploration • Competition",
                loginDesc: "Account sync • Save progress • Rankings",
                // Missions
                missionBoard: "Mission Board", missionActive: "Active", missionAvailable: "Available", missionCompleted: "Completed",
                // Dropdown Menu
                myProfile: "👤 My Profile", dropdownMissions: "📋 Mission Board", dropdownSettings: "⚙️ Settings", dropdownLogout: "🚪 Logout",
                // Body Info
                bodyRadius: "Radius", bodyMass: "Mass", bodyDistance: "Distance", bodyRotation: "Rotation",
                bodySurfaceGravity: "Surface Gravity", bodyOrbitalSpeed: "Orbital Speed", bodyMoons: "Moons", bodyRings: "Rings",
                bodyDetailBtn: "📖 Details", bodyFocusBtn: "🎯 Track", bodyNavBtn: "🧭 Set Nav Target",
                bodyBasicInfo: "📊 Basic Info", bodyOrbitInfo: "🛰️ Orbital Info", bodyDescription: "📝 Description",
                // Info modal
                infoBasicInfo: "Basic Info", infoType: "Type", infoOrbit: "Orbit", infoGravity: "Gravity", infoTemp: "Temp",
                terraformingStatus: "Terraforming Status", infrastructure: "Infrastructure",
                unexplored: "Unexplored", unknownValue: "Unknown", days: "days",
                infraSpaceport: "Spaceport", infraFuel: "Fuel", infraRepair: "Repair", infraShop: "Shop", infraResearch: "Research", infraMining: "Mining",
                // Ad Rewards
                adRewardsTitle: "🎁 Ad Rewards", watchAd: "📺 Watch Ad", close: "Close",
                adBoosterTitle: "🚀 2x Booster", adBoosterDesc: "2x acceleration & max speed (5 min)",
                adEscapeTitle: "⚡ Emergency Escape", adEscapeDesc: "Free emergency escape x1 (10 min)",
                adExploreTitle: "🔭 Explore Mode", adExploreDesc: "Free camera exploration (3 min, stackable)",
                // Body Creation
                dragToSetVelocity: "👆 Drag the arrow tip to set direction and speed",
                // Auth UI
                email: "Email", emailAddress: "Email Address", passwordConfirm: "Confirm Password",
                nickname: "Nickname", nicknameDesc: "(Displayed in game)", emailRequired: "(Verification required)",
                emailVerifyNote: "※ Please enter a valid email. Verification email will be sent.",
                guestStart: "Start as Guest (Not saved)", backToLogin: "← Back to Login",
                findPassword: "Find Password", findId: "Find ID", resetPassword: "Reset Password",
                enterEmailForId: "Enter email registered during signup",
                enterIdAndEmail: "Enter your ID and registered email",
                newPasswordSet: "New password has been set", changePasswordAfterLogin: "Please change your password after login",
                privacyPolicy: "Privacy Policy", termsOfService: "Terms of Service", agreeToTerms: "I agree to",
                // Pilot UI
                currentCoords: "Current Coordinates", navTargetSelect: "🎯 Select Navigation Target...",
                telescope: "Telescope", telescopeMode: "🔭 Telescope Mode", zoomLevel: "Zoom",
                exitToCorridor: "[E] Exit to Corridor", docking: "Docking...", docked: "Docked",
                launching: "Launching...", selectFromList: "Select an item from the list",
                warp: "Warp", accelerating: "🚀 Accelerating...", cruising: "✈️ Cruising...",
                decelerating: "🔻 Decelerating...", arrived: "✅ Arrived", orbitTransfer: "🔄 Orbit Transfer",
                stableOrbitReached: "🌍 Stable Orbit", targetPrefix: "Target: ", orbitSuffix: " Orbit",
                statusNormal: "Normal", save: "Save", load: "Load", enterMessage: "Enter message...",
                enterQuestion: "Enter your question...", selectChannel: "📡 Select a channel",
                andromeda: "Andromeda Galaxy", notVisitedYet: "⚠️ Not visited yet. Fly there directly!",
                selectStation: "🛸 Select Station", selectWeapon: "Select Weapon", selectWeaponDesc: "Select a weapon",
                // Chat
                ariaTab: "🤖 ARIA", chatTab: "💬 Chat", ariaPlaceholder: "Ask ARIA...",
                chatNotConnected: "Not connected to chat", systemInit: "System initialized. Fly safe, pilot.",
                // Pilot Mode
                pilotMode: "🎮 Pilot Mode", spaceMode: "🌌 Space Mode",
                // Additional UI text
                overwrite: "Overwrite", delete: "Delete", chatConnected: "Chat connected",
                radioConnecting: "📡 Connecting...", radioConnectionFailed: "⚠️ Connection failed - Please retry",
                radioPlaybackFailed: "⚠️ Playback failed - Select another channel", playing: "Playing...",
                orbitalStations: "📍 Orbital Stations", fuelDepots: "⛽ Fuel Depots", refueling: "⛽ Refueling...",
                selectArmor: "Select Armor", specialAbility: "Special", warpAbility: "Warp",
                etaLabel: "ETA", user: "User",
                // Login/Register errors
                enterEmailPassword: "Please enter email and password",
                passwordsNotMatch: "Passwords do not match",
                enterNickname: "Please enter a nickname",
                enterEmailRequired: "Please enter email (verification required)",
                invalidEmailFormat: "Please enter a valid email format",
                agreePrivacy: "Please agree to the Privacy Policy",
                agreeTerms: "Please agree to the Terms of Service",
                confirmLogout: "Are you sure you want to logout?",
                // Find ID/Password
                enterRegisteredEmail: "Enter the email you registered with",
                foundId: "Found ID",
                findIdBtn: "Find ID",
                backToLoginBtn: "← Back to Login",
                enterIdAndEmailDesc: "Enter your ID and registered email",
                newPasswordSetMsg: "New password has been set",
                changePasswordNote: "Please change your password after login",
                resetPasswordBtn: "Reset Password",
                // Sound
                soundOnOff: "Sound ON/OFF",
                // Radio
                spaceStation: "Space Station",
                radio: "📻 Radio", radioShort: "📻",
                // orbit
                orbitSuffixText: " Orbit",
                // Additional error/status messages
                on: "ON", off: "OFF",
                connectingServer: "Connecting to server... Please try again",
                emailAlreadyRegistered: "Email already registered",
                enterValidEmail: "Please enter a valid email address",
                registrationComplete: "Registration complete! Please login",
                serverConnectionFailed: "Server connection failed: ",
                enterEmailExample: "Please enter email address (e.g. user@example.com)",
                invalidEmailOrPassword: "Invalid email or password",
                loginFailed: "Login failed: ",
                stop: "⏹️ Stop",
                // SSIL
                ssilTrainingProgram: "SSIL Training Program",
                ssilSubtitle: "Solar System Integrated Logistics",
                mission: "Mission", missionDesc: "Description",
                totalReward: "Total Reward", coins: "Coins",
                ssilWorkOrder: "SSIL Work Order",
                urgentDelivery: "Urgent Delivery Request",
                missionComplete: "🎯 Mission Complete!",
                confirm: "Confirm",
                // Telescope
                telescopeExit: "✕ Exit Telescope",
                mouseDrag: "🖱️ Mouse drag: Pan view",
                wheelZoom: "🔄 Scroll wheel: Zoom",
                escExit: "ESC: Exit Telescope",
                // Space Guide
                spaceKnowledgeGuide: "🛸 Space Knowledge Guide",
                // UI Settings
                uiSettings: "🎛️ UI Settings",
                uiReposition: "🔧 UI Reposition Mode",
                // Shop
                equipmentShopPreparing: "Equipment shop preparing...",
                consumablesShopPreparing: "Consumables shop preparing...",
                // Mobile tabs
                control: "Control", statusTab: "Status", radioTab: "Radio", chatTab2: "Chat", ariaTab2: "ARIA",
                // Email verification
                emailVerificationRequired: "Email verification required.<br><small>Please check your mailbox (also spam folder)</small>",
                // Telescope extended
                telescopeControls: "📖 Controls",
                zoomLabel: "Zoom", maxZoomLabel: "Max", targetNone: "Target: None",
                defaultTelescope: "Default Telescope",
                // UI Settings extended
                uiDragToMove: "Drag UI to move in reposition mode",
                saveSlots: "💾 Save Slots",
                resetDefault: "🔄 Reset to Default",
                done: "✓ Done",
                // Mission related
                accept: "✓ Accept", decline: "✕ Decline", later: "Later",
                // Gravity warning
                gravityWarning: " to", turnLeft: "Left", turnRight: "Right", avoidText: "avoid",
                escapeVelocity: "Escape velocity", currentVelocity: "Current velocity", deficit: "Deficit",
                // Docking/Station
                docking: "Dock", refuelMenu: "⛽ Refuel", refuelingProgress: "⛽ Refueling...",
                goToStationBtn: "Go",
                // Message
                message: "Message",
                // AI
                aiInitMessage: "System initialized. Fly safe, pilot.",
                aiWelcome: "Hello! When celestial bodies collide, they merge. If mass exceeds 100, it becomes a star.",
                unidentifiedSignal: "Unidentified Signal", online: "● Online",
                // Spaceship
                shuttle: "Shuttle", shuttleDesc: "Basic shuttle craft",
                // Interior
                researchLab: "🚪 Research Lab", approachedDoor: "Approached door", enterDoor: "Enter [E]",
                // Chat
                send: "Send",
                // Radio
                spaceRadio: "🛸 Space Radio",
                // Armory
                damage: "Damage", fireRate: "Fire Rate", range: "Range", energy: "Energy",
                tier: "Tier", defense: "Defense", hpBonus: "HP Bonus", weightFactor: "Weight",
                owned: "Owned", ownedMark: "✓ Owned", locked: "Locked",
                // Additional
                noEscapeTicket: "No Escape Ticket", chargeComplete: "✅ Charged", minutes: "min",
                afterburnerOff: "Afterburner disabled", orbitEntryCanceled: "Orbit entry canceled. Stopped at current position.",
                trackingMode: "Tracking Mode", observatory: "🔭 Observatory", undock: "🚀 Undock",
                // Crash
                crashWarning: "Crash Warning!", hullDestroyed: "Hull Destroyed!",
                // Rotate screen
                rotateScreen: "Please rotate to landscape",
                rotateScreenSub: "Pilot mode only supports landscape orientation",
                // Saved ship
                savedShipFound: "Saved ship found!",
                fuelPercent: "⛽ Fuel",
                restoreShip: "Board at this location",
                newShipStart: "Start fresh at station",
                // Players online
                playersOnline: "🟢 Online",
                playersCount: "players",
                // Ad
                activated: "✅ Activated", watchAdBtn: "📺 Watch Ad",
                // Purchase confirm
                confirmPurchase: "Do you want to purchase?",
                coinsUnit: "coins",
                // Reset
                confirmResetSolar: "Reset the solar system?",
                resetSolarDesc: "All added celestial bodies will be deleted and restored to original state.",
                resetSolarSystem: "🔄 Reset Solar System",
                // Auth related
                noAuthInfo: "No auth info. Please login again.",
                verifying: "Verifying...",
                emailPending: "❌ Email verification pending. Please check your inbox.",
                loginFailedMsg: "❌ Login failed: ",
                verified: "✅ Verified! Logging in...",
                serverError: "❌ Server error: ",
                emailNotFound: "Email information not found.",
                sendingEmail: "Sending email...",
                resendFailed: "❌ Resend failed: ",
                resendSuccess: "✅ Verification email sent. Please check your mailbox.",
                // Close
                closeBtn: "✕ Close"
            },
            ja: {
                distExp: "距離: 体験", distReal: "距離: 実際 (50x)",
                station: "🛰️ ステーション", catalog: "📖 図鑑", fullscreen: "⛶ 全画面", windowMode: "⛶ ウィンドウ",
                fine: "精密(0~2x)", fast: "高速(1~100x)",
                bodyList: "天体リスト", catalogTitle: "🌌 天体図鑑 (クリックで生成)",
                boardShip: "🚀 宇宙船搭乗", selectShip: "🚀 宇宙船選択",
                maxSpeed: "最高速度", accelStat: "加速力", turnRate: "旋回力", fuel: "燃料",
                launch: "出撃", cancel: "✕ キャンセル",
                accel: "加速", reverse: "逆噴射", thrust: "推進", emergencyBrake: "🔥<br>緊急制動",
                auto: "🤖 自動", orbitEntry: "🌍 軌道突入", orbitExit: "🌍 軌道離脱",
                interior: "🚪 船内", emergency: "🆘 緊急脱出", disembark: "✕ 下船",
                none: "なし", viewAll: "🔭 全体表示",
                status: "状態", statusNominal: "正常", statusAuto: "自動航行中", statusLowFuel: "燃料不足",
                statusCruising: "巡航中", statusOrbiting: "軌道運行", statusBraking: "緊急制動",
                orbitLock: "🌍 潮汐固定軌道", stableOrbit: "安定軌道",
                orbitPromptMsg: "潮汐固定軌道に入りますか？<br>惑星を見ながら自然に周回します。",
                confirmOrbit: "✓ 軌道固定",
                msgExpMode: "体験モード：観察しやすい距離です。",
                msgRealMode: "実際モード：太陽系縮小版！惑星が遠くなります。",
                msgOrbitEntering: "軌道突入中... 船内移動が可能です。",
                msgOrbitStable: "安定軌道到達！",
                msgOrbitExit: "軌道離脱！手動操縦に切り替えます。",
                msgNeedAuto: "⚠️ 船内移動は自動航法または軌道モードでのみ可能です。",
                login: "ログイン", register: "登録", logout: "ログアウト", username: "ユーザー名", password: "パスワード",
                welcome: "ようこそ", guest: "ゲスト", loginFirst: "先にログインしてください",
                spaceCoin: "スペースコイン", price: "価格", buy: "購入", owned: "所持", freeShip: "初期",
                notEnoughCoins: "コインが足りません！", alreadyOwned: "既に所持しています！",
                purchased: "購入完了！", reward: "報酬",
                shipParked: "宇宙船駐機中", reboard: "再搭乗", goToStation: "ステーションへ",
                upgradeAtStation: "ステーションでアップグレード",
                sellShipTitle: "艦船売却", currentShip: "現在の艦船", sellPrice: "売却価格 (50%)",
                sellAndBoard: "売却して搭乗", sellMessage: "新しい宇宙船に乗るには現在の艦船を売却する必要があります。",
                target: "目標", distance: "距離", eta: "到着予定", speed: "速度",
                // 天体名
                galacticCenter: "銀河中心", sun: "太陽", mercury: "水星", venus: "金星", earth: "地球",
                mars: "火星", jupiter: "木星", saturn: "土星", uranus: "天王星", neptune: "海王星",
                moon: "月", phobos: "フォボス", deimos: "ダイモス", io: "イオ", europa: "エウロパ",
                ganymede: "ガニメデ", callisto: "カリスト", titan: "タイタン", enceladus: "エンケラドゥス",
                titania: "チタニア", oberon: "オベロン", triton: "トリトン",
                // ステーション
                fuelDepotAlpha: "燃料補給所アルファ", fuelDepotBeta: "燃料補給所ベータ",
                fuelDepotGamma: "燃料補給所ガンマ", fuelDepotDelta: "燃料補給所デルタ",
                issStation: "ISS宇宙ステーション", venusPlatform: "ヴィーナスプラットフォーム", marsStation: "マーズステーション",
                jupiterOutpost: "ジュピター前哨基地", saturnBase: "サターンベース",
                uranusRelay: "ウラノスリレー", neptuneTerminal: "ネプチューンターミナル",
                // メインメニュー
                singlePlay: "シングルプレイ", multiPlay: "マルチプレイ", loginBtn: "ログイン", settings: "設定",
                singleDesc: "自由な宇宙探検 • 天体生成 • 無制限",
                multiDesc: "リアルタイムチャット • 共同探検 • 競争",
                loginDesc: "アカウント連携 • 進行保存 • ランキング",
                // ミッション
                missionBoard: "ミッションボード", missionActive: "進行中", missionAvailable: "受諾可能", missionCompleted: "完了",
                // ドロップダウンメニュー
                myProfile: "👤 マイプロフィール", dropdownMissions: "📋 ミッションボード", dropdownSettings: "⚙️ 設定", dropdownLogout: "🚪 ログアウト",
                // 天体情報
                bodyRadius: "半径", bodyMass: "質量", bodyDistance: "距離", bodyRotation: "自転速度",
                bodySurfaceGravity: "表面重力", bodyOrbitalSpeed: "公転速度", bodyMoons: "衛星数", bodyRings: "リング",
                bodyDetailBtn: "📖 詳細", bodyFocusBtn: "🎯 追跡", bodyNavBtn: "🧭 航法目標設定",
                bodyBasicInfo: "📊 基本情報", bodyOrbitInfo: "🛰️ 軌道情報", bodyDescription: "📝 説明",
                // 広告報酬
                adRewardsTitle: "🎁 広告報酬", watchAd: "📺 広告を見る", close: "閉じる",
                adBoosterTitle: "🚀 2倍ブースター", adBoosterDesc: "加速と最大速度2倍 (5分)",
                adEscapeTitle: "⚡ 緊急脱出", adEscapeDesc: "無料緊急脱出1回 (10分)",
                adExploreTitle: "🔭 探索モード", adExploreDesc: "フリーカメラ探索 (3分、累積可能)",
                // 天体生成
                dragToSetVelocity: "👆 矢印の先端をドラッグして方向と速度を設定",
                // 追加UIテキスト
                overwrite: "上書き", delete: "削除", chatConnected: "チャット接続済み",
                radioConnecting: "📡 接続中...", radioConnectionFailed: "⚠️ 接続失敗 - 再試行してください",
                radioPlaybackFailed: "⚠️ 再生失敗 - 別のチャンネルを選択", playing: "再生中...",
                orbitalStations: "📍 軌道ステーション", fuelDepots: "⛽ 燃料補給所", refueling: "⛽ 燃料補給中...",
                selectArmor: "アーマー選択", specialAbility: "特殊能力", warpAbility: "ワープ",
                etaLabel: "ETA", user: "ユーザー",
                // ログイン/登録エラー
                enterEmailPassword: "メールアドレスとパスワードを入力してください",
                passwordsNotMatch: "パスワードが一致しません",
                enterNickname: "ニックネームを入力してください",
                enterEmailRequired: "メールアドレスを入力してください（認証必要）",
                invalidEmailFormat: "有効なメール形式を入力してください",
                agreePrivacy: "プライバシーポリシーに同意してください",
                agreeTerms: "利用規約に同意してください",
                confirmLogout: "ログアウトしますか？",
                // ID/パスワード検索
                enterRegisteredEmail: "登録時のメールアドレスを入力",
                foundId: "見つかったID",
                findIdBtn: "ID検索",
                backToLoginBtn: "← ログインに戻る",
                enterIdAndEmailDesc: "IDと登録メールアドレスを入力",
                newPasswordSetMsg: "新しいパスワードが設定されました",
                changePasswordNote: "ログイン後にパスワードを変更してください",
                resetPasswordBtn: "パスワードリセット",
                // サウンド
                soundOnOff: "サウンド ON/OFF",
                // ラジオ
                spaceStation: "宇宙ステーション",
                radio: "📻 ラジオ", radioShort: "📻",
                // 軌道
                orbitSuffixText: " 軌道",
                // 追加エラー/ステータスメッセージ
                on: "ON", off: "OFF",
                connectingServer: "サーバーに接続中... もう一度お試しください",
                emailAlreadyRegistered: "既に登録されているメールアドレスです",
                enterValidEmail: "有効なメールアドレスを入力してください",
                registrationComplete: "登録完了！ログインしてください",
                serverConnectionFailed: "サーバー接続失敗: ",
                enterEmailExample: "メールアドレスを入力してください (例: user@example.com)",
                invalidEmailOrPassword: "メールアドレスまたはパスワードが正しくありません",
                loginFailed: "ログイン失敗: ",
                stop: "⏹️ 停止",
                // 設定
                settings: "⚙️ 設定", sound: "🔊 サウンド", graphics: "🎨 グラフィック", language: "🌐 言語",
                graphicsLow: "低", graphicsMedium: "中", graphicsHigh: "高",
                // 天体情報モーダル
                infoBasicInfo: "基本情報", infoType: "タイプ", infoOrbit: "公転", infoGravity: "重力", infoTemp: "気温",
                terraformingStatus: "テラフォーミング状態", infrastructure: "インフラ",
                unexplored: "未探査", unknownValue: "不明", days: "日",
                infraSpaceport: "宇宙港", infraFuel: "燃料", infraRepair: "修理", infraShop: "ショップ", infraResearch: "研究", infraMining: "採掘",
                // ミッション関連
                accept: "✓ 受諾", decline: "✕ 拒否", later: "後で",
                // ドッキング
                docking: "ドッキング", refuelMenu: "⛽ 燃料補給", refuelingProgress: "⛽ 燃料補給中...",
                goToStationBtn: "移動",
                // 衝突/墜落
                crashWarning: "墜落危険!", hullDestroyed: "船体破壊!",
                // 画面回転
                rotateScreen: "画面を横向きにしてください",
                rotateScreenSub: "操縦モードは横画面のみ対応しています",
                // 保存された宇宙船
                savedShipFound: "保存された宇宙船を発見!",
                fuelPercent: "⛽ 燃料",
                restoreShip: "この位置から搭乗",
                newShipStart: "ステーションから新規開始",
                // 接続者
                playersOnline: "🟢 オンライン",
                playersCount: "人",
                // 広告
                activated: "✅ 有効化済み", watchAdBtn: "📺 広告を見る",
                // 購入確認
                confirmPurchase: "購入しますか?",
                coinsUnit: "コイン",
                // リセット
                confirmResetSolar: "太陽系をリセットしますか?",
                resetSolarDesc: "追加された天体がすべて削除され、元の状態に復元されます。",
                resetSolarSystem: "🔄 太陽系リセット",
                // 認証関連
                noAuthInfo: "認証情報がありません。再度ログインしてください。",
                verifying: "確認中...",
                emailPending: "❌ メール認証待ち。受信トレイを確認してください。",
                loginFailedMsg: "❌ ログイン失敗: ",
                verified: "✅ 認証完了! ログイン中...",
                serverError: "❌ サーバーエラー: ",
                emailNotFound: "メール情報が見つかりません。",
                sendingEmail: "メール送信中...",
                resendFailed: "❌ 再送信失敗: ",
                resendSuccess: "✅ 認証メールを再送信しました。受信トレイを確認してください。",
                // 閉じる
                closeBtn: "✕ 閉じる",
                // 武装
                damage: "ダメージ", fireRate: "発射速度", range: "射程", energy: "エネルギー",
                tier: "ティア", defense: "防御", hpBonus: "HPボーナス", weightFactor: "重量",
                owned: "所持中", ownedMark: "✓ 所持", locked: "ロック",
                // 追加
                noEscapeTicket: "脱出券なし", chargeComplete: "✅ 充電完了", minutes: "分",
                trackingMode: "追跡モード", observatory: "🔭 展望台", undock: "🚀 切離",
            },
            zh: {
                distExp: "距离: 体验", distReal: "距离: 实际 (50x)",
                station: "🛰️ 空间站", catalog: "📖 图鉴", fullscreen: "⛶ 全屏", windowMode: "⛶ 窗口",
                fine: "精密(0~2x)", fast: "高速(1~100x)",
                bodyList: "天体列表", catalogTitle: "🌌 天体图鉴 (点击生成)",
                boardShip: "🚀 登船", selectShip: "🚀 选择飞船",
                maxSpeed: "最高速度", accelStat: "加速力", turnRate: "转向力", fuel: "燃料",
                launch: "出击", cancel: "✕ 取消",
                accel: "加速", reverse: "反推", thrust: "推进", emergencyBrake: "🔥<br>紧急制动",
                auto: "🤖 自动", orbitEntry: "🌍 入轨", orbitExit: "🌍 脱轨",
                interior: "🚪 舱内", emergency: "🆘 紧急逃生", disembark: "✕ 下船",
                none: "无", viewAll: "🔭 全景",
                status: "状态", statusNominal: "正常", statusAuto: "自动航行", statusLowFuel: "燃料不足",
                statusCruising: "巡航中", statusOrbiting: "轨道运行", statusBraking: "紧急制动",
                orbitLock: "🌍 潮汐锁定轨道", stableOrbit: "稳定轨道",
                orbitPromptMsg: "进入潮汐锁定轨道？<br>飞船将面向行星自然环绕。",
                confirmOrbit: "✓ 锁定轨道",
                msgExpMode: "体验模式：便于观察的距离。",
                msgRealMode: "实际模式：太阳系缩小版！行星间距离很远。",
                msgOrbitEntering: "正在入轨... 可进入舱内。",
                msgOrbitStable: "已到达稳定轨道！",
                msgOrbitExit: "已脱离轨道！切换到手动控制。",
                msgNeedAuto: "⚠️ 仅在自动驾驶或轨道模式下可进入舱内。",
                login: "登录", register: "注册", logout: "登出", username: "用户名", password: "密码",
                welcome: "欢迎", guest: "游客", loginFirst: "请先登录",
                spaceCoin: "太空币", price: "价格", buy: "购买", owned: "已拥有", freeShip: "初始",
                notEnoughCoins: "金币不足！", alreadyOwned: "已拥有！",
                purchased: "购买成功！", reward: "奖励",
                shipParked: "飞船停放中", reboard: "重新登船", goToStation: "前往空间站",
                upgradeAtStation: "在空间站升级",
                sellShipTitle: "出售飞船", currentShip: "当前飞船", sellPrice: "出售价格 (50%)",
                sellAndBoard: "出售并登船", sellMessage: "登上新飞船前需要出售当前飞船。",
                target: "目标", distance: "距离", eta: "预计到达", speed: "速度",
                // 天体名称
                galacticCenter: "银河中心", sun: "太阳", mercury: "水星", venus: "金星", earth: "地球",
                mars: "火星", jupiter: "木星", saturn: "土星", uranus: "天王星", neptune: "海王星",
                moon: "月球", phobos: "火卫一", deimos: "火卫二", io: "木卫一", europa: "木卫二",
                ganymede: "木卫三", callisto: "木卫四", titan: "土卫六", enceladus: "土卫二",
                titania: "天卫三", oberon: "天卫四", triton: "海卫一",
                // 空间站
                fuelDepotAlpha: "加油站阿尔法", fuelDepotBeta: "加油站贝塔",
                fuelDepotGamma: "加油站伽马", fuelDepotDelta: "加油站德尔塔",
                issStation: "国际空间站", venusPlatform: "金星平台", marsStation: "火星站",
                jupiterOutpost: "木星前哨", saturnBase: "土星基地",
                uranusRelay: "天王星中继站", neptuneTerminal: "海王星终端",
                // 主菜单
                singlePlay: "单人游戏", multiPlay: "多人游戏", loginBtn: "登录", settings: "设置",
                singleDesc: "自由太空探索 • 创建天体 • 无限制",
                multiDesc: "实时聊天 • 合作探索 • 竞争",
                loginDesc: "账号同步 • 保存进度 • 排行榜",
                // 任务
                missionBoard: "任务板", missionActive: "进行中", missionAvailable: "可接受", missionCompleted: "已完成",
                // 下拉菜单
                myProfile: "👤 我的资料", dropdownMissions: "📋 任务板", dropdownSettings: "⚙️ 设置", dropdownLogout: "🚪 退出登录",
                // 设置
                sound: "🔊 声音", graphics: "🎨 图形", language: "🌐 语言",
                graphicsLow: "低", graphicsMedium: "中", graphicsHigh: "高",
                // 天体信息模态
                infoBasicInfo: "基本信息", infoType: "类型", infoOrbit: "公转", infoGravity: "重力", infoTemp: "温度",
                terraformingStatus: "改造状态", infrastructure: "基础设施",
                unexplored: "未探索", unknownValue: "未知", days: "天",
                infraSpaceport: "太空港", infraFuel: "燃料", infraRepair: "维修", infraShop: "商店", infraResearch: "研究", infraMining: "采矿",
                // 任务相关
                accept: "✓ 接受", decline: "✕ 拒绝", later: "稍后",
                // 对接
                docking: "对接", refuelMenu: "⛽ 加油", refuelingProgress: "⛽ 加油中...",
                goToStationBtn: "前往",
                // 碰撞
                crashWarning: "坠毁危险!", hullDestroyed: "船体毁坏!",
                // 屏幕旋转
                rotateScreen: "请将屏幕横向",
                rotateScreenSub: "驾驶模式仅支持横屏",
                // 保存的飞船
                savedShipFound: "发现保存的飞船!",
                fuelPercent: "⛽ 燃料",
                restoreShip: "从此位置登船",
                newShipStart: "从空间站重新开始",
                // 在线人数
                playersOnline: "🟢 在线",
                playersCount: "人",
                // 广告
                activated: "✅ 已激活", watchAdBtn: "📺 看广告",
                // 购买确认
                confirmPurchase: "确定购买吗?",
                coinsUnit: "金币",
                // 重置
                confirmResetSolar: "重置太阳系吗?",
                resetSolarDesc: "所有添加的天体将被删除并恢复原始状态。",
                resetSolarSystem: "🔄 重置太阳系",
                // 认证相关
                noAuthInfo: "无认证信息，请重新登录。",
                verifying: "验证中...",
                emailPending: "❌ 邮箱验证中，请检查收件箱。",
                loginFailedMsg: "❌ 登录失败: ",
                verified: "✅ 验证成功! 登录中...",
                serverError: "❌ 服务器错误: ",
                emailNotFound: "未找到邮箱信息。",
                sendingEmail: "发送邮件中...",
                resendFailed: "❌ 重发失败: ",
                resendSuccess: "✅ 验证邮件已重发，请检查收件箱。",
                // 关闭
                closeBtn: "✕ 关闭",
                // 武装
                damage: "伤害", fireRate: "射速", range: "射程", energy: "能量",
                tier: "等级", defense: "防御", hpBonus: "HP加成", weightFactor: "重量",
                owned: "已拥有", ownedMark: "✓ 拥有", locked: "锁定",
                // 追加
                noEscapeTicket: "无逃生票", chargeComplete: "✅ 充电完成", minutes: "分钟",
                trackingMode: "追踪模式", observatory: "🔭 观景台", undock: "🚀 脱离",
            },
            fr: {
                distExp: "Dist: Expérience", distReal: "Dist: Réel (50x)",
                station: "🛰️ Station", catalog: "📖 Catalogue", fullscreen: "⛶ Plein écran", windowMode: "⛶ Fenêtre",
                fine: "Fin(0~2x)", fast: "Rapide(1~100x)",
                bodyList: "Corps célestes", catalogTitle: "🌌 Catalogue céleste (Cliquer pour créer)",
                boardShip: "🚀 Embarquer", selectShip: "🚀 Choisir vaisseau",
                maxSpeed: "Vitesse max", accelStat: "Accélération", turnRate: "Virage", fuel: "Carburant",
                launch: "Lancer", cancel: "✕ Annuler",
                accel: "Accél", reverse: "Rétro", thrust: "Poussée", emergencyBrake: "🔥<br>Frein Urg",
                auto: "🤖 Auto", orbitEntry: "🌍 Orbite", orbitExit: "🌍 Quitter orbite",
                interior: "🚪 Intérieur", emergency: "🆘 Évasion", disembark: "✕ Sortir",
                none: "Aucun", viewAll: "🔭 Vue globale",
                status: "ÉTAT", statusNominal: "NORMAL", statusAuto: "AUTO", statusLowFuel: "CARBURANT BAS",
                statusCruising: "CROISIÈRE", statusOrbiting: "EN ORBITE", statusBraking: "FREINAGE",
                orbitLock: "🌍 Orbite verrouillée", stableOrbit: "Orbite stable",
                orbitPromptMsg: "Entrer en orbite verrouillée?<br>Le vaisseau orbite naturellement face à la planète.",
                confirmOrbit: "✓ Verrouiller",
                msgExpMode: "Mode expérience: Distance facile à observer.",
                msgRealMode: "Mode réel: Système solaire à l'échelle! Les planètes sont éloignées.",
                msgOrbitEntering: "Entrée en orbite... Accès intérieur activé.",
                msgOrbitStable: "Orbite stable atteinte!",
                msgOrbitExit: "Orbite quittée! Contrôle manuel activé.",
                msgNeedAuto: "⚠️ Accès intérieur uniquement en pilote auto ou orbite.",
                login: "Connexion", register: "Inscription", logout: "Déconnexion", username: "Identifiant", password: "Mot de passe",
                welcome: "Bienvenue", guest: "Invité", loginFirst: "Connectez-vous d'abord",
                spaceCoin: "SpaceCoin", price: "Prix", buy: "Acheter", owned: "Possédé", freeShip: "Gratuit",
                notEnoughCoins: "Pas assez de pièces!", alreadyOwned: "Déjà possédé!",
                purchased: "Acheté!", reward: "Récompense",
                shipParked: "Vaisseau garé", reboard: "Remonter", goToStation: "Aller à la Station",
                upgradeAtStation: "Améliorer à la Station",
                sellShipTitle: "Vendre Vaisseau", currentShip: "Vaisseau actuel", sellPrice: "Prix de vente (50%)",
                sellAndBoard: "Vendre et Embarquer", sellMessage: "Vous devez vendre votre vaisseau actuel pour en embarquer un nouveau.",
                target: "Cible", distance: "Distance", eta: "Arrivée", speed: "Vitesse",
                // Corps célestes
                galacticCenter: "Centre Galactique", sun: "Soleil", mercury: "Mercure", venus: "Vénus", earth: "Terre",
                mars: "Mars", jupiter: "Jupiter", saturn: "Saturne", uranus: "Uranus", neptune: "Neptune",
                moon: "Lune", phobos: "Phobos", deimos: "Déimos", io: "Io", europa: "Europe",
                ganymede: "Ganymède", callisto: "Callisto", titan: "Titan", enceladus: "Encelade",
                titania: "Titania", oberon: "Obéron", triton: "Triton",
                // Stations
                fuelDepotAlpha: "Dépôt Alpha", fuelDepotBeta: "Dépôt Bêta",
                fuelDepotGamma: "Dépôt Gamma", fuelDepotDelta: "Dépôt Delta",
                issStation: "Station ISS", venusPlatform: "Plateforme Vénus", marsStation: "Station Mars",
                jupiterOutpost: "Avant-poste Jupiter", saturnBase: "Base Saturne",
                uranusRelay: "Relais Uranus", neptuneTerminal: "Terminal Neptune",
                // Menu principal
                singlePlay: "Solo", multiPlay: "Multijoueur", loginBtn: "Connexion", settings: "Paramètres",
                singleDesc: "Exploration libre • Création • Illimité",
                multiDesc: "Chat en direct • Co-op • Compétition",
                loginDesc: "Sync compte • Sauvegarde • Classement",
                // Missions
                missionBoard: "Tableau de missions", missionActive: "En cours", missionAvailable: "Disponible", missionCompleted: "Terminé",
                // Menu déroulant
                myProfile: "👤 Mon profil", dropdownMissions: "📋 Missions", dropdownSettings: "⚙️ Paramètres", dropdownLogout: "🚪 Déconnexion",
                // Paramètres
                sound: "🔊 Son", graphics: "🎨 Graphiques", language: "🌐 Langue",
                graphicsLow: "Bas", graphicsMedium: "Moyen", graphicsHigh: "Haut",
                // Modal info céleste
                infoBasicInfo: "Info de base", infoType: "Type", infoOrbit: "Orbite", infoGravity: "Gravité", infoTemp: "Temp",
                terraformingStatus: "État terraformation", infrastructure: "Infrastructure",
                unexplored: "Non exploré", unknownValue: "Inconnu", days: "jours",
                infraSpaceport: "Spatioport", infraFuel: "Carburant", infraRepair: "Réparation", infraShop: "Boutique", infraResearch: "Recherche", infraMining: "Minage",
                // Mission
                accept: "✓ Accepter", decline: "✕ Refuser", later: "Plus tard",
                // Amarrage
                docking: "Amarrage", refuelMenu: "⛽ Ravitailler", refuelingProgress: "⛽ Ravitaillement...",
                goToStationBtn: "Aller",
                // Collision
                crashWarning: "Danger de crash!", hullDestroyed: "Coque détruite!",
                // Rotation écran
                rotateScreen: "Tournez l'écran en mode paysage",
                rotateScreenSub: "Le mode pilotage ne supporte que le mode paysage",
                // Vaisseau sauvegardé
                savedShipFound: "Vaisseau sauvegardé trouvé!",
                fuelPercent: "⛽ Carburant",
                restoreShip: "Embarquer ici",
                newShipStart: "Repartir de la station",
                // Joueurs en ligne
                playersOnline: "🟢 En ligne",
                playersCount: "joueurs",
                // Pub
                activated: "✅ Activé", watchAdBtn: "📺 Voir la pub",
                // Confirmation achat
                confirmPurchase: "Acheter?",
                coinsUnit: "pièces",
                // Reset
                confirmResetSolar: "Réinitialiser le système solaire?",
                resetSolarDesc: "Tous les corps ajoutés seront supprimés.",
                resetSolarSystem: "🔄 Réinitialiser système solaire",
                // Auth
                noAuthInfo: "Pas d'info auth. Reconnectez-vous.",
                verifying: "Vérification...",
                emailPending: "❌ Vérification email en attente.",
                loginFailedMsg: "❌ Échec connexion: ",
                verified: "✅ Vérifié! Connexion...",
                serverError: "❌ Erreur serveur: ",
                emailNotFound: "Email non trouvé.",
                sendingEmail: "Envoi email...",
                resendFailed: "❌ Échec renvoi: ",
                resendSuccess: "✅ Email de vérification renvoyé.",
                // Fermer
                closeBtn: "✕ Fermer",
                // Armement
                damage: "Dégâts", fireRate: "Cadence", range: "Portée", energy: "Énergie",
                tier: "Niveau", defense: "Défense", hpBonus: "Bonus HP", weightFactor: "Poids",
                owned: "Possédé", ownedMark: "✓ Possédé", locked: "Verrouillé",
                // Supplémentaire
                noEscapeTicket: "Pas de billet", chargeComplete: "✅ Chargé", minutes: "min",
                trackingMode: "Mode suivi", observatory: "🔭 Observatoire", undock: "🚀 Désamarrer",
            },
            la: {
                distExp: "Dist: Experientia", distReal: "Dist: Verum (50x)",
                station: "🛰️ Statio", catalog: "📖 Catalogus", fullscreen: "⛶ Plenus", windowMode: "⛶ Fenestra",
                fine: "Subtilis(0~2x)", fast: "Velox(1~100x)",
                bodyList: "Corpora Caelestia", catalogTitle: "🌌 Catalogus Caelestis (Preme ad creandum)",
                boardShip: "🚀 Ascende Navem", selectShip: "🚀 Elige Navem",
                maxSpeed: "Velocitas Max", accelStat: "Acceleratio", turnRate: "Conversio", fuel: "Combustibile",
                launch: "Emitte", cancel: "✕ Abnega",
                accel: "Accel", reverse: "Retro", thrust: "Impulsus", emergencyBrake: "🔥<br>Frena",
                auto: "🤖 Auto", orbitEntry: "🌍 Orbita", orbitExit: "🌍 Exi Orbita",
                interior: "🚪 Interior", emergency: "🆘 Fuga", disembark: "✕ Descende",
                none: "Nullus", viewAll: "🔭 Omnia Vide",
                status: "STATUS", statusNominal: "BONUS", statusAuto: "AUTO", statusLowFuel: "PARUM",
                statusCruising: "NAVIGANS", statusOrbiting: "ORBITANS", statusBraking: "FRENANS",
                orbitLock: "🌍 Orbita Fixa", stableOrbit: "Orbita Stabilis",
                orbitPromptMsg: "Intrare orbitam fixam?<br>Navis naturaliter orbitat versus planetam.",
                confirmOrbit: "✓ Fige Orbitam",
                msgExpMode: "Modus Experientiae: Distantia facilis ad observandum.",
                msgRealMode: "Modus Verus: Systema Solare! Planetae longe sunt.",
                msgOrbitEntering: "Intrans orbitam... Accessus interior activatus.",
                msgOrbitStable: "Orbita stabilis attacta!",
                msgOrbitExit: "Orbita relicta! Imperium manuale activatum.",
                msgNeedAuto: "⚠️ Accessus interior solum in autopilota vel orbita.",
                // 로그인
                login: "Intra", register: "Inscribe", logout: "Exi", username: "Nomen", password: "Signum",
                welcome: "Salve", guest: "Hospes", loginFirst: "Prius inscribe",
                // 스페이스코인
                spaceCoin: "Nummus Spatialis", price: "Pretium", buy: "Eme", owned: "Possessum", freeShip: "Gratis",
                notEnoughCoins: "Pecunia insufficiens!", alreadyOwned: "Iam possides!",
                purchased: "Emptum!", reward: "Praemium",
                // 우주선
                shipParked: "Navis relicta", reboard: "Reascende", goToStation: "I ad stationem",
                upgradeAtStation: "Ad stationem meliora",
                sellShipTitle: "Vende Navem", currentShip: "Navis praesens", sellPrice: "Pretium venditionis (50%)",
                sellAndBoard: "Vende et Ascende", sellMessage: "Navem praesentem vendere debes ut novam ascendas.",
                // HUD
                target: "Scopus", distance: "Distantia", eta: "Tempus", speed: "Velocitas",
                // Corpora Caelestia
                galacticCenter: "Centrum Galaxiae", sun: "Sol", mercury: "Mercurius", venus: "Venus", earth: "Terra",
                mars: "Mars", jupiter: "Iuppiter", saturn: "Saturnus", uranus: "Uranus", neptune: "Neptunus",
                moon: "Luna", phobos: "Phobos", deimos: "Deimos", io: "Io", europa: "Europa",
                ganymede: "Ganymedes", callisto: "Callisto", titan: "Titan", enceladus: "Enceladus",
                titania: "Titania", oberon: "Oberon", triton: "Triton",
                // Stationes
                fuelDepotAlpha: "Statio Alpha", fuelDepotBeta: "Statio Beta",
                fuelDepotGamma: "Statio Gamma", fuelDepotDelta: "Statio Delta",
                issStation: "Statio ISS", venusPlatform: "Suggestus Veneris", marsStation: "Statio Martis",
                jupiterOutpost: "Praesidium Iovis", saturnBase: "Basis Saturni",
                uranusRelay: "Transmissio Urani", neptuneTerminal: "Terminus Neptuni",
                // Menu Principale
                singlePlay: "Solus", multiPlay: "Multi", loginBtn: "Intra", settings: "Optiones",
                singleDesc: "Exploratio libera • Creatio • Infinitum",
                multiDesc: "Colloquium • Cooperatio • Certamen",
                loginDesc: "Sync • Servo • Ordo",
                // Missiones
                missionBoard: "Tabula Missionum", missionActive: "Activum", missionAvailable: "Praesto", missionCompleted: "Perfectum",
                // Menu
                myProfile: "👤 Profilo Meum", dropdownMissions: "📋 Missiones", dropdownSettings: "⚙️ Optiones", dropdownLogout: "🚪 Exitus",
                // Optiones
                sound: "🔊 Sonus", graphics: "🎨 Graphica", language: "🌐 Lingua",
                graphicsLow: "Infimus", graphicsMedium: "Medius", graphicsHigh: "Summus",
                // Info corporum
                infoBasicInfo: "Info Prima", infoType: "Genus", infoOrbit: "Orbita", infoGravity: "Gravitas", infoTemp: "Temperies",
                terraformingStatus: "Status Terraformationis", infrastructure: "Infrastructura",
                unexplored: "Inexplorata", unknownValue: "Ignotum", days: "dies",
                infraSpaceport: "Portus", infraFuel: "Combustibile", infraRepair: "Reparatio", infraShop: "Taberna", infraResearch: "Investigatio", infraMining: "Fodienda",
                // Missiones
                accept: "✓ Accipe", decline: "✕ Recusa", later: "Postea",
                // Iunctio
                docking: "Iunctio", refuelMenu: "⛽ Refice", refuelingProgress: "⛽ Reficiens...",
                goToStationBtn: "Vade",
                // Collisio
                crashWarning: "Periculum ruinae!", hullDestroyed: "Alveus destructus!",
                // Rota
                rotateScreen: "Verte in latus",
                rotateScreenSub: "Modus gubernandi solum horizontalis",
                // Navis servata
                savedShipFound: "Navis servata inventa!",
                fuelPercent: "⛽ Combustibile",
                restoreShip: "Ascende hic",
                newShipStart: "Initium novum a statione",
                // Connexi
                playersOnline: "🟢 Connexi",
                playersCount: "",
                // Nuntius
                activated: "✅ Activum", watchAdBtn: "📺 Vide",
                // Emptio
                confirmPurchase: "Emere vis?",
                coinsUnit: "nummi",
                // Reset
                confirmResetSolar: "Renovare systema solare?",
                resetSolarDesc: "Omnia corpora addita delebuntur.",
                resetSolarSystem: "🔄 Renova systema solare",
                // Auth
                noAuthInfo: "Nulla info. Iterum intra.",
                verifying: "Verificans...",
                emailPending: "❌ Epistula pendente.",
                loginFailedMsg: "❌ Intratio defecit: ",
                verified: "✅ Verificatum! Intrans...",
                serverError: "❌ Error servientis: ",
                emailNotFound: "Epistula non inventa.",
                sendingEmail: "Mittens epistulam...",
                resendFailed: "❌ Remissio defecit: ",
                resendSuccess: "✅ Epistula remissa.",
                // Claude
                closeBtn: "✕ Claude",
                // Arma
                damage: "Damnum", fireRate: "Celeritas", range: "Spatium", energy: "Energia",
                tier: "Gradus", defense: "Defensio", hpBonus: "HP Bonus", weightFactor: "Pondus",
                owned: "Possessum", ownedMark: "✓ Possessum", locked: "Clausum",
                // Addendum
                noEscapeTicket: "Nulla tessera", chargeComplete: "✅ Paratum", minutes: "min",
                trackingMode: "Modus sequendi", observatory: "🔭 Speculatorium", undock: "🚀 Dissolve",
            }
        };
        window.translations = translations;  // 전역으로 노출
        
        // 우주선 이름 다국어 지원 함수
        function getShipName(ship) {
            const langMap = { ko: 'name', en: 'nameEn', ja: 'nameJa', zh: 'nameZh', fr: 'nameFr', la: 'nameLa' };
            return ship[langMap[currentLang]] || ship.nameEn || ship.name;
        }
        
        function t(key) {
            const lang = window.currentLang || currentLang;
            return translations[lang][key] || translations['en'][key] || key;
        }
        window.t = t;  // 전역으로 노출
        
        // ★★★ 천체 이름 번역 함수 ★★★
        const bodyNameMap = {
            '은하 중심': 'galacticCenter', '태양': 'sun', '수성': 'mercury', '금성': 'venus', '지구': 'earth',
            '화성': 'mars', '목성': 'jupiter', '토성': 'saturn', '천왕성': 'uranus', '해왕성': 'neptune',
            '달': 'moon', '포보스': 'phobos', '데이모스': 'deimos', '이오': 'io', '유로파': 'europa',
            '가니메데': 'ganymede', '칼리스토': 'callisto', '타이탄': 'titan', '엔셀라두스': 'enceladus',
            '티타니아': 'titania', '오베론': 'oberon', '트리톤': 'triton',
            '연료정거장 알파': 'fuelDepotAlpha', '연료정거장 베타': 'fuelDepotBeta',
            '연료정거장 감마': 'fuelDepotGamma', '연료정거장 델타': 'fuelDepotDelta',
            'ISS 우주정거장': 'issStation', '비너스 플랫폼': 'venusPlatform', '마스 스테이션': 'marsStation',
            '주피터 아웃포스트': 'jupiterOutpost', '새턴 베이스': 'saturnBase',
            '우라노스 릴레이': 'uranusRelay', '넵튠 터미널': 'neptuneTerminal',
            '안드로메다은하': 'andromeda'
        };
        
        function translateBodyName(koreanName) {
            const lang = window.currentLang || currentLang;
            const key = bodyNameMap[koreanName];
            if (key && translations[lang][key]) {
                return translations[lang][key];
            }
            return koreanName;  // 번역 없으면 원본 반환
        }
        window.translateBodyName = translateBodyName;  // 전역으로 노출
        
        function setLanguage(lang) {
            currentLang = lang;
            window.currentLang = lang;  // 전역 변수도 업데이트
            localStorage.setItem('milkyway-lang', lang);
            
            // data-i18n 속성이 있는 모든 요소 업데이트
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                if (translations[lang][key]) {
                    el.innerHTML = translations[lang][key];
                }
            });
            
            // placeholder 업데이트
            document.querySelectorAll('[data-placeholder-i18n]').forEach(el => {
                const key = el.getAttribute('data-placeholder-i18n');
                if (translations[lang][key]) {
                    el.placeholder = translations[lang][key];
                }
            });
            
            // ★★★ title 속성 업데이트 ★★★
            document.querySelectorAll('[data-i18n-title]').forEach(el => {
                const key = el.getAttribute('data-i18n-title');
                if (translations[lang][key]) {
                    el.title = translations[lang][key];
                }
            });
            
            // ★★★ 3D 천체 라벨 업데이트 ★★★
            document.querySelectorAll('.label[data-body-name]').forEach(el => {
                const originalName = el.dataset.bodyName;
                if (originalName) {
                    el.textContent = translateBodyName(originalName);
                }
            });
            
            // ★★★ galaxy-label 업데이트 (은하 중심, 안드로메다) ★★★
            document.querySelectorAll('.galaxy-label[data-body-name]').forEach(el => {
                const originalName = el.dataset.bodyName;
                if (originalName) {
                    el.textContent = translateBodyName(originalName);
                }
            });
            
            // 동적 버튼 상태 업데이트
            const scaleBtn = document.getElementById('btn-scale-mode');
            if (scaleBtn) {
                const isReal = CONFIG && CONFIG.distScale > 1.0;
                scaleBtn.textContent = t(isReal ? 'distReal' : 'distExp');
            }
            
            const fullscreenBtn = document.getElementById('btn-fullscreen');
            if (fullscreenBtn) {
                const isFullscreen = !!document.fullscreenElement;
                fullscreenBtn.textContent = t(isFullscreen ? 'windowMode' : 'fullscreen');
            }
            
            // ★★★ 설정 모달 언어 선택 동기화 ★★★
            const settingsLang = document.getElementById('settings-language');
            if (settingsLang) settingsLang.value = lang;
            
            // HUD 업데이트
            updateHUDLanguage();
            
            // ★★★ 네비게이션 천체 목록 업데이트 ★★★
            updateNavList();
            
            // ★★★ 미션 보드 리렌더링 ★★★
            if (typeof MissionSystem !== 'undefined' && MissionSystem.render) {
                MissionSystem.render();
            }
        }
        
        function updateHUDLanguage() {
            // 조종석 HUD 라벨 업데이트는 동적으로 처리
        }

        // ===== 유저 시스템 (Supabase 통합) =====
        let currentUser = null;
        
        // 주차된 우주선 정보
        let parkedShip = null;  // { position, rotation, type, fuel }
        let parkedShipMesh = null;  // 씬에 표시되는 주차된 우주선 메시
        
        // ★ 통합 로그인 체크 함수
        function isUserLoggedIn() {
            return !!(window.mpUser || window.mpUserId);
        }
        
        // ★ 현재 사용자 정보 가져오기
        function getCurrentUserInfo() {
            if (window.mpUser) {
                return {
                    username: window.mpUser.username,
                    nickname: window.mpUser.nickname,
                    coins: window.mpUser.coins || 0,
                    unlockedShips: window.mpUser.unlockedShips || ['shuttle'],
                    currentShip: window.mpUser.currentShip || 'shuttle'
                };
            }
            return null;
        }
        
        // 기존 loginUser 함수는 사용하지 않음 (Supabase로 대체됨)
        function loginUser() {
            console.log('⚠️ 기존 loginUser는 비활성화됨. Supabase 로그인 사용');
            // 구버전 모달 닫기
            var loginModal = document.getElementById('login-modal');
            console.log('login-modal:', loginModal);
            if (loginModal) loginModal.classList.remove('open');
            // Supabase 로그인 창 띄우기
            var authOverlay = document.getElementById('auth-overlay');
            console.log('auth-overlay:', authOverlay);
            if (authOverlay) {
                authOverlay.style.display = 'flex';
                console.log('✅ auth-overlay 표시됨');
                // 회원가입 탭으로 전환
                if (typeof showRegisterTab === 'function') {
                    showRegisterTab();
                }
            } else {
                console.error('❌ auth-overlay를 찾을 수 없음');
            }
            return false;
        }
        
        // ★ 아이디/비밀번호 찾기 (Supabase에서는 이메일로 처리)
        function findUserId(email) {
            showMsg('Please use email password reset in Supabase.');
        }
        
        function findUserPassword(username, email) {
            showMsg('Please use email password reset in Supabase.');
        }
        
        // ★ 로그인 폼 초기화 및 표시
        function showLoginForm() {
            document.getElementById('login-form').style.display = 'block';
            document.getElementById('find-id-form').style.display = 'none';
            document.getElementById('find-pw-form').style.display = 'none';
            document.querySelector('.login-tabs').style.display = 'flex';
            document.getElementById('login-title').innerHTML = '🔐 <span data-i18n="login">Login</span>';
            
            // ★ 약관 섹션 숨김 및 체크 해제
            document.getElementById('terms-agree-section').style.display = 'none';
            const agreePrivacy = document.getElementById('agree-privacy');
            const agreeTerms = document.getElementById('agree-terms');
            if (agreePrivacy) agreePrivacy.checked = false;
            if (agreeTerms) agreeTerms.checked = false;
            
            // 입력 필드 초기화
            document.getElementById('find-id-email').value = '';
            document.getElementById('find-pw-username').value = '';
            document.getElementById('find-pw-email').value = '';
            document.getElementById('find-id-result').style.display = 'none';
            document.getElementById('find-pw-result').style.display = 'none';
            document.getElementById('find-id-error').textContent = '';
            document.getElementById('find-pw-error').textContent = '';
        }
        
        // ★ 아이디 찾기 폼 표시
        function showFindIdForm() {
            document.getElementById('login-form').style.display = 'none';
            document.getElementById('find-id-form').style.display = 'block';
            document.getElementById('find-pw-form').style.display = 'none';
            document.querySelector('.login-tabs').style.display = 'none';
            document.getElementById('login-title').innerHTML = '🔍 ' + t('findId');
        }
        
        // ★ 비밀번호 찾기 폼 표시
        function showFindPwForm() {
            document.getElementById('login-form').style.display = 'none';
            document.getElementById('find-id-form').style.display = 'none';
            document.getElementById('find-pw-form').style.display = 'block';
            document.querySelector('.login-tabs').style.display = 'none';
            document.getElementById('login-title').innerHTML = '🔑 ' + t('findPassword');
        }
        
        function logoutUser() {
            // ★ Supabase 로그아웃
            if (typeof supabase !== 'undefined' && supabase) {
                supabase.auth.signOut().then(function() {
                    console.log('Supabase 로그아웃 완료');
                }).catch(function(e) {
                    console.log('Supabase 로그아웃 오류:', e);
                });
            }
            
            // 로컬 상태 초기화
            currentUser = null;
            window.mpUser = null;
            window.mpUserId = null;
            window.mpNickname = null;
            window.currentUser = null;
            
            localStorage.removeItem('milkyway-currentUser');
            localStorage.removeItem('solar_user');
            
            parkedShip = null;
            savedShipState = null;  // 우주선 상태도 초기화
            
            updateUserUI();
            showMsg('Logged out!');
            
            // 페이지 새로고침 (깔끔한 상태로)
            setTimeout(() => {
                location.reload();
            }, 500);
        }
        window.logoutUser = logoutUser;  // 전역 노출
        
        // ★ 로그아웃 확인 함수
        function confirmLogout() {
            if (confirm(t('confirmLogout'))) {
                logoutUser();
            }
        }
        window.confirmLogout = confirmLogout;
        
        function updateUserUI() {
            const loginBtn = document.getElementById('btn-login');
            const loginMainBtn = document.getElementById('btn-login-main');  // ★ 메인 메뉴 로그인 버튼
            const userInfo = document.getElementById('user-info');
            const userCoins = document.getElementById('user-coins');
            const userName = document.getElementById('user-name');
            const coinAmount = document.getElementById('coin-amount');
            const logoutBtn = document.getElementById('btn-logout');
            const profilePanel = document.getElementById('user-profile-panel');
            
            // Supabase 로그인 상태 확인
            const isLoggedIn = window.mpUser || window.mpUserId;
            const isMultiMode = window.gameMode === 'multi';
            
            console.log('updateUserUI 호출됨, 로그인상태:', isLoggedIn, 'mpUser:', !!window.mpUser, 'mpUserId:', window.mpUserId);
            
            if (isLoggedIn) {
                // 로그인 버튼 숨기기
                if (loginBtn) {
                    loginBtn.style.display = 'none';
                    loginBtn.style.visibility = 'hidden';
                }
                // ★ 메인 메뉴 로그인 버튼도 숨기기
                if (loginMainBtn) {
                    loginMainBtn.style.display = 'none';
                }
                
                // ★★★ 멀티모드: 프로필 패널 표시 ★★★
                if (isMultiMode && profilePanel) {
                    profilePanel.style.display = 'flex';
                    if (userInfo) userInfo.style.display = 'none';
                    if (userCoins) userCoins.style.display = 'none';
                    
                    // 프로필 정보 업데이트
                    const profileName = document.getElementById('profile-name');
                    const profileCoins = document.getElementById('profile-coins');
                    const profileLevel = document.getElementById('profile-level');
                    const profileExpFill = document.getElementById('profile-exp-fill');
                    const profileAvatar = document.getElementById('profile-avatar');
                    
                    if (window.mpUser) {
                        if (profileName) profileName.textContent = window.mpUser.nickname || window.mpUser.username || t('user');
                        if (profileCoins) profileCoins.textContent = (window.mpUser.coins || 0).toLocaleString();
                        
                        // 레벨 계산 (경험치 기반)
                        const exp = window.mpUser.exp || 0;
                        const level = Math.floor(Math.sqrt(exp / 100)) + 1;
                        const expForCurrentLevel = Math.pow(level - 1, 2) * 100;
                        const expForNextLevel = Math.pow(level, 2) * 100;
                        const expProgress = ((exp - expForCurrentLevel) / (expForNextLevel - expForCurrentLevel)) * 100;
                        
                        if (profileLevel) profileLevel.textContent = level;
                        if (profileExpFill) profileExpFill.style.width = Math.min(100, expProgress) + '%';
                        
                        window.userLevel = level;  // 전역 레벨 저장
                        
                        // 아바타 (프로필 이미지가 있으면 표시)
                        if (profileAvatar) {
                            if (window.mpUser.avatar_url) {
                                profileAvatar.innerHTML = `<img src="${window.mpUser.avatar_url}" alt="avatar">`;
                            } else {
                                profileAvatar.innerHTML = '👤';
                            }
                        }
                    } else if (window.mpNickname) {
                        // 게스트
                        if (profileName) profileName.textContent = window.mpNickname;
                        if (profileCoins) profileCoins.textContent = '0';
                        if (profileLevel) profileLevel.textContent = '1';
                    }
                } else {
                    // 싱글모드: 기존 UI 표시
                    if (profilePanel) profilePanel.style.display = 'none';
                    if (userInfo) {
                        userInfo.style.display = 'flex';
                        userInfo.style.visibility = 'visible';
                    }
                    if (userCoins) userCoins.style.display = 'block';
                    if (logoutBtn) {
                        logoutBtn.style.display = 'inline-block';
                        logoutBtn.style.visibility = 'visible';
                    }
                    
                    if (window.mpUser) {
                        if (userName) userName.textContent = window.mpUser.nickname || window.mpUser.username;
                        if (coinAmount) coinAmount.textContent = (window.mpUser.coins || 0).toLocaleString();
                    } else if (window.mpNickname) {
                        if (userName) userName.textContent = window.mpNickname;
                    }
                }
                
                // 주차된 우주선 복원
                if (window.mpUser && window.mpUser.parkedShip) {
                    parkedShip = window.mpUser.parkedShip;
                }
            } else {
                // 로그아웃 상태
                if (loginBtn) {
                    loginBtn.style.display = 'block';
                    loginBtn.style.visibility = 'visible';
                }
                // ★ 메인 메뉴 로그인 버튼 다시 표시
                if (loginMainBtn) {
                    loginMainBtn.style.display = 'flex';
                }
                if (profilePanel) profilePanel.style.display = 'none';
                if (userInfo) {
                    userInfo.style.display = 'none';
                    userInfo.style.visibility = 'hidden';
                }
                if (userCoins) userCoins.style.display = 'none';
                if (logoutBtn) {
                    logoutBtn.style.display = 'none';
                }
            }
        }
        
        // ★★★ 경험치 추가 함수 ★★★
        function addExp(amount) {
            if (window.mpUser && window.supabaseClient) {
                window.mpUser.exp = (window.mpUser.exp || 0) + amount;
                window.supabaseClient
                    .from('profiles')
                    .update({ exp: window.mpUser.exp })
                    .eq('id', window.mpUserId)
                    .then(function() {
                        updateUserUI();
                    })
                    .catch(function(e) {
                        console.warn('경험치 저장 실패:', e);
                    });
            }
        }
        window.addExp = addExp;
        
        function getUserCoins() {
            // Supabase 로그인 상태면 mpUser 사용
            if (window.mpUser && window.mpUser.coins !== undefined) {
                return window.mpUser.coins;
            }
            return 0;
        }
        
        function addCoins(amount) {
            // Supabase 로그인 상태
            if (window.mpUser && window.supabaseClient) {
                window.mpUser.coins = (window.mpUser.coins || 0) + amount;
                window.supabaseClient
                    .from('profiles')
                    .update({ coins: window.mpUser.coins })
                    .eq('id', window.mpUserId)
                    .then(function() {})
                    .catch(function(e) {
                        console.warn('코인 저장 실패:', e);
                    });
                updateUserUI();
            }
        }
        
        function spendCoins(amount) {
            // Supabase 로그인 상태
            if (window.mpUser && window.supabaseClient) {
                if ((window.mpUser.coins || 0) >= amount) {
                    window.mpUser.coins -= amount;
                    window.supabaseClient
                        .from('profiles')
                        .update({ coins: window.mpUser.coins })
                        .eq('id', window.mpUserId)
                        .then(function() {})
                        .catch(function(e) {
                            console.warn('코인 저장 실패:', e);
                        });
                    updateUserUI();
                    return true;
                }
            }
            return false;
        }
        
        function ownsShip(shipId) {
            // Supabase 로그인 상태
            if (window.mpUser && window.mpUser.unlockedShips) {
                return window.mpUser.unlockedShips.includes(shipId);
            }
            // 비로그인 시 기본 4개 우주선만 사용 가능
            return ['shuttle', 'scout', 'interceptor', 'freighter'].includes(shipId);
        }
        
        function buyShip(shipId) {
            if (!window.mpUser) {
                showMsg(t('loginFirst'));
                return false;
            }
            
            var ship = SHIP_TYPES.find(function(s) { return s.id === shipId; });
            if (!ship) return false;
            
            if (ownsShip(shipId)) {
                showMsg(t('alreadyOwned'));
                return false;
            }
            
            if (!spendCoins(ship.price)) {
                showMsg(t('notEnoughCoins'));
                return false;
            }
            
            // Supabase에 저장
            if (window.mpUser && window.supabaseClient) {
                window.mpUser.unlockedShips = window.mpUser.unlockedShips || ['shuttle'];
                window.mpUser.unlockedShips.push(shipId);
                window.supabaseClient
                    .from('profiles')
                    .update({ unlocked_ships: window.mpUser.unlockedShips })
                    .eq('id', window.mpUserId)
                    .then(function() {})
                    .catch(function(e) {
                        console.warn('우주선 저장 실패:', e);
                    });
            }
            
            showMsg('✅ ' + t('purchased') + ' ' + getShipName(ship) + '!');
            return true;
        }
        
        // 우주선 주차 (하선 시)
        function parkShip() {
            if (!playerShip || !playerShip.mesh) return;
            
            parkedShip = {
                position: playerShip.mesh.position.clone(),
                rotation: playerShip.mesh.rotation.clone(),
                quaternion: playerShip.mesh.quaternion.clone(),
                type: currentShipType.id,
                fuel: playerShip.fuel,
                hull: playerShip.hull,
                speed: playerShip.speed
            };
            
            // Supabase에 저장
            if (window.mpUser && window.supabaseClient) {
                window.supabaseClient
                    .from('profiles')
                    .update({ 
                        parked_ship: {
                            type: parkedShip.type,
                            fuel: parkedShip.fuel,
                            hull: parkedShip.hull,
                            position: { x: parkedShip.position.x, y: parkedShip.position.y, z: parkedShip.position.z },
                            rotation: { x: parkedShip.rotation.x, y: parkedShip.rotation.y, z: parkedShip.rotation.z }
                        }
                    })
                    .eq('id', window.mpUserId)
                    .then(function() {})
                    .catch(function(e) {
                        console.warn('주차 정보 저장 실패:', e);
                    });
            }
        }
        
        // 주차된 우주선에 재탑승
        function reboardParkedShip() {
            if (!parkedShip) return false;
            return true;  // 재탑승 가능
        }

        // 1. Constants & Globals
        const CONFIG = {
            G: 0.1,
            timeScale: 0.1,
            subSteps: 10,
            softening: 1.0,
            trailLength: 300,
            distScale: 1.0
        };

        const STAR_THRESHOLD = 100;
        const API_BASE = '/api';  // Vercel API
        const API_URL = 'data.json';  // fallback
        const ASSET_PATH = 'uploads/';  // fallback
        const SUPABASE_STORAGE = 'https://sfirzuqngdbpwvdoyero.supabase.co/storage/v1/object/public/assets/';  // Supabase Storage

        const TEXTURES = {
            SUN: { map: '2k_sun.jpg' }, MERCURY: { map: '2k_mercury.jpg' }, VENUS: { map: '2k_venus_atmosphere.jpg' },
            EARTH: { map: '2k_earth_daymap.jpg' }, MARS: { map: '2k_mars.jpg' }, JUPITER: { map: '2k_jupiter.jpg' },
            SATURN: { map: '2k_saturn.jpg' }, URANUS: { map: '2k_uranus.jpg' }, NEPTUNE: { map: '2k_neptune.jpg' }, MOON: { map: '2k_moon.jpg' }
        };

        // ★ Supabase Storage에 업로드된 파일명 매핑 (assets/ 루트에 있음)
        const SUPABASE_TEXTURES = {
            'earth': 'earth_1765901958.jpeg',
            'mars': 'mars_1765902547.jpg',
            'venus': 'venus_1765902007.jpg',
            'saturn': 'saturn_1765902576.jpg',
            'saturn_ring': 'saturn_ring_1765903886.png',
            'uranus': 'uranus_1765903664.jpg',
            'neptune': 'neptune_1765907700.jpeg',
            'moon': 'moon_1765907677.jpg',
            'mercury': 'mercury_1765902026.jpg',
            'jupiter': 'jupiter_1765902587.jpg'
        };

        // ★ 텍스처 URL 가져오기 함수
        function getTextureUrl(filename) {
            // Supabase Storage에서 찾기
            const baseName = filename.toLowerCase().replace(/\.(jpg|jpeg|png)$/i, '').replace(/^2k_/, '').replace(/_.*$/, '');
            if (SUPABASE_TEXTURES[baseName]) {
                return SUPABASE_STORAGE + SUPABASE_TEXTURES[baseName];
            }
            // uploads/ 경로면 Supabase에서 파일명만 추출해서 시도
            if (filename.startsWith('uploads/')) {
                const justFilename = filename.replace('uploads/', '').replace('ships/', '');
                return SUPABASE_STORAGE + justFilename;
            }
            // http로 시작하면 그대로
            if (filename.startsWith('http')) {
                return filename;
            }
            // 기본: Supabase Storage (루트)
            return SUPABASE_STORAGE + filename;
        }

        let scene, camera, renderer, labelRenderer, controls;
        let bodies = [];
        let satellites = []; 
        let particles = [];
        let focusedBody = null;
        let isPlacing = false;
        let ghostMesh = null;
        let spawnData = null;
        let dragStartPos = null;  // 드래그 시작 위치
        let dragLine = null;      // 드래그 방향 표시 선
        let isDraggingBody = false;  // 천체 드래그 중
        
        // ★★★ 2단계 천체 생성 시스템 (모바일용) ★★★
        let pendingBody = null;        // 1단계에서 배치된 대기 중인 천체
        let pendingBodyMesh = null;    // 대기 중인 천체 메쉬
        let isPendingDrag = false;     // 2단계 드래그 중
        let pendingDragStart = null;   // 2단계 드래그 시작점
        let velocityArrow = null;      // 속도 방향 화살표
        let velocityLine = null;       // 속도 방향 선
        
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
        const textureLoader = new THREE.TextureLoader();
        
        // ★★★ 일식/월식 그림자 시스템 ★★★
        const EclipseSystem = {
            // 그림자 오버레이 메쉬들
            shadowOverlays: new Map(),
            
            // 일식 체크: occluder가 target과 sun 사이에 있는지
            checkEclipse: function(target, occluder, sun) {
                if (!target || !occluder || !sun) return null;
                if (!target.mesh || !occluder.mesh || !sun.mesh) return null;
                
                const sunPos = sun.mesh.position;
                const targetPos = target.mesh.position;
                const occluderPos = occluder.mesh.position;
                
                // 타겟에서 태양으로의 방향
                const toSun = new THREE.Vector3().subVectors(sunPos, targetPos).normalize();
                
                // 타겟에서 가림체까지의 벡터
                const toOccluder = new THREE.Vector3().subVectors(occluderPos, targetPos);
                
                // 가림체가 태양 방향에 있는지 확인 (내적 > 0)
                const dotProduct = toOccluder.dot(toSun);
                if (dotProduct <= 0) return null;  // 가림체가 태양 반대쪽에 있음
                
                // 태양-타겟 선에 대한 가림체의 수직 거리
                const projection = toSun.clone().multiplyScalar(dotProduct);
                const perpendicular = new THREE.Vector3().subVectors(toOccluder, projection);
                const perpDist = perpendicular.length();
                
                // 가림체까지의 거리
                const occluderDist = toOccluder.length();
                
                // 태양까지의 거리
                const sunDist = new THREE.Vector3().subVectors(sunPos, targetPos).length();
                
                // 가림체가 태양보다 가까워야 함
                if (occluderDist >= sunDist) return null;
                
                // 각 크기 계산 (라디안)
                const occluderRadius = occluder.radius || 0.5;
                const targetRadius = target.radius || 1;
                const sunRadius = sun.radius || 10;
                
                // 가림체의 각 크기 (타겟에서 본)
                const occluderAngularSize = Math.atan2(occluderRadius, occluderDist);
                
                // 태양의 각 크기 (타겟에서 본)
                const sunAngularSize = Math.atan2(sunRadius, sunDist);
                
                // 수직 거리의 각도
                const perpAngularDist = Math.atan2(perpDist, occluderDist);
                
                // 그림자 강도 계산
                // 가림체가 태양을 얼마나 가리는지
                if (perpAngularDist > occluderAngularSize + sunAngularSize) {
                    return null;  // 완전히 벗어남
                }
                
                let shadowIntensity = 0;
                if (perpAngularDist < Math.abs(occluderAngularSize - sunAngularSize)) {
                    // 완전 일식 (본영) 또는 금환일식
                    if (occluderAngularSize >= sunAngularSize) {
                        shadowIntensity = 1.0;  // 개기일식
                    } else {
                        shadowIntensity = (occluderAngularSize / sunAngularSize) * (occluderAngularSize / sunAngularSize);  // 금환일식
                    }
                } else {
                    // 부분 일식 (반영) - 강도 증가
                    const overlap = (occluderAngularSize + sunAngularSize - perpAngularDist) / (2 * sunAngularSize);
                    shadowIntensity = Math.max(0, Math.min(1, overlap * 1.5));  // 0.7 → 1.5
                }
                
                return {
                    intensity: shadowIntensity,
                    direction: toSun.clone().negate(),
                    occluderName: occluder.name
                };
            },
            
            // 그림자 오버레이 생성
            createShadowOverlay: function(body) {
                if (!body || !body.mesh) return null;
                
                const radius = body.radius * (body.visualScale || 1) * 1.005;
                const geo = new THREE.SphereGeometry(radius, 64, 64);
                const mat = new THREE.ShaderMaterial({
                    uniforms: {
                        shadowDirection: { value: new THREE.Vector3(1, 0, 0) },
                        shadowIntensity: { value: 0.0 },
                        shadowSoftness: { value: 0.15 },
                        shadowSize: { value: 0.5 }
                    },
                    vertexShader: `
                        varying vec3 vNormal;
                        varying vec3 vWorldPosition;
                        
                        void main() {
                            vNormal = normalize(normalMatrix * normal);
                            vec4 worldPos = modelMatrix * vec4(position, 1.0);
                            vWorldPosition = worldPos.xyz;
                            gl_Position = projectionMatrix * viewMatrix * worldPos;
                        }
                    `,
                    fragmentShader: `
                        uniform vec3 shadowDirection;
                        uniform float shadowIntensity;
                        uniform float shadowSoftness;
                        uniform float shadowSize;
                        
                        varying vec3 vNormal;
                        varying vec3 vWorldPosition;
                        
                        void main() {
                            vec3 normal = normalize(vNormal);
                            vec3 lightDir = normalize(-shadowDirection);
                            
                            // 태양을 향하는 면에만 그림자 적용
                            float facing = dot(normal, lightDir);
                            
                            // 그림자 영역 계산 (부드러운 엣지)
                            float shadowMask = smoothstep(-shadowSoftness, shadowSoftness * 2.0, facing);
                            
                            // 그림자 강도 (5배 증가)
                            float shadow = shadowMask * shadowIntensity * 5.0;
                            shadow = min(shadow, 1.0);  // 최대 1.0으로 클램프
                            
                            // 그림자 색상 (더 어두운 색)
                            vec3 shadowColor = vec3(0.0, 0.0, 0.0);
                            
                            // 가장자리 부드럽게
                            float edgeFade = 1.0 - smoothstep(0.7, 1.0, abs(facing));
                            shadow *= (1.0 - edgeFade * 0.2);
                            
                            gl_FragColor = vec4(shadowColor, shadow * 0.95);
                        }
                    `,
                    transparent: true,
                    side: THREE.FrontSide,
                    depthWrite: false,
                    blending: THREE.MultiplyBlending
                });
                
                const overlay = new THREE.Mesh(geo, mat);
                overlay.renderOrder = 10;
                overlay.name = 'eclipseShadow';
                body.mesh.add(overlay);
                
                return overlay;
            },
            
            // 매 프레임 업데이트
            update: function() {
                const sun = bodies.find(b => b.name === '태양' || b.name === 'Sun');
                if (!sun) return;
                
                // 일식 알림 쿨다운
                if (!this.lastEclipseAlert) this.lastEclipseAlert = {};
                const now = Date.now();
                
                // 모든 행성에 대해 일식 체크
                bodies.forEach(target => {
                    if (target === sun || target.type === 'star' || target.type === 'blackhole') return;
                    
                    // 그림자 오버레이 생성 (최초 1회)
                    if (!this.shadowOverlays.has(target.name)) {
                        const overlay = this.createShadowOverlay(target);
                        if (overlay) {
                            this.shadowOverlays.set(target.name, overlay);
                        }
                    }
                    
                    const overlay = this.shadowOverlays.get(target.name);
                    if (!overlay) return;
                    
                    // 모든 위성(달)에 대해 일식 체크
                    let maxEclipse = null;
                    
                    satellites.forEach(sat => {
                        if (sat.isSpaceStation) return;  // 우주정거장 제외
                        
                        const satBody = {
                            mesh: sat.mesh,
                            radius: sat.radius || 0.3,
                            name: sat.name
                        };
                        
                        const eclipse = this.checkEclipse(target, satBody, sun);
                        if (eclipse && (!maxEclipse || eclipse.intensity > maxEclipse.intensity)) {
                            maxEclipse = eclipse;
                        }
                    });
                    
                    // 다른 행성에 의한 일식도 체크
                    bodies.forEach(occluder => {
                        if (occluder === target || occluder === sun) return;
                        if (occluder.type === 'star' || occluder.type === 'blackhole') return;
                        
                        const eclipse = this.checkEclipse(target, occluder, sun);
                        if (eclipse && (!maxEclipse || eclipse.intensity > maxEclipse.intensity)) {
                            maxEclipse = eclipse;
                        }
                    });
                    
                    // 그림자 적용
                    if (maxEclipse && maxEclipse.intensity > 0.01) {
                        overlay.material.uniforms.shadowIntensity.value = maxEclipse.intensity;
                        overlay.material.uniforms.shadowDirection.value.copy(maxEclipse.direction);
                        overlay.visible = true;
                    } else {
                        overlay.visible = false;
                        overlay.material.uniforms.shadowIntensity.value = 0;
                    }
                });
                
                // 위성(달)에 대해서도 일식 체크 (월식 = 지구 그림자에 달이 들어감)
                satellites.forEach(sat => {
                    if (sat.isSpaceStation) return;
                    
                    // 달 그림자 오버레이 생성
                    const satKey = 'sat_' + sat.name;
                    if (!this.shadowOverlays.has(satKey)) {
                        const satBody = {
                            mesh: sat.mesh,
                            radius: sat.radius || 0.3,
                            visualScale: 1
                        };
                        const overlay = this.createShadowOverlay(satBody);
                        if (overlay) {
                            this.shadowOverlays.set(satKey, overlay);
                        }
                    }
                    
                    const overlay = this.shadowOverlays.get(satKey);
                    if (!overlay) return;
                    
                    // 모행성에 의한 월식 체크
                    const satBody = {
                        mesh: sat.mesh,
                        radius: sat.radius || 0.3,
                        name: sat.name
                    };
                    
                    const eclipse = this.checkEclipse(satBody, sat.parentBody, sun);
                    
                    if (eclipse && eclipse.intensity > 0.01) {
                        overlay.material.uniforms.shadowIntensity.value = eclipse.intensity;
                        overlay.material.uniforms.shadowDirection.value.copy(eclipse.direction);
                        overlay.visible = true;
                    } else {
                        overlay.visible = false;
                        overlay.material.uniforms.shadowIntensity.value = 0;
                    }
                });
            }
        };
        
        window.EclipseSystem = EclipseSystem;

        // ===== 우주선 조종 시스템 변수 =====
        
        // 10종 우주선 타입 정의 (스펙 5배 적용)
        const SHIP_TYPES = [
            {
                id: 'shuttle',
                name: '셔틀',
                nameEn: 'Shuttle',
                nameJa: 'シャトル',
                nameZh: '穿梭机',
                nameFr: 'Navette',
                nameLa: 'Navicula',
                tier: 1,
                maxSpeed: 375,  // 75 * 5
                acceleration: 40.0,
                turnSpeed: 0.125,
                maxFuel: 25,
                maxHull: 80,
                size: 'small',
                color: 0x888888,
                accentColor: 0xcccccc,
                special: null,
                description: '기본형 왕복선. 안정적인 성능.',
                descEn: 'Basic shuttle. Stable performance.',
                descJa: '基本シャトル。安定した性能。',
                descZh: '基础穿梭机。稳定的性能。',
                descFr: 'Navette de base. Performance stable.',
                descLa: 'Navis fundamentalis. Stabilis.',
                price: 500,
                unlocked: true,
                image: '',
                model: 'https://sfirzuqngdbpwvdoyero.supabase.co/storage/v1/object/public/assets/ships/shuttle_model_1767450908791.glb'
            },
            {
                id: 'scout',
                name: '탐사정',
                nameEn: 'Scout',
                nameJa: '偵察機',
                nameZh: '侦察船',
                nameFr: 'Éclaireur',
                nameLa: 'Explorator',
                tier: 1,
                maxSpeed: 450,  // 90 * 5
                acceleration: 50.0,
                turnSpeed: 0.15,
                maxFuel: 30,
                maxHull: 70,
                size: 'small',
                color: 0x4a90d9,
                accentColor: 0x7ec8e3,
                special: 'scan',
                specialDesc: '스캔 범위 +50%',
                description: '장거리 탐사용. 넓은 센서 범위.',
                descEn: 'Long-range scout. Wide sensor range.',
                descJa: '長距離偵察用。広いセンサー範囲。',
                descZh: '远程侦察用。宽广的传感器范围。',
                descFr: 'Éclaireur longue portée. Large zone de capteur.',
                descLa: 'Explorator longinquus. Latus sensus.',
                price: 1000,
                unlocked: true,
                model: 'https://sfirzuqngdbpwvdoyero.supabase.co/storage/v1/object/public/assets/ships/explorer_model_1766457987.glb'
            },
            {
                id: 'interceptor',
                name: '인터셉터',
                nameEn: 'Interceptor',
                nameJa: 'インターセプター',
                nameZh: '拦截机',
                nameFr: 'Intercepteur',
                nameLa: 'Interceptor',
                tier: 2,
                maxSpeed: 875,  // 175 * 5
                acceleration: 100.0,
                turnSpeed: 0.2,
                maxFuel: 20,
                maxHull: 60,
                size: 'small',
                color: 0xe74c3c,
                accentColor: 0xff6b6b,
                special: 'boost',
                specialDesc: '긴급부스트 (3초간 속도 2배)',
                specialCooldown: 30,
                description: '고속 요격기. 빠른 가속과 선회.',
                descEn: 'High-speed interceptor. Fast acceleration.',
                descJa: '高速迎撃機。素早い加速と旋回。',
                descZh: '高速拦截机。快速加速和转向。',
                descFr: 'Intercepteur haute vitesse. Accélération rapide.',
                descLa: 'Velox interceptor. Celer acceleratio.',
                price: 2000,
                unlocked: true,
                model: 'https://sfirzuqngdbpwvdoyero.supabase.co/storage/v1/object/public/assets/ships/interceptor_model_1765905786.glb'
            },
            {
                id: 'freighter',
                name: '화물선',
                nameEn: 'Freighter',
                nameJa: '貨物船',
                nameZh: '货船',
                nameFr: 'Cargo',
                nameLa: 'Oneraria',
                tier: 2,
                maxSpeed: 300,  // 60 * 5
                acceleration: 30.0,
                turnSpeed: 0.075,
                maxFuel: 75,
                maxHull: 150,
                size: 'large',
                color: 0x8b4513,
                accentColor: 0xcd853f,
                special: 'fuelEfficiency',
                specialDesc: '연료 효율 +30%',
                description: '대형 화물선. 느리지만 연료가 풍부.',
                descEn: 'Large freighter. Slow but fuel-rich.',
                descJa: '大型貨物船。遅いが燃料豊富。',
                descZh: '大型货船。速度慢但燃料充足。',
                descFr: 'Grand cargo. Lent mais carburant abondant.',
                descLa: 'Magna oneraria. Lenta sed combustibile.',
                price: 4000,
                unlocked: true,
                model: 'https://sfirzuqngdbpwvdoyero.supabase.co/storage/v1/object/public/assets/ships/freighter_model_1765906618.glb'
            },
            {
                id: 'corvette',
                name: '코르벳',
                nameEn: 'Corvette',
                nameJa: 'コルベット',
                nameZh: '护卫舰',
                nameFr: 'Corvette',
                nameLa: 'Corbita',
                tier: 3,
                maxSpeed: 700,  // 140 * 5
                acceleration: 70.0,
                turnSpeed: 0.15,
                maxFuel: 40,
                maxHull: 120,
                size: 'medium',
                color: 0x2ecc71,
                accentColor: 0x58d68d,
                special: 'shield',
                specialDesc: '쉴드 장착 (충돌 1회 방어)',
                description: '다목적 호위함. 균형 잡힌 성능.',
                descEn: 'Multi-purpose corvette. Balanced stats.',
                descJa: '多目的コルベット。バランスの取れた性能。',
                descZh: '多功能护卫舰。均衡的性能。',
                descFr: 'Corvette polyvalente. Stats équilibrées.',
                descLa: 'Navis multiplex. Aequilibrata.',
                price: 8000,
                unlocked: false
            },
            {
                id: 'racer',
                name: '레이서',
                nameEn: 'Racer',
                nameJa: 'レーサー',
                nameZh: '赛车',
                nameFr: 'Coureur',
                nameLa: 'Cursor',
                tier: 3,
                maxSpeed: 1125,  // 225 * 5
                acceleration: 120.0,
                turnSpeed: 0.25,
                maxFuel: 15,
                maxHull: 50,
                size: 'small',
                color: 0xf39c12,
                accentColor: 0xf7dc6f,
                special: 'afterburner',
                specialDesc: '애프터버너 (연료 3배로 속도 1.5배)',
                description: '극한의 속도. 연료 관리 필수.',
                descEn: 'Extreme speed. Fuel management required.',
                descJa: '極限の速度。燃料管理必須。',
                descZh: '极限速度。燃料管理必需。',
                descFr: 'Vitesse extrême. Gestion carburant requise.',
                descLa: 'Velocitas extrema. Combustibile curandum.',
                price: 12000,
                unlocked: false
            },
            {
                id: 'frigate',
                name: '프리깃',
                nameEn: 'Frigate',
                nameJa: 'フリゲート',
                nameZh: '护卫舰',
                nameFr: 'Frégate',
                nameLa: 'Fregata',
                tier: 4,
                maxSpeed: 800,  // 160 * 5
                acceleration: 80.0,
                turnSpeed: 0.125,
                maxFuel: 60,
                maxHull: 140,
                size: 'medium',
                color: 0x9b59b6,
                accentColor: 0xbb8fce,
                special: 'autoRepair',
                specialDesc: '자동 수리 (10초당 연료 1% 회복)',
                description: '중형 호위함. 장거리 임무에 적합.',
                descEn: 'Medium frigate. Good for long missions.',
                descJa: '中型フリゲート。長距離任務に最適。',
                descZh: '中型护卫舰。适合长途任务。',
                descFr: 'Frégate moyenne. Idéale missions longues.',
                descLa: 'Navis media. Ad longinqua apta.',
                price: 20000,
                unlocked: false
            },
            {
                id: 'cruiser',
                name: '크루저',
                nameEn: 'Cruiser',
                nameJa: 'クルーザー',
                nameZh: '巡洋舰',
                nameFr: 'Croiseur',
                nameLa: 'Cruciator',
                tier: 4,
                maxSpeed: 625,  // 125 * 5
                acceleration: 60.0,
                turnSpeed: 0.1,
                maxFuel: 100,
                maxHull: 180,
                size: 'large',
                color: 0x3498db,
                accentColor: 0x85c1e9,
                special: 'warp',
                specialDesc: '워프 드라이브 (목표로 즉시 이동)',
                specialCooldown: 60,
                description: '대형 순양함. 워프 기능 탑재.',
                descEn: 'Large cruiser. Warp drive equipped.',
                descJa: '大型巡洋艦。ワープドライブ搭載。',
                descZh: '大型巡洋舰。配备曲速引擎。',
                descFr: 'Grand croiseur. Moteur warp équipé.',
                descLa: 'Magna navis. Propulsio warpi.',
                price: 35000,
                unlocked: false
            },
            {
                id: 'battleship',
                name: '배틀십',
                nameEn: 'Battleship',
                nameJa: 'バトルシップ',
                nameZh: '战舰',
                nameFr: 'Cuirassé',
                nameLa: 'Navis Bellica',
                tier: 5,
                maxSpeed: 550,  // 110 * 5
                acceleration: 50.0,
                turnSpeed: 0.075,
                maxFuel: 150,
                maxHull: 250,
                size: 'huge',
                color: 0x1a5276,
                accentColor: 0x2980b9,
                special: 'gravityResist',
                specialDesc: '중력 저항 (중력 영향 50% 감소)',
                description: '초대형 전함. 중력에 강하다.',
                descEn: 'Super-large battleship. Gravity resistant.',
                descJa: '超大型戦艦。重力に強い。',
                descZh: '超大型战舰。抗重力能力强。',
                descFr: 'Super cuirassé. Résistant à la gravité.',
                descLa: 'Navis maxima. Gravitas resistens.',
                price: 60000,
                unlocked: false
            },
            {
                id: 'flagship',
                name: '플래그십',
                nameEn: 'Flagship',
                nameJa: 'フラッグシップ',
                nameZh: '旗舰',
                nameFr: 'Vaisseau Amiral',
                nameLa: 'Navis Praetoria',
                tier: 5,
                maxSpeed: 1000,  // 200 * 5
                acceleration: 90.0,
                turnSpeed: 0.15,
                maxFuel: 250,
                maxHull: 300,
                size: 'huge',
                color: 0xd4af37,
                accentColor: 0xffd700,
                special: 'allInOne',
                specialDesc: '전 기능 통합',
                description: '최고급 기함. 모든 능력 보유.',
                descEn: 'Ultimate flagship. All abilities included.',
                descJa: '最高級旗艦。全能力搭載。',
                descZh: '顶级旗舰。拥有所有能力。',
                descFr: 'Vaisseau amiral ultime. Toutes capacités.',
                descLa: 'Optima navis. Omnes facultates.',
                price: 100000,
                unlocked: false
            }
        ];

        // 전역 노출 (멀티플레이어에서 사용)
        window.SHIP_TYPES = SHIP_TYPES;

        // ★ 무기 시스템 (30종)
        const WEAPONS = [
            // Tier 1 - 기본 무기 (셔틀~탐사정)
            { id: 'laser_basic', name: '기본 레이저', tier: 1, damage: 10, fireRate: 2.0, range: 500, energy: 5, price: 200, desc: '가장 기본적인 레이저 무기' },
            { id: 'laser_dual', name: '듀얼 레이저', tier: 1, damage: 18, fireRate: 1.8, range: 500, energy: 8, price: 400, desc: '두 줄기 레이저 동시 발사' },
            { id: 'machinegun', name: '우주 기관총', tier: 1, damage: 5, fireRate: 8.0, range: 300, energy: 2, price: 350, desc: '빠른 연사 속도의 실탄 무기' },
            { id: 'flare_launcher', name: '플레어 런처', tier: 1, damage: 15, fireRate: 1.0, range: 200, energy: 10, price: 300, desc: '미사일 교란용 플레어' },
            
            // Tier 2 - 중급 무기 (인터셉터~화물선)
            { id: 'laser_triple', name: '트리플 레이저', tier: 2, damage: 25, fireRate: 1.5, range: 600, energy: 12, price: 800, desc: '세 줄기 레이저 동시 발사' },
            { id: 'pulse_laser', name: '펄스 레이저', tier: 2, damage: 30, fireRate: 3.0, range: 450, energy: 15, price: 1000, desc: '고속 펄스 에너지탄' },
            { id: 'missile_basic', name: '기본 미사일', tier: 2, damage: 50, fireRate: 0.5, range: 1000, energy: 20, price: 1200, desc: '유도 기능 없는 직선 미사일' },
            { id: 'gatling', name: '개틀링건', tier: 2, damage: 8, fireRate: 12.0, range: 350, energy: 3, price: 1500, desc: '초고속 회전 기관포' },
            { id: 'shotgun', name: '스페이스 산탄총', tier: 2, damage: 40, fireRate: 0.8, range: 150, energy: 18, price: 900, desc: '근거리 광역 피해' },
            
            // Tier 3 - 고급 무기 (코르벳~레이서)
            { id: 'beam_laser', name: '빔 레이저', tier: 3, damage: 45, fireRate: 0.1, range: 800, energy: 25, price: 3000, desc: '지속 조사형 고출력 빔' },
            { id: 'plasma_cannon', name: '플라즈마 캐논', tier: 3, damage: 60, fireRate: 1.0, range: 600, energy: 30, price: 3500, desc: '고온 플라즈마 발사' },
            { id: 'ion_cannon', name: '이온 캐논', tier: 3, damage: 35, fireRate: 1.5, range: 700, energy: 22, price: 2800, desc: '적 시스템 마비 효과' },
            { id: 'homing_missile', name: '호밍 미사일', tier: 3, damage: 70, fireRate: 0.4, range: 1500, energy: 35, price: 4000, desc: '열추적 유도 미사일' },
            { id: 'sniper_cannon', name: '스나이퍼 캐논', tier: 3, damage: 100, fireRate: 0.3, range: 2000, energy: 40, price: 4500, desc: '초장거리 정밀 사격' },
            { id: 'emp_missile', name: 'EMP 미사일', tier: 3, damage: 20, fireRate: 0.3, range: 800, energy: 45, price: 5000, desc: '전자기 펄스로 시스템 마비' },
            
            // Tier 4 - 전함급 무기 (프리깃~크루저)
            { id: 'railgun', name: '레일건', tier: 4, damage: 150, fireRate: 0.2, range: 2500, energy: 60, price: 8000, desc: '전자기 가속 관통탄' },
            { id: 'gauss_cannon', name: '가우스 캐논', tier: 4, damage: 120, fireRate: 0.4, range: 1800, energy: 50, price: 7000, desc: '자기장 가속 중금속탄' },
            { id: 'torpedo', name: '광자 어뢰', tier: 4, damage: 200, fireRate: 0.15, range: 3000, energy: 80, price: 10000, desc: '대형 함선용 중어뢰' },
            { id: 'cluster_missile', name: '클러스터 미사일', tier: 4, damage: 30, fireRate: 0.5, range: 1200, energy: 55, price: 9000, desc: '분산 탄두 8발 동시 폭발' },
            { id: 'tesla_coil', name: '테슬라 코일', tier: 4, damage: 80, fireRate: 2.0, range: 400, energy: 45, price: 8500, desc: '연쇄 전기 방전' },
            { id: 'disruptor', name: '디스럽터', tier: 4, damage: 90, fireRate: 0.8, range: 600, energy: 55, price: 9500, desc: '실드 특화 파괴 무기' },
            
            // Tier 5 - 최종병기 (배틀십~플래그십)
            { id: 'antimatter_cannon', name: '반물질 캐논', tier: 5, damage: 300, fireRate: 0.1, range: 2000, energy: 100, price: 25000, desc: '반물질 폭발로 광역 피해' },
            { id: 'quantum_cannon', name: '양자 캐논', tier: 5, damage: 250, fireRate: 0.15, range: 2500, energy: 90, price: 22000, desc: '양자 불확정성 관통' },
            { id: 'nuke_missile', name: '핵 미사일', tier: 5, damage: 500, fireRate: 0.05, range: 5000, energy: 150, price: 30000, desc: '전술 핵탄두 미사일' },
            { id: 'gravity_well', name: '중력장 발생기', tier: 5, damage: 50, fireRate: 0.2, range: 1000, energy: 120, price: 28000, desc: '중력장으로 적 속박' },
            { id: 'mine_layer', name: '퀀텀 마인', tier: 5, damage: 180, fireRate: 0.3, range: 100, energy: 70, price: 20000, desc: '공간에 기뢰 설치' },
            { id: 'singularity_launcher', name: '특이점 발사기', tier: 5, damage: 400, fireRate: 0.08, range: 1500, energy: 130, price: 35000, desc: '미니 블랙홀 생성' },
            { id: 'darkmatter_beam', name: '암흑물질 빔', tier: 5, damage: 350, fireRate: 0.1, range: 3000, energy: 110, price: 32000, desc: '암흑물질 에너지 방출' },
            { id: 'tachyon_beam', name: '타키온 빔', tier: 5, damage: 280, fireRate: 0.2, range: 4000, energy: 95, price: 28000, desc: '초광속 입자 빔' },
            { id: 'omega_cannon', name: '오메가 캐논', tier: 5, damage: 1000, fireRate: 0.02, range: 3500, energy: 200, price: 50000, desc: '최종 병기, 행성급 파괴력' }
        ];
        
        // ★ 장갑 시스템 (5단계)
        const ARMORS = [
            { 
                id: 'steel_armor', 
                name: '강철 합금 장갑', 
                tier: 1, 
                defense: 50, 
                hpBonus: 100, 
                weight: 1.0,
                price: 500, 
                desc: '기본적인 강철 합금 장갑판',
                effect: null
            },
            { 
                id: 'titanium_armor', 
                name: '강화 티타늄 장갑', 
                tier: 2, 
                defense: 100, 
                hpBonus: 200, 
                weight: 0.9,
                price: 2000, 
                desc: '경량 고강도 티타늄 복합재',
                effect: '이동속도 감소 10% 감면'
            },
            { 
                id: 'nanocarbon_armor', 
                name: '나노카본 복합 장갑', 
                tier: 3, 
                defense: 180, 
                hpBonus: 350, 
                weight: 0.7,
                price: 8000, 
                desc: '나노 탄소섬유 자가수복 장갑',
                effect: '5초당 HP 1% 자동 회복'
            },
            { 
                id: 'energy_shield', 
                name: '에너지 실드', 
                tier: 4, 
                defense: 280, 
                hpBonus: 500, 
                weight: 0.5,
                price: 20000, 
                desc: '에너지 역장 방어막',
                effect: '에너지 무기 피해 30% 감소'
            },
            { 
                id: 'quantum_barrier', 
                name: '양자 분해 방어벽', 
                tier: 5, 
                defense: 500, 
                hpBonus: 1000, 
                weight: 0.3,
                price: 50000, 
                desc: '양자 얽힘을 이용한 물질 분해 방어벽. 접촉하는 모든 물체를 양자 수준에서 분해하여 무효화',
                effect: '피해의 20%를 적에게 반사, 일정 확률로 피해 완전 무효화'
            }
        ];
        
        // ★ 우주선별 무기/장갑 슬롯 설정
        const SHIP_COMBAT_STATS = {
            shuttle:     { weaponSlots: 1, armorSlots: 1, maxWeaponTier: 1, maxArmorTier: 2, hp: 100 },
            scout:       { weaponSlots: 1, armorSlots: 1, maxWeaponTier: 2, maxArmorTier: 2, hp: 80 },
            interceptor: { weaponSlots: 2, armorSlots: 1, maxWeaponTier: 3, maxArmorTier: 2, hp: 120 },
            freighter:   { weaponSlots: 1, armorSlots: 3, maxWeaponTier: 2, maxArmorTier: 3, hp: 300 },
            corvette:    { weaponSlots: 3, armorSlots: 2, maxWeaponTier: 3, maxArmorTier: 3, hp: 200 },
            racer:       { weaponSlots: 2, armorSlots: 1, maxWeaponTier: 3, maxArmorTier: 2, hp: 90 },
            frigate:     { weaponSlots: 4, armorSlots: 3, maxWeaponTier: 4, maxArmorTier: 4, hp: 350 },
            cruiser:     { weaponSlots: 5, armorSlots: 4, maxWeaponTier: 4, maxArmorTier: 4, hp: 500 },
            battleship:  { weaponSlots: 8, armorSlots: 5, maxWeaponTier: 5, maxArmorTier: 5, hp: 800 },
            flagship:    { weaponSlots: 10, armorSlots: 5, maxWeaponTier: 5, maxArmorTier: 5, hp: 1000 }
        };
        
        // ★ 무기 아이콘 매핑
        const WEAPON_ICONS = {
            laser_basic: '🔫', laser_dual: '🔫', laser_triple: '🔫', beam_laser: '⚡',
            pulse_laser: '💥', machinegun: '🔧', gatling: '⚙️', shotgun: '💣',
            flare_launcher: '🎆', missile_basic: '🚀', homing_missile: '🎯', emp_missile: '⚡',
            cluster_missile: '💢', plasma_cannon: '🔥', ion_cannon: '⚡', sniper_cannon: '🎯',
            railgun: '⚡', gauss_cannon: '🧲', torpedo: '🐟', tesla_coil: '⚡',
            disruptor: '💫', antimatter_cannon: '☢️', quantum_cannon: '🔮', nuke_missile: '☢️',
            gravity_well: '🌀', mine_layer: '💣', singularity_launcher: '🕳️',
            darkmatter_beam: '🌑', tachyon_beam: '✨', omega_cannon: '💀'
        };
        
        const ARMOR_ICONS = {
            steel_armor: '🛡️', titanium_armor: '🔰', nanocarbon_armor: '🔷',
            energy_shield: '💠', quantum_barrier: '🌟'
        };
        
        // ★ 플레이어 무장 인벤토리 (localStorage)
        let playerArmory = JSON.parse(localStorage.getItem('milkyway-armory') || '{}');
        
        function saveArmory() {
            localStorage.setItem('milkyway-armory', JSON.stringify(playerArmory));
        }
        
        function getPlayerArmory() {
            // mpUser 또는 mpUserId 사용
            const oderId = window.mpUserId || (window.mpUser && window.mpUser.username);
            if (!oderId) return { ownedWeapons: [], ownedArmors: [], equipped: {} };
            if (!playerArmory[oderId]) {
                playerArmory[oderId] = {
                    ownedWeapons: ['laser_basic'],  // 기본 무기 지급
                    ownedArmors: [],
                    equipped: {}  // shipId: { weapons: [], armor: null }
                };
                saveArmory();
            }
            return playerArmory[oderId];
        }
        
        function ownsWeapon(weaponId) {
            return getPlayerArmory().ownedWeapons.includes(weaponId);
        }
        
        function ownsArmor(armorId) {
            return getPlayerArmory().ownedArmors.includes(armorId);
        }
        
        function buyWeapon(weaponId) {
            const weapon = WEAPONS.find(w => w.id === weaponId);
            const userId = window.mpUserId || (window.mpUser && window.mpUser.username);
            if (!weapon || !userId) return false;
            if (ownsWeapon(weaponId)) return false;
            if (!spendCoins(weapon.price)) return false;
            getPlayerArmory().ownedWeapons.push(weaponId);
            saveArmory();
            return true;
        }
        
        function buyArmor(armorId) {
            const armor = ARMORS.find(a => a.id === armorId);
            const userId = window.mpUserId || (window.mpUser && window.mpUser.username);
            if (!armor || !userId) return false;
            if (ownsArmor(armorId)) return false;
            if (!spendCoins(armor.price)) return false;
            getPlayerArmory().ownedArmors.push(armorId);
            saveArmory();
            return true;
        }
        
        function getEquipped(shipId) {
            const armory = getPlayerArmory();
            if (!armory.equipped[shipId]) {
                armory.equipped[shipId] = { weapons: [], armor: null };
            }
            return armory.equipped[shipId];
        }
        
        function equipWeapon(shipId, weaponId, slotIndex) {
            const ship = SHIP_TYPES.find(s => s.id === shipId);
            const weapon = WEAPONS.find(w => w.id === weaponId);
            const combatStats = SHIP_COMBAT_STATS[shipId];
            if (!ship || !weapon || !combatStats) return false;
            if (weapon.tier > combatStats.maxWeaponTier) return false;
            if (slotIndex >= combatStats.weaponSlots) return false;
            if (!ownsWeapon(weaponId)) return false;
            
            const equipped = getEquipped(shipId);
            equipped.weapons[slotIndex] = weaponId;
            saveArmory();
            return true;
        }
        
        function equipArmor(shipId, armorId) {
            const ship = SHIP_TYPES.find(s => s.id === shipId);
            const armor = ARMORS.find(a => a.id === armorId);
            const combatStats = SHIP_COMBAT_STATS[shipId];
            if (!ship || !armor || !combatStats) return false;
            if (armor.tier > combatStats.maxArmorTier) return false;
            if (!ownsArmor(armorId)) return false;
            
            const equipped = getEquipped(shipId);
            equipped.armor = armorId;
            saveArmory();
            return true;
        }
        
        function unequipWeapon(shipId, slotIndex) {
            const equipped = getEquipped(shipId);
            equipped.weapons[slotIndex] = null;
            saveArmory();
        }
        
        function unequipArmor(shipId) {
            const equipped = getEquipped(shipId);
            equipped.armor = null;
            saveArmory();
        }
        
        // 현재 우주선 설정 (선택된 우주선 타입에서 가져옴)
        let currentShipType = SHIP_TYPES[0];  // 기본: 셔틀
        window.currentShipType = currentShipType;  // ★ 전역 노출
        let selectedShipIndex = 0;
        
        // 특수능력 상태
        let shipAbility = {
            cooldown: 0,
            shieldActive: false,
            afterburnerActive: false,
            warpReady: true
        };
        
        // 거리 모드 저장용
        let savedDistScale = 1.0;
        
        const SHIP_CONFIG = {
            get maxSpeed() { return currentShipType.maxSpeed; },
            get acceleration() { return currentShipType.acceleration; },
            get deceleration() { return currentShipType.acceleration * 0.6; },
            get reverseThrust() { return currentShipType.acceleration * 2.5; },
            get turnSpeed() { return currentShipType.turnSpeed; },
            get maxFuel() { return currentShipType.maxFuel; },
            get maxHull() { return currentShipType.maxHull || 100; },  // ★ 내구도 추가
            fuelConsumption: 5.0,  // 100배 증가 (0.05 → 5.0)
            reverseFuelMult: 5,
            emergencyBrakeFuelMult: 3,
            gravityWarningThreshold: 0.3,
            orbitAltitudeMultiplier: 2.5
        };
        
        let playerShip = null;
        let savedShipState = null;  // 우주선 위치/방향 저장용
        let dockedShipMesh = null;
        let isPilotMode = false;
        let isInteriorMode = false;
        let isObservatoryMode = false;
        let shipTargetBody = null;
        let autopilot = { engaged: false, phase: 'idle' };
        const shipInputs = { pitch: 0, yaw: 0, throttle: 0, brake: false, emergencyReverse: false };
        window.shipInputs = shipInputs;  // ★ 전역으로 노출 (모바일 버튼용)
        let joystickActive = false, joystickCenter = { x: 0, y: 0 };
        let currentETA = 0;
        let isGravityWarning = false;
        let beepInterval = null;
        
        // ★ engineConfig 불꽃 그룹 (전역)
        var configuredThrustFlames = null;
        var configuredReverseFlames = null;
        var hasEngineConfig = false;
        let audioContext = null;
        
        // ★ 도킹 해제 연출 시스템
        let undockingState = {
            active: false,
            phase: 'idle',  // 'idle', 'undocking', 'complete'
            startTime: 0,
            duration: 4000,  // ★ 4초 연출
            startPos: null,
            targetDist: 2,   // ★ 정거장에서 이탈 거리 (더 줄임)
            stationPos: null,
            undockDirection: null  // ★ 지구 반대 방향 저장
        };
        
        // ★ 긴급 역추진 시스템
        let emergencyBrakeActive = false;
        const EMERGENCY_BRAKE_FUEL_MULT = 5;  // 연료 5배 소모
        const EMERGENCY_BRAKE_POWER_MULT = 3;  // 역추진 효율 3배
        
        // ★★★ AI 부조종사 시스템 (ARIA) ★★★
        const aiCopilot = {
            isTyping: false,
            typeSpeed: 60,  // ms per character (느리게)
            lastWarningTime: 0,
            lastBodyCheck: null,
            missionActive: null,
            commEvent: null,
            audioCtx: null,
            warningCooldowns: {
                fuel: 0,
                speed: 0,
                collision: 0,
                gravity: 0
            }
        };
        
        // AI 미션 템플릿
        const AI_MISSIONS = [
            { id: 'explore', type: 'explore', title: '탐사 미션', desc: '{target} 근처를 탐사하세요.', reward: 200, targets: ['화성', '목성', '토성', '천왕성'] },
            { id: 'speed', type: 'speed', title: '속도 도전', desc: '{speed}km/s 이상 도달하세요.', reward: 150, speeds: [50, 75, 100] },
            { id: 'orbit', type: 'orbit', title: '궤도 진입', desc: '{target} 궤도에 진입하세요.', reward: 300, targets: ['지구', '화성', '목성'] },
            { id: 'fuel', type: 'fuel', title: '연료 효율', desc: '연료 {fuel}% 이상 유지하며 {target}까지 비행', reward: 250, fuels: [50, 70], targets: ['화성', '금성'] },
            { id: 'distance', type: 'distance', title: '장거리 비행', desc: '{distance}AU 이상 비행하세요.', reward: 500, distances: [5, 10, 20] }
        ];
        
        // AI 교신 이벤트 템플릿
        const AI_COMM_EVENTS = [
            {
                id: 'alien_friendly',
                portrait: '👽',
                name: '외계 탐사선',
                message: '평화로운 인사를 전합니다, 지구인. 우리는 탐사 목적으로 이 구역을 지나고 있습니다. 정보를 교환하시겠습니까?',
                choices: [
                    { text: '📡 정보 교환 수락', action: 'accept', result: { coins: 100, message: '유용한 항로 정보를 얻었습니다! +100 코인' } },
                    { text: '👋 정중히 거절', action: 'decline', result: { message: '외계 탐사선이 평화롭게 떠났습니다.' } }
                ]
            },
            {
                id: 'pirate',
                portrait: '🏴‍☠️',
                name: '우주 해적',
                message: '멈춰라! 화물을 내놓으면 살려주지. 저항하면... 알겠지?',
                choices: [
                    { text: '💰 코인 50개 지불', action: 'pay', cost: 50, result: { message: '해적이 코인을 받고 떠났습니다.' } },
                    { text: '🚀 도주 시도', action: 'flee', result: { damage: 10, message: '도주 중 선체에 경미한 손상! -10% 연료' } },
                    { text: '⚔️ 전투 준비', action: 'fight', result: { coins: 150, damage: 20, message: '해적을 격퇴했습니다! +150 코인, -20% 연료' } }
                ]
            },
            {
                id: 'station_hail',
                portrait: '🛰️',
                name: '우주 정거장 관제',
                message: '미확인 선박, 식별 코드를 전송하세요. 도킹 허가가 필요합니다.',
                choices: [
                    { text: '📋 식별 코드 전송', action: 'identify', result: { message: '도킹 허가가 승인되었습니다. 안전한 비행 되세요.' } },
                    { text: '🔄 무시하고 지나감', action: 'ignore', result: { message: '관제소에서 경고를 보내지만 추적은 없습니다.' } }
                ]
            },
            {
                id: 'distress',
                portrait: '🆘',
                name: '조난 신호',
                message: '메이데이! 메이데이! 엔진 고장으로 표류 중입니다. 연료를 나눠주실 수 있습니까?',
                choices: [
                    { text: '⛽ 연료 20% 제공', action: 'help', cost_fuel: 20, result: { coins: 200, message: '감사합니다! 보상으로 코인을 드립니다. +200 코인' } },
                    { text: '📡 구조대에 연락', action: 'contact', result: { message: '근처 정거장에 구조 요청을 전달했습니다.' } },
                    { text: '😔 도울 수 없음', action: 'decline', result: { message: '안타깝지만 지나칩니다.' } }
                ]
            },
            {
                id: 'trader',
                portrait: '🛸',
                name: '우주 상인',
                message: '여행자여! 희귀한 물품이 있소. 100 코인에 행운의 부적을... 구매하면 좋은 일이 생길 거요!',
                choices: [
                    { text: '💎 100 코인 지불', action: 'buy', cost: 100, result: { coins: 300, message: '행운의 부적이 빛났습니다! 숨겨진 보물 발견! +300 코인' } },
                    { text: '🙅 사양합니다', action: 'decline', result: { message: '상인이 아쉬워하며 떠났습니다.' } }
                ]
            }
        ];
        
        // ★★★ SSIL 미션 시스템 ★★★
        const SSIL_TRAINING_MISSIONS = [
            { id: 'explore', type: 'explore', title: '탐사 미션', desc: '🚀 화성에 가까이 가보세요! (거리 50 이내)', reward: 200, target: '화성', targetDist: 50 },
            { id: 'speed', type: 'speed', title: '속도 도전', desc: '⚡ 우주선 속도를 50km/s까지 올려보세요!', reward: 150, targetSpeed: 50 },
            { id: 'orbit', type: 'orbit', title: '궤도 진입', desc: '🌍 지구 궤도에 들어가세요 (도착 후 궤도 버튼)', reward: 300, target: '지구' },
            { id: 'fuel', type: 'fuel', title: '연료 효율', desc: '⛽ 연료 50% 이상 남기고 화성까지 가세요!', reward: 250, minFuel: 50, target: '화성' },
            { id: 'distance', type: 'distance', title: '장거리 비행', desc: '🌌 태양에서 5AU 이상 멀리 가보세요! (목성 근처)', reward: 500, targetDistance: 5 }
        ];
        
        // 일일 미션 템플릿 (각 10개씩)
        const DAILY_MISSION_TEMPLATES = {
            delivery: [
                { title: '화성 긴급 배달', desc: '화성 정거장으로 긴급 물자 배달', target: '화성', reward: 300 },
                { title: '목성 보급 임무', desc: '목성 정거장에 연료 보급품 전달', target: '목성', reward: 450 },
                { title: '토성 연구 장비', desc: '토성 연구소에 장비 배송', target: '토성', reward: 500 },
                { title: '금성 의약품 수송', desc: '금성 기지에 의약품 긴급 수송', target: '금성', reward: 350 },
                { title: '천왕성 탐사 장비', desc: '천왕성 전초기지에 탐사 장비 배달', target: '천왕성', reward: 600 },
                { title: '해왕성 식량 보급', desc: '해왕성 정거장에 식량 보급', target: '해왕성', reward: 700 },
                { title: '수성 냉각 장치', desc: '수성 기지에 냉각 장치 배송', target: '수성', reward: 400 },
                { title: 'ISS 부품 수송', desc: 'ISS에 교체 부품 전달', target: 'ISS', reward: 200 },
                { title: '달 기지 물자', desc: '달 기지에 생활 물자 배송', target: '달', reward: 250 },
                { title: '외곽 전초기지', desc: '카이퍼 벨트 전초기지에 물자 수송', target: '해왕성', reward: 800 }
            ],
            stationTour: [
                { title: '내행성 순회', desc: '수성, 금성, 화성 정거장 방문', targets: ['수성', '금성', '화성'], reward: 400 },
                { title: '외행성 탐방', desc: '목성, 토성, 천왕성 정거장 방문', targets: ['목성', '토성', '천왕성'], reward: 550 },
                { title: '가스 행성 투어', desc: '목성, 토성 정거장 순회', targets: ['목성', '토성'], reward: 450 },
                { title: '얼음 행성 탐험', desc: '천왕성, 해왕성 정거장 방문', targets: ['천왕성', '해왕성'], reward: 650 },
                { title: '지구권 순찰', desc: 'ISS와 달 기지 점검', targets: ['지구', '달'], reward: 300 },
                { title: '태양계 일주', desc: '모든 행성 정거장 방문', targets: ['수성', '금성', '화성', '목성', '토성'], reward: 800 },
                { title: '암석 행성 투어', desc: '수성, 금성, 화성 탐방', targets: ['수성', '금성', '화성'], reward: 400 },
                { title: '거대 행성 순례', desc: '목성, 토성 정거장 방문', targets: ['목성', '토성'], reward: 500 },
                { title: '먼 우주 여행', desc: '천왕성, 해왕성까지 왕복', targets: ['천왕성', '해왕성'], reward: 700 },
                { title: '신입 순찰', desc: '지구, 화성 정거장 점검', targets: ['지구', '화성'], reward: 350 }
            ],
            timeAttack: [
                { title: '화성 급행', desc: '지구→화성 15분 내 도착', target: '화성', timeLimit: 900, reward: 350 },
                { title: '목성 특급', desc: '지구→목성 20분 내 도착', target: '목성', timeLimit: 1200, reward: 450 },
                { title: '금성 스프린트', desc: '지구→금성 10분 내 도착', target: '금성', timeLimit: 600, reward: 300 },
                { title: '토성 레이스', desc: '지구→토성 25분 내 도착', target: '토성', timeLimit: 1500, reward: 500 },
                { title: '수성 도전', desc: '지구→수성 12분 내 도착', target: '수성', timeLimit: 720, reward: 350 },
                { title: '천왕성 마라톤', desc: '지구→천왕성 30분 내 도착', target: '천왕성', timeLimit: 1800, reward: 600 },
                { title: '해왕성 울트라', desc: '지구→해왕성 40분 내 도착', target: '해왕성', timeLimit: 2400, reward: 750 },
                { title: '달 스프린트', desc: '지구→달 5분 내 도착', target: '달', timeLimit: 300, reward: 200 },
                { title: 'ISS 도킹', desc: 'ISS에 3분 내 도킹', target: 'ISS', timeLimit: 180, reward: 250 },
                { title: '왕복 챌린지', desc: '화성 왕복 30분', target: '화성', timeLimit: 1800, reward: 500 }
            ],
            exploration: [
                { title: '화성 표면 스캔', desc: '화성 근접 비행으로 표면 스캔', target: '화성', scanDist: 30, reward: 250 },
                { title: '목성 대기 관측', desc: '목성 대기권 근접 관측', target: '목성', scanDist: 50, reward: 350 },
                { title: '토성 고리 탐사', desc: '토성 고리 근접 비행', target: '토성', scanDist: 60, reward: 400 },
                { title: '금성 구름 관측', desc: '금성 대기 상층부 관측', target: '금성', scanDist: 25, reward: 300 },
                { title: '수성 분화구 조사', desc: '수성 분화구 근접 촬영', target: '수성', scanDist: 20, reward: 350 },
                { title: '천왕성 자기장', desc: '천왕성 자기장 측정', target: '천왕성', scanDist: 40, reward: 450 },
                { title: '해왕성 폭풍 관측', desc: '해왕성 대흑점 관측', target: '해왕성', scanDist: 50, reward: 500 },
                { title: '태양 플레어 관측', desc: '태양 안전거리 접근', target: '태양', scanDist: 100, reward: 400 },
                { title: '소행성대 탐사', desc: '화성-목성 사이 소행성대 탐사', target: '화성', scanDist: 100, reward: 350 },
                { title: '혜성 추적', desc: '태양계 외곽 혜성 추적', target: '해왕성', scanDist: 80, reward: 550 }
            ],
            precision: [
                { title: '정밀 도킹 A', desc: 'ISS에 1km/s 이하로 도킹', target: 'ISS', maxSpeed: 1, reward: 200 },
                { title: '정밀 도킹 B', desc: '화성 정거장에 0.5km/s 이하로 도킹', target: '화성', maxSpeed: 0.5, reward: 300 },
                { title: '완벽한 착륙', desc: '목성 정거장에 0.1km/s 이하로 도킹', target: '목성', maxSpeed: 0.1, reward: 450 },
                { title: '부드러운 접근', desc: '토성 정거장에 0.3km/s 이하로 도킹', target: '토성', maxSpeed: 0.3, reward: 400 },
                { title: '금성 정밀 진입', desc: '금성 정거장에 0.5km/s 이하로 도킹', target: '금성', maxSpeed: 0.5, reward: 350 },
                { title: '천왕성 연착륙', desc: '천왕성 정거장에 0.2km/s 이하로 도킹', target: '천왕성', maxSpeed: 0.2, reward: 500 },
                { title: '해왕성 마스터', desc: '해왕성 정거장에 0.1km/s 이하로 도킹', target: '해왕성', maxSpeed: 0.1, reward: 600 },
                { title: '수성 접근 주의', desc: '수성 정거장에 0.5km/s 이하로 도킹', target: '수성', maxSpeed: 0.5, reward: 350 },
                { title: '달 착륙 연습', desc: '달에 0.3km/s 이하로 접근', target: '달', maxSpeed: 0.3, reward: 250 },
                { title: '제로 임팩트', desc: '어느 정거장이든 0.05km/s 이하로 도킹', target: 'any', maxSpeed: 0.05, reward: 700 }
            ],
            economy: [
                { title: '연료 절약 A', desc: '화성까지 연료 80% 이상 유지', target: '화성', minFuel: 80, reward: 300 },
                { title: '연료 절약 B', desc: '목성까지 연료 60% 이상 유지', target: '목성', minFuel: 60, reward: 400 },
                { title: '극한 절약', desc: '토성까지 연료 50% 이상 유지', target: '토성', minFuel: 50, reward: 500 },
                { title: '효율의 달인', desc: '천왕성까지 연료 40% 이상 유지', target: '천왕성', minFuel: 40, reward: 600 },
                { title: '에코 파일럿', desc: '금성까지 연료 90% 이상 유지', target: '금성', minFuel: 90, reward: 350 },
                { title: '절약 마스터', desc: '해왕성까지 연료 30% 이상 유지', target: '해왕성', minFuel: 30, reward: 700 },
                { title: '근거리 효율', desc: '달까지 연료 95% 이상 유지', target: '달', minFuel: 95, reward: 250 },
                { title: '수성 챌린지', desc: '수성까지 연료 70% 이상 유지', target: '수성', minFuel: 70, reward: 400 },
                { title: 'ISS 절약 비행', desc: 'ISS까지 연료 98% 이상 유지', target: 'ISS', minFuel: 98, reward: 200 },
                { title: '초절약 도전', desc: '화성 왕복 연료 40% 이상 유지', target: '화성', minFuel: 40, reward: 550 }
            ],
            returnHome: [
                { title: '화성 귀환', desc: '화성에서 지구로 무사 귀환', from: '화성', to: '지구', reward: 350 },
                { title: '목성 귀환', desc: '목성에서 지구로 무사 귀환', from: '목성', to: '지구', reward: 450 },
                { title: '토성 귀환', desc: '토성에서 지구로 무사 귀환', from: '토성', to: '지구', reward: 500 },
                { title: '천왕성 귀환', desc: '천왕성에서 지구로 무사 귀환', from: '천왕성', to: '지구', reward: 600 },
                { title: '해왕성 귀환', desc: '해왕성에서 지구로 무사 귀환', from: '해왕성', to: '지구', reward: 700 },
                { title: '금성 귀환', desc: '금성에서 지구로 무사 귀환', from: '금성', to: '지구', reward: 300 },
                { title: '수성 귀환', desc: '수성에서 지구로 무사 귀환', from: '수성', to: '지구', reward: 400 },
                { title: '달 귀환', desc: '달에서 지구로 무사 귀환', from: '달', to: '지구', reward: 200 },
                { title: '외곽 귀환', desc: '카이퍼 벨트에서 귀환', from: '해왕성', to: '지구', reward: 800 },
                { title: '탐사 귀환', desc: '아무 외행성에서 지구로 귀환', from: 'any_outer', to: '지구', reward: 400 }
            ],
            speed: [
                { title: '속도의 신', desc: '100km/s 달성', targetSpeed: 100, reward: 300 },
                { title: '초고속 비행', desc: '150km/s 달성', targetSpeed: 150, reward: 400 },
                { title: '음속 돌파', desc: '200km/s 달성', targetSpeed: 200, reward: 500 },
                { title: '광속의 1%', desc: '300km/s 달성', targetSpeed: 300, reward: 600 },
                { title: '극초음속', desc: '75km/s 달성', targetSpeed: 75, reward: 250 },
                { title: '순항 속도', desc: '50km/s 유지 30초', targetSpeed: 50, duration: 30, reward: 200 },
                { title: '고속 순항', desc: '100km/s 유지 60초', targetSpeed: 100, duration: 60, reward: 350 },
                { title: '안정 비행', desc: '150km/s 유지 30초', targetSpeed: 150, duration: 30, reward: 450 },
                { title: '워프 준비', desc: '250km/s 달성', targetSpeed: 250, reward: 550 },
                { title: '최고 속도', desc: '현재 우주선 최고 속도 달성', targetSpeed: 'max', reward: 400 }
            ],
            distance: [
                { title: '1AU 비행', desc: '태양에서 1AU 거리 비행', targetAU: 1, reward: 150 },
                { title: '5AU 비행', desc: '태양에서 5AU 거리 비행', targetAU: 5, reward: 300 },
                { title: '10AU 비행', desc: '태양에서 10AU 거리 비행', targetAU: 10, reward: 450 },
                { title: '20AU 비행', desc: '태양에서 20AU 거리 비행', targetAU: 20, reward: 600 },
                { title: '30AU 비행', desc: '해왕성 궤도까지', targetAU: 30, reward: 750 },
                { title: '50AU 도전', desc: '카이퍼 벨트 진입', targetAU: 50, reward: 900 },
                { title: '내행성 탐험', desc: '0.5AU 이내 접근', targetAU: 0.5, reward: 250 },
                { title: '태양 접근', desc: '0.3AU 이내 접근', targetAU: 0.3, reward: 400 },
                { title: '외곽 탐험', desc: '40AU 도달', targetAU: 40, reward: 800 },
                { title: '태양계 끝', desc: '100AU 도달', targetAU: 100, reward: 1500 }
            ],
            multiCoop: [
                { title: '만남의 광장', desc: '다른 플레이어와 같은 정거장 도킹', reward: 300 },
                { title: '편대 비행', desc: '다른 플레이어 근처 비행', reward: 250 },
                { title: '행성 모임', desc: '같은 행성 근처에서 만남', reward: 350 },
                { title: '우주 인사', desc: '다른 플레이어에게 접근', reward: 200 },
                { title: '탐사대 합류', desc: '외행성에서 다른 플레이어 만남', reward: 450 },
                { title: '지구 귀환 파티', desc: '지구에서 다른 플레이어 만남', reward: 300 },
                { title: '화성 탐험대', desc: '화성에서 다른 플레이어 만남', reward: 350 },
                { title: '목성 원정대', desc: '목성에서 다른 플레이어 만남', reward: 400 },
                { title: '토성 관광단', desc: '토성에서 다른 플레이어 만남', reward: 450 },
                { title: '우주 파일럿 모임', desc: 'ISS에서 다른 플레이어 만남', reward: 250 }
            ]
        };
        
        // SSIL 미션 상태
        let ssilMissionState = {
            isFirstBoarding: true,
            trainingCompleted: {},  // { missionId: true }
            dailyMission: null,
            dailyMissionAccepted: false,
            dailyMissionStartTime: 0,
            missionPoints: 0,
            lastDailyDate: null,
            totalDistance: 0,  // ★ 총 이동 거리 (AU)
            lastPosition: null  // ★ 이전 위치 (거리 계산용)
        };
        
        // 미션 상태 로드
        function loadSSILState() {
            const saved = localStorage.getItem('ssilMissionState');
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    ssilMissionState = { ...ssilMissionState, ...parsed };
                } catch (e) {
                    console.warn('SSIL 상태 로드 실패:', e);
                }
            }
        }
        
        // 미션 상태 저장
        function saveSSILState() {
            localStorage.setItem('ssilMissionState', JSON.stringify(ssilMissionState));
        }
        
        // 첫 탑승 시 ARIA 인트로
        function showSSILIntro() {
            if (!ssilMissionState.isFirstBoarding) return;
            
            ssilMissionState.isFirstBoarding = false;
            saveSSILState();
            
            // ARIA 인트로 메시지
            const introMessages = [
                "안녕하세요, 파일럿님.",
                "당신은 Solar System Integrated Logistics, 이하 SSIL(씰)의 운송업무 신입직원입니다.",
                "지구에서 충분히 훈련 하셨을 테지만 우주에서의 실전은 또 다릅니다.",
                "제가 당신의 훈련 및 앞으로의 업무에 대한 안내를 전반적으로 담당하게 된 AI ARIA 입니다.",
                "궁금한점이 있다면 언제든지 물어보세요.",
                "자, 이제 바로 훈련을 시작하겠습니다!",
                "훈련을 잘 마친다면 당신은 회사로부터 급여외의 보너스 코인을 지급 받으실 수 있으니 적극적으로 참여 해 주시기 바랍니다."
            ];
            
            let msgIndex = 0;
            const showNextMessage = () => {
                if (msgIndex < introMessages.length) {
                    aiTypeMessage(introMessages[msgIndex]);
                    msgIndex++;
                    setTimeout(showNextMessage, 4000);
                } else {
                    // ★ 인트로 끝나면 미션 버튼 표시 + 알림
                    setTimeout(() => {
                        showMissionButton();
                        aiTypeMessage("오른쪽 📋 미션 버튼을 눌러 훈련 목록을 확인하세요!");
                    }, 2000);
                }
            };
            
            setTimeout(showNextMessage, 2000);
        }
        
        // 미션 패널 열기
        function openMissionPanel() {
            const panel = document.getElementById('ssil-mission-panel');
            const tbody = document.getElementById('training-mission-body');
            
            tbody.innerHTML = '';
            let totalReward = 0;
            let completedReward = 0;
            
            SSIL_TRAINING_MISSIONS.forEach(mission => {
                const isCompleted = ssilMissionState.trainingCompleted[mission.id];
                const tr = document.createElement('tr');
                if (isCompleted) tr.classList.add('completed');
                
                tr.innerHTML = `
                    <td class="mission-status">${isCompleted ? '✅' : '⬜'}</td>
                    <td>${mission.title}</td>
                    <td>${mission.desc}</td>
                    <td class="mission-reward">${mission.reward} 🪙</td>
                `;
                tbody.appendChild(tr);
                
                totalReward += mission.reward;
                if (isCompleted) completedReward += mission.reward;
            });
            
            document.getElementById('total-training-reward').textContent = 
                `${completedReward} / ${totalReward} 코인`;
            
            panel.classList.add('open');
        }
        window.openMissionPanel = openMissionPanel;
        
        // 미션 패널 닫기
        function closeMissionPanel() {
            document.getElementById('ssil-mission-panel').classList.remove('open');
        }
        window.closeMissionPanel = closeMissionPanel;
        
        // ★ 미션 버튼 표시
        function showMissionButton() {
            if (document.getElementById('mission-float-btn')) return;  // 이미 있으면 무시
            
            const btn = document.createElement('button');
            btn.id = 'mission-float-btn';
            btn.innerHTML = '📋';
            btn.title = 'SSIL 미션';
            btn.style.cssText = `
                position: fixed;
                right: 15px;
                top: 50%;
                transform: translateY(-50%);
                width: 50px;
                height: 50px;
                border-radius: 50%;
                background: linear-gradient(135deg, #1a3a5c, #0a1a2c);
                border: 2px solid #00d4ff;
                color: #00d4ff;
                font-size: 24px;
                cursor: pointer;
                z-index: 1000;
                box-shadow: 0 0 15px rgba(0,212,255,0.5);
                transition: all 0.3s ease;
            `;
            btn.onmouseover = () => btn.style.boxShadow = '0 0 25px rgba(0,212,255,0.8)';
            btn.onmouseout = () => btn.style.boxShadow = '0 0 15px rgba(0,212,255,0.5)';
            btn.onclick = openMissionPanel;
            document.body.appendChild(btn);
        }
        window.showMissionButton = showMissionButton;
        
        // 훈련 미션 완료 체크
        function checkTrainingMissions() {
            if (!playerShip || !playerShip.mesh) return;
            
            // ★ 이동 거리 누적 계산
            const currentPos = playerShip.mesh.position.clone();
            if (ssilMissionState.lastPosition) {
                const moved = currentPos.distanceTo(ssilMissionState.lastPosition);
                const movedAU = moved / 220;  // AU로 변환
                ssilMissionState.totalDistance += movedAU;
            }
            ssilMissionState.lastPosition = currentPos;
            
            SSIL_TRAINING_MISSIONS.forEach(mission => {
                if (ssilMissionState.trainingCompleted[mission.id]) return;
                
                let completed = false;
                
                switch (mission.type) {
                    case 'explore':
                        // 행성 근처 탐사
                        const targetBody = bodies.find(b => b.name === mission.target);
                        if (targetBody && targetBody.mesh) {
                            const dist = playerShip.mesh.position.distanceTo(targetBody.mesh.position);
                            if (dist < mission.targetDist) completed = true;
                        }
                        break;
                        
                    case 'speed':
                        // 속도 달성
                        if (playerShip.speed >= mission.targetSpeed) completed = true;
                        break;
                        
                    case 'orbit':
                        // 궤도 진입
                        if (orbitState.locked && orbitState.targetBody) {
                            if (orbitState.targetBody.name === mission.target) completed = true;
                        }
                        break;
                        
                    case 'fuel':
                        // 연료 효율 (목표 행성 도착 시)
                        const fuelTarget = bodies.find(b => b.name === mission.target);
                        if (fuelTarget && fuelTarget.mesh) {
                            const d = playerShip.mesh.position.distanceTo(fuelTarget.mesh.position);
                            if (d < 50 && playerShip.fuel >= mission.minFuel) completed = true;
                        }
                        break;
                        
                    case 'distance':
                        // 장거리 비행 - 총 이동 거리 체크 (시작 위치 기준이 아닌 누적 거리)
                        if (ssilMissionState.totalDistance >= mission.targetDistance) completed = true;
                        break;
                }
                
                if (completed) {
                    completeTrainingMission(mission);
                }
            });
        }
        
        // 훈련 미션 완료 처리
        function completeTrainingMission(mission) {
            ssilMissionState.trainingCompleted[mission.id] = true;
            saveSSILState();
            
            // 보상 지급
            addCoins(mission.reward);
            
            // 완료 알림
            showMissionCompleteToast(mission.title, mission.reward);
            
            // ARIA 축하 메시지
            aiTypeMessage(`🎉 훌륭합니다! "${mission.title}" 미션을 완료하셨습니다! +${mission.reward} 코인`);
        }
        
        // 미션 완료 토스트
        function showMissionCompleteToast(title, reward) {
            const toast = document.createElement('div');
            toast.className = 'mission-complete-toast';
            toast.innerHTML = `
                <h3>🎯 미션 완료!</h3>
                <div>${title}</div>
                <div class="reward">+${reward} 🪙</div>
            `;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'translateX(-50%) translateY(-30px)';
                setTimeout(() => toast.remove(), 500);
            }, 3000);
        }
        
        // 일일 미션 생성
        function generateDailyMission() {
            const today = new Date().toDateString();
            
            // 이미 오늘 미션이 있으면 스킵
            if (ssilMissionState.lastDailyDate === today && ssilMissionState.dailyMission) {
                return;
            }
            
            // 미션 타입 랜덤 선택
            const missionTypes = Object.keys(DAILY_MISSION_TEMPLATES);
            const randomType = missionTypes[Math.floor(Math.random() * missionTypes.length)];
            const templates = DAILY_MISSION_TEMPLATES[randomType];
            const randomMission = templates[Math.floor(Math.random() * templates.length)];
            
            ssilMissionState.dailyMission = {
                ...randomMission,
                type: randomType,
                generated: Date.now()
            };
            ssilMissionState.lastDailyDate = today;
            ssilMissionState.dailyMissionAccepted = false;
            saveSSILState();
            
            // 이메일 아이콘 표시
            updateDailyMissionIcon();
        }
        
        // 일일 미션 아이콘 업데이트
        function updateDailyMissionIcon() {
            const icon = document.getElementById('daily-mission-icon');
            if (ssilMissionState.dailyMission && !ssilMissionState.dailyMissionAccepted) {
                icon.classList.add('has-mission');
            } else {
                icon.classList.remove('has-mission');
            }
            
            // 미션 포인트 표시
            const mpDisplay = document.getElementById('mission-points-display');
            if (ssilMissionState.missionPoints > 0) {
                mpDisplay.classList.add('visible');
                document.getElementById('mission-points-value').textContent = ssilMissionState.missionPoints;
            }
        }
        
        // 일일 미션 모달 열기
        function openDailyMission() {
            if (!ssilMissionState.dailyMission) return;
            
            const mission = ssilMissionState.dailyMission;
            const modal = document.getElementById('daily-mission-modal');
            
            // 날짜 표시
            const now = new Date();
            document.getElementById('daily-mission-date').textContent = 
                `${now.getMonth()+1}/${now.getDate()}`;
            
            // 미션 설명
            document.getElementById('daily-mission-desc').textContent = mission.desc;
            
            // 보상
            document.getElementById('daily-reward-coins').textContent = mission.reward;
            document.getElementById('daily-reward-points').textContent = '+1';
            
            modal.classList.add('open');
        }
        window.openDailyMission = openDailyMission;
        
        // 일일 미션 수락
        function acceptDailyMission() {
            ssilMissionState.dailyMissionAccepted = true;
            ssilMissionState.dailyMissionStartTime = Date.now();
            saveSSILState();
            
            closeDailyMission();
            updateDailyMissionIcon();
            
            const mission = ssilMissionState.dailyMission;
            aiTypeMessage(`📧 업무 지시서 수락: "${mission.title}" - ${mission.desc}`);
            showMessage(`📧 일일 미션 수락: ${mission.title}`);
        }
        window.acceptDailyMission = acceptDailyMission;
        
        // 일일 미션 닫기
        function closeDailyMission() {
            document.getElementById('daily-mission-modal').classList.remove('open');
        }
        window.closeDailyMission = closeDailyMission;
        
        // 일일 미션 완료 체크
        function checkDailyMission() {
            if (!ssilMissionState.dailyMissionAccepted || !ssilMissionState.dailyMission) return;
            if (!playerShip || !playerShip.mesh) return;
            
            const mission = ssilMissionState.dailyMission;
            let completed = false;
            
            // 미션 타입별 완료 조건 체크
            switch (mission.type) {
                case 'delivery':
                case 'exploration':
                    // 목표 행성/정거장 도착
                    const target = bodies.find(b => b.name === mission.target) ||
                                   satellites.find(s => s.name && s.name.includes(mission.target));
                    if (target && target.mesh) {
                        const dist = playerShip.mesh.position.distanceTo(target.mesh.position);
                        if (dist < 30) completed = true;
                    }
                    break;
                    
                case 'speed':
                    if (playerShip.speed >= mission.targetSpeed) completed = true;
                    break;
                    
                case 'distance':
                    const distAU = playerShip.mesh.position.length() / 220;
                    if (distAU >= mission.targetAU) completed = true;
                    break;
                    
                // 다른 타입들도 추가 가능
            }
            
            if (completed) {
                completeDailyMission();
            }
        }
        
        // 일일 미션 완료 처리
        function completeDailyMission() {
            const mission = ssilMissionState.dailyMission;
            
            // 보상 지급
            addCoins(mission.reward);
            ssilMissionState.missionPoints += 1;
            
            // 미션 초기화
            ssilMissionState.dailyMission = null;
            ssilMissionState.dailyMissionAccepted = false;
            saveSSILState();
            
            updateDailyMissionIcon();
            
            // 완료 알림
            showMissionCompleteToast(mission.title, mission.reward);
            aiTypeMessage(`🎉 일일 미션 "${mission.title}" 완료! +${mission.reward} 코인, +1 미션 포인트`);
        }
        
        // AI 천체 정보
        const AI_BODY_INFO = {
            '태양': '태양은 태양계의 중심 항성으로, 지구 질량의 약 33만 배입니다. 표면 온도는 약 5,500°C이며, 중심부는 1,500만°C에 달합니다.',
            '수성': '수성은 태양에 가장 가까운 행성입니다. 낮에는 430°C, 밤에는 -180°C로 극심한 온도차를 보입니다.',
            '금성': '금성은 두꺼운 이산화탄소 대기로 인해 표면 온도가 465°C에 달하는 태양계에서 가장 뜨거운 행성입니다.',
            '지구': '지구는 현재까지 알려진 유일한 생명체 서식 행성입니다. 달이라는 위성을 가지고 있습니다.',
            '화성': '화성은 붉은 행성으로 불리며, 올림푸스 몬스라는 태양계 최대 화산이 있습니다. 높이가 약 22km입니다.',
            '목성': '목성은 태양계 최대 행성으로, 대적점이라는 거대한 폭풍이 300년 이상 지속되고 있습니다.',
            '토성': '토성은 아름다운 고리로 유명합니다. 고리는 주로 얼음과 암석 조각으로 이루어져 있습니다.',
            '천왕성': '천왕성은 자전축이 98도 기울어져 옆으로 누워 도는 독특한 행성입니다.',
            '해왕성': '해왕성은 태양계에서 가장 강한 바람이 불며, 시속 2,000km를 넘습니다.',
            '달': '달은 지구의 유일한 자연 위성으로, 지구로부터 약 38만km 떨어져 있습니다.',
            'ISS 우주정거장': 'ISS는 국제 우주 정거장으로, 지구 저궤도를 약 90분에 한 바퀴 돕니다. 우주 연구의 핵심 기지입니다.'
        };
        
        // 타이핑 효과 함수
        function aiTypeMessage(message, callback) {
            const textEl = document.getElementById('ai-message-text');
            const panel = document.getElementById('ai-copilot-panel');
            
            // ★ 통합 채팅에도 메시지 추가
            if (typeof unifiedChatSystem !== 'undefined') {
                unifiedChatSystem.addAriaMessage(message, false);
            }
            
            if (!textEl || !panel) {
                if (callback) callback();
                return;
            }
            
            aiCopilot.isTyping = true;
            panel.classList.add('speaking');
            textEl.innerHTML = '<span class="cursor"></span>';
            
            let i = 0;
            const typeInterval = setInterval(() => {
                if (i < message.length) {
                    // 효과음 재생
                    aiPlayTypeSound();
                    textEl.innerHTML = message.substring(0, i + 1) + '<span class="cursor"></span>';
                    i++;
                } else {
                    clearInterval(typeInterval);
                    textEl.innerHTML = message;
                    aiCopilot.isTyping = false;
                    panel.classList.remove('speaking');
                    if (callback) callback();
                }
            }, aiCopilot.typeSpeed);
        }
        
        // AI 효과음 (Web Audio API)
        function aiPlayTypeSound() {
            try {
                if (!aiCopilot.audioCtx) {
                    aiCopilot.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                }
                const ctx = aiCopilot.audioCtx;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                
                osc.connect(gain);
                gain.connect(ctx.destination);
                
                // 짧은 비프음
                osc.frequency.value = 800 + Math.random() * 400;
                osc.type = 'sine';
                gain.gain.value = 0.03;
                
                osc.start();
                gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.05);
                osc.stop(ctx.currentTime + 0.05);
            } catch (e) { }
        }
        
        // AI 경고음
        function aiPlayAlertSound() {
            try {
                if (!aiCopilot.audioCtx) {
                    aiCopilot.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                }
                const ctx = aiCopilot.audioCtx;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                
                osc.connect(gain);
                gain.connect(ctx.destination);
                
                osc.frequency.value = 600;
                osc.type = 'square';
                gain.gain.value = 0.08;
                
                osc.start();
                osc.frequency.exponentialRampToValueAtTime(400, ctx.currentTime + 0.2);
                gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.3);
                osc.stop(ctx.currentTime + 0.3);
            } catch (e) { }
        }
        
        // AI 교신음
        function aiPlayCommSound() {
            try {
                if (!aiCopilot.audioCtx) {
                    aiCopilot.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                }
                const ctx = aiCopilot.audioCtx;
                
                // 두 번의 비프
                for (let i = 0; i < 2; i++) {
                    setTimeout(() => {
                        const osc = ctx.createOscillator();
                        const gain = ctx.createGain();
                        osc.connect(gain);
                        gain.connect(ctx.destination);
                        osc.frequency.value = 1000;
                        osc.type = 'sine';
                        gain.gain.value = 0.1;
                        osc.start();
                        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.15);
                        osc.stop(ctx.currentTime + 0.15);
                    }, i * 200);
                }
            } catch (e) { }
        }
        
        // AI 부조종사 업데이트 (매 프레임)
        function updateAICopilot(dt) {
            if (!isPilotMode || !playerShip || aiCopilot.isTyping) return;
            
            const now = Date.now();
            
            // 1. 연료 경고
            if (playerShip.fuel < 20 && now - aiCopilot.warningCooldowns.fuel > 30000) {
                aiCopilot.warningCooldowns.fuel = now;
                aiPlayAlertSound();
                if (playerShip.fuel < 10) {
                    aiTypeMessage('⚠️ 경고: 연료 잔량 위험! 즉시 가까운 정거장으로 귀환하세요.');
                } else {
                    aiTypeMessage('⚠️ 주의: 연료가 ' + Math.round(playerShip.fuel) + '/' + SHIP_CONFIG.maxFuel + ' 입니다. 보급을 권장합니다.');
                }
                return;
            }
            
            // 2. 과속 경고
            // 2. 최대 속도 도달 (100%일 때만)
            if (playerShip.speed >= SHIP_CONFIG.maxSpeed && now - aiCopilot.warningCooldowns.speed > 60000) {
                aiCopilot.warningCooldowns.speed = now;
                aiTypeMessage('🚀 최대 속도 도달! 현재 ' + playerShip.speed.toFixed(0) + 'km/s');
                return;
            }
            
            // 3. 중력 경고
            if (isGravityWarning && now - aiCopilot.warningCooldowns.gravity > 15000) {
                aiCopilot.warningCooldowns.gravity = now;
                aiPlayAlertSound();
                aiTypeMessage('🚨 중력장 포착! 탈출 추력을 높이세요!');
                return;
            }
            
            // 4. 천체 접근 시 정보 제공
            if (shipTargetBody && shipTargetBody.mesh && playerShip.mesh) {
                const dist = playerShip.mesh.position.distanceTo(shipTargetBody.mesh.position);
                const bodySize = shipTargetBody.radius || 1;
                
                // 천체에 충분히 가까워졌고, 이전에 안내하지 않았던 천체라면
                if (dist < bodySize * 10 && aiCopilot.lastBodyCheck !== shipTargetBody.name) {
                    aiCopilot.lastBodyCheck = shipTargetBody.name;
                    const info = AI_BODY_INFO[shipTargetBody.name];
                    if (info) {
                        aiTypeMessage('📍 ' + shipTargetBody.name + ' 접근 중.\n' + info);
                    }
                }
            }
            
            // 5. 랜덤 교신 이벤트 (5분마다 10% 확률)
            if (!aiCopilot.commEvent && Math.random() < 0.00003 * dt) {  // 약 5분에 10%
                triggerAICommEvent();
            }
        }
        
        // AI 상태 분석 버튼
        function aiRequestInfo() {
            if (!playerShip || aiCopilot.isTyping) return;
            
            const speed = playerShip.speed.toFixed(1);
            const fuel = Math.round(playerShip.fuel);
            const maxFuel = SHIP_CONFIG.maxFuel;
            const status = fuel < 20 ? '⚠️ 연료 부족' : fuel < 50 ? '주의 필요' : '양호';
            
            let targetInfo = '';
            if (shipTargetBody && shipTargetBody.mesh && playerShip.mesh) {
                const dist = playerShip.mesh.position.distanceTo(shipTargetBody.mesh.position);
                targetInfo = '\n목표: ' + shipTargetBody.name + ' (' + formatShipDistance(dist) + ')';
            }
            
            aiTypeMessage('📊 현재 상태 분석:\n속도: ' + speed + 'km/s\n연료: ' + fuel + '/' + maxFuel + ' (' + status + ')' + targetInfo);
        }
        
        // AI 항법 도움 버튼
        function aiRequestNavHelp() {
            if (!playerShip || aiCopilot.isTyping) return;
            
            if (!shipTargetBody) {
                aiTypeMessage('🧭 항법 목표가 설정되지 않았습니다. 우측 상단 드롭다운에서 목적지를 선택하세요.');
                return;
            }
            
            const dist = playerShip.mesh.position.distanceTo(shipTargetBody.mesh.position);
            const eta = playerShip.speed > 0.1 ? dist / playerShip.speed : Infinity;
            
            let advice = '🧭 ' + shipTargetBody.name + '까지 ' + formatShipDistance(dist) + '\n';
            
            if (eta < 60) {
                advice += '도착 임박! 감속을 준비하세요.';
            } else if (eta < 600) {
                advice += '예상 도착: ' + Math.floor(eta / 60) + '분 ' + Math.floor(eta % 60) + '초';
            } else if (eta < 3600) {
                advice += '예상 도착: 약 ' + Math.floor(eta / 60) + '분\n속도를 높이면 더 빨리 도착합니다.';
            } else if (eta !== Infinity) {
                advice += '장거리 비행입니다. 자동항법을 권장합니다.';
            } else {
                advice += '현재 정지 상태입니다. 가속하세요.';
            }
            
            aiTypeMessage(advice);
        }
        
        // AI 미션 체크 버튼
        function aiCheckMissions() {
            if (aiCopilot.isTyping) return;
            
            if (aiCopilot.missionActive) {
                // 진행 중인 미션 상태 확인
                checkMissionProgress();
            } else {
                // 새 미션 제안
                generateNewMission();
            }
        }
        
        // 새 미션 생성
        function generateNewMission() {
            const template = AI_MISSIONS[Math.floor(Math.random() * AI_MISSIONS.length)];
            let mission = { ...template };
            
            // 미션 파라미터 랜덤 선택
            if (template.targets) {
                mission.targetName = template.targets[Math.floor(Math.random() * template.targets.length)];
                mission.desc = mission.desc.replace('{target}', mission.targetName);
            }
            if (template.speeds) {
                mission.targetSpeed = template.speeds[Math.floor(Math.random() * template.speeds.length)];
                mission.desc = mission.desc.replace('{speed}', mission.targetSpeed);
            }
            if (template.distances) {
                mission.targetDistance = template.distances[Math.floor(Math.random() * template.distances.length)];
                mission.desc = mission.desc.replace('{distance}', mission.targetDistance);
            }
            if (template.fuels) {
                mission.minFuel = template.fuels[Math.floor(Math.random() * template.fuels.length)];
                mission.desc = mission.desc.replace('{fuel}', mission.minFuel);
            }
            
            aiTypeMessage('📡 ' + t('mission') + '!\n\n🎯 ' + mission.title + '\n' + mission.desc + '\n\n' + t('reward') + ': ' + mission.reward + ' ' + t('coinsUnit') + '\n\n' + t('confirmPurchase').replace('?','') + '?', () => {
                // 버튼 영역에 수락/거절 버튼 추가
                const btns = document.getElementById('ai-action-btns');
                btns.innerHTML = `
                    <button class="ai-action-btn success" onclick="acceptMission()">${t('accept')}</button>
                    <button class="ai-action-btn" onclick="declineMission()">${t('decline')}</button>
                `;
                aiCopilot.missionActive = mission;
                aiCopilot.missionActive.accepted = false;
            });
        }
        
        // 미션 수락
        function acceptMission() {
            if (!aiCopilot.missionActive) return;
            aiCopilot.missionActive.accepted = true;
            aiCopilot.missionActive.startTime = Date.now();
            
            resetAIButtons();
            aiTypeMessage('✅ 미션 수락! ' + aiCopilot.missionActive.title + '\n\n행운을 빕니다, 파일럿.');
        }
        
        // 미션 거절
        function declineMission() {
            aiCopilot.missionActive = null;
            resetAIButtons();
            aiTypeMessage('미션을 거절했습니다. 다른 미션이 필요하시면 말씀하세요.');
        }
        
        // 미션 진행 상황 확인
        function checkMissionProgress() {
            const m = aiCopilot.missionActive;
            if (!m || !m.accepted) {
                generateNewMission();
                return;
            }
            
            let complete = false;
            let progress = '';
            
            switch (m.type) {
                case 'explore':
                    const targetBody = bodies.find(b => b.name === m.targetName) || satellites.find(s => s.name === m.targetName);
                    if (targetBody && playerShip && playerShip.mesh) {
                        const dist = playerShip.mesh.position.distanceTo(targetBody.mesh.position);
                        if (dist < (targetBody.radius || 1) * 8) {
                            complete = true;
                        } else {
                            progress = m.targetName + '까지 ' + formatShipDistance(dist);
                        }
                    }
                    break;
                case 'speed':
                    if (playerShip && playerShip.speed >= m.targetSpeed) {
                        complete = true;
                    } else {
                        progress = '현재 속도: ' + playerShip.speed.toFixed(0) + '/' + m.targetSpeed + ' km/s';
                    }
                    break;
                case 'orbit':
                    if (orbitState.inOrbit && orbitState.orbitBody && orbitState.orbitBody.name === m.targetName) {
                        complete = true;
                    } else {
                        progress = m.targetName + ' 궤도 진입 필요';
                    }
                    break;
                case 'distance':
                    if (playerShip && playerShip.mesh) {
                        const distAU = playerShip.mesh.position.length() / 149.6;
                        if (distAU >= m.targetDistance) {
                            complete = true;
                        } else {
                            progress = '비행 거리: ' + distAU.toFixed(1) + '/' + m.targetDistance + ' AU';
                        }
                    }
                    break;
            }
            
            if (complete) {
                completeMission();
            } else {
                aiTypeMessage('📋 미션 진행 중: ' + m.title + '\n\n' + progress);
            }
        }
        
        // 미션 완료
        function completeMission() {
            const m = aiCopilot.missionActive;
            if (!m) return;
            
            aiPlayCommSound();
            aiTypeMessage('🎉 미션 완료!\n\n' + m.title + '\n보상: +' + m.reward + ' 코인!', function() {
                addCoins(m.reward);
                showMsg('🎉 Mission Complete! +' + m.reward + ' coins');
            });
            
            aiCopilot.missionActive = null;
            resetAIButtons();
        }
        
        // AI 버튼 초기화
        function resetAIButtons() {
            const btns = document.getElementById('ai-action-btns');
            if (btns) {
                btns.innerHTML = `
                    <button class="ai-action-btn" onclick="aiRequestInfo()">📊 상태</button>
                    <button class="ai-action-btn" onclick="aiRequestNavHelp()">🧭 항법</button>
                    <button class="ai-action-btn mission" onclick="aiCheckMissions()">📡 미션</button>
                    <button class="ai-action-btn" onclick="aiRequestTips()">💡 팁</button>
                `;
            }
        }
        
        // 교신 이벤트 발생
        function triggerAICommEvent() {
            if (aiCopilot.commEvent) return;
            
            const event = AI_COMM_EVENTS[Math.floor(Math.random() * AI_COMM_EVENTS.length)];
            aiCopilot.commEvent = event;
            
            aiPlayCommSound();
            
            const modal = document.getElementById('ai-comm-modal');
            document.getElementById('ai-comm-portrait').textContent = event.portrait;
            document.getElementById('ai-comm-name').textContent = event.name;
            document.getElementById('ai-comm-message').textContent = '';
            
            // 선택지 렌더링
            const choicesEl = document.getElementById('ai-comm-choices');
            choicesEl.innerHTML = '';
            event.choices.forEach((choice, idx) => {
                const btn = document.createElement('button');
                btn.className = 'ai-comm-choice';
                if (choice.action === 'fight' || choice.action === 'flee') btn.classList.add('danger');
                if (choice.action === 'accept' || choice.action === 'help') btn.classList.add('success');
                btn.textContent = choice.text;
                btn.onclick = () => handleCommChoice(idx);
                choicesEl.appendChild(btn);
            });
            
            modal.classList.add('open');
            
            // 메시지 타이핑 효과
            let i = 0;
            const msgEl = document.getElementById('ai-comm-message');
            const typeInt = setInterval(() => {
                if (i < event.message.length) {
                    aiPlayTypeSound();
                    msgEl.textContent = event.message.substring(0, i + 1);
                    i++;
                } else {
                    clearInterval(typeInt);
                }
            }, 25);
            
            aiTypeMessage('📡 수신 중... ' + event.name + '로부터 교신 요청');
        }
        
        // 교신 선택 처리
        function handleCommChoice(idx) {
            const event = aiCopilot.commEvent;
            if (!event) return;
            
            const choice = event.choices[idx];
            const result = choice.result;
            
            // 비용 처리
            if (choice.cost) {
                if (getUserCoins() < choice.cost) {
                    aiTypeMessage('코인이 부족합니다!');
                    return;
                }
                spendCoins(choice.cost);
            }
            
            if (choice.cost_fuel && playerShip) {
                if (playerShip.fuel < choice.cost_fuel) {
                    aiTypeMessage('연료가 부족합니다!');
                    return;
                }
                playerShip.fuel -= choice.cost_fuel;
            }
            
            // 결과 처리
            if (result.coins) {
                addCoins(result.coins);
            }
            
            if (result.damage && playerShip) {
                playerShip.fuel = Math.max(0, playerShip.fuel - result.damage);
            }
            
            // 모달 닫기
            document.getElementById('ai-comm-modal').classList.remove('open');
            aiCopilot.commEvent = null;
            
            // 결과 메시지
            aiTypeMessage(result.message);
        }
        
        // ★★★ AI 질문 응답 시스템 ★★★
        
        // AI 패널 확장/축소
        function toggleAIPanel() {
            const panel = document.getElementById('ai-copilot-panel');
            const btn = document.getElementById('ai-expand-btn');
            panel.classList.toggle('collapsed');
            btn.textContent = panel.classList.contains('collapsed') ? '▶' : '▼';
        }
        
        // 빠른 질문
        function aiQuickAsk(topic) {
            const questions = {
                '조작법': '우주선 조작법을 알려줘',
                '연료': '연료 관리는 어떻게 해?',
                '자동항법': '자동항법 사용법을 알려줘',
                '궤도': '궤도 진입은 어떻게 해?'
            };
            document.getElementById('ai-input').value = questions[topic] || topic;
            aiSendQuestion();
        }
        
        // AI 팁 요청
        function aiRequestTips() {
            if (aiCopilot.isTyping) return;
            
            const tips = [
                '💡 팁: W/S 키 또는 마우스 휠로 가속/감속할 수 있습니다.',
                '💡 팁: 스페이스바를 누르면 긴급 역추진이 작동합니다. 연료를 5배 소모하지만 3배 빠르게 정지합니다.',
                '💡 팁: 목표 천체를 선택하고 🤖자동 버튼을 누르면 자동항법이 활성화됩니다.',
                '💡 팁: 행성 근처에서 궤도진입 버튼이 나타나면 안정적인 궤도에 진입할 수 있습니다.',
                '💡 팁: 연료가 부족하면 ISS 우주정거장으로 돌아가 보급하세요.',
                '💡 팁: 블랙홀에 너무 가까이 가면 탈출할 수 없으니 주의하세요!',
                '💡 팁: 각 우주선마다 고유한 특수능력이 있습니다. 우주선 선택 화면에서 확인하세요.',
                '💡 팁: 미션을 완료하면 코인을 획득할 수 있습니다.',
                '💡 팁: 화면을 드래그하면 우주선의 방향을 조절할 수 있습니다.',
                '💡 팁: 레이더에서 빨간 점은 위험한 천체, 노란 점은 목표입니다.'
            ];
            
            aiTypeMessage(tips[Math.floor(Math.random() * tips.length)]);
        }
        
        // 질문 전송
        function aiSendQuestion() {
            var input = document.getElementById('ai-input');
            var question = input.value.trim();
            if (!question || aiCopilot.isTyping) return;
            
            input.value = '';
            var panel = document.getElementById('ai-copilot-panel');
            panel.classList.add('loading');
            
            // Gemini API 호출
            var systemPrompt = '당신은 "ARIA"라는 이름의 우주선 AI 부조종사입니다.\n' +
'당신은 SSIL(Solar System Integrated Logistics, 씰)의 AI 어시스턴트입니다.\n\n' +
'【회사 개요】\n' +
'- SSIL은 태양계 전역에서 운송/물류 서비스를 제공하는 우주 운송 회사입니다\n' +
'- 신입 파일럿들의 훈련과 업무 지원을 담당합니다\n' +
'- 당신의 이름은 ARIA (Advanced Resource & Intelligence Assistant)입니다\n\n' +
'【게임 개요】\n' +
'- 이것은 "Solar Explorer"라는 태양계 우주 탐사 시뮬레이션 게임입니다\n' +
'- 플레이어는 우주선을 조종하여 태양계를 탐험합니다\n' +
'- 싱글플레이와 멀티플레이어 모드가 있습니다\n' +
'- 천체를 방문하고, 미션을 수행하고, 코인을 모읍니다\n\n' +
'【우주선 조작법】\n' +
'- W/↑ 또는 화면 상단 가속 버튼: 가속\n' +
'- S/↓ 또는 화면 하단 감속 버튼: 감속/후진\n' +
'- 마우스 드래그 또는 모바일 조이스틱: 방향 전환\n' +
'- 스페이스바 또는 긴급정지 버튼: 역추진 (급정거)\n' +
'- Q/E: 좌우 롤링\n' +
'- 1~5 숫자키: 속도 프리셋\n\n' +
'【주요 기능】\n' +
'- 자동항법: 목표 천체 선택 후 "자동" 버튼 - AI가 자동으로 목적지까지 비행\n' +
'- 궤도 진입: 행성 근처에서 "궤도진입" 버튼 - 행성 주위를 공전\n' +
'- 도킹: 정거장에서 "도킹" 버튼 - 연료 보급, 수리, 상점 이용\n' +
'- 워프: 먼 거리를 빠르게 이동 (연료 소모 많음)\n\n' +
'【미션 시스템】\n' +
'- 훈련 미션: 탐사, 속도 도전, 궤도 진입, 연료 효율, 장거리 비행\n' +
'- 일일 미션: 매일 새로운 업무 지시 (📧 아이콘), 코인 + 미션 포인트 획득\n' +
'- 미션 포인트: 일일 미션 완료 시 +1 MP\n\n' +
'【규칙】\n' +
'1. 파일럿을 SSIL의 신입 직원으로 친근하게 대하세요.\n' +
'2. 게임과 관련 없는 질문에는 "저는 SSIL의 AI ARIA입니다. 우주 운송 업무와 관련된 질문만 도와드릴 수 있어요. 🚀"라고 답하세요.\n' +
'3. 답변은 2~3문장으로 짧고 친절하게 해주세요.\n' +
'4. 이모지를 적절히 사용하세요.';

            // Vercel: /api/gemini, 로컬: gemini_proxy.php
            const geminiEndpoint = window.location.hostname.includes('vercel') ? '/api/gemini' : 'gemini_proxy.php';
            fetch(geminiEndpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    systemInstruction: { parts: [{ text: systemPrompt }] },
                    contents: [{ parts: [{ text: question }] }]
                })
            })
            .then(function(response) {
                panel.classList.remove('loading');
                if (!response.ok) {
                    throw new Error('API Error');
                }
                return response.json();
            })
            .then(function(data) {
                var answer = data.candidates && data.candidates[0] && 
                             data.candidates[0].content && data.candidates[0].content.parts && 
                             data.candidates[0].content.parts[0] && data.candidates[0].content.parts[0].text;
                
                if (answer) {
                    aiTypeMessage(answer);
                } else {
                    throw new Error('Empty response');
                }
            })
            .catch(function(error) {
                panel.classList.remove('loading');
                console.error('ARIA API 오류:', error);
                // API 실패 시 로컬 답변으로 대체
                var localAnswer = getLocalAIAnswer(question);
                if (localAnswer) {
                    aiTypeMessage(localAnswer);
                } else {
                    aiTypeMessage('📡 통신 상태가 좋지 않습니다. 잠시 후 다시 시도해주세요.');
                }
            });
        }
        
        // 로컬 AI 답변 (API 없이 즉시 응답)
        function getLocalAIAnswer(question) {
            const q = question.toLowerCase();
            
            // 인사
            if (q.includes('안녕') || q.includes('하이') || q.includes('헬로') || q === 'hi' || q === 'hello') {
                return '👋 안녕하세요, 파일럿! ARIA입니다. 무엇을 도와드릴까요?';
            }
            
            // 누구/뭐야 질문
            if (q.includes('누구') || q.includes('뭐야') || q.includes('소개')) {
                return '🤖 저는 ARIA, 당신의 AI 부조종사입니다. 우주선 조작, 항법, 미션 등 이 시뮬레이션에 관한 모든 것을 도와드릴 수 있어요!';
            }
            
            // 도움말
            if (q.includes('도움') || q.includes('help') || q.includes('뭐 할 수') || q.includes('기능')) {
                return '📚 도움말:\n• 상태: 현재 우주선 상태\n• 항법: 목적지 안내\n• 미션: 보상 미션\n• 팁: 유용한 팁\n\n또는 직접 질문해주세요!';
            }
            
            // 조작법 관련 (키워드 정확도 향상)
            if (q.includes('조작') || q.includes('컨트롤') || (q.includes('어떻게') && (q.includes('움직') || q.includes('조종') || q.includes('운전')))) {
                return '🎮 조작법:\n• W/↑: 가속\n• S/↓: 감속\n• 드래그: 방향\n• 스페이스: 긴급정지';
            }
            
            // 가속
            if (q.includes('가속') || (q.includes('빨리') && q.includes('가'))) {
                return '🎮 가속: W키 또는 ↑키, 모바일은 조이스틱 위로!';
            }
            
            // 감속/정지
            if (q.includes('감속') || q.includes('멈') || q.includes('정지') || q.includes('브레이크') || q.includes('서')) {
                return '🛑 감속: S키, 긴급정지는 스페이스바!';
            }
            
            // 방향/회전
            if (q.includes('회전') || q.includes('방향') || q.includes('조향') || q.includes('돌')) {
                return '🔄 방향: 화면을 드래그하세요!';
            }
            
            // 자동항법
            if (q.includes('자동') || q.includes('오토') || q.includes('항법')) {
                return '🤖 자동항법: 목표 선택 → 🤖자동 버튼!';
            }
            
            // 궤도
            if (q.includes('궤도')) {
                return '🌍 궤도: 행성 접근 → 궤도진입 버튼!';
            }
            
            // 연료
            if (q.includes('연료') || q.includes('보급') || q.includes('충전')) {
                return '⛽ 연료: ISS 정거장에서 자동 보급!';
            }
            
            // 미션
            if (q.includes('미션') || q.includes('퀘스트') || q.includes('임무')) {
                return '📡 미션: 📡미션 버튼으로 수락, 완료시 코인!';
            }
            
            // 우주선
            if (q.includes('우주선') || q.includes('함선') || q.includes('구매') || q.includes('ship')) {
                return '🚀 우주선: ISS에서 선택/구매 가능!';
            }
            
            // 무장
            if (q.includes('무장') || q.includes('무기') || q.includes('장갑') || q.includes('전투')) {
                return '⚔️ 무장: 우주선 화면에서 ⚔️무장 버튼!';
            }
            
            // 천체/행성
            if (q.includes('행성') || q.includes('천체') || q.includes('태양') || q.includes('지구') || q.includes('화성') || q.includes('목성') || q.includes('토성')) {
                return '🪐 천체: 좌측 목록에서 선택, 자동항법 가능!';
            }
            
            // 블랙홀
            if (q.includes('블랙홀')) {
                return '🕳️ 블랙홀: 너무 가까이 가면 탈출 불가!';
            }
            
            // 코인
            if (q.includes('코인') || q.includes('돈') || q.includes('화폐')) {
                return '🪙 코인: 미션 완료로 획득, 우주선 구매!';
            }
            
            // 로그인
            if (q.includes('로그인') || q.includes('회원') || q.includes('계정')) {
                return '🔐 계정: 회원가입시 1000코인+셔틀 지급!';
            }
            
            // 탈출/하선
            if (q.includes('탈출') || q.includes('하선') || q.includes('나가')) {
                return '🚪 하선: 하단 X하선 버튼 또는 긴급탈출!';
            }
            
            // 속도
            if (q.includes('속도') || q.includes('빠르')) {
                return '📊 속도: 현재 속도는 화면 중앙 하단에 표시됩니다!';
            }
            
            // 레이더
            if (q.includes('레이더') || q.includes('radar')) {
                return '📡 레이더: 우측 상단, 노란점=목표, 빨간점=위험!';
            }
            
            // 기타 - 앱 관련 아닌 질문
            if (q.includes('날씨') || q.includes('뉴스') || q.includes('주식') || q.includes('음악') || q.includes('영화')) {
                return '🤖 저는 우주선 AI입니다. 이 시뮬레이션에 관한 질문만 도와드릴 수 있어요!';
            }
            
            // 기본 응답 (매칭 안 될 때)
            return '🤖 질문을 이해하지 못했어요. 조작법, 자동항법, 연료, 미션 등에 대해 물어보세요!';
        }
        
        // 기본 도움말 (API 실패 시)
        function getDefaultHelp(question) {
            return '기본 조작법:\n• W/S: 가속/감속\n• 드래그: 방향\n• 스페이스: 긴급정지\n• 🤖자동: 자동항법\n\n더 자세한 질문을 해주세요!';
        }
        
        // Enter 키로 질문 전송
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(() => {
                const input = document.getElementById('ai-input');
                if (input) {
                    input.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            aiSendQuestion();
                        }
                    });
                }
            }, 1000);
        });
        
        
        // ===== 1인칭 조종석 시스템 =====
        let cockpitGroup;
        let cockpitFloatGroup;  // 플로팅 플랫폼 (애니메이션용)
        let cockpitMainHUD, cockpitSubHUD;  // 홀로그램 HUD
        let cockpitLookRotY = 0, cockpitLookRotX = 0;
        let cockpitTargetRotY = 0, cockpitTargetRotX = 0;
        let cockpitDragging = false, cockpitPrevMouse = { x: 0, y: 0 };
        const COCKPIT_LOOK_SPEED = 0.003;
        const COCKPIT_DAMPING = 0.08;
        let cockpitMonitors = {};
        let cockpitBtnMesh, cockpitBlinkIndices = [];
        let cockpitStickGroup;
        let isCockpitView = false;  // 1인칭 조종석 시점 여부
        
        // 궤도 진입 상태
        let orbitState = {
            active: false,        // 궤도 운행 중
            inOrbit: false,
            enteringOrbit: false,  // 궤도 진입 중
            orbitBody: null,
            orbitRadius: 0,
            orbitAngle: 0,
            orbitSpeed: 0,
            targetOrbitSpeed: 0,
            currentOrbitSpeed: 0,
            orbitTransitionTime: 0,
            tidalLocked: true  // 항상 행성을 향함
        };
        
        // 긴급 회피 시스템
        let emergencyEvasion = {
            active: false,
            phase: 'idle',       // 'idle', 'escaping'
            targetBody: null,
            escapeRadius: 0,     // 탈출 기준 거리
            targetDirection: null,
            thrustTime: 0,
            maxThrustTime: 5     // 최대 역추진 시간 (초)
        };
        
        function playBeep() {
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                oscillator.frequency.value = 880;
                oscillator.type = 'square';
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.2);
            } catch(e) {}
        }
        
        // 선내 시스템 변수
        let interiorScene, interiorCamera, interiorRenderer;
        let interiorPlayer = { position: new THREE.Vector3(0, 1.6, -5), rotationY: Math.PI, pitchX: 0 };
        let currentRoom = 'corridor';
        let rooms = {};
        let nearDoor = null;
        let moveInput = { x: 0, z: 0 };
        let moveJoystickActive = false, moveJoystickCenter = { x: 0, y: 0 };
        let lookDragging = false, lastLookPos = { x: 0, y: 0 };
        let allColliders = [];
        let physicsObjects = [];
        let interactableObjects = [];
        let lookedAtObject = null;
        let engineParts = [];
        
        // 전망대 카메라
        let obsCamera;
        let obsCamRotation = { theta: 0, phi: Math.PI / 2 };
        let obsDragging = false, obsLastPos = { x: 0, y: 0 };
        const galaxyCenter = new THREE.Vector3(-50000000, 0, 0);  // 은하 중심 (태양에서 5000만 단위 떨어짐) - 10배 증가
        const clock = new THREE.Clock();

        // 천체 실제 이미지 URL (NASA/Wikimedia)
        const CELESTIAL_IMAGES = {
            SUN: 'https://upload.wikimedia.org/wikipedia/commons/thumb/b/b4/The_Sun_by_the_Atmospheric_Imaging_Assembly_of_NASA%27s_Solar_Dynamics_Observatory_-_20100819.jpg/220px-The_Sun_by_the_Atmospheric_Imaging_Assembly_of_NASA%27s_Solar_Dynamics_Observatory_-_20100819.jpg',
            MERCURY: 'https://upload.wikimedia.org/wikipedia/commons/thumb/4/4a/Mercury_in_true_color.jpg/220px-Mercury_in_true_color.jpg',
            VENUS: 'https://upload.wikimedia.org/wikipedia/commons/thumb/0/08/Venus_from_Mariner_10.jpg/220px-Venus_from_Mariner_10.jpg',
            EARTH: 'https://upload.wikimedia.org/wikipedia/commons/thumb/c/cb/The_Blue_Marble_%28remastered%29.jpg/220px-The_Blue_Marble_%28remastered%29.jpg',
            MARS: 'https://upload.wikimedia.org/wikipedia/commons/thumb/0/0c/Mars_-_August_30_2021_-_Flickr_-_Kevin_M._Gill.png/220px-Mars_-_August_30_2021_-_Flickr_-_Kevin_M._Gill.png',
            JUPITER: 'https://upload.wikimedia.org/wikipedia/commons/thumb/c/c1/Jupiter_New_Horizons.jpg/220px-Jupiter_New_Horizons.jpg',
            SATURN: 'https://upload.wikimedia.org/wikipedia/commons/thumb/c/c7/Saturn_during_Equinox.jpg/220px-Saturn_during_Equinox.jpg',
            URANUS: 'https://upload.wikimedia.org/wikipedia/commons/thumb/4/48/Uranus_as_seen_by_NASA%27s_Voyager_2_%28remastered%29.png/220px-Uranus_as_seen_by_NASA%27s_Voyager_2_%28remastered%29.png',
            NEPTUNE: 'https://upload.wikimedia.org/wikipedia/commons/thumb/6/63/Neptune_-_Voyager_2_%2829347980845%29_flatten_crop.jpg/220px-Neptune_-_Voyager_2_%2829347980845%29_flatten_crop.jpg',
            MOON: 'https://upload.wikimedia.org/wikipedia/commons/thumb/e/e1/FullMoon2010.jpg/220px-FullMoon2010.jpg',
            PHOBOS: 'https://upload.wikimedia.org/wikipedia/commons/thumb/5/5c/Phobos_colour_2008.jpg/220px-Phobos_colour_2008.jpg',
            DEIMOS: 'https://upload.wikimedia.org/wikipedia/commons/thumb/8/8d/Deimos-MRO.jpg/220px-Deimos-MRO.jpg',
            IO: 'https://upload.wikimedia.org/wikipedia/commons/thumb/7/7b/Io_highest_resolution_true_color.jpg/220px-Io_highest_resolution_true_color.jpg',
            EUROPA: 'https://upload.wikimedia.org/wikipedia/commons/thumb/e/e4/Europa-moon-with-margins.jpg/220px-Europa-moon-with-margins.jpg',
            GANYMEDE: 'https://upload.wikimedia.org/wikipedia/commons/thumb/2/21/Ganymede_-_Perijove_34_Composite.png/220px-Ganymede_-_Perijove_34_Composite.png',
            CALLISTO: 'https://upload.wikimedia.org/wikipedia/commons/thumb/e/e9/Callisto.jpg/220px-Callisto.jpg',
            TITAN: 'https://upload.wikimedia.org/wikipedia/commons/thumb/8/84/Titan_in_true_color.jpg/220px-Titan_in_true_color.jpg',
            ENCELADUS: 'https://upload.wikimedia.org/wikipedia/commons/thumb/8/83/PIA17202_-_Approaching_Enceladus.jpg/220px-PIA17202_-_Approaching_Enceladus.jpg',
            TITANIA: 'https://upload.wikimedia.org/wikipedia/commons/thumb/2/2e/Titania_%28moon%29_color%2C_cropped.jpg/220px-Titania_%28moon%29_color%2C_cropped.jpg',
            OBERON: 'https://upload.wikimedia.org/wikipedia/commons/thumb/e/e0/Oberon_in_true_color.jpg/220px-Oberon_in_true_color.jpg',
            TRITON: 'https://upload.wikimedia.org/wikipedia/commons/thumb/a/a6/Triton_moon_mosaic_Voyager_2_%28large%29.jpg/220px-Triton_moon_mosaic_Voyager_2_%28large%29.jpg',
            PLUTO: 'https://upload.wikimedia.org/wikipedia/commons/thumb/e/ef/Pluto_in_True_Color_-_High-Res.jpg/220px-Pluto_in_True_Color_-_High-Res.jpg',
            CERES: 'https://upload.wikimedia.org/wikipedia/commons/thumb/7/76/Ceres_-_RC3_-_Haulani_Crater_%2822381131691%29_%28cropped%29.jpg/220px-Ceres_-_RC3_-_Haulani_Crater_%2822381131691%29_%28cropped%29.jpg',
            ERIS: 'https://upload.wikimedia.org/wikipedia/commons/thumb/5/5b/Eris_and_dysnomia2.jpg/220px-Eris_and_dysnomia2.jpg',
            HAUMEA: 'https://upload.wikimedia.org/wikipedia/commons/thumb/2/2b/Haumea_Hubble.png/220px-Haumea_Hubble.png',
            MAKEMAKE: 'https://upload.wikimedia.org/wikipedia/commons/thumb/2/29/Makemake_and_its_moon.jpg/220px-Makemake_and_its_moon.jpg',
            SIRIUS: 'https://upload.wikimedia.org/wikipedia/commons/thumb/c/c0/Sirius_A_and_B_artwork.jpg/220px-Sirius_A_and_B_artwork.jpg',
            BETELGEUSE: 'https://upload.wikimedia.org/wikipedia/commons/thumb/c/c8/Betelgeuse_star_%28Hubble%29.jpg/220px-Betelgeuse_star_%28Hubble%29.jpg',
            PROXIMA: 'https://upload.wikimedia.org/wikipedia/commons/thumb/9/95/New_shot_of_Proxima_Centauri%2C_our_nearest_neighbour.jpg/220px-New_shot_of_Proxima_Centauri%2C_our_nearest_neighbour.jpg',
            BLACKHOLE: 'https://upload.wikimedia.org/wikipedia/commons/thumb/4/4f/Black_hole_-_Messier_87_crop_max_res.jpg/220px-Black_hole_-_Messier_87_crop_max_res.jpg'
        };
        
        let DEFAULT_TYPES = {
            SUN:        { r: 35.0, m: 50000, color: 0xffaa00, emissive: 0xff4400, texType: 'star', type: 'star', rotSpeed: 0.04 },  // ★ 30% 감소
            MERCURY:    { r: 0.38, m: 0.05,  color: 0xaaaaaa, texType: 'rock', texKey: 'MERCURY', type: 'planet', rotSpeed: 0.017 },
            VENUS:      { r: 0.95, m: 0.4,   color: 0xe3bb76, texType: 'gas', texKey: 'VENUS', type: 'planet', rotSpeed: -0.004 },
            EARTH:      { r: 1.00, m: 0.5,   color: 0x2233ff, texType: 'earth', texKey: 'EARTH', type: 'planet', rotSpeed: 1.0 },
            MARS:       { r: 0.53, m: 0.06,  color: 0xff4500, texType: 'rock', texKey: 'MARS', type: 'planet', rotSpeed: 0.97 },
            JUPITER:    { r: 11.2, m: 50.0,  color: 0xd8ca9d, texType: 'gas', texKey: 'JUPITER', type: 'gas', rotSpeed: 2.4 },
            SATURN:     { r: 9.4,  m: 15.0,  color: 0xf4d03f, ring: true, texType: 'gas', texKey: 'SATURN', type: 'gas', rotSpeed: 2.2 },
            URANUS:     { r: 4.0,  m: 3.0,   color: 0x40e0d0, texType: 'gas', texKey: 'URANUS', type: 'gas', rotSpeed: -1.4 },
            NEPTUNE:    { r: 3.9,  m: 3.0,   color: 0x4169e1, texType: 'gas', texKey: 'NEPTUNE', type: 'gas', rotSpeed: 1.5 },
            MOON:       { r: 0.27, m: 0.006, color: 0xdddddd, texType: 'rock', texKey: 'MOON', type: 'moon', rotSpeed: 0.03 },
            PHOBOS:     { r: 0.02, m: 0.0001, color: 0x887766, texType: 'rock', type: 'moon' },  // 실제: 0.0018, 가시성 위해 0.02
            DEIMOS:     { r: 0.015, m: 0.0001, color: 0x776655, texType: 'rock', type: 'moon' }, // 실제: 0.001, 가시성 위해 0.015
            IO:         { r: 0.286, m: 0.007, color: 0xffffaa, texType: 'rock', type: 'moon' },
            EUROPA:     { r: 0.245, m: 0.005, color: 0xccddff, texType: 'rock', type: 'moon' },
            GANYMEDE:   { r: 0.413, m: 0.012, color: 0xddccaa, texType: 'rock', type: 'moon' },
            CALLISTO:   { r: 0.378, m: 0.009, color: 0x554433, texType: 'rock', type: 'moon' },
            TITAN:      { r: 0.404, m: 0.011, color: 0xffaa00, texType: 'gas', type: 'moon' },
            ENCELADUS:  { r: 0.04, m: 0.001, color: 0xffffff, texType: 'rock', type: 'moon' },
            TITANIA:    { r: 0.124, m: 0.003, color: 0xeeeeee, texType: 'rock', type: 'moon' },
            OBERON:     { r: 0.119, m: 0.003, color: 0xcccccc, texType: 'rock', type: 'moon' },
            TRITON:     { r: 0.212, m: 0.008, color: 0xffcccc, texType: 'rock', type: 'moon' },
            PLUTO:      { r: 0.18, m: 0.002, color: 0xddccbb, texType: 'rock', type: 'planet' },
            CERES:      { r: 0.07, m: 0.001, color: 0x999999, texType: 'rock', type: 'planet' },
            ERIS:       { r: 0.18, m: 0.002, color: 0xffffff, texType: 'rock', type: 'planet' },
            HAUMEA:     { r: 0.14, m: 0.001, color: 0xaaaaaa, texType: 'rock', type: 'planet' },
            MAKEMAKE:   { r: 0.14, m: 0.001, color: 0xaa5555, texType: 'rock', type: 'planet' },
            SIRIUS:     { r: 85.0, m: 100000, color: 0xaaddff, texType: 'star', type: 'star' },
            BETELGEUSE: { r: 500.0, m: 300000, color: 0xff3300, texType: 'star', type: 'star' },
            PROXIMA:    { r: 7.0, m: 6000, color: 0xff6666, texType: 'star', type: 'star' },
            BLACKHOLE:  { r: 3.0,  m: 500000, color: 0x000000, type: 'blackhole', rotSpeed: 0 }
        };

        const SPAWN_LIST = [ 
            { name: "지구", type: DEFAULT_TYPES.EARTH, tex: "EARTH" }, 
            { name: "목성", type: DEFAULT_TYPES.JUPITER, tex: "JUPITER" }, 
            { name: "태양(별)", type: DEFAULT_TYPES.SUN, tex: "SUN" } 
        ];

        function generateAccretionDiskTexture() { 
            const canvas = document.createElement('canvas'); canvas.width=512; canvas.height=512; 
            const ctx = canvas.getContext('2d'); const cx=256; const cy=256; 
            const g = ctx.createRadialGradient(cx, cy, 120, cx, cy, 250); 
            g.addColorStop(0,'rgba(0,0,0,0)'); g.addColorStop(0.2,'rgba(255,30,0,0.9)'); 
            g.addColorStop(0.4,'rgba(255,140,0,1)'); g.addColorStop(0.6,'rgba(255,240,150,1)'); 
            g.addColorStop(1,'rgba(0,0,0,0)'); 
            ctx.fillStyle=g; ctx.beginPath(); ctx.arc(cx,cy,256,0,Math.PI*2); ctx.fill(); 
            return new THREE.CanvasTexture(canvas); 
        }

        function generateJetTexture() { 
            const c=document.createElement('canvas'); c.width=64; c.height=256; 
            const ctx=c.getContext('2d'); const g=ctx.createLinearGradient(0,0,0,256); 
            g.addColorStop(0,'rgba(200,230,255,0)'); g.addColorStop(0.2,'rgba(150,200,255,0.8)'); 
            g.addColorStop(1,'rgba(100,0,0,0)'); 
            ctx.fillStyle=g; ctx.fillRect(0,0,64,256); return new THREE.CanvasTexture(c); 
        }

        function generateProceduralTexture(type, colorHex) { 
            const canvas = document.createElement('canvas'); canvas.width=512; canvas.height=256; 
            const ctx = canvas.getContext('2d'); const color = new THREE.Color(colorHex); 
            ctx.fillStyle = '#' + color.getHexString(); ctx.fillRect(0, 0, 512, 256); 
            if(type==='gas'){ 
                for(let i=0;i<15;i++){ 
                    ctx.fillStyle=`rgba(255,255,255,${Math.random()*0.15})`; 
                    ctx.fillRect(0,Math.random()*256,512,Math.random()*30+5); 
                } 
            } else if(type==='rock'){ 
                for(let i=0;i<400;i++){ 
                    ctx.fillStyle='rgba(0,0,0,0.2)'; ctx.beginPath(); 
                    ctx.arc(Math.random()*512,Math.random()*256,Math.random()*3+1,0,Math.PI*2); ctx.fill(); 
                } 
            } else if(type==='earth'){ 
                ctx.fillStyle='#1a3b8e'; ctx.fillRect(0,0,512,256); 
                ctx.fillStyle='#2d6e32'; 
                for(let i=0;i<30;i++){ 
                    ctx.beginPath(); ctx.ellipse(Math.random()*512,60+Math.random()*136,20+Math.random()*40,10+Math.random()*30,Math.random()*Math.PI,0,Math.PI*2); ctx.fill(); 
                } 
            } 
            return new THREE.CanvasTexture(canvas); 
        }

        // 궤도 링 저장
        let orbitLines = [];
        
        // ★★★ 타원 궤도 라인 생성 (행성 초기 위치와 동일한 공식) ★★★
        function createOrbitLine(semiMajor, eccentricity = 0, inclination = 0, omega = 0, color = 0x444444, planetName = '') {
            const a = semiMajor;
            const e = eccentricity;
            const inc = inclination * Math.PI / 180;  // 경사각 (라디안)
            const omegaRad = omega * Math.PI / 180;   // 근일점 경도 (라디안)
            
            const points = [];
            const segments = 128;
            
            for (let i = 0; i <= segments; i++) {
                // 진근점이각 (True Anomaly) 0 ~ 2π
                const nu = (i / segments) * 2 * Math.PI;
                
                // 궤도 평면에서의 거리 (타원 방정식)
                const r = a * (1 - e * e) / (1 + e * Math.cos(nu));
                
                // 궤도 평면에서의 위치 (근일점 경도 적용)
                const xOrbit = r * Math.cos(nu + omegaRad);
                const yOrbit = r * Math.sin(nu + omegaRad);
                
                // 궤도 경사각 적용하여 3D 위치 계산
                const x = xOrbit;
                const y = yOrbit * Math.sin(inc);  // 경사각에 의한 Y 성분
                const z = yOrbit * Math.cos(inc);
                
                points.push(new THREE.Vector3(x, y, z));
            }
            
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ color: color, transparent: true, opacity: 0.5 });
            const ellipse = new THREE.Line(geometry, material);
            
            ellipse.userData.planetName = planetName;
            ellipse.userData.semiMajor = semiMajor / CONFIG.distScale;
            ellipse.userData.eccentricity = eccentricity;
            ellipse.userData.inclination = inclination;
            scene.add(ellipse);
            orbitLines.push(ellipse);
            return ellipse;
        }
        
        // 이전 버전 호환용 (원형 궤도)
        function createCircularOrbitLine(radius, color = 0x444444, planetName = '') {
            return createOrbitLine(radius, 0, 0, 0, color, planetName);
        }
        
        // 모든 궤도 라인 제거
        function clearOrbitLines() {
            orbitLines.forEach(line => {
                scene.remove(line);
                if (line.geometry) line.geometry.dispose();
                if (line.material) line.material.dispose();
            });
            orbitLines = [];
        }
        
        // 실제 태양계 궤도 데이터 (AU 기준, 지구 = 1.0)
        // ★★★ NASA JPL 공식 데이터 (1800 AD - 2050 AD) ★★★
        // 출처: https://ssd.jpl.nasa.gov/planets/approx_pos.html
        const REAL_ORBIT_DATA = {
            "수성": { 
                au: 0.38709927,     // 장반경 (AU) - NASA JPL
                e: 0.20563593,      // 이심률 - NASA JPL
                i: 7.00497902,      // 궤도 경사각 (도) - NASA JPL
                omega: 77.45779628, // 근일점 경도 (도) - NASA JPL
                node: 48.33076593,  // 승교점 경도 (도) - NASA JPL
                L0: 252.25032350,   // 평균 경도 (도) - NASA JPL
                color: 0x888888, 
                period: 87.969      // 공전주기 (일)
            },
            "금성": { 
                au: 0.72333566,     // NASA JPL
                e: 0.00677672,      // 거의 원형
                i: 3.39467605,      // NASA JPL
                omega: 131.60246718,
                node: 76.67984255,
                L0: 181.97909950,
                color: 0xddaa55, 
                period: 224.701 
            },
            "지구": { 
                au: 1.00000261,     // NASA JPL
                e: 0.01671123,      // 약간 타원
                i: 0.00001531,      // 거의 0 (기준면)
                omega: 102.93768193,
                node: 0.0,
                L0: 100.46457166,
                color: 0x4488ff, 
                period: 365.256 
            },
            "화성": { 
                au: 1.52371034,     // NASA JPL
                e: 0.09339410,      // 꽤 타원형
                i: 1.84969142,      // NASA JPL
                omega: -23.94362959 + 360, // 336.06 (양수로 변환)
                node: 49.55953891,
                L0: -4.55343205 + 360, // 355.45
                color: 0xff6644, 
                period: 686.980 
            },
            "목성": { 
                au: 5.20288700,     // NASA JPL
                e: 0.04838624,      // NASA JPL
                i: 1.30439695,      // NASA JPL
                omega: 14.72847983,
                node: 100.47390909,
                L0: 34.39644051,
                color: 0xddcc88, 
                period: 4332.59 
            },
            "토성": { 
                au: 9.53667594,     // NASA JPL
                e: 0.05386179,      // NASA JPL
                i: 2.48599187,      // NASA JPL
                omega: 92.59887831,
                node: 113.66242448,
                L0: 49.95424423,
                color: 0xeecc66, 
                period: 10759.22 
            },
            "천왕성": { 
                au: 19.18916464,    // NASA JPL
                e: 0.04725744,      // NASA JPL
                i: 0.77263783,      // NASA JPL
                omega: 170.95427630,
                node: 74.01692503,
                L0: 313.23810451,
                color: 0x66dddd, 
                period: 30688.5 
            },
            "해왕성": { 
                au: 30.06992276,    // NASA JPL
                e: 0.00859048,      // 거의 원형
                i: 1.77004347,      // NASA JPL
                omega: 44.96476227,
                node: 131.78422574,
                L0: -55.12002969 + 360, // 304.88
                color: 0x4466ff, 
                period: 60182.0 
            }
        };
        
        // ★★★ 케플러 궤도 시간 변수 (누적) ★★★
        let keplerTime = Date.now() * 0.00001;  // 원본 스케일 유지

        // ★★★ NASA JPL 공식 공식으로 케플러 궤도 계산 ★★★
        // 출처: https://ssd.jpl.nasa.gov/planets/approx_pos.html
        function updateKeplerOrbits(dt) {
            const baseUnit = 2200;  // 10배 증가

            // ★★★ 멀티모드: Date.now() 기준 (공전 + 동기화) ★★★
            if (window.gameMode === 'multi') {
                // 모든 기기에서 Date.now()는 동일 (UTC)
                // 같은 시간 = 같은 keplerTime = 같은 행성 위치
                keplerTime = Date.now() * 0.00000001;  // 느린 공전 속도
            } else {
                // 싱글모드: 기존 방식 (상대적 누적, timeScale 적용)
                keplerTime += dt * 0.0001 * CONFIG.timeScale;
            }
            
            bodies.forEach(body => {
                if (!body || !body.mesh || !body.name) return;
                
                const orbitData = REAL_ORBIT_DATA[body.name];
                if (!orbitData) return;  // 태양이나 다른 천체는 제외
                
                // NASA JPL 궤도 요소
                const a = baseUnit * orbitData.au * CONFIG.distScale;  // 장반경 (스케일 적용)
                const e = orbitData.e;  // 이심률
                const I = orbitData.i * Math.PI / 180;  // 경사각 (라디안)
                const varpi = orbitData.omega * Math.PI / 180;  // 근일점 경도 (라디안)
                const Omega = (orbitData.node || 0) * Math.PI / 180;  // 승교점 경도 (라디안)
                
                // 근일점 편각 (argument of perihelion)
                const omega_arg = varpi - Omega;
                
                // 평균 근점이각 (Mean Anomaly) - 시간에 따라 변화
                const periodFactor = 1 / Math.pow(orbitData.au, 1.5);  // 케플러 제3법칙
                let M = (keplerTime * periodFactor * 2) % (2 * Math.PI);
                
                // M을 -π ~ +π 범위로 조정
                while (M > Math.PI) M -= 2 * Math.PI;
                while (M < -Math.PI) M += 2 * Math.PI;
                
                // 이심 근점이각 (Eccentric Anomaly) - NASA JPL 뉴턴-랩슨
                const eStar = e * 180 / Math.PI;  // e* = 57.29578 * e
                let E = M + e * Math.sin(M);  // 초기값
                
                for (let i = 0; i < 10; i++) {
                    const dM = M - (E - e * Math.sin(E));
                    const dE = dM / (1 - e * Math.cos(E));
                    E = E + dE;
                    if (Math.abs(dE) < 1e-8) break;
                }
                
                // 궤도 평면에서의 좌표 (x' = perihelion 방향)
                const xPrime = a * (Math.cos(E) - e);
                const yPrime = a * Math.sqrt(1 - e * e) * Math.sin(E);
                
                // 3D 황도 좌표로 변환 (NASA JPL 공식)
                const cosOmega = Math.cos(Omega);
                const sinOmega = Math.sin(Omega);
                const cosI = Math.cos(I);
                const sinI = Math.sin(I);
                const cosw = Math.cos(omega_arg);
                const sinw = Math.sin(omega_arg);
                
                const x_ecl = (cosw * cosOmega - sinw * sinOmega * cosI) * xPrime +
                              (-sinw * cosOmega - cosw * sinOmega * cosI) * yPrime;
                const y_ecl = (cosw * sinOmega + sinw * cosOmega * cosI) * xPrime +
                              (-sinw * sinOmega + cosw * cosOmega * cosI) * yPrime;
                const z_ecl = (sinw * sinI) * xPrime + (cosw * sinI) * yPrime;
                
                // Three.js 좌표계로 변환 (Y-up)
                // 황도 좌표: x_ecl (춘분점), y_ecl (황도면), z_ecl (황도 북극)
                // Three.js: x (right), y (up), z (forward)
                body.mesh.position.set(x_ecl, z_ecl, -y_ecl);
                
                // 속도 벡터 업데이트 (다른 시스템용)
                if (body.velocity) {
                    const r = Math.sqrt(xPrime * xPrime + yPrime * yPrime);
                    const vAngle = Math.atan2(yPrime, xPrime) + Math.PI / 2;
                    const GM = CONFIG.G * 1e10;
                    const speed = Math.sqrt(Math.abs(GM * (2 / r - 1 / a))) * 0.001;
                    
                    const vxPrime = speed * Math.cos(vAngle);
                    const vyPrime = speed * Math.sin(vAngle);
                    
                    const vx_ecl = (cosw * cosOmega - sinw * sinOmega * cosI) * vxPrime +
                                   (-sinw * cosOmega - cosw * sinOmega * cosI) * vyPrime;
                    const vy_ecl = (cosw * sinOmega + sinw * cosOmega * cosI) * vxPrime +
                                   (-sinw * sinOmega + cosw * cosOmega * cosI) * vyPrime;
                    const vz_ecl = (sinw * sinI) * vxPrime + (cosw * sinI) * vyPrime;
                    
                    body.velocity.set(vx_ecl, vz_ecl, -vy_ecl);
                }
            });
        }
        
        // 궤도 라인 생성 (실제 타원 궤도) - ★ 실제 궤도 데이터 기반으로 미리 표시
        function createAllOrbitLines() {
            clearOrbitLines();
            
            const baseUnit = 2200;  // 기본 단위 (지구 궤도) - 10배 증가
            
            Object.entries(REAL_ORBIT_DATA).forEach(([name, data]) => {
                const semiMajor = baseUnit * data.au * CONFIG.distScale;  // 장반경
                const eccentricity = data.e || 0;  // 이심률
                const inclination = data.i || 0;   // 경사각
                const omega = data.omega || 0;     // 근일점 경도
                
                createOrbitLine(semiMajor, eccentricity, inclination, omega, data.color, name);
            });
        }

        function initTrail(body) { 
            if (!body || !body.mesh) return;
            const points=[]; 
            for(let i=0;i<CONFIG.trailLength;i++) points.push(body.mesh.position.clone()); 
            const trailColor = (body.mesh.material && body.mesh.material.color) ? body.mesh.material.color : 0xffffff;
            const trail = new THREE.Line(
                new THREE.BufferGeometry().setFromPoints(points), 
                new THREE.LineBasicMaterial({color: trailColor, transparent:true, opacity:0.3})
            ); 
            trail.frustumCulled=false; scene.add(trail); 
            body.trail=trail; body.trailPoints=points; body.trailIndex=0; body.trailTimer=0; 
        }

        function showMsg(text) { 
            const el=document.getElementById('msg-box'); 
            el.innerText=text; 
            el.style.opacity=1; 
            setTimeout(()=>el.style.opacity=0, 3000); 
        }
        
        // ★ 우주선 위치 마커 표시 (화면 UI)
        let shipMarkerInterval = null;
        let shipMarkerShipType = null;
        
        function showShipLocationMarker(position, shipName, shipType) {
            // 기존 마커 인터벌 제거
            if (shipMarkerInterval) {
                clearInterval(shipMarkerInterval);
                shipMarkerInterval = null;
            }
            
            shipMarkerShipType = shipType;
            
            // HTML 마커 설정
            const marker = document.getElementById('ship-location-marker');
            const markerBox = document.getElementById('ship-marker-box');
            const markerName = document.getElementById('ship-marker-name');
            
            // 이미지 설정
            if (shipType && shipType.image && shipType.image.length > 0) {
                markerBox.innerHTML = `<img src="${shipType.image}" style="width:100%; height:100%; object-fit:contain;">`;
            } else {
                markerBox.innerHTML = `<span style="font-size:30px;">🚀</span>`;
            }
            markerName.textContent = shipName;
            
            marker.style.display = 'block';
            
            // 화면 위치 업데이트 함수
            let blinkCount = 0;
            shipMarkerInterval = setInterval(() => {
                // 3D 위치를 화면 좌표로 변환
                const vector = position.clone();
                vector.project(camera);
                
                const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-(vector.y * 0.5) + 0.5) * window.innerHeight;
                
                // 화면 안에 있을 때만 표시
                if (vector.z < 1 && x > 0 && x < window.innerWidth && y > 0 && y < window.innerHeight) {
                    marker.style.left = (x - 30) + 'px';
                    marker.style.top = (y - 90) + 'px';
                    marker.style.opacity = '1';
                } else {
                    marker.style.opacity = '0.3';
                    // 화면 가장자리에 표시
                    const clampedX = Math.max(40, Math.min(window.innerWidth - 100, x));
                    const clampedY = Math.max(100, Math.min(window.innerHeight - 50, y));
                    marker.style.left = (clampedX - 30) + 'px';
                    marker.style.top = (clampedY - 90) + 'px';
                }
                
                blinkCount++;
                if (blinkCount > 40) {  // 20초 후 중지
                    clearInterval(shipMarkerInterval);
                    shipMarkerInterval = null;
                    marker.style.display = 'none';
                }
            }, 500);
        }
        
        // 마커 숨기기
        function hideShipLocationMarker() {
            const marker = document.getElementById('ship-location-marker');
            marker.style.display = 'none';
            if (shipMarkerInterval) {
                clearInterval(shipMarkerInterval);
                shipMarkerInterval = null;
            }
        }
        
        // ★ 마커 클릭 시 주차된 우주선으로 카메라 이동
        window.focusOnParkedShip = function() {
            if (parkedShipMesh && parkedShipMesh.position) {
                const pos = parkedShipMesh.position.clone();
                const offset = new THREE.Vector3(2, 1, 2);
                camera.position.copy(pos).add(offset);
                controls.target.copy(pos);
                controls.update();
                
                // 주차된 우주선 body 찾아서 포커스
                const parkedBody = bodies.find(b => b.isParkedShip);
                if (parkedBody) {
                    focusBody(parkedBody);
                }
            }
        };
        
        // ★★★ 게임 시작 시 운항중 우주선 체크 ★★★
        function checkActiveShipOnStart() {
            const savedShipData = ShipPositionManager.load();
            if (savedShipData && savedShipData.position) {
                const distFromISS = Math.sqrt(
                    savedShipData.position.x ** 2 + 
                    savedShipData.position.y ** 2 + 
                    savedShipData.position.z ** 2
                );
                
                // ISS 근처가 아니면 (거리 100 이상) 운항중으로 간주
                if (distFromISS > 100) {
                    const shipName = savedShipData.shipName || 'Ship';
                    showActiveShipPopup(savedShipData, shipName, distFromISS);
                }
            }
        }
        
        // 게임 로드 완료 후 체크 (3초 후)
        setTimeout(() => {
            if (!isPilotMode) {
                checkActiveShipOnStart();
            }
        }, 3000);
        
        // ★★★ 운항중 우주선 팝업 표시 및 처리 ★★★
        let savedActiveShipData = null;
        
        function showActiveShipPopup(shipData, shipName, distance) {
            savedActiveShipData = shipData;
            
            const popup = document.getElementById('active-ship-popup');
            
            // ★ 우주선 타입 찾아서 이미지 표시
            const savedShipTypeId = shipData.shipType || 'shuttle';
            const shipType = SHIP_TYPES.find(s => s.id === savedShipTypeId) || SHIP_TYPES[0];
            const iconBox = document.getElementById('active-ship-icon');
            
            if (shipType.image && shipType.image.length > 0) {
                iconBox.innerHTML = `<img src="${shipType.image}" style="width:100%; height:100%; object-fit:contain;">`;
            } else {
                iconBox.innerHTML = `<span style="font-size:40px;">🚀</span>`;
            }
            
            // ★ 다국어 텍스트 설정
            const isKorean = (window.currentLang || 'ko') === 'ko';
            
            document.getElementById('active-ship-title').textContent = isKorean ? '운항중인 우주선 발견!' : 'Active Ship Found!';
            document.getElementById('active-ship-name').textContent = isKorean ? shipType.name : shipType.nameEn;
            document.getElementById('active-ship-fuel-label').textContent = isKorean ? '⛽ 연료:' : '⛽ Fuel:';
            document.getElementById('active-ship-fuel').textContent = Math.round(shipData.fuel || 0) + '%';
            document.getElementById('active-ship-dist-label').textContent = isKorean ? '📍 ISS로부터:' : '📍 From ISS:';
            document.getElementById('active-ship-dist').textContent = Math.round(distance).toLocaleString() + 'km';
            document.getElementById('active-ship-go-btn').innerHTML = isKorean ? '📍 우주선으로 이동' : '📍 Go to Ship';
            document.getElementById('active-ship-new-btn').innerHTML = isKorean ? '🗑️ 새로 탑승' : '🗑️ New Ship';
            
            popup.style.display = 'flex';
            
            // 이벤트 바인딩
            document.getElementById('active-ship-go-btn').onclick = () => goToActiveShip();
            document.getElementById('active-ship-new-btn').onclick = () => discardAndNewShip();
            document.getElementById('active-ship-close-btn').onclick = () => popup.style.display = 'none';
        }
        
        function goToActiveShip() {
            if (!savedActiveShipData) return;
            
            const popup = document.getElementById('active-ship-popup');
            popup.style.display = 'none';
            
            // ★★★ 로컬 변수로 복사 (비동기 콜백에서 사용) ★★★
            const shipData = { ...savedActiveShipData };
            const savedFuel = shipData.fuel || 100;
            const isKorean = (window.currentLang || 'ko') === 'ko';
            
            const pos = new THREE.Vector3(
                shipData.position.x,
                shipData.position.y,
                shipData.position.z
            );
            const rot = shipData.rotation || { x: 0, y: 0, z: 0 };
            
            // ★ 저장된 우주선 타입 찾기
            const savedShipTypeId = shipData.shipType || 'shuttle';
            const shipIdx = SHIP_TYPES.findIndex(s => s.id === savedShipTypeId);
            let shipType = SHIP_TYPES[0];  // 기본값
            
            if (shipIdx >= 0) {
                selectedShipIndex = shipIdx;
                currentShipType = SHIP_TYPES[shipIdx];
                window.currentShipType = currentShipType;
                shipType = currentShipType;
            }
            
            // ★ 다국어 우주선 이름
            const shipName = isKorean ? shipType.name : shipType.nameEn;
            const moveMsg = isKorean 
                ? `📍 ${shipName} 위치로 이동! 우주선을 클릭해서 탑승하세요.`
                : `📍 Moved to ${shipName}! Click the ship to board.`;
            
            // 먼저 savedActiveShipData 클리어
            savedActiveShipData = null;
            
            // ★★★ 저장된 위치에 주차된 우주선으로 생성 ★★★
            const parkedShipGroup = new THREE.Group();
            parkedShipGroup.position.copy(pos);
            parkedShipGroup.rotation.set(rot.x, rot.y, rot.z);
            
            // GLB 모델 로드
            if (shipType.model && shipType.model.length > 0) {
                const gltfLoader = new GLTFLoader();
                
                // DRACO 압축 모델용 (선택적)
                try {
                    const dracoLoader = new DRACOLoader();
                    dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
                    gltfLoader.setDRACOLoader(dracoLoader);
                } catch(e) {
                    console.log('DRACO 로더 없이 진행');
                }
                
                // ★ URL을 Supabase Storage로 변환
                const modelUrl = convertToSupabaseUrl(shipType.model);
                console.log('🚀 GLB 로드 시도:', modelUrl);
                
                gltfLoader.load(modelUrl, (gltf) => {
                    console.log('✅ GLB 로드 성공:', modelUrl);
                    const model = gltf.scene;
                    model.scale.setScalar(0.5);
                    model.rotation.y = Math.PI;
                    parkedShipGroup.add(model);
                    scene.add(parkedShipGroup);
                    
                    // 주차된 우주선 데이터 저장
                    parkedShip = {
                        type: shipType.id,
                        position: pos.clone(),
                        quaternion: parkedShipGroup.quaternion.clone(),
                        rotation: parkedShipGroup.rotation.clone(),
                        fuel: savedFuel,
                        speed: 0,
                        hull: shipType.maxHull || 100
                    };
                    parkedShipMesh = parkedShipGroup;
                    parkedShipMesh.userData.isParkedShip = true;
                    parkedShipMesh.userData.shipTypeIndex = shipIdx >= 0 ? shipIdx : 0;
                    parkedShipMesh.userData.fuel = savedFuel;
                    parkedShipMesh.userData.speed = 0;
                    
                    // 클릭 가능하게 bodies 배열에 추가
                    const parkedLabel = isKorean ? '(주차됨)' : '(Parked)';
                    const parkedBody = {
                        name: `${shipName} ${parkedLabel}`,
                        mesh: parkedShipGroup,
                        type: 'ship',
                        isParkedShip: true,
                        radius: 0.1
                    };
                    bodies.push(parkedBody);
                    
                    // 카메라 이동
                    const offset = new THREE.Vector3(3, 2, 3);
                    camera.position.copy(pos).add(offset);
                    controls.target.copy(pos);
                    controls.update();
                    
                    showMsg(moveMsg);
                    
                    // 마커 표시 (shipType 전달)
                    showShipLocationMarker(pos, shipName, shipType);
                    
                }, undefined, (err) => {
                    console.error('❌ GLB 로드 실패:', shipType.model, err);
                    // 모델 없이 기본 형태로
                    createFallbackShip(parkedShipGroup, pos, shipName, shipType, shipIdx, savedFuel);
                });
            } else {
                console.log('⚠️ 모델 경로 없음, 기본 박스 사용');
                // 모델 없으면 기본 박스
                createFallbackShip(parkedShipGroup, pos, shipName, shipType, shipIdx, savedFuel);
            }
        }
        
        // ★ 기본 우주선 형태 생성 (모델 없을 때)
        function createFallbackShip(parkedShipGroup, pos, shipName, shipType, shipIdx, savedFuel) {
            const isKorean = (window.currentLang || 'ko') === 'ko';
            const boxGeom = new THREE.BoxGeometry(0.5, 0.2, 0.8);
            const boxMat = new THREE.MeshStandardMaterial({ color: shipType.color || 0x888888 });
            const box = new THREE.Mesh(boxGeom, boxMat);
            parkedShipGroup.add(box);
            scene.add(parkedShipGroup);
            
            // 주차된 우주선 데이터 저장
            parkedShip = {
                type: shipType.id,
                position: pos.clone(),
                quaternion: parkedShipGroup.quaternion.clone(),
                rotation: parkedShipGroup.rotation.clone(),
                fuel: savedFuel,
                speed: 0,
                hull: shipType.maxHull || 100
            };
            parkedShipMesh = parkedShipGroup;
            parkedShipMesh.userData.isParkedShip = true;
            parkedShipMesh.userData.shipTypeIndex = shipIdx >= 0 ? shipIdx : 0;
            parkedShipMesh.userData.fuel = savedFuel;
            parkedShipMesh.userData.speed = 0;
            
            // 클릭 가능하게 bodies 배열에 추가
            const parkedLabel = isKorean ? '(주차됨)' : '(Parked)';
            const parkedBody = {
                name: `${shipName} ${parkedLabel}`,
                mesh: parkedShipGroup,
                type: 'ship',
                isParkedShip: true,
                radius: 0.1
            };
            bodies.push(parkedBody);
            
            const offset = new THREE.Vector3(3, 2, 3);
            camera.position.copy(pos).add(offset);
            controls.target.copy(pos);
            controls.update();
            
            const moveMsg = isKorean 
                ? `📍 ${shipName} 위치로 이동! 우주선을 클릭해서 탑승하세요.`
                : `📍 Moved to ${shipName}! Click the ship to board.`;
            showMsg(moveMsg);
            showShipLocationMarker(pos, shipName, shipType);
        }
        
        function discardAndNewShip() {
            const popup = document.getElementById('active-ship-popup');
            popup.style.display = 'none';
            
            ShipPositionManager.clear();
            showMsg('🗑️ 기존 우주선이 폐기되었습니다.');
            savedActiveShipData = null;
            
            // 새 우주선 선택 모달 열기
            setTimeout(() => openShipSelectModal(), 100);
        }

        function updateNavList() {
            const list = document.getElementById('nav-list'); 
            if(!list) return;
            list.innerHTML = '';
            bodies.forEach(body => {
                if (!body || !body.mesh) return;
                const item = document.createElement('div'); item.className = 'nav-item';
                if(focusedBody === body) item.classList.add('active');
                const typeIcon = body.type==='star' ? '🌟' : (body.type === 'blackhole' ? '🕳️' : '🪐');
                const displayName = translateBodyName(body.name);
                item.innerHTML = `<span>${displayName}</span><span class="type-icon">${typeIcon}</span>`;
                item.onclick = (e) => { e.stopPropagation(); focusBody(body); updateNavList(); };
                list.appendChild(item);
                
                const bodySatellites = satellites.filter(s => s && s.parentBody === body);
                bodySatellites.forEach(sat => {
                     if (!sat || !sat.mesh) return;
                     const satItem = document.createElement('div'); satItem.className = 'nav-item satellite';
                     if(focusedBody === sat) satItem.classList.add('active');
                     const sIcon = sat.type === 'station' ? '🛰️' : '🌑';
                     
                     // 멀티모드: 방문 여부 표시
                     const visited = typeof visitedSatellites !== 'undefined' && visitedSatellites.has(sat.name);
                     const visitedMark = (typeof gameMode !== 'undefined' && gameMode === 'multi' && visited) ? ' ✓' : '';
                     
                     const satDisplayName = translateBodyName(sat.name);
                     satItem.innerHTML = `<span>${satDisplayName}${visitedMark}</span><span class="type-icon">${sIcon}</span>`;
                     satItem.onclick = (e) => { 
                         e.stopPropagation(); 
                         // 멀티모드: 방문한 곳만 이동 가능
                         if (typeof gameMode !== 'undefined' && gameMode === 'multi') {
                             if (typeof visitedSatellites !== 'undefined' && !visitedSatellites.has(sat.name)) {
                                 showMessage(t('notVisitedYet') || '⚠️ Not visited yet. Fly there directly!');
                                 return;
                             }
                         }
                         focusBody(sat); 
                         updateNavList(); 
                     };
                     list.appendChild(satItem);
                });
            });
        }

        function focusBody(body) {
            if (!body || !body.mesh) return;
            focusedBody = body;
            
            // 행성 선택 효과음
            if (typeof SpaceAudio !== 'undefined') SpaceAudio.playSelect();
            
            // ISS 선택 시 정거장 사운드, 아니면 우주 사운드
            if (typeof SpaceAudio !== 'undefined' && SpaceAudio.isPlaying && !isPilotMode) {
                if (body.type === 'station' && body.name.includes('ISS')) {
                    SpaceAudio.playStation();
                } else {
                    SpaceAudio.playSpace();
                }
            }
            
            const resetBtn = document.getElementById('reset-cam');
            if(resetBtn) resetBtn.style.display = 'block';
            const boardBtn = document.getElementById('board-ship-btn');
            
            // 탑승 버튼 표시 로직
            if (!isPilotMode && boardBtn) {
                if (body.type === 'station' && body.name.includes('ISS')) {
                    // ISS 우주정거장 선택 시 탑승 버튼 표시
                    boardBtn.style.display = 'block';
                    boardBtn.textContent = `🚀 ${t('boardShip')}`;
                } else if (body.isParkedShip) {
                    // 주차된 우주선 선택 시 재탑승 버튼 표시
                    boardBtn.style.display = 'block';
                    boardBtn.textContent = `🚀 ${t('reboard')}`;
                } else {
                    boardBtn.style.display = 'none';
                }
            }
            
            showMsg(`${translateBodyName(body.name)} ${t('trackingMode')}`);
            
            // ★★★ 싱글모드에서 천체 정보 팝업 표시 ★★★
            if (window.gameMode !== 'multi' && !isPilotMode) {
                showBodyInfoPopup(body);
            }
            
            // ★★★ 시각적 스케일 반영한 카메라 거리 ★★★
            const visualScale = body.visualScale || 1.0;
            
            // ★ 대상에 따라 minDistance 동적 설정 (표면 바로 위까지 줌인 가능)
            if (body.type === 'station' || body.isParkedShip || body.type === 'ship') {
                controls.minDistance = 0.05;  // ★ 우주선/정거장 아주 가까이 줌인 가능
            } else if (body.type === 'moon') {
                controls.minDistance = body.radius * visualScale * 1.05;  // 달 표면 바로 위
            } else {
                controls.minDistance = body.radius * visualScale * 1.02;  // 행성/항성 표면 바로 위
            }
            
            if (body.type === 'station' || body.type === 'moon' || body.isParkedShip) {
               const offset = body.type==='station' ? 0.75 : (body.isParkedShip ? 3 : body.orbitRadius * 0.8);
               const offsetVec = new THREE.Vector3(offset, offset*0.5, offset);
               camera.position.copy(body.mesh.position).add(offsetVec);
               controls.target.copy(body.mesh.position);
            } else {
               // 행성/항성은 시각적 스케일 반영
               const baseOffset = body.radius * visualScale * 3;
               const offsetVec = new THREE.Vector3(baseOffset, baseOffset * 0.5, baseOffset);
               camera.position.copy(body.mesh.position).add(offsetVec);
               controls.target.copy(body.mesh.position);
            }
        }

        // ★★★ 천체 정보 팝업 시스템 ★★★
        let currentPopupBody = null;
        let popupUpdateInterval = null;
        
        // 천체 정보 팝업 표시
        function showBodyInfoPopup(body) {
            const popup = document.getElementById('body-info-popup');
            if (!popup || !body) return;
            
            currentPopupBody = body;
            
            // 천체 아이콘 결정
            const icon = getBodyIcon(body);
            const typeText = getBodyTypeText(body);
            
            // 팝업 내용 업데이트
            popup.querySelector('.popup-icon').textContent = icon;
            popup.querySelector('.popup-name').textContent = body.name;
            popup.querySelector('.popup-type').textContent = typeText;
            
            // 반지름 포맷팅
            const radiusKm = (body.radius * 6371).toLocaleString(); // 지구 반지름 기준
            document.getElementById('popup-radius').textContent = radiusKm + ' km';
            
            // 질량 포맷팅
            const massText = formatMass(body.mass);
            document.getElementById('popup-mass').textContent = massText;
            
            // 거리는 실시간 업데이트
            updatePopupDistance();
            
            // 화면 중앙 우측에 표시
            popup.style.display = 'block';
            popup.style.top = '50%';
            popup.style.right = '20px';
            popup.style.left = 'auto';
            popup.style.transform = 'translateY(-50%)';
            
            // 실시간 거리 업데이트 시작
            if (popupUpdateInterval) clearInterval(popupUpdateInterval);
            popupUpdateInterval = setInterval(updatePopupDistance, 500);
            
            // 5초 후 자동 숨김 (조작이 없으면)
            clearTimeout(popup.autoHideTimeout);
            popup.autoHideTimeout = setTimeout(() => {
                if (popup.style.display === 'block' && !popup.matches(':hover')) {
                    hideBodyInfoPopup();
                }
            }, 8000);
        }
        
        // 팝업 거리 업데이트
        function updatePopupDistance() {
            if (!currentPopupBody || !currentPopupBody.mesh) return;
            
            const sun = bodies.find(b => b.name === '태양' || b.name === 'Sun');
            let distKm = 0;
            
            if (sun && sun.mesh) {
                const dist = currentPopupBody.mesh.position.distanceTo(sun.mesh.position);
                distKm = dist * 149597.87; // AU to km 변환 (단순화)
            }
            
            const distEl = document.getElementById('popup-distance');
            if (distEl) {
                if (distKm >= 1e9) {
                    distEl.textContent = (distKm / 1e9).toFixed(2) + ' B km';
                } else if (distKm >= 1e6) {
                    distEl.textContent = (distKm / 1e6).toFixed(2) + ' M km';
                } else if (distKm >= 1000) {
                    distEl.textContent = (distKm / 1000).toFixed(1) + 'K km';
                } else {
                    distEl.textContent = Math.round(distKm) + ' km';
                }
            }
        }
        
        // 천체 정보 팝업 숨기기
        function hideBodyInfoPopup() {
            const popup = document.getElementById('body-info-popup');
            if (popup) {
                popup.style.display = 'none';
            }
            if (popupUpdateInterval) {
                clearInterval(popupUpdateInterval);
                popupUpdateInterval = null;
            }
            currentPopupBody = null;
        }
        
        // 천체 아이콘 결정
        function getBodyIcon(body) {
            if (!body) return '🌍';
            
            const name = body.name.toLowerCase();
            const type = body.type;
            
            if (type === 'star') return '☀️';
            if (type === 'blackhole') return '🕳️';
            if (type === 'station') return '🛰️';
            if (body.isParkedShip) return '🚀';
            
            // 행성별 아이콘
            if (name.includes('수성') || name.includes('mercury')) return '☿️';
            if (name.includes('금성') || name.includes('venus')) return '♀️';
            if (name.includes('지구') || name.includes('earth')) return '🌍';
            if (name.includes('화성') || name.includes('mars')) return '🔴';
            if (name.includes('목성') || name.includes('jupiter')) return '🪐';
            if (name.includes('토성') || name.includes('saturn')) return '💫';
            if (name.includes('천왕성') || name.includes('uranus')) return '🔵';
            if (name.includes('해왕성') || name.includes('neptune')) return '🔷';
            if (name.includes('달') || name.includes('moon')) return '🌙';
            if (type === 'moon') return '🌑';
            if (type === 'gas') return '🪐';
            
            return '🌍';
        }
        
        // 천체 타입 텍스트
        function getBodyTypeText(body) {
            if (!body) return '';
            
            const lang = (typeof currentLang !== 'undefined') ? currentLang : 'en';
            const type = body.type;
            
            const types = {
                ko: { star: '항성', planet: '행성', moon: '위성', gas: '가스 행성', blackhole: '블랙홀', station: '우주정거장' },
                en: { star: 'Star', planet: 'Planet', moon: 'Moon', gas: 'Gas Giant', blackhole: 'Black Hole', station: 'Station' },
                ja: { star: '恒星', planet: '惑星', moon: '衛星', gas: 'ガス惑星', blackhole: 'ブラックホール', station: '宇宙ステーション' }
            };
            
            const langTypes = types[lang] || types.en;
            
            if (body.isParkedShip) return lang === 'ko' ? '우주선' : lang === 'ja' ? '宇宙船' : 'Spacecraft';
            
            return langTypes[type] || langTypes.planet;
        }
        
        // 질량 포맷팅
        function formatMass(mass) {
            if (!mass) return '-';
            
            // 게임 내 질량을 실제 kg으로 변환 (대략적)
            const realMass = mass * 5.97e24; // 지구 질량 기준
            
            if (realMass >= 1e30) {
                return (realMass / 1.989e30).toFixed(2) + ' M☉';
            } else if (realMass >= 1e27) {
                return (realMass / 1e27).toFixed(2) + '×10²⁷ kg';
            } else if (realMass >= 1e24) {
                return (realMass / 1e24).toFixed(2) + '×10²⁴ kg';
            } else if (realMass >= 1e21) {
                return (realMass / 1e21).toFixed(2) + '×10²¹ kg';
            } else {
                return realMass.toExponential(2) + ' kg';
            }
        }
        
        // ★★★ 천체 상세보기 모달 ★★★
        function showBodyDetailModal(body) {
            if (!body) body = currentPopupBody;
            if (!body) return;
            
            const modal = document.getElementById('body-detail-modal');
            if (!modal) return;
            
            // 아이콘 및 기본 정보
            modal.querySelector('.detail-icon').textContent = getBodyIcon(body);
            modal.querySelector('.detail-name').textContent = body.name;
            modal.querySelector('.detail-type').textContent = getBodyTypeText(body);
            
            // 기본 정보
            const radiusKm = (body.radius * 6371).toLocaleString();
            document.getElementById('detail-radius').textContent = radiusKm + ' km';
            document.getElementById('detail-mass').textContent = formatMass(body.mass);
            
            // 자전 속도
            const rotSpeed = body.rotSpeed || 0;
            let rotText = '-';
            if (rotSpeed !== 0) {
                const dayLength = Math.abs(24 / rotSpeed);
                if (dayLength < 1) {
                    rotText = (dayLength * 60).toFixed(1) + ' min';
                } else if (dayLength > 1000) {
                    rotText = (dayLength / 24).toFixed(0) + ' days';
                } else {
                    rotText = dayLength.toFixed(1) + ' hours';
                }
                if (rotSpeed < 0) rotText += ' (역행)';
            }
            document.getElementById('detail-rotation').textContent = rotText;
            
            // 표면 중력 (대략 계산)
            const surfaceGravity = (body.mass / (body.radius * body.radius)) * 9.8;
            document.getElementById('detail-gravity').textContent = surfaceGravity.toFixed(2) + ' m/s²';
            
            // 궤도 정보
            const sun = bodies.find(b => b.name === '태양' || b.name === 'Sun');
            if (sun && sun.mesh && body.mesh) {
                const dist = body.mesh.position.distanceTo(sun.mesh.position);
                const distKm = dist * 149597.87;
                
                if (distKm >= 1e9) {
                    document.getElementById('detail-distance').textContent = (distKm / 1e9).toFixed(2) + ' B km';
                } else if (distKm >= 1e6) {
                    document.getElementById('detail-distance').textContent = (distKm / 1e6).toFixed(2) + ' M km';
                } else {
                    document.getElementById('detail-distance').textContent = Math.round(distKm).toLocaleString() + ' km';
                }
            } else {
                document.getElementById('detail-distance').textContent = '-';
            }
            
            // 공전 속도
            const orbitalSpeed = body.velocity ? body.velocity.length() * 29.78 : 0; // km/s 변환
            document.getElementById('detail-orbital-speed').textContent = orbitalSpeed.toFixed(2) + ' km/s';
            
            // 위성 수 계산
            const moonCount = bodies.filter(b => 
                b.type === 'moon' && b.parentBody && b.parentBody.name === body.name
            ).length;
            document.getElementById('detail-moons').textContent = moonCount > 0 ? moonCount : '-';
            
            // 고리 유무
            const hasRing = body.ring || (body.name && (body.name.includes('토성') || body.name.includes('Saturn')));
            const lang = (typeof currentLang !== 'undefined') ? currentLang : 'en';
            document.getElementById('detail-rings').textContent = hasRing ? 
                (lang === 'ko' ? '있음' : lang === 'ja' ? 'あり' : 'Yes') : 
                (lang === 'ko' ? '없음' : lang === 'ja' ? 'なし' : 'No');
            
            // 설명
            const description = getBodyDescription(body);
            document.getElementById('detail-description').textContent = description;
            
            // 모달 표시
            modal.classList.add('open');
            
            // 팝업 숨기기
            hideBodyInfoPopup();
        }
        
        // 천체 설명 생성
        function getBodyDescription(body) {
            if (!body) return '';
            
            const lang = (typeof currentLang !== 'undefined') ? currentLang : 'en';
            const name = body.name.toLowerCase();
            
            const descriptions = {
                ko: {
                    sun: '태양은 태양계의 중심에 위치한 항성으로, 지구에 빛과 열을 제공하는 생명의 원천입니다.',
                    mercury: '수성은 태양계에서 가장 작고 태양에 가장 가까운 행성입니다. 극심한 온도 변화가 특징입니다.',
                    venus: '금성은 지구와 비슷한 크기를 가진 행성으로, 두꺼운 대기로 인해 태양계에서 가장 뜨거운 행성입니다.',
                    earth: '지구는 태양계에서 세 번째 행성이며, 알려진 유일한 생명체가 존재하는 천체입니다.',
                    mars: '화성은 붉은 행성으로 불리며, 과거에 물이 존재했던 흔적이 발견되어 탐사의 주요 대상입니다.',
                    jupiter: '목성은 태양계에서 가장 큰 행성으로, 대적점이라는 거대한 폭풍이 수백 년간 지속되고 있습니다.',
                    saturn: '토성은 아름다운 고리 시스템으로 유명한 가스 행성입니다. 80개 이상의 위성을 보유하고 있습니다.',
                    uranus: '천왕성은 축이 거의 90도 기울어진 독특한 행성으로, 푸른 색을 띠는 얼음 거인입니다.',
                    neptune: '해왕성은 태양계의 가장 바깥쪽 행성으로, 강력한 바람과 푸른 색이 특징입니다.',
                    moon: '달은 지구의 유일한 자연 위성으로, 인류가 직접 발을 딛은 유일한 외계 천체입니다.',
                    default: '태양계의 천체입니다. 자세한 정보를 탐사를 통해 알아보세요.'
                },
                en: {
                    sun: 'The Sun is the star at the center of the Solar System, providing light and heat essential for life on Earth.',
                    mercury: 'Mercury is the smallest planet and closest to the Sun, characterized by extreme temperature variations.',
                    venus: 'Venus is similar in size to Earth but has a thick atmosphere making it the hottest planet in the Solar System.',
                    earth: 'Earth is the third planet from the Sun and the only known celestial body to harbor life.',
                    mars: 'Mars is called the Red Planet and shows evidence of past water, making it a prime target for exploration.',
                    jupiter: 'Jupiter is the largest planet, featuring the Great Red Spot, a storm that has persisted for centuries.',
                    saturn: 'Saturn is famous for its beautiful ring system and has over 80 known moons.',
                    uranus: 'Uranus is an ice giant with a unique axial tilt of nearly 90 degrees.',
                    neptune: 'Neptune is the outermost planet, known for its strong winds and deep blue color.',
                    moon: 'The Moon is Earth\'s only natural satellite and the only extraterrestrial body humans have walked on.',
                    default: 'A celestial body in the Solar System. Explore to learn more.'
                },
                ja: {
                    sun: '太陽は太陽系の中心にある恒星で、地球に生命に不可欠な光と熱を提供しています。',
                    mercury: '水星は太陽系で最も小さく、太陽に最も近い惑星です。極端な温度変化が特徴です。',
                    venus: '金星は地球と似たサイズですが、厚い大気により太陽系で最も暑い惑星です。',
                    earth: '地球は太陽から3番目の惑星で、生命が存在することが知られている唯一の天体です。',
                    mars: '火星は赤い惑星と呼ばれ、過去に水が存在した証拠があり、探査の主要対象です。',
                    jupiter: '木星は太陽系最大の惑星で、大赤斑という巨大な嵐が数百年も続いています。',
                    saturn: '土星は美しいリングシステムで有名なガス惑星で、80以上の衛星を持っています。',
                    uranus: '天王星は軸がほぼ90度傾いた独特の惑星で、青い氷の巨人です。',
                    neptune: '海王星は太陽系の最も外側の惑星で、強い風と深い青色が特徴です。',
                    moon: '月は地球唯一の自然衛星で、人類が直接足を踏み入れた唯一の地球外天体です。',
                    default: '太陽系の天体です。探査して詳しく調べましょう。'
                }
            };
            
            const langDesc = descriptions[lang] || descriptions.en;
            
            // 천체 이름으로 설명 찾기
            for (const key of Object.keys(langDesc)) {
                if (name.includes(key) || name.includes(key.toLowerCase())) {
                    return langDesc[key];
                }
            }
            
            return langDesc.default;
        }
        
        // 상세보기 모달 닫기
        function hideBodyDetailModal() {
            const modal = document.getElementById('body-detail-modal');
            if (modal) {
                modal.classList.remove('open');
            }
        }
        
        // 이벤트 리스너 초기화 (DOM 로드 후)
        function initBodyInfoSystem() {
            // 팝업 상세보기 버튼
            const detailBtn = document.getElementById('popup-detail-btn');
            if (detailBtn) {
                detailBtn.addEventListener('click', () => {
                    showBodyDetailModal(currentPopupBody);
                });
            }
            
            // 상세보기 모달 닫기 버튼
            const closeBtn = document.getElementById('body-detail-close');
            if (closeBtn) {
                closeBtn.addEventListener('click', hideBodyDetailModal);
            }
            
            // 모달 배경 클릭 시 닫기
            const modal = document.getElementById('body-detail-modal');
            if (modal) {
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        hideBodyDetailModal();
                    }
                });
            }
            
            // 추적하기 버튼
            const focusBtn = document.getElementById('detail-focus-btn');
            if (focusBtn) {
                focusBtn.addEventListener('click', () => {
                    hideBodyDetailModal();
                });
            }
            
            // 항법 목표 설정 버튼
            const navBtn = document.getElementById('detail-nav-btn');
            if (navBtn) {
                navBtn.addEventListener('click', () => {
                    if (currentPopupBody && typeof setNavTarget === 'function') {
                        setNavTarget(currentPopupBody);
                    }
                    hideBodyDetailModal();
                });
            }
            
            // 팝업 마우스 오버 시 자동 숨김 타이머 취소
            const popup = document.getElementById('body-info-popup');
            if (popup) {
                popup.addEventListener('mouseenter', () => {
                    clearTimeout(popup.autoHideTimeout);
                });
                popup.addEventListener('mouseleave', () => {
                    popup.autoHideTimeout = setTimeout(() => {
                        hideBodyInfoPopup();
                    }, 3000);
                });
            }
        }

        function resetCamera() { 
            focusedBody=null; 
            const resetBtn = document.getElementById('reset-cam');
            if(resetBtn) resetBtn.style.display='none'; 
            // 탑승 버튼도 숨김
            const boardBtn = document.getElementById('board-ship-btn');
            if(boardBtn && !isPilotMode) boardBtn.style.display='none';
            // 포커스 거리 패널도 숨김
            const distPanel = document.getElementById('focus-distance-panel');
            if(distPanel) distPanel.classList.remove('visible');
            // ★ 천체 정보 팝업도 숨김
            hideBodyInfoPopup();
            controls.target.set(0,0,0);
            controls.minDistance = 0.05;  // ★ 기본 minDistance 줄임 (줌인 가능)
            updateNavList(); 
        }
        
        // 포커스된 천체와의 거리 업데이트
        function updateFocusDistance() {
            const panel = document.getElementById('focus-distance-panel');
            if (!panel) return;
            
            // pilot 모드에서는 표시하지 않음
            if (isPilotMode) {
                panel.classList.remove('visible');
                return;
            }
            
            if (focusedBody && focusedBody.mesh) {
                // 카메라와 포커스 천체 사이 거리 계산
                const dist = camera.position.distanceTo(focusedBody.mesh.position);
                
                let distKm;
                
                // ★ 우주선/정거장은 현실적인 스케일 적용 (1 unit ≈ 100m)
                if (focusedBody.type === 'station' || focusedBody.type === 'ship' || 
                    focusedBody.mesh?.userData?.isParkedShip || focusedBody.name?.includes('셔틀') ||
                    focusedBody.name?.includes('정거장') || focusedBody.name?.includes('ISS') ||
                    focusedBody.name?.includes('플랫폼')) {
                    distKm = dist * 0.1;  // 1 unit = 100m = 0.1 km
                } else {
                    // 천체는 기존 AU 기반 스케일
                    const AU_KM = 149597870.7;
                    distKm = (dist / CONFIG.distScale) * AU_KM;
                }
                
                // 거리 포맷팅
                let distStr;
                if (distKm >= 1e9) {
                    distStr = (distKm / 1e9).toFixed(3) + ' B km';
                } else if (distKm >= 1e6) {
                    distStr = (distKm / 1e6).toFixed(3) + ' M km';
                } else if (distKm >= 1000) {
                    distStr = (distKm / 1000).toFixed(2) + ' 천 km';
                } else if (distKm >= 1) {
                    distStr = distKm.toFixed(2) + ' km';
                } else {
                    distStr = (distKm * 1000).toFixed(0) + ' m';
                }
                
                document.getElementById('focus-target-name').textContent = '📍 ' + translateBodyName(focusedBody.name);
                document.getElementById('focus-distance-value').textContent = distStr;
                panel.classList.add('visible');
            } else {
                panel.classList.remove('visible');
            }
        }

        function destroy(body, idx) { 
            if (!body) return;
            if (body.mesh) {
                scene.remove(body.mesh); 
                body.mesh.traverse(c => {
                    if(c.isCSS2DObject && c.element && c.element.parentNode) c.element.parentNode.removeChild(c.element);
                });
            }
            if(body.trail) scene.remove(body.trail); 
            bodies.splice(idx, 1); 
            if(focusedBody===body) resetCamera(); 
            updateNavList(); 
        }

        function showFloatingLabel(body, text, type) {
            if (!body || !body.mesh) return;
            const div = document.createElement('div');
            div.className = `notify-label ${type}`;
            div.textContent = text;
            const label = new CSS2DObject(div);
            label.position.set(0, body.radius * 1.02, 0);  // 천체 바로 위 
            body.mesh.add(label);
            setTimeout(() => {
                div.classList.add('fade-out');
                setTimeout(() => { if(body.mesh) body.mesh.remove(label); }, 1000);
            }, 3000);
        }

        function evolveToStar(body) {
            if (!body || !body.mesh) return;
            scene.remove(body.mesh);
            if (body.mesh.children) {
                body.mesh.children.forEach(c => {
                    if (c.isCSS2DObject && c.element && c.element.parentNode) c.element.parentNode.removeChild(c.element);
                });
            }
            const typeData = { r: body.radius, color: 0xffaa00 };
            const geo = new THREE.SphereGeometry(typeData.r, 64, 64);
            const mat = new THREE.ShaderMaterial({ 
                uniforms: { time: { value: 0 } }, 
                vertexShader: document.getElementById('vertexShader').textContent, 
                fragmentShader: document.getElementById('fragmentShader').textContent, 
                transparent: false, depthWrite: true, depthTest: true, blending: THREE.NoBlending, side: THREE.FrontSide 
            });
            const newMesh = new THREE.Mesh(geo, mat);
            newMesh.position.copy(body.mesh.position);
            const light = new THREE.PointLight(typeData.color, 3.0, 0, 0); 
            newMesh.add(light);
            const coronaGeo = new THREE.PlaneGeometry(typeData.r * 6, typeData.r * 6);
            const coronaMat = new THREE.ShaderMaterial({ 
                uniforms: { time: { value: 0 } }, 
                vertexShader: document.getElementById('coronaVertexShader').textContent, 
                fragmentShader: document.getElementById('coronaFragmentShader').textContent, 
                transparent: true, blending: THREE.AdditiveBlending, depthWrite: false, side: THREE.DoubleSide 
            });
            const coronaMesh = new THREE.Mesh(coronaGeo, coronaMat); 
            newMesh.add(coronaMesh);
            const div = document.createElement('div');
            div.className = 'label';
            div.textContent = body.name + " (Star)";
            const label = new CSS2DObject(div);
            label.position.set(0, typeData.r * 1.02, 0);  // 천체 바로 위
            newMesh.add(label);
            scene.add(newMesh);
            body.mesh = newMesh;
            body.corona = coronaMesh;
            body.type = 'star';
            body.isEvolving = false;
            showFloatingLabel(body, "🌟 항성 탄생!", "notify-success");
            updateNavList();
        }

        function checkEvolution(body) {
            if (body.type === 'star' || body.type === 'blackhole' || body.isEvolving) return;
            if (body.mass >= STAR_THRESHOLD) {
                body.isEvolving = true;
                showFloatingLabel(body, "🔥 핵융합 임계점 도달!", "notify-warn");
                setTimeout(() => { evolveToStar(body); }, 3000);
            }
        }

        function handleCollision(b1, b2, i1, i2) {
            if (!b1 || !b2) return;
            let winner, loser, lIdx;
            
            // 블랙홀은 항상 승자 (다른 천체 흡수)
            if (b1.type === 'blackhole') {
                winner = b1; loser = b2; lIdx = i2;
            } else if (b2.type === 'blackhole') {
                winner = b2; loser = b1; lIdx = i1;
            } else if (b1.mass >= b2.mass) { 
                winner = b1; loser = b2; lIdx = i2; 
            } else { 
                winner = b2; loser = b1; lIdx = i1; 
            }
            
            const m1 = winner.mass, m2 = loser.mass;
            const v1 = winner.velocity.clone(), v2 = loser.velocity.clone();
            const newVel = v1.multiplyScalar(m1).add(v2.multiplyScalar(m2)).divideScalar(m1 + m2);
            winner.velocity.copy(newVel);
            winner.mass += loser.mass;
            
            // 블랙홀은 크기 증가 안함
            if (winner.type !== 'blackhole') {
                const newRadius = Math.pow(Math.pow(winner.radius, 3) + Math.pow(loser.radius, 3), 1/3);
                const scaleRatio = newRadius / winner.radius;
                if (winner.mesh) winner.mesh.scale.multiplyScalar(scaleRatio);
                winner.radius = newRadius;
            }
            
            destroy(loser, lIdx);
            showMsg(`${winner.name}가 ${loser.name}을(를) 흡수했습니다!`);
            checkEvolution(winner);
        }

        function updatePhysics(dt) {
            // Adaptive sub-steps for stability at high speeds
            let steps = CONFIG.subSteps;
            if (CONFIG.timeScale > 10) steps = 50; 
            if (CONFIG.timeScale > 50) steps = 100;
            
            const subDt = dt / steps;
            
            // 물리 적용 대상: bodies + 물리 활성화된 위성들
            const physicsMoons = satellites.filter(s => s && s.isPhysicsEnabled && s.mesh);
            const allPhysicsObjects = [...bodies, ...physicsMoons];
            
            for(let s=0; s<steps; s++) {
                allPhysicsObjects.forEach(b => { if(b && b.force) b.force.set(0,0,0); });
                
                for(let i=0; i<allPhysicsObjects.length; i++) {
                    for(let j=i+1; j<allPhysicsObjects.length; j++) {
                        const b1=allPhysicsObjects[i], b2=allPhysicsObjects[j];
                        if (!b1 || !b2 || !b1.mesh || !b2.mesh) continue;
                        if (b1.isStatic && b2.isStatic) continue;
                        const distVec=new THREE.Vector3().subVectors(b2.mesh.position,b1.mesh.position);
                        const distSq=distVec.lengthSq(); const dist=Math.sqrt(distSq);
                        
                        // 충돌 체크 (위성 포함)
                        const r1 = b1.radius || 0.3;
                        const r2 = b2.radius || 0.3;
                        if(dist < (r1 + r2) * 0.8) { 
                            handleCollisionAll(b1, b2); 
                            return; 
                        }
                        
                        const f=(CONFIG.G * (b1.mass || 0.01) * (b2.mass || 0.01))/(distSq+CONFIG.softening);
                        const fVec=distVec.normalize().multiplyScalar(f);
                        if (b1.force) b1.force.add(fVec); 
                        if (b2.force) b2.force.sub(fVec);
                    }
                }
                
                allPhysicsObjects.forEach(b => {
                    if (!b || !b.mesh || b.isStatic) return; 
                    if (b.velocity && b.force && b.mass) {
                        b.velocity.add(b.force.divideScalar(b.mass).multiplyScalar(subDt));
                        b.mesh.position.add(b.velocity.clone().multiplyScalar(subDt));
                    }
                });
            }
        }
        
        // 위성 포함 충돌 처리
        function handleCollisionAll(b1, b2) {
            if (!b1 || !b2) return;
            let winner, loser;
            
            // 블랙홀은 항상 승자
            if (b1.type === 'blackhole') {
                winner = b1; loser = b2;
            } else if (b2.type === 'blackhole') {
                winner = b2; loser = b1;
            } else if ((b1.mass || 0.01) >= (b2.mass || 0.01)) { 
                winner = b1; loser = b2; 
            } else { 
                winner = b2; loser = b1; 
            }
            
            const m1 = winner.mass || 0.01, m2 = loser.mass || 0.01;
            const v1 = winner.velocity ? winner.velocity.clone() : new THREE.Vector3();
            const v2 = loser.velocity ? loser.velocity.clone() : new THREE.Vector3();
            const newVel = v1.multiplyScalar(m1).add(v2.multiplyScalar(m2)).divideScalar(m1 + m2);
            if (winner.velocity) winner.velocity.copy(newVel);
            winner.mass = m1 + m2;
            
            // 블랙홀은 크기 증가 안함
            if (winner.type !== 'blackhole' && winner.radius && loser.radius) {
                const newRadius = Math.pow(Math.pow(winner.radius, 3) + Math.pow(loser.radius, 3), 1/3);
                const scaleRatio = newRadius / winner.radius;
                if (winner.mesh) winner.mesh.scale.multiplyScalar(scaleRatio);
                winner.radius = newRadius;
            }
            
            // 패배자 제거
            if (loser.type === 'moon') {
                // 위성인 경우 satellites에서 제거
                const idx = satellites.indexOf(loser);
                if (idx > -1) {
                    if (loser.mesh) scene.remove(loser.mesh);
                    satellites.splice(idx, 1);
                }
            } else {
                // 일반 천체
                const idx = bodies.indexOf(loser);
                if (idx > -1) destroy(loser, idx);
            }
            
            showMsg(`${winner.name}가 ${loser.name}을(를) 흡수했습니다!`);
            if (winner.mass) checkEvolution(winner);
        }

        function updateTrails() {
            bodies.forEach(b => {
                if (!b || !b.mesh || b.isStatic) return; 
                b.trailTimer++;
                if(b.trailTimer > 3 && b.trail && b.trailPoints) {
                    b.trailTimer=0; b.trailPoints.push(b.mesh.position.clone()); b.trailPoints.shift();
                    b.trail.geometry.setFromPoints(b.trailPoints); b.trail.geometry.attributes.position.needsUpdate=true;
                }
            });
        }

        // ★★★ 멀티모드 시각적 스케일 (물리 계산은 그대로) ★★★
        // ★★★ 전체 스케일 10배 (2024-01-07) ★★★
        const VISUAL_SCALE = {
            star: 30.0,      // 태양: 30배 (3*10)
            planet: 50.0,    // 행성: 50배 (5*10)
            gas: 50.0,       // 가스 행성: 50배 (5*10)
            moon: 50.0,      // 위성: 50배 (5*10)
            blackhole: 30.0  // 블랙홀: 30배 (3*10)
        };
        
        function getVisualScale(type) {
            // 멀티모드 체크 (window.gameMode === 'multi')
            const isMultiMode = (typeof window.gameMode !== 'undefined' && window.gameMode === 'multi');
            if (!isMultiMode) return 1.0;  // 싱글모드는 1배
            return VISUAL_SCALE[type] || 5.0;
        }

        // ★★★ 2단계 천체 생성 시스템 ★★★
        
        // 1단계: 대기 천체 생성 (위치만 결정, 물리 미적용)
        let velocityHandle = null;  // 화살표 끝 핸들
        let initialArrowDir = null; // 초기 화살표 방향
        
        function createPendingBody(typeData, position, name, texKey) {
            // 기존 대기 천체가 있으면 제거
            cancelPendingBody();
            
            // 대기 천체 메쉬 생성 (반투명)
            const bodyRadius = typeData.r || 1;
            const geo = new THREE.SphereGeometry(bodyRadius, 32, 32);
            const mat = new THREE.MeshBasicMaterial({
                color: parseInt(typeData.color) || 0xffffff,
                transparent: true,
                opacity: 0.6,
                wireframe: false
            });
            pendingBodyMesh = new THREE.Mesh(geo, mat);
            pendingBodyMesh.position.copy(position);
            scene.add(pendingBodyMesh);
            
            // 펄스 효과를 위한 링 추가
            const ringGeo = new THREE.RingGeometry(bodyRadius * 1.2, bodyRadius * 1.5, 32);
            const ringMat = new THREE.MeshBasicMaterial({
                color: 0x00ff88,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = Math.PI / 2;
            ring.name = 'pendingRing';
            pendingBodyMesh.add(ring);
            
            // 대기 천체 데이터 저장
            pendingBody = {
                typeData: typeData,
                position: position.clone(),
                name: name,
                texKey: texKey,
                radius: bodyRadius
            };
            
            // OrbitControls 비활성화 (천체 드래그 시 화면 회전 방지)
            if (controls) controls.enabled = false;
            
            // ★★★ 초기 화살표와 핸들 생성 ★★★
            createInitialArrowWithHandle(position, bodyRadius);
            
            // 안내 메시지
            const lang = (typeof currentLang !== 'undefined') ? currentLang : 'en';
            const msg = lang === 'ko' ? `👆 화살표 끝을 드래그하여 방향과 속도를 설정하세요` :
                       lang === 'ja' ? `👆 矢印の先端をドラッグして方向と速度を設定` :
                       `👆 Drag the arrow tip to set direction and speed`;
            showMsg(msg);
        }
        
        // ★★★ 초기 화살표와 드래그 핸들 생성 ★★★
        function createInitialArrowWithHandle(position, radius) {
            // 카메라 방향에서 오른쪽으로 화살표 생성
            const camDir = new THREE.Vector3();
            camera.getWorldDirection(camDir);
            
            // 화살표 방향: 카메라 오른쪽 방향 (xz 평면)
            initialArrowDir = new THREE.Vector3(-camDir.z, 0, camDir.x).normalize();
            
            // 화살표 길이 (천체 반지름의 3배)
            const arrowLength = Math.max(radius * 4, 30);
            const arrowEnd = position.clone().add(initialArrowDir.clone().multiplyScalar(arrowLength));
            
            // 화살표 선 생성
            const lineGeo = new THREE.BufferGeometry().setFromPoints([position, arrowEnd]);
            const lineMat = new THREE.LineBasicMaterial({ 
                color: 0x00ff88,
                linewidth: 3
            });
            velocityLine = new THREE.Line(lineGeo, lineMat);
            scene.add(velocityLine);
            
            // 드래그 핸들 (화살표 끝의 구체) - 크기 대폭 증가
            const handleSize = Math.max(radius * 2, 15);  // 최소 15 유닛
            const handleGeo = new THREE.SphereGeometry(handleSize, 16, 16);
            const handleMat = new THREE.MeshBasicMaterial({
                color: 0xffaa00,
                transparent: true,
                opacity: 0.8
            });
            velocityHandle = new THREE.Mesh(handleGeo, handleMat);
            velocityHandle.position.copy(arrowEnd);
            velocityHandle.name = 'velocityHandle';
            scene.add(velocityHandle);
            
            // 핸들 주위 링 (손으로 잡으라는 표시) - 크기 증가
            const handleRingGeo = new THREE.RingGeometry(
                handleSize * 1.3, 
                handleSize * 1.8, 
                32
            );
            const handleRingMat = new THREE.MeshBasicMaterial({
                color: 0xffaa00,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide
            });
            const handleRing = new THREE.Mesh(handleRingGeo, handleRingMat);
            handleRing.name = 'handleRing';
            velocityHandle.add(handleRing);
            
            // 화살표 머리 (cone)
            const coneGeo = new THREE.ConeGeometry(Math.max(radius * 0.5, 3), Math.max(radius * 1, 6), 8);
            const coneMat = new THREE.MeshBasicMaterial({ color: 0x00ff88 });
            const cone = new THREE.Mesh(coneGeo, coneMat);
            cone.name = 'arrowCone';
            
            // 화살표 방향으로 콘 회전
            const dir = initialArrowDir.clone();
            const quaternion = new THREE.Quaternion();
            quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir);
            cone.quaternion.copy(quaternion);
            cone.position.copy(arrowEnd).add(dir.multiplyScalar(Math.max(radius * 0.5, 3)));
            scene.add(cone);
            velocityArrow = cone;
        }
        
        // 줌인 함수 제거됨 - 화면 그대로 유지
        
        // 대기 천체 취소
        function cancelPendingBody() {
            if (pendingBodyMesh) {
                scene.remove(pendingBodyMesh);
                pendingBodyMesh = null;
            }
            if (velocityLine) {
                scene.remove(velocityLine);
                velocityLine = null;
            }
            if (velocityArrow) {
                scene.remove(velocityArrow);
                velocityArrow = null;
            }
            if (velocityHandle) {
                scene.remove(velocityHandle);
                velocityHandle = null;
            }
            pendingBody = null;
            isPendingDrag = false;
            pendingDragStart = null;
            initialArrowDir = null;
            
            // 속도 표시 숨기기
            hideSpeedDisplay();
            
            // OrbitControls 재활성화
            if (controls) controls.enabled = true;
        }
        
        // 2단계: 대기 천체 확정 (속도 적용하여 실제 생성)
        function confirmPendingBody(velocity) {
            if (!pendingBody) return;
            
            // 실제 천체 생성
            createBody(
                pendingBody.typeData,
                pendingBody.position,
                velocity,
                pendingBody.name + " (New)",
                pendingBody.texKey
            );
            
            // 속도 정보 표시
            const speed = velocity.length().toFixed(2);
            const lang = (typeof currentLang !== 'undefined') ? currentLang : 'en';
            const msg = lang === 'ko' ? `🌍 ${pendingBody.name} 생성 완료! 속도: ${speed}` :
                       lang === 'ja' ? `🌍 ${pendingBody.name} 生成完了！速度: ${speed}` :
                       `🌍 ${pendingBody.name} created! Speed: ${speed}`;
            showMsg(msg);
            
            // 정리
            cancelPendingBody();
        }
        
        // 속도 방향 표시 업데이트
        // updateVelocityIndicator 함수는 updateArrowAndHandle로 대체됨
        
        // 터치로 화살표 핸들 드래그 시작 체크
        // pendingBody가 있으면 화면 어디든 터치해서 드래그 가능
        function checkPendingBodyTouch(touchX, touchY) {
            if (!pendingBody) return false;
            
            // pendingBody가 있으면 무조건 드래그 허용 (화면 어디든)
            return true;
        }
        
        // 터치 위치를 3D 좌표로 변환
        function touchTo3D(touchX, touchY) {
            mouse.x = (touchX / window.innerWidth) * 2 - 1;
            mouse.y = -(touchY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const target = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, target);
            return target;
        }
        
        // ★★★ 화살표 및 핸들 위치 업데이트 ★★★
        function updateArrowAndHandle(endPos) {
            if (!pendingBody || !velocityLine) return;
            
            const startPos = pendingBody.position;
            
            // 선 업데이트
            const positions = velocityLine.geometry.attributes.position;
            positions.setXYZ(0, startPos.x, startPos.y, startPos.z);
            positions.setXYZ(1, endPos.x, endPos.y, endPos.z);
            positions.needsUpdate = true;
            
            // 방향 및 거리
            const dir = new THREE.Vector3().subVectors(endPos, startPos);
            const length = dir.length();
            const dirNorm = dir.clone().normalize();
            
            // 속도 계산 (실제 게임 내부 단위)
            const speedScale = Math.min(length * 0.01, 2.0);
            const speedDisplay = speedScale.toFixed(2);
            
            // 색상 변경 (속도에 따라)
            const speedColor = length > 100 ? 0xff4400 : length > 50 ? 0xffaa00 : 0x00ff88;
            velocityLine.material.color.setHex(speedColor);
            
            // ★★★ 속도 표시 UI 업데이트 ★★★
            updateSpeedDisplay(speedDisplay, speedColor, length);
            
            // 핸들 위치 업데이트
            if (velocityHandle) {
                velocityHandle.position.copy(endPos);
                velocityHandle.material.color.setHex(speedColor);
                
                // 핸들 링 색상도 업데이트
                const handleRing = velocityHandle.getObjectByName('handleRing');
                if (handleRing) {
                    handleRing.material.color.setHex(speedColor);
                }
            }
            
            // 화살표 콘 업데이트
            if (velocityArrow && length > 5) {
                velocityArrow.material.color.setHex(speedColor);
                const quaternion = new THREE.Quaternion();
                quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dirNorm);
                velocityArrow.quaternion.copy(quaternion);
                velocityArrow.position.copy(endPos).add(dirNorm.clone().multiplyScalar(pendingBody.radius * 0.5 || 3));
            }
        }
        
        // ★★★ 속도 표시 UI ★★★
        function updateSpeedDisplay(speedValue, color, length) {
            let speedDisplay = document.getElementById('velocity-speed-display');
            
            if (!speedDisplay) {
                speedDisplay = document.createElement('div');
                speedDisplay.id = 'velocity-speed-display';
                speedDisplay.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    padding: 15px 25px;
                    background: rgba(0, 20, 40, 0.9);
                    border: 2px solid #00ff88;
                    border-radius: 10px;
                    color: #00ff88;
                    font-family: 'Orbitron', monospace;
                    font-size: 24px;
                    font-weight: bold;
                    z-index: 10000;
                    text-align: center;
                    pointer-events: none;
                    box-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
                `;
                document.body.appendChild(speedDisplay);
            }
            
            // 색상 설정
            const colorHex = '#' + color.toString(16).padStart(6, '0');
            speedDisplay.style.borderColor = colorHex;
            speedDisplay.style.color = colorHex;
            speedDisplay.style.boxShadow = `0 0 30px ${colorHex}80`;
            
            // 속도 등급
            const lang = (typeof currentLang !== 'undefined') ? currentLang : 'en';
            let grade = '';
            if (length > 100) {
                grade = lang === 'ko' ? '🚀 고속' : lang === 'ja' ? '🚀 高速' : '🚀 Fast';
            } else if (length > 50) {
                grade = lang === 'ko' ? '⚡ 보통' : lang === 'ja' ? '⚡ 普通' : '⚡ Normal';
            } else {
                grade = lang === 'ko' ? '🐢 저속' : lang === 'ja' ? '🐢 低速' : '🐢 Slow';
            }
            
            speedDisplay.innerHTML = `
                <div style="font-size: 14px; opacity: 0.8; margin-bottom: 5px;">${grade}</div>
                <div>${speedValue} <span style="font-size: 14px;">units</span></div>
            `;
            
            speedDisplay.style.display = 'block';
        }
        
        // 속도 표시 숨기기
        function hideSpeedDisplay() {
            const speedDisplay = document.getElementById('velocity-speed-display');
            if (speedDisplay) {
                speedDisplay.style.display = 'none';
            }
        }

        function createBody(typeData, pos, vel, name, textureKeyName=null) {
            let mesh, coronaMesh;
            const visualScale = getVisualScale(typeData.type);
            
            if (typeData.type === 'star') {
                const geo = new THREE.SphereGeometry(typeData.r, 64, 64);
                const mat = new THREE.ShaderMaterial({ uniforms: { time: { value: 0 } }, vertexShader: document.getElementById('vertexShader').textContent, fragmentShader: document.getElementById('fragmentShader').textContent, transparent: false, depthWrite: true, depthTest: true, blending: THREE.NoBlending, side: THREE.FrontSide });
                mesh = new THREE.Mesh(geo, mat);
                mesh.scale.setScalar(visualScale);  // ★ 시각적 스케일 적용
                const light = new THREE.PointLight(typeData.color, 3.0, 0, 0); mesh.add(light);
                const coronaGeo = new THREE.PlaneGeometry(typeData.r * 6, typeData.r * 6);
                const coronaMat = new THREE.ShaderMaterial({ uniforms: { time: { value: 0 } }, vertexShader: document.getElementById('coronaVertexShader').textContent, fragmentShader: document.getElementById('coronaFragmentShader').textContent, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false, side: THREE.DoubleSide });
                coronaMesh = new THREE.Mesh(coronaGeo, coronaMat); mesh.add(coronaMesh);
            } else if (typeData.type === 'blackhole') {
                const geo = new THREE.SphereGeometry(typeData.r, 32, 32); 
                mesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({color:0}));
                mesh.scale.setScalar(visualScale);  // ★ 시각적 스케일 적용
                
                // ★ 심플한 불의 고리 강착원반
                const bhGroup = new THREE.Group();
                bhGroup.name = 'blackholeEffects';
                
                const r = typeData.r;
                
                // 1. 메인 불의 고리 (여러 층)
                const fireRings = [];
                const numRings = 5;
                for (let i = 0; i < numRings; i++) {
                    const innerR = r * (1.8 + i * 0.6);
                    const outerR = r * (2.2 + i * 0.6);
                    const ringGeo = new THREE.RingGeometry(innerR, outerR, 64, 1);
                    
                    // 안쪽일수록 밝은 노랑/흰색, 바깥쪽일수록 빨강/주황
                    const t = i / numRings;
                    const ringColor = new THREE.Color();
                    ringColor.setRGB(
                        1,
                        0.8 - t * 0.5,  // 안쪽: 노랑, 바깥: 빨강
                        0.3 - t * 0.25
                    );
                    
                    const ringMat = new THREE.MeshBasicMaterial({
                        color: ringColor,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.9 - t * 0.3,
                        blending: THREE.AdditiveBlending,
                        depthWrite: false
                    });
                    
                    const ring = new THREE.Mesh(ringGeo, ringMat);
                    ring.rotation.x = Math.PI / 2;
                    ring.userData.rotationSpeed = 0.005 - t * 0.001;  // 안쪽이 더 빠름
                    fireRings.push(ring);
                    bhGroup.add(ring);
                }
                
                // 2. 내부 밝은 링 (이벤트 호라이즌 근처)
                const innerGlowGeo = new THREE.RingGeometry(r * 1.3, r * 1.7, 64);
                const innerGlowMat = new THREE.MeshBasicMaterial({
                    color: 0xffffaa,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 1,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                const innerGlow = new THREE.Mesh(innerGlowGeo, innerGlowMat);
                innerGlow.rotation.x = Math.PI / 2;
                innerGlow.userData.rotationSpeed = 0.01;
                bhGroup.add(innerGlow);
                
                // 3. 외곽 글로우 (은은한 빛)
                const outerGlowGeo = new THREE.RingGeometry(r * 4.5, r * 6, 64);
                const outerGlowMat = new THREE.MeshBasicMaterial({
                    color: 0xff4400,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.2,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                const outerGlow = new THREE.Mesh(outerGlowGeo, outerGlowMat);
                outerGlow.rotation.x = Math.PI / 2;
                bhGroup.add(outerGlow);
                
                mesh.add(bhGroup);
                
                // 애니메이션용 데이터 저장
                mesh.userData.fireRings = fireRings;
                mesh.userData.innerGlow = innerGlow;
            } else {
                const geo = new THREE.SphereGeometry(typeData.r, 64, 64);
                const params = { color: 0xffffff, roughness: 0.9, metalness: 0.0 };  // ★ 텍스처 원색 유지
                const safeMap = generateProceduralTexture(typeData.texType||'rock', typeData.color); params.map = safeMap;
                const mat = new THREE.MeshStandardMaterial(params);
                mesh = new THREE.Mesh(geo, mat);
                mesh.scale.setScalar(visualScale);  // ★ 시각적 스케일 적용
                mesh.castShadow = true; mesh.receiveShadow = true;
                
                // ★★★ 지구에 대기와 구름 추가 ★★★
                if (name === '지구') {
                    // 대기 레이어
                    const atmosphereGeo = new THREE.SphereGeometry(typeData.r * 1.025, 64, 64);
                    const atmosphereMat = new THREE.ShaderMaterial({
                        vertexShader: document.getElementById('atmosphereVertexShader').textContent,
                        fragmentShader: document.getElementById('atmosphereFragmentShader').textContent,
                        uniforms: {
                            sunDirection: { value: new THREE.Vector3(1, 0, 0) },
                            atmosphereRadius: { value: typeData.r * 1.025 },
                            planetRadius: { value: typeData.r },
                            time: { value: 0 }
                        },
                        transparent: true,
                        blending: THREE.AdditiveBlending,
                        side: THREE.BackSide,
                        depthWrite: false
                    });
                    const atmosphere = new THREE.Mesh(atmosphereGeo, atmosphereMat);
                    atmosphere.name = 'earthAtmosphere';
                    mesh.add(atmosphere);
                    
                    // ★★★ 다층 구름 시스템 (3개 레이어) ★★★
                    const cloudLayers = [];
                    const cloudHeights = [1.008, 1.012, 1.018];  // 낮은 구름, 중간, 높은 구름
                    
                    cloudHeights.forEach((height, idx) => {
                        const cloudGeo = new THREE.SphereGeometry(typeData.r * height, 64, 64);
                        const cloudMat = new THREE.ShaderMaterial({
                            vertexShader: document.getElementById('cloudVertexShader').textContent,
                            fragmentShader: document.getElementById('cloudFragmentShader').textContent,
                            uniforms: {
                                time: { value: idx * 100 },  // 레이어별 시간 오프셋
                                sunDirection: { value: new THREE.Vector3(1, 0, 0) },
                                cloudDensity: { value: 1.0 - idx * 0.2 },  // 높을수록 옅어짐
                                cloudSpeed: { value: 0.02 + idx * 0.01 }   // 높을수록 빠르게
                            },
                            transparent: true,
                            blending: THREE.NormalBlending,
                            side: THREE.FrontSide,
                            depthWrite: false
                        });
                        const clouds = new THREE.Mesh(cloudGeo, cloudMat);
                        clouds.name = 'earthClouds_' + idx;
                        clouds.renderOrder = idx;  // 렌더링 순서
                        mesh.add(clouds);
                        cloudLayers.push(cloudMat);
                    });
                    
                    // 쉐이더 참조 저장 (애니메이션용)
                    mesh.userData.atmosphereMat = atmosphereMat;
                    mesh.userData.cloudLayers = cloudLayers;
                    mesh.userData.hasAtmosphere = true;
                    
                    console.log('🌍 지구 대기/구름 쉐이더 생성 완료 (3 레이어)');
                }
            }
            mesh.position.copy(pos); scene.add(mesh);
            if (textureKeyName && typeData.type !== 'star') {
                let url;
                if (textureKeyName.startsWith('http')) {
                    url = textureKeyName;
                } else if (textureKeyName.startsWith('uploads/')) {
                    // uploads 경로는 Supabase Storage로
                    const justFilename = textureKeyName.replace('uploads/', '').replace('ships/', '');
                    url = SUPABASE_STORAGE + justFilename;
                } else if (TEXTURES[textureKeyName]) {
                    // TEXTURES 매핑에서 Supabase 파일 찾기
                    url = getTextureUrl(TEXTURES[textureKeyName].map);
                } else {
                    url = getTextureUrl(textureKeyName);
                }
                if(url) textureLoader.load(url, (t) => { mesh.material.map = t; mesh.material.needsUpdate = true; }, undefined, (err) => {
                    console.warn('텍스처 로드 실패 (Supabase), 로컬 시도:', textureKeyName);
                    // 실패시 로컬 시도
                    const localUrl = textureKeyName.startsWith('uploads/') ? textureKeyName : ASSET_PATH + (TEXTURES[textureKeyName] ? TEXTURES[textureKeyName].map : textureKeyName);
                    textureLoader.load(localUrl, (t) => { mesh.material.map = t; mesh.material.needsUpdate = true; });
                });
            }
            if (typeData.ring) {
                const rGeo = new THREE.RingGeometry(typeData.r*1.3, typeData.r*2.2, 64);
                // UV 좌표 수정 (가로 이미지가 고리 형태로 감싸지도록)
                const pos = rGeo.attributes.position;
                const uv = rGeo.attributes.uv;
                for (let i = 0; i < uv.count; i++) {
                    const x = pos.getX(i);
                    const y = pos.getY(i);
                    const dist = Math.sqrt(x*x + y*y);
                    const innerR = typeData.r * 1.3;
                    const outerR = typeData.r * 2.2;
                    const u = (dist - innerR) / (outerR - innerR);  // 반경 방향
                    const angle = Math.atan2(y, x);
                    const v = (angle + Math.PI) / (2 * Math.PI);  // 각도 방향
                    uv.setXY(i, v, u);
                }
                uv.needsUpdate = true;
                
                const rMat = new THREE.MeshStandardMaterial({ color: 0xaa9977, side: THREE.DoubleSide, transparent:true, opacity:0.9 });
                const rMesh = new THREE.Mesh(rGeo, rMat); rMesh.rotation.x = -Math.PI/2; rMesh.castShadow = true; rMesh.receiveShadow=true; mesh.add(rMesh);
                
                // ★ 고리 텍스처 로드 (data.json의 ringTexture 또는 Supabase Storage)
                let ringTexPath;
                if (typeData.ringTexture) {
                    if (typeData.ringTexture.startsWith('http')) {
                        ringTexPath = typeData.ringTexture;
                    } else if (typeData.ringTexture.startsWith('uploads/')) {
                        ringTexPath = SUPABASE_STORAGE + typeData.ringTexture.replace('uploads/', '');
                    } else {
                        ringTexPath = typeData.ringTexture;
                    }
                } else {
                    ringTexPath = SUPABASE_STORAGE + 'saturn_ring_1765903886.png';
                }
                new THREE.TextureLoader().load(ringTexPath, (t)=>{
                    t.wrapS = THREE.RepeatWrapping;
                    t.wrapT = THREE.ClampToEdgeWrapping;
                    rMat.map=t; rMat.alphaMap=t; rMat.needsUpdate=true;
                });
            }
            const div = document.createElement('div'); div.className = 'label'; 
            div.dataset.bodyName = name;  // 원본 이름 저장
            div.textContent = translateBodyName(name);  // 번역된 이름 표시
            const labelY = typeData.r * visualScale * 1.02;  // ★ 시각적 스케일 반영
            const label = new CSS2DObject(div); label.position.set(0, labelY, 0); mesh.add(label);
            const body = { mesh: mesh, mass: typeData.m, radius: typeData.r, velocity: vel.clone(), force: new THREE.Vector3(), name: name, type: typeData.type||'planet', rotSpeed: typeData.rotSpeed || 0, corona: coronaMesh, visualScale: visualScale };
            initTrail(body); bodies.push(body); updateNavList(); 
            return body;
        }

        function createSatellite(parentBody, typeData, distRatio, speed, name, isSpaceStation = false) {
            let mesh;
            // ★ 부모의 visualScale 가져오기 (10배 스케일 적용)
            const parentVisualScale = parentBody.visualScale || 1;
            const dist = parentBody.radius * distRatio * parentVisualScale;  // ★ 궤도도 스케일 적용
            if (isSpaceStation) {
                // ========== SF 거대 우주정거장 모델링 ==========
                const group = new THREE.Group();
                
                // 재질 정의
                const hullMat = new THREE.MeshStandardMaterial({ 
                    color: 0xcccccc, metalness: 0.9, roughness: 0.2 
                });
                const darkHullMat = new THREE.MeshStandardMaterial({ 
                    color: 0x444455, metalness: 0.8, roughness: 0.3 
                });
                const glowMat = new THREE.MeshBasicMaterial({ 
                    color: 0x00ffff, transparent: true, opacity: 0.8 
                });
                const panelMat = new THREE.MeshStandardMaterial({ 
                    color: 0x112244, metalness: 0.6, roughness: 0.1, 
                    emissive: 0x000033, emissiveIntensity: 0.3 
                });
                const accentMat = new THREE.MeshStandardMaterial({ 
                    color: 0xff6600, metalness: 0.7, roughness: 0.3,
                    emissive: 0xff3300, emissiveIntensity: 0.2
                });
                const windowMat = new THREE.MeshBasicMaterial({ 
                    color: 0x88ccff, transparent: true, opacity: 0.6 
                });
                
                // === 1. 중앙 회전 링 (토러스) - 거주 구역 ===
                const ringGeo = new THREE.TorusGeometry(3, 0.4, 16, 64);
                const ring = new THREE.Mesh(ringGeo, hullMat);
                ring.rotation.x = Math.PI / 2;
                group.add(ring);
                
                // 링 위의 창문들
                for (let i = 0; i < 32; i++) {
                    const angle = (i / 32) * Math.PI * 2;
                    const windowGeo = new THREE.BoxGeometry(0.15, 0.08, 0.05);
                    const window = new THREE.Mesh(windowGeo, windowMat);
                    window.position.set(
                        Math.cos(angle) * 3,
                        0.35,
                        Math.sin(angle) * 3
                    );
                    window.rotation.y = -angle;
                    group.add(window);
                }
                
                // 링 세그먼트 구분선
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const segGeo = new THREE.BoxGeometry(0.05, 0.85, 0.05);
                    const seg = new THREE.Mesh(segGeo, darkHullMat);
                    seg.position.set(Math.cos(angle) * 3, 0, Math.sin(angle) * 3);
                    seg.rotation.y = -angle;
                    group.add(seg);
                }
                
                // === 2. 중앙 허브 (커맨드 센터) ===
                const hubGeo = new THREE.CylinderGeometry(0.8, 1.0, 2.5, 12);
                const hub = new THREE.Mesh(hubGeo, hullMat);
                group.add(hub);
                
                // 허브 상단 돔 (관측실)
                const domeGeo = new THREE.SphereGeometry(0.85, 24, 12, 0, Math.PI * 2, 0, Math.PI / 2);
                const dome = new THREE.Mesh(domeGeo, windowMat);
                dome.position.y = 1.25;
                group.add(dome);
                
                // 허브 하단 도킹 포트
                const dockBaseGeo = new THREE.CylinderGeometry(0.6, 0.8, 0.5, 8);
                const dockBase = new THREE.Mesh(dockBaseGeo, darkHullMat);
                dockBase.position.y = -1.5;
                group.add(dockBase);
                
                // === 3. 스포크 (링과 허브 연결) ===
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2;
                    const spokeGeo = new THREE.CylinderGeometry(0.12, 0.12, 2.2, 8);
                    const spoke = new THREE.Mesh(spokeGeo, hullMat);
                    spoke.position.set(Math.cos(angle) * 1.5, 0, Math.sin(angle) * 1.5);
                    spoke.rotation.z = Math.PI / 2;
                    spoke.rotation.y = angle;
                    group.add(spoke);
                    
                    // 스포크 연결부 조인트
                    const jointGeo = new THREE.SphereGeometry(0.18, 8, 8);
                    const jointInner = new THREE.Mesh(jointGeo, darkHullMat);
                    jointInner.position.set(Math.cos(angle) * 0.9, 0, Math.sin(angle) * 0.9);
                    group.add(jointInner);
                    const jointOuter = new THREE.Mesh(jointGeo, darkHullMat);
                    jointOuter.position.set(Math.cos(angle) * 2.6, 0, Math.sin(angle) * 2.6);
                    group.add(jointOuter);
                }
                
                // === 4. 태양광 패널 어레이 (태양 추적용 별도 그룹) ===
                const solarArrayGroup = new THREE.Group();
                solarArrayGroup.name = 'solarArrayGroup';
                
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2 + Math.PI / 8;
                    const panelGroup = new THREE.Group();
                    
                    // 패널 암
                    const armGeo = new THREE.CylinderGeometry(0.04, 0.04, 3.5, 6);
                    const arm = new THREE.Mesh(armGeo, darkHullMat);
                    arm.rotation.z = Math.PI / 2;
                    panelGroup.add(arm);
                    
                    // 대형 패널들
                    for (let p = -1; p <= 1; p += 2) {
                        const panel = new THREE.Group();
                        // 패널 프레임
                        const frameGeo = new THREE.BoxGeometry(2.8, 0.05, 1.2);
                        const frame = new THREE.Mesh(frameGeo, darkHullMat);
                        panel.add(frame);
                        // 패널 셀
                        const cellGeo = new THREE.BoxGeometry(2.6, 0.03, 1.0);
                        const cell = new THREE.Mesh(cellGeo, panelMat);
                        cell.position.y = 0.02;
                        panel.add(cell);
                        // 패널 세부 그리드
                        for (let g = -2; g <= 2; g++) {
                            const gridGeo = new THREE.BoxGeometry(0.02, 0.06, 1.0);
                            const grid = new THREE.Mesh(gridGeo, darkHullMat);
                            grid.position.x = g * 0.5;
                            panel.add(grid);
                        }
                        panel.position.x = p * 1.5;
                        panelGroup.add(panel);
                    }
                    
                    panelGroup.position.set(Math.cos(angle) * 4.5, 0.8, Math.sin(angle) * 4.5);
                    panelGroup.rotation.y = -angle + Math.PI / 2;
                    solarArrayGroup.add(panelGroup);
                }
                group.add(solarArrayGroup);
                
                // === 5. 도킹 베이 (4개) ===
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2 + Math.PI / 4;
                    const dockGroup = new THREE.Group();
                    
                    // 도킹 암
                    const dockArmGeo = new THREE.BoxGeometry(0.3, 0.2, 1.5);
                    const dockArm = new THREE.Mesh(dockArmGeo, hullMat);
                    dockArm.position.z = 0.75;
                    dockGroup.add(dockArm);
                    
                    // 도킹 포트 (링 형태)
                    const portGeo = new THREE.TorusGeometry(0.25, 0.06, 8, 16);
                    const port = new THREE.Mesh(portGeo, accentMat);
                    port.position.z = 1.5;
                    dockGroup.add(port);
                    
                    // 도킹 조명
                    const lightGeo = new THREE.SphereGeometry(0.05, 8, 8);
                    const dockLight = new THREE.Mesh(lightGeo, glowMat);
                    dockLight.position.set(0, 0.15, 1.5);
                    dockGroup.add(dockLight);
                    
                    dockGroup.position.set(Math.cos(angle) * 3.5, -0.3, Math.sin(angle) * 3.5);
                    dockGroup.rotation.y = -angle;
                    group.add(dockGroup);
                }
                
                // === 6. 안테나 어레이 ===
                // 상단 주 안테나
                const mainAntennaGeo = new THREE.CylinderGeometry(0.02, 0.02, 1.5, 6);
                const mainAntenna = new THREE.Mesh(mainAntennaGeo, darkHullMat);
                mainAntenna.position.y = 2.5;
                group.add(mainAntenna);
                
                // 안테나 접시
                const dishGeo = new THREE.SphereGeometry(0.4, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2);
                const dish = new THREE.Mesh(dishGeo, hullMat);
                dish.position.y = 3.2;
                dish.rotation.x = Math.PI;
                group.add(dish);
                
                // 부 안테나들
                for (let i = 0; i < 3; i++) {
                    const angle = (i / 3) * Math.PI * 2;
                    const subAntennaGeo = new THREE.CylinderGeometry(0.015, 0.015, 0.8, 4);
                    const subAntenna = new THREE.Mesh(subAntennaGeo, darkHullMat);
                    subAntenna.position.set(Math.cos(angle) * 0.5, 2.8, Math.sin(angle) * 0.5);
                    subAntenna.rotation.z = 0.3;
                    subAntenna.rotation.y = angle;
                    group.add(subAntenna);
                }
                
                // === 7. 외부 조명 ===
                // 항법 조명 (빨강/녹색)
                const navLightGeoR = new THREE.SphereGeometry(0.08, 8, 8);
                const navLightMatR = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const navLightR = new THREE.Mesh(navLightGeoR, navLightMatR);
                navLightR.position.set(4.5, 0, 0);
                group.add(navLightR);
                
                const navLightMatG = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                const navLightG = new THREE.Mesh(navLightGeoR, navLightMatG);
                navLightG.position.set(-4.5, 0, 0);
                group.add(navLightG);
                
                // 스트로브 조명
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2;
                    const strobeGeo = new THREE.SphereGeometry(0.06, 6, 6);
                    const strobeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                    const strobe = new THREE.Mesh(strobeGeo, strobeMat);
                    strobe.position.set(Math.cos(angle) * 3, 0.5, Math.sin(angle) * 3);
                    strobe.name = 'strobe_' + i;
                    group.add(strobe);
                }
                
                // === 8. 화물 모듈 ===
                const cargoGeo = new THREE.BoxGeometry(0.8, 0.6, 1.2);
                const cargo1 = new THREE.Mesh(cargoGeo, darkHullMat);
                cargo1.position.set(1.2, -1.2, 0.8);
                group.add(cargo1);
                const cargo2 = new THREE.Mesh(cargoGeo, darkHullMat);
                cargo2.position.set(-1.0, -1.2, -0.6);
                group.add(cargo2);
                
                // === 9. 연구 모듈 ===
                const labGeo = new THREE.CylinderGeometry(0.35, 0.35, 1.8, 8);
                const lab = new THREE.Mesh(labGeo, hullMat);
                lab.position.set(0, -2.2, 0);
                group.add(lab);
                
                // 연구 모듈 창문
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    const labWindowGeo = new THREE.BoxGeometry(0.12, 0.08, 0.05);
                    const labWindow = new THREE.Mesh(labWindowGeo, windowMat);
                    labWindow.position.set(
                        Math.cos(angle) * 0.33,
                        -2.2,
                        Math.sin(angle) * 0.33
                    );
                    labWindow.rotation.y = -angle;
                    group.add(labWindow);
                }
                
                // === 10. 추진 모듈 ===
                const thrusterGeo = new THREE.ConeGeometry(0.15, 0.4, 8);
                const thrusterMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.9 });
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2 + Math.PI / 4;
                    const thruster = new THREE.Mesh(thrusterGeo, thrusterMat);
                    thruster.position.set(
                        Math.cos(angle) * 0.5,
                        -3.0,
                        Math.sin(angle) * 0.5
                    );
                    thruster.rotation.x = Math.PI;
                    group.add(thruster);
                }
                
                // === 포인트 라이트 (정거장 조명) ===
                const stationLight = new THREE.PointLight(0x88ccff, 1.5, 15);
                stationLight.position.set(0, 0, 0);
                group.add(stationLight);
                
                // 전체 스케일 조정 (더 크게)
                group.scale.set(0.12, 0.12, 0.12);
                
                // ★★★ 그림자 설정 (정거장 전체) ★★★
                group.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                
                // 회전 애니메이션용 데이터 저장
                group.userData.isStation = true;
                group.userData.ringMesh = ring;
                
                mesh = group;
            } else {
                const geo = new THREE.SphereGeometry(typeData.r, 32, 32);
                const mat = new THREE.MeshStandardMaterial({ color: typeData.color || 0x888888, roughness: 0.9 });
                if (typeData.texKey) {
                   const url = TEXTURES[typeData.texKey] ? ASSET_PATH + TEXTURES[typeData.texKey].map : null;
                   if(url) textureLoader.load(url, (t) => { mat.map = t; mat.needsUpdate = true; });
                } else {
                    mat.map = generateProceduralTexture('rock', typeData.color || 0x888888);
                }
                mesh = new THREE.Mesh(geo, mat);
                mesh.castShadow = true; mesh.receiveShadow = true;
                // ★ 위성도 VISUAL_SCALE 적용 (10배)
                const moonScale = getVisualScale('moon');
                mesh.scale.setScalar(moonScale);
            }
            const div = document.createElement('div');
            div.className = 'label';
            div.dataset.bodyName = name;  // 원본 이름 저장
            div.textContent = translateBodyName(name);  // 번역된 이름 표시
            div.style.color = isSpaceStation ? '#00ffff' : '#cccccc';
            if (isSpaceStation) div.style.fontSize = '9px';
            const label = new CSS2DObject(div);
            const satRadius = isSpaceStation ? 0.5 : (typeData ? typeData.r : 0.3);
            label.position.set(0, satRadius * 1.02, 0);  // 천체 바로 위
            mesh.add(label);
            scene.add(mesh);
            
            // ★★★ 멀티모드: Date.now() 기준 초기 각도 (동기화) ★★★
            let initialAngle;
            if (window.gameMode === 'multi') {
                const seed = name ? name.split('').reduce((a, c) => a + c.charCodeAt(0), 0) : 0;
                const baseTime = Date.now() * 0.0000001;
                initialAngle = (seed * 0.1 + baseTime * speed) % (Math.PI * 2);
            } else {
                initialAngle = Math.random() * Math.PI * 2;
            }

            // 위성 물리 속성 (모든 위성은 부모 행성 따라가며 공전)
            const satellite = {
                mesh: mesh, name: name, type: isSpaceStation ? "station" : "moon",
                isSpaceStation: isSpaceStation,  // ★ 추가: 우주정거장 여부
                parentBody: parentBody, orbitRadius: dist, orbitSpeed: speed, angle: initialAngle,
                realOrbitRadius: dist,  // 실제 거리 비율 (나중에 설정)
                // ★★★ 위성은 물리 비활성화 - 부모 행성 따라감 (안정적) ★★★
                mass: isSpaceStation ? 0.001 : (typeData ? typeData.m : 0.01),
                radius: isSpaceStation ? 0.5 : (typeData ? typeData.r : 0.3),
                velocity: new THREE.Vector3(0, 0, 0),
                force: new THREE.Vector3(0, 0, 0),
                isPhysicsEnabled: false,  // ★ 위성은 물리 비활성화 (부모 따라감)
                isStatic: false
            };
            
            // ★ 초기 위치 설정 (부모 행성 주변)
            const initR = dist;  // 초기 궤도 반경
            mesh.position.x = parentBody.mesh.position.x + Math.cos(satellite.angle) * initR;
            mesh.position.z = parentBody.mesh.position.z + Math.sin(satellite.angle) * initR;
            mesh.position.y = parentBody.mesh.position.y;
            
            satellites.push(satellite);
            return satellite;
        }

        function createMoons() {
            // 위성에 초기 궤도 위치 설정하는 헬퍼 함수
            function initMoonOrbit(moon, parent) {
                if (!moon || !parent || !parent.mesh || !moon.mesh) return;
                
                // 실제 거리 모드 확인
                const isRealMode = CONFIG.distScale > 1.0;
                
                // 초기 위치 설정 - 실제 모드면 realOrbitRadius 사용
                let r;
                if (isRealMode && moon.realOrbitRadius) {
                    // ★ visualScale 적용 (10배 스케일 반영)
                    const parentScale = parent.visualScale || 1;
                    r = moon.realOrbitRadius * (parent.radius || 1) * parentScale;
                } else {
                    r = moon.orbitRadius;
                }
                
                const angle = moon.angle;
                moon.mesh.position.x = parent.mesh.position.x + Math.cos(angle) * r;
                moon.mesh.position.z = parent.mesh.position.z + Math.sin(angle) * r;
                moon.mesh.position.y = parent.mesh.position.y;
            }
            
            const earth = bodies.find(b => b.name === "지구");
            if (earth) { 
                // 달 공전 주기: 27.3일, 지구 공전 주기: 365.25일
                // 달은 지구 공전 대비 약 13.4배 빠르게 공전
                // 지구 orbitSpeed 기준으로 달 속도 계산
                const moonOrbitSpeed = 2.5;  // 달 공전 속도 (게임 내 시각적 속도)
                const moon = createSatellite(earth, DEFAULT_TYPES.MOON, 6, moonOrbitSpeed, "달", false); 
                moon.realOrbitRadius = 60;  // 실제: 지구 반지름의 60배
                moon.orbitalPeriod = 27.3;  // 공전 주기 (일)
                initMoonOrbit(moon, earth);
                
                // ISS: 달(6) 바깥 궤도 → 12로 더 멀리
                const iss = createSatellite(earth, null, 12, 0.5, "ISS 우주정거장", true);  // 속도 2.5 → 0.5 (5배 감소)
                iss.realOrbitRadius = 15;
                iss.stationSize = 0.1;  // 지구 정거장 - 1/5 축소
                iss.hasFuel = true;  // 연료 충전 가능
                if (iss.mesh) iss.mesh.scale.setScalar(0.1);  // 1/5 축소
            }
            
            // ★ 금성 정거장 (위성 없음 → 넓은 궤도)
            const venus = bodies.find(b => b.name === "금성");
            if (venus) {
                const venusStation = createSatellite(venus, null, 7, 0.6, "비너스 플랫폼", true);  // 속도 3.0 → 0.6
                venusStation.realOrbitRadius = 8;
                venusStation.stationSize = 0.05;  // 1/5 축소
                venusStation.hasFuel = true;
                if (venusStation.mesh) venusStation.mesh.scale.setScalar(0.05);  // 1/5 축소
            }
            
            const mars = bodies.find(b => b.name === "화성");
            if (mars) { 
                // 포보스 공전 주기: 0.32일 (매우 빠름)
                const phobos = createSatellite(mars, DEFAULT_TYPES.PHOBOS, 2.5, 8.0, "포보스"); 
                phobos.realOrbitRadius = 2.76;
                initMoonOrbit(phobos, mars);
                
                // 데이모스 공전 주기: 1.26일
                const deimos = createSatellite(mars, DEFAULT_TYPES.DEIMOS, 4.0, 4.0, "데이모스"); 
                deimos.realOrbitRadius = 6.9;
                initMoonOrbit(deimos, mars);
                
                // ★ 화성 정거장: 데이모스(4.0) 바깥 궤도 → 7
                const marsStation = createSatellite(mars, null, 7, 0.6, "마스 스테이션", true);  // 속도 3.0 → 0.6
                marsStation.realOrbitRadius = 8;
                marsStation.stationSize = 0.05;  // 1/5 축소
                marsStation.hasFuel = true;
                if (marsStation.mesh) marsStation.mesh.scale.setScalar(0.05);  // 1/5 축소
            }
            const jupiter = bodies.find(b => b.name === "목성");
            if (jupiter) { 
                // 이오 공전 주기: 1.77일
                const io = createSatellite(jupiter, DEFAULT_TYPES.IO, 3.0, 6.0, "이오"); 
                io.realOrbitRadius = 5.9;
                initMoonOrbit(io, jupiter);
                
                // 유로파 공전 주기: 3.55일
                const europa = createSatellite(jupiter, DEFAULT_TYPES.EUROPA, 4.0, 4.5, "유로파"); 
                europa.realOrbitRadius = 9.4;
                initMoonOrbit(europa, jupiter);
                
                // 가니메데 공전 주기: 7.15일
                const ganymede = createSatellite(jupiter, DEFAULT_TYPES.GANYMEDE, 5.5, 3.0, "가니메데"); 
                ganymede.realOrbitRadius = 15;
                initMoonOrbit(ganymede, jupiter);
                
                // 칼리스토 공전 주기: 16.69일
                const callisto = createSatellite(jupiter, DEFAULT_TYPES.CALLISTO, 7.0, 2.0, "칼리스토"); 
                callisto.realOrbitRadius = 26;
                initMoonOrbit(callisto, jupiter);
                
                // ★ 목성 정거장: 칼리스토(7.0) 바깥 궤도 → 12
                const jupiterStation = createSatellite(jupiter, null, 12, 0.3, "주피터 아웃포스트", true);  // 속도 1.5 → 0.3
                jupiterStation.realOrbitRadius = 35;
                jupiterStation.stationSize = 0.05;  // 1/5 축소
                jupiterStation.hasFuel = true;
                if (jupiterStation.mesh) jupiterStation.mesh.scale.setScalar(0.05);  // 1/5 축소
            }
            const saturn = bodies.find(b => b.name === "토성");
            if (saturn) { 
                // 타이탄 공전 주기: 15.95일
                const titan = createSatellite(saturn, DEFAULT_TYPES.TITAN, 4.0, 2.5, "타이탄"); 
                titan.realOrbitRadius = 20;
                initMoonOrbit(titan, saturn);
                
                // 엔셀라두스 공전 주기: 1.37일
                const enceladus = createSatellite(saturn, DEFAULT_TYPES.ENCELADUS, 2.0, 6.0, "엔셀라두스"); 
                enceladus.realOrbitRadius = 4;
                initMoonOrbit(enceladus, saturn);
                
                // ★ 토성 정거장: 타이탄(4.0) 바깥 궤도 → 8
                const saturnStation = createSatellite(saturn, null, 8, 0.4, "새턴 베이스", true);  // 속도 2.0 → 0.4
                saturnStation.realOrbitRadius = 30;
                saturnStation.stationSize = 0.05;  // 1/5 축소
                saturnStation.hasFuel = true;
                if (saturnStation.mesh) saturnStation.mesh.scale.setScalar(0.05);  // 1/5 축소
            }
            const uranus = bodies.find(b => b.name === "천왕성");
            if (uranus) { 
                // 티타니아 공전 주기: 8.7일
                const titania = createSatellite(uranus, DEFAULT_TYPES.TITANIA, 3.5, 3.0, "티타니아"); 
                titania.realOrbitRadius = 17;
                initMoonOrbit(titania, uranus);
                
                // 오베론 공전 주기: 13.5일
                const oberon = createSatellite(uranus, DEFAULT_TYPES.OBERON, 4.5, 2.0, "오베론"); 
                oberon.realOrbitRadius = 23;
                initMoonOrbit(oberon, uranus);
                
                // ★ 천왕성 정거장: 오베론(4.5) 바깥 궤도 → 8
                const uranusStation = createSatellite(uranus, null, 8, 0.3, "우라노스 릴레이", true);  // 속도 1.5 → 0.3
                uranusStation.realOrbitRadius = 30;
                uranusStation.stationSize = 0.05;  // 1/5 축소
                uranusStation.hasFuel = true;
                if (uranusStation.mesh) uranusStation.mesh.scale.setScalar(0.05);  // 1/5 축소
            }
            const neptune = bodies.find(b => b.name === "해왕성");
            if (neptune) { 
                // 트리톤 공전 주기: 5.88일 (역행)
                const triton = createSatellite(neptune, DEFAULT_TYPES.TRITON, 3.5, -3.5, "트리톤"); 
                triton.realOrbitRadius = 14;
                initMoonOrbit(triton, neptune);
                
                // ★ 해왕성 정거장: 트리톤(3.5) 바깥 궤도 → 8
                const neptuneStation = createSatellite(neptune, null, 8, 0.2, "넵튠 터미널", true);  // 속도 1.0 → 0.2
                neptuneStation.realOrbitRadius = 25;
                neptuneStation.stationSize = 0.05;  // 1/5 축소
                neptuneStation.hasFuel = true;
                if (neptuneStation.mesh) neptuneStation.mesh.scale.setScalar(0.05);  // 1/5 축소
            }
            
            // ★★★ 중간 궤도 연료 정거장 생성 ★★★
            createFuelDepots();
            
            updateNavList();
        }
        
        // 중간 궤도 연료 정거장 생성 함수
        function createFuelDepots() {
            const sun = bodies.find(b => b.name === "태양");
            if (!sun) return;
            
            // 연료 정거장 데이터 (태양 기준 절대 위치) - 10배 확대
            const depots = [
                { name: "연료정거장 알파", orbit: 1200, desc: "지구-화성 중간" },  // 지구~화성 (10배)
                { name: "연료정거장 베타", orbit: 3500, desc: "화성-목성 중간 (소행성대)" },  // 화성~목성 (10배)
                { name: "연료정거장 감마", orbit: 6500, desc: "목성-토성 중간" },  // 목성~토성 (10배)
                { name: "연료정거장 델타", orbit: 12000, desc: "토성-천왕성 중간" }  // 토성~천왕성 (10배)
            ];
            
            depots.forEach((depot, i) => {
                // 연료 정거장 메쉬 생성 (토러스 형태) - 1/20 크기
                const torusGeo = new THREE.TorusGeometry(0.4, 0.15, 8, 16);
                const torusMat = new THREE.MeshStandardMaterial({ 
                    color: 0xff6600, 
                    emissive: 0x331100,
                    metalness: 0.8, 
                    roughness: 0.3 
                });
                const mesh = new THREE.Mesh(torusGeo, torusMat);
                mesh.rotation.x = Math.PI / 2;
                mesh.scale.setScalar(0.1);  // 1/5 축소
                
                // 태양 주위 궤도 위치
                const angle = (i * Math.PI / 2) + Math.PI / 4;  // 균등 분포
                mesh.position.x = Math.cos(angle) * depot.orbit;
                mesh.position.z = Math.sin(angle) * depot.orbit;
                mesh.position.y = 0;
                
                // 라벨 - 번역 적용
                const div = document.createElement('div');
                div.className = 'label';
                div.dataset.bodyName = depot.name;  // 원본 이름 저장
                div.textContent = translateBodyName(depot.name);  // 번역된 이름
                div.style.color = '#ff6600';
                div.style.fontSize = '8px';
                const label = new CSS2DObject(div);
                label.position.set(0, 0.6, 0);
                mesh.add(label);
                
                scene.add(mesh);
                
                // satellites 배열에 추가
                const fuelDepot = {
                    mesh: mesh,
                    name: depot.name,
                    type: 'station',
                    isFuelDepot: true,  // 연료 정거장 구분
                    description: depot.desc,
                    orbitRadius: depot.orbit,
                    orbitSpeed: 0.01 / Math.sqrt(depot.orbit),  // 케플러 법칙
                    angle: angle,
                    parentBody: sun,
                    stationSize: 0.03,  // 1/5 축소
                    hasFuel: true,
                    mass: 0.0001,
                    velocity: new THREE.Vector3(0, 0, 0),
                    isPhysicsEnabled: false
                };
                satellites.push(fuelDepot);
            });
        }

        function initChat() {
            var toggle = document.getElementById('chat-toggle'); 
            var panel = document.getElementById('chat-panel'); 
            var close = document.getElementById('chat-close'); 
            var send = document.getElementById('chat-send'); 
            var input = document.getElementById('chat-input'); 
            var messages = document.getElementById('chat-messages');
            
            toggle.onclick = function() { 
                panel.classList.toggle('open'); 
                if (panel.classList.contains('open')) input.focus(); 
            }; 
            close.onclick = function() { panel.classList.remove('open'); };
            
            var sendMessage = function() { 
                var text = input.value.trim(); 
                if (!text) return; 
                addMessage(text, 'user'); 
                input.value = ''; 
                addMessage('답변 생성 중...', 'system'); 
                
                callGeminiAPI(text)
                    .then(function(response) {
                        messages.removeChild(messages.lastChild); 
                        addMessage(response, 'ai'); 
                    })
                    .catch(function(error) { 
                        messages.removeChild(messages.lastChild); 
                        console.error(error); 
                        addMessage('오류 발생: ' + error.message, 'system'); 
                    });
            };
            send.onclick = sendMessage; 
            input.onkeypress = function(e) { if (e.key === 'Enter') sendMessage(); };
        }
        
        function addMessage(text, type) { 
            var messages = document.getElementById('chat-messages'); 
            var div = document.createElement('div'); 
            div.className = 'msg ' + type; 
            div.textContent = text; 
            messages.appendChild(div); 
            messages.scrollTop = messages.scrollHeight; 
        }
        
        function callGeminiAPI(query) { 
            var systemPrompt = '당신은 우주 시뮬레이션 게임의 전문 도우미입니다.\n' +
'다음 주제에 대해서만 답변하세요:\n' +
'- 우주, 행성, 태양계, 천체에 관한 질문\n' +
'- 우주선 조종, 비행, 항해에 관한 질문\n' +
'- 이 시뮬레이션 게임의 조작법, 기능에 관한 질문\n' +
'- 우주 탐사, 우주정거장, 궤도에 관한 질문\n' +
'- 천문학, 물리학(중력, 궤도역학 등)에 관한 질문\n\n' +
'위 주제와 관련 없는 질문(일상대화, 다른 분야의 질문 등)에는 반드시 다음과 같이 답변하세요:\n' +
'"죄송합니다. 저는 우주 시뮬레이션 관련 질문에만 답변할 수 있습니다. 🚀"\n\n' +
'답변은 간결하고 친절하게 해주세요.';
            
            // Vercel: /api/gemini, 로컬: gemini_proxy.php
            const geminiUrl = window.location.hostname.includes('vercel') ? '/api/gemini' : 'gemini_proxy.php';
            return fetch(geminiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    systemInstruction: { parts: [{ text: systemPrompt }] },
                    contents: [{ parts: [{ text: query }] }]
                })
            })
            .then(function(response) {
                if (!response.ok) throw new Error('API/Server Error'); 
                return response.json();
            })
            .then(function(data) {
                var answer = data.candidates && data.candidates[0] && 
                             data.candidates[0].content && data.candidates[0].content.parts && 
                             data.candidates[0].content.parts[0] && data.candidates[0].content.parts[0].text;
                return answer || "답변을 생성할 수 없습니다.";
            });
        }
        
        // ★ ships.json에서 우주선 이미지/모델 로드
        let shipsDataLoaded = false;

        // ★ 우주선 파일 경로를 Supabase Storage로 변환
        function convertToSupabaseUrl(path) {
            if (!path || path.length === 0) return path;

            if (path.startsWith('http')) return path;  // 이미 절대 URL
            if (path.startsWith('uploads/')) {
                const filename = path.replace('uploads/', '').replace('ships/', '');
                return SUPABASE_STORAGE + 'ships/' + filename;
            }
            return path;
        }
        
        function loadShipsData() {
            // ★ Vercel API에서 ships 데이터 로드 (Supabase)
            const shipsUrl = API_BASE + '/ships';

            return fetch(shipsUrl)
                .then(res => {
                    if (!res.ok) throw new Error('API 응답 실패');
                    return res.json();
                })
                .catch(err => {
                    // API 실패 시 로컬 ships.json fallback
                    console.log('⚠️ Vercel API 실패, 로컬 fallback 시도:', err);
                    return fetch('ships.json').then(res => res.json());
                })
                .then(shipsData => {
                    // 에러 응답 체크
                    if (shipsData.error) {
                        console.log('⚠️ API 에러:', shipsData.error);
                        shipsDataLoaded = true;
                        return;
                    }

                    console.log('📦 ships 데이터 로드됨:', shipsData);
                    console.log('📦 SHIP_TYPES ids:', SHIP_TYPES.map(s => s.id));

                    shipsData.forEach(shipData => {
                        console.log(`  🔍 ships 항목: id="${shipData.id}", image="${shipData.image || '없음'}", model="${shipData.model || '없음'}"`);

                        const ship = SHIP_TYPES.find(s => s.id === shipData.id);
                        if (ship) {
                            // 이미지와 모델 경로 업데이트 (Supabase Storage로 변환)
                            if (shipData.image && shipData.image.length > 0) {
                                ship.image = convertToSupabaseUrl(shipData.image);
                                console.log(`    ✅ ${ship.id} 이미지 적용: ${ship.image}`);
                            }
                            if (shipData.model && shipData.model.length > 0) {
                                ship.model = convertToSupabaseUrl(shipData.model);
                                console.log(`    ✅ ${ship.id} 모델 적용: ${ship.model}`);
                            }
                            // ★ 엔진 설정 로드
                            if (shipData.engineConfig) {
                                ship.engineConfig = shipData.engineConfig;
                                console.log(`    🔥 ${ship.id} 엔진설정 적용`);
                            }
                        } else {
                            console.log(`    ⚠️ SHIP_TYPES에서 id="${shipData.id}" 를 찾을 수 없음!`);
                        }
                    });

                    // 최종 결과 확인
                    console.log('📦 적용 후 SHIP_TYPES 이미지 현황:');
                    SHIP_TYPES.forEach(s => {
                        console.log(`    ${s.id}: image=${s.image || '없음'}, model=${s.model || '없음'}`);
                    });

                    shipsDataLoaded = true;
                    console.log('✅ ships 데이터 적용 완료');
                })
                .catch(err => {
                    console.log('ℹ️ ships 데이터 로드 실패 (기본 설정 사용)', err);
                    shipsDataLoaded = true;
                });
        }
        
        function loadDataAndInit() {
            // ★ 우주선 데이터 먼저 로드
            loadShipsData();
            
            if (API_URL && window.location.protocol !== 'file:') {
                fetch(API_URL)
                    .then(res => {
                        if (!res.ok) throw new Error('Network response was not ok');
                        return res.json();
                    })
                    .then(data => {
                        Object.assign(DEFAULT_TYPES, data);
                        initSolarSystem(DEFAULT_TYPES);
                    })
                    .catch(err => {
                        console.log("Using default solar system data");
                        initSolarSystem(DEFAULT_TYPES);
                    });
            } else {
                initSolarSystem(DEFAULT_TYPES);
            }
        }

        function createDetailedGalaxy() { 
            // 은하 중심 블랙홀
            const bhSize = 8000;
            const bhGeo = new THREE.SphereGeometry(bhSize, 64, 64); 
            const bhMat = new THREE.MeshBasicMaterial({ color: 0x000000 }); 
            const blackHole = new THREE.Mesh(bhGeo, bhMat); 
            blackHole.position.copy(galaxyCenter);
            scene.add(blackHole); 
            
            // 은하 중심 벌지 글로우
            const bulgeSize = 5000000;  // 10배 증가
            const bulgeGeo = new THREE.SphereGeometry(bulgeSize, 32, 32);
            const bulgeMat = new THREE.MeshBasicMaterial({
                color: 0xfffde8,
                transparent: true,
                opacity: 0.3,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            const bulge = new THREE.Mesh(bulgeGeo, bulgeMat);
            blackHole.add(bulge);
            
            // 내부 벌지 (더 밝게)
            const innerBulgeGeo = new THREE.SphereGeometry(bulgeSize * 0.4, 32, 32);
            const innerBulgeMat = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.5,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            const innerBulge = new THREE.Mesh(innerBulgeGeo, innerBulgeMat);
            blackHole.add(innerBulge);
            
            // ★ 강착원반 생성
            const accretionDiskGroup = new THREE.Group();
            accretionDiskGroup.name = 'accretionDisk';
            
            // 여러 층의 링으로 강착원반 구성
            const diskLayers = [];
            const numLayers = 8;
            for (let i = 0; i < numLayers; i++) {
                const innerR = 100000 + i * 20000;
                const outerR = 120000 + i * 20000;
                const ringGeo = new THREE.RingGeometry(innerR, outerR, 128, 1);
                
                // 안쪽일수록 더 밝고 뜨거운 색
                const heatLevel = 1 - (i / numLayers);
                const color = new THREE.Color();
                if (heatLevel > 0.7) {
                    color.setRGB(1, 1, 0.9);
                } else if (heatLevel > 0.5) {
                    color.setRGB(1, 0.8, 0.3);
                } else if (heatLevel > 0.3) {
                    color.setRGB(1, 0.4, 0.1);
                } else {
                    color.setRGB(0.8, 0.15, 0.05);
                }
                
                const ringMat = new THREE.MeshBasicMaterial({
                    color: color,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.6 + heatLevel * 0.4,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.userData.rotationSpeed = 0.001 + heatLevel * 0.004;
                ring.userData.layerIndex = i;
                diskLayers.push(ring);
                accretionDiskGroup.add(ring);
            }
            
            // 메인 글로우 디스크
            const mainDisk = new THREE.Mesh(
                new THREE.RingGeometry(100000, 350000, 128),
                new THREE.MeshBasicMaterial({ 
                    map: generateAccretionDiskTexture(), 
                    side: THREE.DoubleSide, 
                    transparent: true, 
                    blending: THREE.AdditiveBlending, 
                    depthWrite: false,
                    opacity: 0.8
                })
            );
            mainDisk.userData.rotationSpeed = 0.002;
            accretionDiskGroup.add(mainDisk);
            
            // 내부 글로우
            const innerGlow = new THREE.Mesh(
                new THREE.RingGeometry(85000, 110000, 64),
                new THREE.MeshBasicMaterial({
                    color: 0xffffee,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.9,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                })
            );
            innerGlow.userData.rotationSpeed = 0.008;
            accretionDiskGroup.add(innerGlow);
            
            // 강착원반 기울기
            accretionDiskGroup.rotation.x = Math.PI / 2;
            accretionDiskGroup.rotation.y = Math.PI / 8;
            blackHole.add(accretionDiskGroup);
            
            // 강착원반 데이터 저장 (애니메이션용)
            blackHole.userData.diskLayers = diskLayers;
            blackHole.userData.mainDisk = mainDisk;
            blackHole.userData.innerGlow = innerGlow;
            blackHole.userData.accretionDiskGroup = accretionDiskGroup;
            
            // 제트 (10배 확대)
            const jetGeo = new THREE.CylinderGeometry(10000, 60000, 800000, 32, 1, true);
            jetGeo.translate(0, 400000, 0); 
            const jetMat = new THREE.MeshBasicMaterial({ map: generateJetTexture(), side: THREE.DoubleSide, transparent:true, blending:THREE.AdditiveBlending, depthWrite:false }); 
            const jetGroup = new THREE.Group(); 
            const jetUp = new THREE.Mesh(jetGeo, jetMat); 
            const jetDown = new THREE.Mesh(jetGeo, jetMat); 
            jetDown.rotation.x = Math.PI; 
            jetGroup.add(jetUp); jetGroup.add(jetDown); 
            jetGroup.rotation.z = Math.PI/8; blackHole.add(jetGroup); 
            
            bodies.push({ mesh: blackHole, mass: 10000000, radius: bhSize, velocity: new THREE.Vector3(), force: new THREE.Vector3(), name: '은하 중심', type: 'blackhole', isStatic: true, jets: { up: jetUp, down: jetDown } }); 
            const centerDiv = document.createElement('div'); centerDiv.className = 'galaxy-label'; 
            centerDiv.dataset.bodyName = '은하 중심';
            centerDiv.textContent = translateBodyName('은하 중심'); 
            const centerLabel = new CSS2DObject(centerDiv); 
            centerLabel.position.set(0, bhSize * 1.02, 0);  // 블랙홀 바로 위
            blackHole.add(centerLabel);  // 블랙홀에 추가
            createGalaxyStars(); 
        }

        function createGalaxyStars() { 
            const geom = new THREE.BufferGeometry(); const pos=[], col=[]; const c=new THREE.Color(); 
            
            // 은하 크기 10배 확대
            const galaxyRadius = 80000000;  // 8000만 단위 (10배 확대)
            const clearZone = 5000000;  // 태양계 실제거리 모드 반경 (10배 확대)
            
            // ===== 1. 나선팔 별들 (80,000개) =====
            for(let i=0; i<80000; i++){ 
                const r = Math.pow(Math.random(), 2) * galaxyRadius + 500000;
                // 4개 나선팔 + 강한 나선 감김(15) + 약간의 랜덤
                const ang = (i % 4) * (Math.PI * 2 / 4) + (r / galaxyRadius) * 15 + (Math.random() - 0.5) * 0.5; 
                const x = Math.cos(ang) * r; 
                const z = Math.sin(ang) * r; 
                // 원반 두께 (바깥으로 갈수록 얇아짐) - 10배 확대
                const y = (Math.random() - 0.5) * 1500000 * (1 - r / galaxyRadius); 
                
                const gx = x + galaxyCenter.x; 
                const gy = y + galaxyCenter.y; 
                const gz = z + galaxyCenter.z; 
                
                if(Math.sqrt(gx*gx + gy*gy + gz*gz) < clearZone) continue; 
                pos.push(gx, gy, gz); 
                
                // 색상: 바깥으로 갈수록 파란색
                c.setHSL(0.6 * (r / galaxyRadius) + 0.05, 0.8, 0.8); 
                col.push(c.r, c.g, c.b); 
            }
            
            // ===== 2. 나선팔 사이 배경 별들 (40,000개) =====
            for(let i=0; i<40000; i++){ 
                const r = Math.random() * galaxyRadius * 0.95 + galaxyRadius * 0.05;
                // 완전 랜덤 각도 (나선팔 무시)
                const ang = Math.random() * Math.PI * 2; 
                const x = Math.cos(ang) * r; 
                const z = Math.sin(ang) * r; 
                // 더 얇은 원반 - 10배 확대
                const y = (Math.random() - 0.5) * 800000 * (1 - r / galaxyRadius); 
                
                const gx = x + galaxyCenter.x; 
                const gy = y + galaxyCenter.y; 
                const gz = z + galaxyCenter.z; 
                
                if(Math.sqrt(gx*gx + gy*gy + gz*gz) < clearZone) continue; 
                pos.push(gx, gy, gz); 
                
                // 희미한 노란/주황색 (늙은 별)
                c.setHSL(0.08 + Math.random() * 0.08, 0.4, 0.5 + Math.random() * 0.2); 
                col.push(c.r, c.g, c.b); 
            } 
            
            geom.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3)); 
            geom.setAttribute('color', new THREE.Float32BufferAttribute(col, 3)); 
            const galaxyMat = new THREE.PointsMaterial({
                size: 10000,  // 10배 확대
                vertexColors: true, 
                transparent: true, 
                opacity: 0.9, 
                blending: THREE.AdditiveBlending, 
                sizeAttenuation: true, 
                depthWrite: false, 
                depthTest: true 
            }); 
            const points = new THREE.Points(geom, galaxyMat); 
            window.galaxyPoints = points; 
            scene.add(points); 
            
            // ★ 우리 은하 바깥 배경 별들 (사방에 점 형태)
            createBackgroundStars();
            
            // ★ 안드로메다 은하 (M31)
            createAndromedaGalaxy();
            
            // 먼 은하들 (희미한 점으로만 표시)
            createBackgroundGalaxies();
            
            // 성운들 추가 (희미한 구름)
            createNebulae();
        }
        
        // 우리 은하 바깥 배경 별들
        function createBackgroundStars() {
            const starCount = 8000;
            const positions = new Float32Array(starCount * 3);
            const colors = new Float32Array(starCount * 3);
            const c = new THREE.Color();
            
            for (let i = 0; i < starCount; i++) {
                // 구형으로 사방에 배치
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 90000000 + Math.random() * 100000000;  // 9000만~19000만 (은하 바로 바깥) - 10배 확대
                
                positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = r * Math.cos(phi);
                
                // 다양한 별 색상
                const colorType = Math.random();
                if (colorType < 0.1) {
                    c.setHSL(0.6, 0.5, 0.8);  // 파란별
                } else if (colorType < 0.2) {
                    c.setHSL(0.05, 0.6, 0.8);  // 붉은별
                } else {
                    c.setHSL(0.15, 0.3, 0.7 + Math.random() * 0.3);  // 노란/흰색
                }
                colors[i * 3] = c.r;
                colors[i * 3 + 1] = c.g;
                colors[i * 3 + 2] = c.b;
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 50000,  // 10배 확대
                vertexColors: true,
                transparent: true,
                opacity: 1.0,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true,
                depthWrite: false
            });

            const stars = new THREE.Points(geometry, material);
            scene.add(stars);
        }

        // 태양계 주변 로컬 별들 (태양에서 수백~수천 광년 내 별들)
        // 태양계는 은하 안에 있으므로, 이 별들은 은하 원반의 일부
        
        // 안드로메다 은하 (뿌옇지만 은하 형태 + 별 점들)
        function createAndromedaGalaxy() {
            const galaxyGroup = new THREE.Group();
            const position = new THREE.Vector3(80000000, 20000000, -50000000);  // 10배 확대
            const size = 6000000;  // 10배 확대
            
            galaxyGroup.position.copy(position);
            galaxyGroup.rotation.x = 0.3;
            galaxyGroup.rotation.z = 0.5;
            
            // ===== 1. 나선 은하 형태의 별 점들 =====
            const starCount = 10000;
            const positions = new Float32Array(starCount * 3);
            const colors = new Float32Array(starCount * 3);
            const baseColor = new THREE.Color(0xaaccff);
            
            for (let i = 0; i < starCount; i++) {
                const armIndex = Math.floor(Math.random() * 4);
                const armAngle = (armIndex / 4) * Math.PI * 2;
                const r = Math.pow(Math.random(), 0.6) * size;
                
                const spiralAngle = armAngle + (r / size) * Math.PI * 3 + (Math.random() - 0.5) * 1.2;
                
                const x = Math.cos(spiralAngle) * r + (Math.random() - 0.5) * size * 0.15;
                const z = Math.sin(spiralAngle) * r + (Math.random() - 0.5) * size * 0.15;
                const y = (Math.random() - 0.5) * size * 0.05;
                
                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;
                
                const brightness = 0.06 + 0.04 * (1 - r / size);  // 밝기 5배 감소
                colors[i * 3] = baseColor.r * brightness;
                colors[i * 3 + 1] = baseColor.g * brightness;
                colors[i * 3 + 2] = baseColor.b * brightness;
            }
            
            const starGeometry = new THREE.BufferGeometry();
            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            starGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const starMaterial = new THREE.PointsMaterial({
                size: 300000,  // 10배 확대
                vertexColors: true,
                transparent: true,
                opacity: 0.3,  // 밝기 증가
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true
            });
            
            const stars = new THREE.Points(starGeometry, starMaterial);
            galaxyGroup.add(stars);
            
            // ===== 2. 뿌연 중심 벌지 (밝게) =====
            const bulgeGeo = new THREE.SphereGeometry(size * 0.15, 32, 32);
            const bulgeMat = new THREE.MeshBasicMaterial({
                color: 0xffeedd,
                transparent: true,
                opacity: 0.09,  // 밝기 5배 감소
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            const bulge = new THREE.Mesh(bulgeGeo, bulgeMat);
            galaxyGroup.add(bulge);
            
            // 중간 벌지
            const midBulgeGeo = new THREE.SphereGeometry(size * 0.3, 32, 32);
            const midBulgeMat = new THREE.MeshBasicMaterial({
                color: 0xddccbb,
                transparent: true,
                opacity: 0.05,  // 밝기 5배 감소
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            const midBulge = new THREE.Mesh(midBulgeGeo, midBulgeMat);
            midBulge.scale.set(1, 0.3, 1);
            galaxyGroup.add(midBulge);
            
            // ===== 3. 뿌연 원반 (나선팔 형태) =====
            for (let layer = 0; layer < 4; layer++) {
                const diskGeo = new THREE.RingGeometry(
                    size * (0.15 + layer * 0.15),
                    size * (0.35 + layer * 0.2),
                    64, 1
                );
                const diskMat = new THREE.MeshBasicMaterial({
                    color: 0xaabbdd,
                    transparent: true,
                    opacity: 0.04 - layer * 0.008,  // 밝기 5배 감소
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });
                const disk = new THREE.Mesh(diskGeo, diskMat);
                disk.rotation.x = Math.PI / 2;
                disk.rotation.z = layer * 0.3;
                galaxyGroup.add(disk);
            }
            
            // 외곽 뿌연 헤일로
            const haloGeo = new THREE.SphereGeometry(size * 0.7, 32, 32);
            const haloMat = new THREE.MeshBasicMaterial({
                color: 0x8899aa,
                transparent: true,
                opacity: 0.03,  // 밝기 5배 감소
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            const halo = new THREE.Mesh(haloGeo, haloMat);
            halo.scale.set(1.2, 0.25, 1);
            galaxyGroup.add(halo);
            
            galaxyGroup.userData.name = 'andromeda';
            scene.add(galaxyGroup);
            
            // ★ 안드로메다 은하 라벨 추가
            const andromedaDiv = document.createElement('div');
            andromedaDiv.className = 'galaxy-label';
            andromedaDiv.dataset.bodyName = '안드로메다은하';
            andromedaDiv.textContent = t('andromeda');
            const andromedaLabel = new CSS2DObject(andromedaDiv);
            andromedaLabel.position.set(0, size * 0.02, 0);
            galaxyGroup.add(andromedaLabel);
        }
        
        // 배경 은하들 (점으로 표시)
        function createBackgroundGalaxies() {
            // ===== 1. 가까운 은하들 (우리 은하 바로 바깥) =====
            const nearGalaxyCount = 100;
            const nearPositions = new Float32Array(nearGalaxyCount * 3);
            const nearColors = new Float32Array(nearGalaxyCount * 3);
            
            for (let i = 0; i < nearGalaxyCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 90000000 + Math.random() * 60000000;  // 9000만~15000만 (은하 바로 바깥) - 10배 확대
                
                nearPositions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                nearPositions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                nearPositions[i * 3 + 2] = r * Math.cos(phi);
                
                const colorType = Math.random();
                const brightness = 1.4 + Math.random() * 0.6;  // 2배 밝게
                if (colorType < 0.4) {
                    nearColors[i * 3] = 0.7 * brightness;
                    nearColors[i * 3 + 1] = 0.8 * brightness;
                    nearColors[i * 3 + 2] = 1 * brightness;
                } else if (colorType < 0.7) {
                    nearColors[i * 3] = 1 * brightness;
                    nearColors[i * 3 + 1] = 0.9 * brightness;
                    nearColors[i * 3 + 2] = 0.7 * brightness;
                } else {
                    nearColors[i * 3] = 1 * brightness;
                    nearColors[i * 3 + 1] = 1 * brightness;
                    nearColors[i * 3 + 2] = 1 * brightness;
                }
            }
            
            const nearGeometry = new THREE.BufferGeometry();
            nearGeometry.setAttribute('position', new THREE.BufferAttribute(nearPositions, 3));
            nearGeometry.setAttribute('color', new THREE.BufferAttribute(nearColors, 3));
            
            const nearMaterial = new THREE.PointsMaterial({
                size: 1000000,  // 10배 확대
                vertexColors: true,
                transparent: true,
                opacity: 1.0,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true
            });
            
            scene.add(new THREE.Points(nearGeometry, nearMaterial));
            
            // ===== 2. 중간 거리 은하들 =====
            const midGalaxyCount = 150;
            const midPositions = new Float32Array(midGalaxyCount * 3);
            const midColors = new Float32Array(midGalaxyCount * 3);
            
            for (let i = 0; i < midGalaxyCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 150000000 + Math.random() * 100000000;  // 1억5천만~2억5천만 - 10배 확대
                
                midPositions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                midPositions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                midPositions[i * 3 + 2] = r * Math.cos(phi);
                
                const colorType = Math.random();
                const brightness = 1.4 + Math.random() * 0.6;  // 2배 밝게
                if (colorType < 0.4) {
                    midColors[i * 3] = 0.7 * brightness;
                    midColors[i * 3 + 1] = 0.8 * brightness;
                    midColors[i * 3 + 2] = 1 * brightness;
                } else if (colorType < 0.7) {
                    midColors[i * 3] = 1 * brightness;
                    midColors[i * 3 + 1] = 0.9 * brightness;
                    midColors[i * 3 + 2] = 0.7 * brightness;
                } else {
                    midColors[i * 3] = 0.9 * brightness;
                    midColors[i * 3 + 1] = 0.9 * brightness;
                    midColors[i * 3 + 2] = 0.9 * brightness;
                }
            }
            
            const midGeometry = new THREE.BufferGeometry();
            midGeometry.setAttribute('position', new THREE.BufferAttribute(midPositions, 3));
            midGeometry.setAttribute('color', new THREE.BufferAttribute(midColors, 3));
            
            const midMaterial = new THREE.PointsMaterial({
                size: 800000,  // 10배 확대
                vertexColors: true,
                transparent: true,
                opacity: 1.0,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true
            });
            
            scene.add(new THREE.Points(midGeometry, midMaterial));
        }
        
        // 성운 생성 (뿌연 구름만) - 은하 내부에 위치
        function createNebulae() {
            // 성운 데이터 - 10배 확대
            const nebulaData = [
                { pos: new THREE.Vector3(50000000, 20000000, -30000000), size: 8000000, color: 0xff6688, name: '장미 성운' },
                { pos: new THREE.Vector3(-40000000, -10000000, 60000000), size: 6000000, color: 0x66aaff, name: '오리온 성운' },
                { pos: new THREE.Vector3(30000000, -25000000, -50000000), size: 10000000, color: 0x88ff88, name: '독수리 성운' },
                { pos: new THREE.Vector3(-60000000, 15000000, -20000000), size: 5000000, color: 0xffaa66, name: '게 성운' },
                { pos: new THREE.Vector3(70000000, 5000000, 40000000), size: 7000000, color: 0xaa88ff, name: '고리 성운' }
            ];
            
            nebulaData.forEach(nebula => {
                const nebulaGroup = new THREE.Group();
                nebulaGroup.position.copy(nebula.pos);
                
                // 여러 층의 뿌연 구체만 (점 없이)
                for (let i = 0; i < 6; i++) {
                    const size = nebula.size * (0.4 + i * 0.2);
                    const geo = new THREE.SphereGeometry(size, 24, 24);
                    const mat = new THREE.MeshBasicMaterial({
                        color: nebula.color,
                        transparent: true,
                        opacity: 0.025 - i * 0.003,
                        blending: THREE.AdditiveBlending,
                        depthWrite: false,
                        side: THREE.DoubleSide
                    });
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.scale.set(1 + Math.random() * 0.4, 0.5 + Math.random() * 0.4, 1 + Math.random() * 0.4);
                    mesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                    nebulaGroup.add(mesh);
                }
                
                nebulaGroup.userData.name = nebula.name;
                scene.add(nebulaGroup);
            });
        }

        function startPlacing(item, btn) { 
            if(ghostMesh) scene.remove(ghostMesh); 
            isPlacing=true; 
            spawnData=item; 
            const geo=new THREE.SphereGeometry(item.type.r,16,16); 
            const mat=new THREE.MeshBasicMaterial({color:0xffffff,wireframe:true,transparent:true,opacity:0.3}); 
            ghostMesh=new THREE.Mesh(geo,mat); 
            scene.add(ghostMesh); 
            if (btn) {
                document.querySelectorAll('.spawn-btn').forEach(b=>b.classList.remove('active')); 
                btn.classList.add('active'); 
            }
            showMsg(`${item.name} 생성 모드 (드래그하여 배치, 방향=속도)`); 
        }

        function onMouseMove(e) { 
            if (!isPlacing || !ghostMesh) return; 
            mouse.x=(e.clientX/window.innerWidth)*2-1; 
            mouse.y=-(e.clientY/window.innerHeight)*2+1; 
            raycaster.setFromCamera(mouse, camera); 
            const target=new THREE.Vector3(); 
            raycaster.ray.intersectPlane(plane, target); 
            
            // 드래그 중이면 방향선 업데이트
            if (isDraggingBody && dragStartPos && target) {
                if (dragLine) scene.remove(dragLine);
                const dir = new THREE.Vector3().subVectors(target, dragStartPos);
                const len = dir.length();
                const arrowGeo = new THREE.BufferGeometry().setFromPoints([
                    dragStartPos,
                    target
                ]);
                const arrowMat = new THREE.LineBasicMaterial({ 
                    color: len > 50 ? 0xff6600 : 0x00ff00,
                    linewidth: 2 
                });
                dragLine = new THREE.Line(arrowGeo, arrowMat);
                scene.add(dragLine);
            } else if(target) {
                ghostMesh.position.copy(target); 
            }
        }

        // 마우스 다운 - 드래그 시작
        function onMouseDown(e) {
            if (!isPlacing || !ghostMesh) return;
            // e.target이 없거나 closest 메서드가 없으면 건너뛰기
            if(e.target && e.target.closest && (e.target.closest('.spawn-btn')||e.target.closest('#top-bar')||e.target.closest('#catalog-modal')||e.target.closest('#btn-catalog'))) return; 
            
            mouse.x=(e.clientX/window.innerWidth)*2-1; 
            mouse.y=-(e.clientY/window.innerHeight)*2+1; 
            raycaster.setFromCamera(mouse, camera); 
            const target=new THREE.Vector3(); 
            raycaster.ray.intersectPlane(plane, target); 
            
            if (target) {
                dragStartPos = target.clone();
                ghostMesh.position.copy(target);
                isDraggingBody = true;
            }
        }

        // 마우스 업 - 배치 완료
        function onMouseUp(e) {
            if (!isPlacing || !ghostMesh || !isDraggingBody) return;
            
            mouse.x=(e.clientX/window.innerWidth)*2-1; 
            mouse.y=-(e.clientY/window.innerHeight)*2+1; 
            raycaster.setFromCamera(mouse, camera); 
            const target=new THREE.Vector3(); 
            raycaster.ray.intersectPlane(plane, target); 
            
            if (target && dragStartPos) {
                // 드래그 방향과 거리로 초기 속도 계산
                const dragVec = new THREE.Vector3().subVectors(target, dragStartPos);
                const dragLen = dragVec.length();
                
                // 속도 스케일 (드래그 길이에 비례, 최대 제한)
                const speedScale = Math.min(dragLen * 0.0001, 0.05);
                const velocity = dragVec.normalize().multiplyScalar(speedScale);
                
                createBody(spawnData.type, dragStartPos.clone(), velocity, spawnData.name+" (New)", spawnData.tex); 
                
                // 정리
                if (dragLine) {
                    scene.remove(dragLine);
                    dragLine = null;
                }
                scene.remove(ghostMesh); 
                ghostMesh=null; 
                isPlacing=false; 
                isDraggingBody = false;
                dragStartPos = null;
                
                const speedKmS = (speedScale * 1000).toFixed(1);
                showMsg(`생성 완료! 초기 속도: ${speedKmS} km/s`); 
            }
        }

        function onMouseClick(e) { 
            if(e.target.closest('.spawn-btn')||e.target.closest('#top-bar')||e.target.closest('#catalog-modal')||e.target.closest('#btn-catalog')) return; 
            
            // 드래그 배치 모드에서는 click 무시 (mousedown/mouseup으로 처리)
            if(isPlacing && ghostMesh) return;
            
            mouse.x=(e.clientX/window.innerWidth)*2-1; 
            mouse.y=-(e.clientY/window.innerHeight)*2+1; 
            raycaster.setFromCamera(mouse, camera); 
            
            // 주차된 우주선도 클릭 대상에 추가
            const allMeshes = [...bodies.filter(b => b && b.mesh).map(b=>b.mesh), ...satellites.filter(s => s && s.mesh).map(s=>s.mesh)];
            if (parkedShipMesh) {
                allMeshes.push(parkedShipMesh);
            }
            const intersects = raycaster.intersectObjects(allMeshes, true); 
            
            let foundTarget = null;
            
            if(intersects.length > 0) {
                const targetMesh = intersects[0].object;
                
                // 주차된 우주선 클릭 확인
                if (parkedShipMesh) {
                    let checkMesh = targetMesh;
                    while (checkMesh) {
                        if (checkMesh === parkedShipMesh) {
                            const parkedShipBody = {
                                name: `🚀 ${getShipName(SHIP_TYPES[parkedShipMesh.userData.shipTypeIndex])}`,
                                mesh: parkedShipMesh,
                                isParkedShip: true,
                                shipTypeIndex: parkedShipMesh.userData.shipTypeIndex
                            };
                            focusBody(parkedShipBody);
                            return;
                        }
                        checkMesh = checkMesh.parent;
                    }
                }
                
                foundTarget = bodies.find(b => b && b.mesh && (b.mesh === targetMesh || b.mesh === targetMesh.parent));
                if (!foundTarget) {
                    foundTarget = satellites.find(s => {
                        if (!s || !s.mesh) return false;
                        if (s.mesh === targetMesh) return true;
                        let parent = targetMesh.parent;
                        while(parent) {
                            if(parent === s.mesh) return true;
                            parent = parent.parent;
                        }
                        return false;
                    });
                }
            }
            
            // Fallback: 직접 감지 안되면 화면 좌표 기준 가장 가까운 천체 찾기
            // (raycast로 직접 맞춘 경우에만 작동하도록 범위 축소)
            if (!foundTarget) {
                const clickX = e.clientX;
                const clickY = e.clientY;
                let minDist = 35;  // 35px 이내만 감지 (더 정확하게)
                
                // 모든 천체와 위성 검사
                const allBodies = [...bodies, ...satellites];
                allBodies.forEach(b => {
                    if (!b || !b.mesh) return;
                    
                    // 3D 위치를 화면 좌표로 변환
                    const pos = new THREE.Vector3();
                    b.mesh.getWorldPosition(pos);
                    pos.project(camera);
                    
                    const screenX = (pos.x * 0.5 + 0.5) * window.innerWidth;
                    const screenY = (-pos.y * 0.5 + 0.5) * window.innerHeight;
                    
                    // 화면상 거리 계산
                    const dist = Math.sqrt((clickX - screenX) ** 2 + (clickY - screenY) ** 2);
                    
                    // 천체 크기에 따라 감지 범위 조절
                    const radius = b.radius || 1;
                    const threshold = Math.max(40, Math.min(100, radius * 10));
                    
                    if (dist < threshold && dist < minDist) {
                        minDist = dist;
                        foundTarget = b;
                    }
                });
            }
            
            if(foundTarget) focusBody(foundTarget);
        }

        function onResize() { 
            camera.aspect=window.innerWidth/window.innerHeight; 
            camera.updateProjectionMatrix(); 
            renderer.setSize(window.innerWidth, window.innerHeight); 
            labelRenderer.setSize(window.innerWidth, window.innerHeight); 
        }

        function renderCatalog() {
            const catalogContent = document.getElementById('catalog-content');
            catalogContent.innerHTML = ''; 
            
            // 태양계 천체 목록 (멀티모드용)
            const SOLAR_SYSTEM_BODIES = [
                'SUN', 'MERCURY', 'VENUS', 'EARTH', 'MARS', 
                'JUPITER', 'SATURN', 'URANUS', 'NEPTUNE',
                'MOON', 'PHOBOS', 'DEIMOS',
                'IO', 'EUROPA', 'GANYMEDE', 'CALLISTO',
                'TITAN', 'ENCELADUS', 'MIMAS', 'RHEA', 'DIONE', 'IAPETUS',
                'TITANIA', 'OBERON', 'MIRANDA', 'ARIEL', 'UMBRIEL',
                'TRITON', 'PLUTO', 'CHARON', 'CERES', 'ERIS'
            ];
            
            // 한글 이름 매핑
            const KOREAN_NAMES = {
                'SUN': '태양', 'MERCURY': '수성', 'VENUS': '금성', 'EARTH': '지구', 'MARS': '화성',
                'JUPITER': '목성', 'SATURN': '토성', 'URANUS': '천왕성', 'NEPTUNE': '해왕성',
                'MOON': '달', 'PHOBOS': '포보스', 'DEIMOS': '데이모스',
                'IO': '이오', 'EUROPA': '유로파', 'GANYMEDE': '가니메데', 'CALLISTO': '칼리스토',
                'TITAN': '타이탄', 'ENCELADUS': '엔셀라두스', 'MIMAS': '미마스', 
                'RHEA': '레아', 'DIONE': '디오네', 'IAPETUS': '이아페투스',
                'TITANIA': '티타니아', 'OBERON': '오베론', 'MIRANDA': '미란다', 
                'ARIEL': '아리엘', 'UMBRIEL': '움브리엘',
                'TRITON': '트리톤', 'PLUTO': '명왕성', 'CHARON': '카론', 
                'CERES': '세레스', 'ERIS': '에리스'
            };
            
            // 멀티모드면 태양계만, 싱글모드면 전체
            const keysToShow = (window.gameMode === 'multi') 
                ? SOLAR_SYSTEM_BODIES.filter(key => DEFAULT_TYPES[key])
                : Object.keys(DEFAULT_TYPES);
            
            keysToShow.forEach(key => {
                const data = DEFAULT_TYPES[key];
                if (!data) return;
                
                const card = document.createElement('div');
                card.className = 'catalog-card';
                const thumb = document.createElement('div');
                thumb.className = 'catalog-thumb';
                
                // 먼저 NASA/위키 이미지 사용, 없으면 텍스처 또는 색상
                if (CELESTIAL_IMAGES[key]) {
                    thumb.style.backgroundImage = `url('${CELESTIAL_IMAGES[key]}')`;
                    thumb.style.backgroundSize = 'cover';
                    thumb.style.backgroundPosition = 'center';
                } else {
                    let texUrl = '';
                    if (data.texKey) {
                       texUrl = TEXTURES[data.texKey] ? ASSET_PATH + TEXTURES[data.texKey].map : data.texKey;
                    }
                    if (texUrl) {
                        thumb.style.backgroundImage = `url('${texUrl}')`;
                    } else {
                        const colorHex = (typeof data.color === 'number') ? '#' + new THREE.Color(data.color).getHexString() : data.color;
                        thumb.style.backgroundColor = colorHex;
                        if(data.type==='star') thumb.style.boxShadow = `0 0 10px ${colorHex}`;
                    }
                }
                const name = document.createElement('div');
                name.className = 'catalog-name';
                // 멀티모드에서는 한글 이름, 싱글에서는 영어
                name.innerText = (window.gameMode === 'multi' && KOREAN_NAMES[key]) ? KOREAN_NAMES[key] : key;
                card.appendChild(thumb);
                card.appendChild(name);
                
                // 데스크톱 클릭
                card.onclick = () => {
                    document.getElementById('catalog-modal').classList.remove('open');
                    // 멀티모드: 정보 표시, 싱글모드: 생성
                    if (window.gameMode === 'multi') {
                        showBodyInfo(key, data);
                    } else {
                        startPlacing({ name: key, type: data, tex: data.texKey }, null);
                    }
                };
                
                // 싱글모드에서만 모바일 드래그 배치 활성화
                if (window.gameMode !== 'multi') {
                    // 모바일 드래그 배치
                    let catDragGhost = null;
                    let catIsDragging = false;
                    let catStartPos = null;
                    
                    card.addEventListener('touchstart', (e) => {
                        catStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                        catIsDragging = false;
                    });
                    
                    card.addEventListener('touchmove', (e) => {
                        if (!catStartPos) return;
                        const touch = e.touches[0];
                        const dx = touch.clientX - catStartPos.x;
                        const dy = touch.clientY - catStartPos.y;
                        
                        if (Math.abs(dx) > 20 || Math.abs(dy) > 20) {
                            catIsDragging = true;
                            
                            if (!catDragGhost) {
                                // 도감 닫기
                                document.getElementById('catalog-modal').classList.remove('open');
                                
                                // 드래그 고스트 생성
                                catDragGhost = document.createElement('div');
                                catDragGhost.style.cssText = `
                                    position: fixed;
                                    width: 60px;
                                    height: 60px;
                                    border-radius: 50%;
                                    z-index: 10000;
                                    pointer-events: none;
                                    opacity: 0.9;
                                    border: 3px solid #e74c3c;
                                    box-shadow: 0 0 30px #e74c3c;
                                    background-image: ${thumb.style.backgroundImage || 'none'};
                                    background-size: cover;
                                    background-position: center;
                                    background-color: ${thumb.style.backgroundColor || '#333'};
                                `;
                                document.body.appendChild(catDragGhost);
                            }
                            catDragGhost.style.left = (touch.clientX - 30) + 'px';
                            catDragGhost.style.top = (touch.clientY - 30) + 'px';
                        }
                    });
                    
                    card.addEventListener('touchend', (e) => {
                        if (catDragGhost && catIsDragging) {
                            const touch = e.changedTouches[0];
                            // 드롭 위치 계산
                            mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
                            mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
                            raycaster.setFromCamera(mouse, camera);
                            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                            const target = new THREE.Vector3();
                            raycaster.ray.intersectPlane(plane, target);
                            
                            if (target) {
                                // ★★★ 1단계: 위치에 대기 천체 생성 (아직 물리 적용 안됨) ★★★
                                createPendingBody(data, target.clone(), key, data.texKey);
                            }
                            catDragGhost.remove();
                        }
                        catDragGhost = null;
                        catIsDragging = false;
                        catStartPos = null;
                    });
                }
                
                catalogContent.appendChild(card);
            });
        }

        function initUI() { 
            const dock = document.getElementById('spawn-dock'); 
            dock.innerHTML = ''; 
            
            // 멀티모드에서는 천체 생성 버튼 숨기기
            if (window.gameMode === 'multi') {
                dock.style.display = 'none';
                return;
            }
            dock.style.display = 'flex';
            
            SPAWN_LIST.forEach(item => { 
                const btn = document.createElement('div'); 
                btn.className = 'spawn-btn'; 
                btn.dataset.name = item.name; 
                
                // NASA/위키 실제 이미지 우선 사용
                if (item.tex && CELESTIAL_IMAGES[item.tex]) {
                    btn.style.backgroundImage = `url('${CELESTIAL_IMAGES[item.tex]}')`;
                    btn.style.backgroundSize = 'cover';
                    btn.style.backgroundPosition = 'center';
                } else {
                    let texUrl = '';
                    if (item.tex) {
                       texUrl = TEXTURES[item.tex] ? ASSET_PATH + TEXTURES[item.tex].map : null;
                    }
                    if (texUrl) {
                        btn.style.backgroundImage = `url('${texUrl}')`;
                    } else {
                        btn.style.backgroundColor = '#555';
                    }
                }

                btn.onclick = (e) => { 
                    e.stopPropagation(); 
                    startPlacing(item, btn); 
                }; 
                
                // 모바일 드래그 배치
                let dragGhost = null;
                let isDragging = false;
                
                btn.addEventListener('touchstart', (e) => {
                    if (e.cancelable) e.preventDefault();
                    isDragging = false;
                    
                    // 드래그 고스트 생성
                    dragGhost = document.createElement('div');
                    dragGhost.className = 'spawn-btn drag-ghost';
                    dragGhost.style.cssText = `
                        position: fixed;
                        width: 50px;
                        height: 50px;
                        border-radius: 50%;
                        z-index: 10000;
                        pointer-events: none;
                        opacity: 0.8;
                        border: 3px solid #e74c3c;
                        box-shadow: 0 0 20px #e74c3c;
                        background-image: ${btn.style.backgroundImage || 'none'};
                        background-size: cover;
                        background-position: center;
                        background-color: ${btn.style.backgroundColor || '#555'};
                    `;
                    const touch = e.touches[0];
                    dragGhost.style.left = (touch.clientX - 25) + 'px';
                    dragGhost.style.top = (touch.clientY - 25) + 'px';
                    document.body.appendChild(dragGhost);
                });
                
                btn.addEventListener('touchmove', (e) => {
                    if (!dragGhost) return;
                    if (e.cancelable) e.preventDefault();
                    isDragging = true;
                    const touch = e.touches[0];
                    dragGhost.style.left = (touch.clientX - 25) + 'px';
                    dragGhost.style.top = (touch.clientY - 25) + 'px';
                });
                
                btn.addEventListener('touchend', (e) => {
                    if (!dragGhost) return;
                    
                    if (isDragging) {
                        const touch = e.changedTouches[0];
                        // 드롭 위치 계산
                        mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
                        mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
                        raycaster.setFromCamera(mouse, camera);
                        const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                        const target = new THREE.Vector3();
                        raycaster.ray.intersectPlane(plane, target);
                        
                        if (target) {
                            // ★★★ 1단계: 위치에 대기 천체 생성 (아직 물리 적용 안됨) ★★★
                            createPendingBody(item.type, target.clone(), item.name, item.tex);
                        }
                    } else {
                        // 짧은 탭 = 기존 배치 모드
                        startPlacing(item, btn);
                    }
                    
                    dragGhost.remove();
                    dragGhost = null;
                    isDragging = false;
                });
                
                dock.appendChild(btn); 
            }); 
        }

        function initSolarSystem(types) {
            createBody(types.SUN, new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,0), "태양", null);
            
            // 실제 궤도 데이터 기반 행성 배치
            const baseUnit = 2200;  // 기본 단위 (지구 궤도) - 220→2200 (10배 증가)
            const planets = [
                { type: types.MERCURY, name: "수성", tex: "MERCURY" }, 
                { type: types.VENUS, name: "금성", tex: "VENUS" }, 
                { type: types.EARTH, name: "지구", tex: "EARTH" }, 
                { type: types.MARS, name: "화성", tex: "MARS" }, 
                { type: types.JUPITER, name: "목성", tex: "JUPITER" }, 
                { type: types.SATURN, name: "토성", tex: "SATURN" }, 
                { type: types.URANUS, name: "천왕성", tex: "URANUS" }, 
                { type: types.NEPTUNE, name: "해왕성", tex: "NEPTUNE" }
            ];
            
            const now = Date.now() * 0.00001;

            planets.forEach(p => {
                const orbitData = REAL_ORBIT_DATA[p.name];
                if (!orbitData) return;
                
                // ★★★ 타원 궤도 계산 ★★★
                const a = baseUnit * orbitData.au * CONFIG.distScale;  // 장반경
                const e = orbitData.e || 0;  // 이심률
                const inc = (orbitData.i || 0) * Math.PI / 180;  // 경사각 (라디안)
                const omega = (orbitData.omega || 0) * Math.PI / 180;  // 근일점 경도 (라디안)
                
                // 평균 근점이각 (Mean Anomaly) - 시간에 따라 변화
                const periodFactor = 1 / Math.pow(orbitData.au, 1.5);  // 케플러 제3법칙
                const M = (now * periodFactor * 2 + p.name.charCodeAt(0) * 0.5) % (2 * Math.PI);
                
                // 이심 근점이각 (Eccentric Anomaly) - 케플러 방정식 풀이
                let E = M;
                for (let i = 0; i < 10; i++) {
                    E = M + e * Math.sin(E);  // 반복법
                }
                
                // 진근점이각 (True Anomaly)
                const nu = 2 * Math.atan2(
                    Math.sqrt(1 + e) * Math.sin(E / 2),
                    Math.sqrt(1 - e) * Math.cos(E / 2)
                );
                
                // 궤도 평면에서의 거리
                const r = a * (1 - e * e) / (1 + e * Math.cos(nu));
                
                // 궤도 평면에서의 위치 (근일점 경도 적용)
                const xOrbit = r * Math.cos(nu + omega);
                const yOrbit = r * Math.sin(nu + omega);
                
                // 궤도 경사각 적용하여 3D 위치 계산
                const x = xOrbit;
                const y = yOrbit * Math.sin(inc);  // 경사각에 의한 Y 성분
                const z = yOrbit * Math.cos(inc);
                
                // ★★★ 타원 궤도 속도 계산 (vis-viva 방정식) ★★★
                // v² = GM(2/r - 1/a)
                const GM = CONFIG.G * types.SUN.m;
                const speed = Math.sqrt(GM * (2 / r - 1 / a));
                
                // 속도 방향 (궤도에 접선 방향)
                const vAngle = nu + omega + Math.PI / 2;  // 진행 방향
                const vxOrbit = speed * Math.cos(vAngle);
                const vyOrbit = speed * Math.sin(vAngle);
                
                // 경사각 적용
                const vx = vxOrbit;
                const vy = vyOrbit * Math.sin(inc);
                const vz = vyOrbit * Math.cos(inc);

                // 천체 생성 시 궤도 데이터 저장
                const body = createBody(p.type, new THREE.Vector3(x, y, z), new THREE.Vector3(vx, vy, vz), p.name, p.type.texKey || p.tex);
                if (body) {
                    body.orbitData = {
                        a: a,
                        e: e,
                        i: inc,
                        omega: omega,
                        period: orbitData.period
                    };
                }
            });
            
            // 궤도 라인 생성
            createAllOrbitLines();
            createMoons();
        }
        
        // ★★★ 멀티모드용 태양계 재초기화 (실제 거리) ★★★
        function reinitSolarSystemForMulti() {
            console.log('멀티모드: 태양계 재초기화 (distScale=' + CONFIG.distScale + ')');
            
            // 궤도 라인 제거
            clearOrbitLines();
            
            // 위성 제거
            satellites.forEach(s => {
                if (s && s.mesh) {
                    scene.remove(s.mesh);
                    s.mesh.traverse(c => {
                        if (c.isCSS2DObject && c.element && c.element.parentNode) {
                            c.element.parentNode.removeChild(c.element);
                        }
                    });
                }
            });
            satellites = [];
            
            // 모든 천체 제거 (태양 포함)
            bodies.forEach(b => {
                if (b && b.mesh) {
                    scene.remove(b.mesh);
                    b.mesh.traverse(c => {
                        if (c.isCSS2DObject && c.element && c.element.parentNode) {
                            c.element.parentNode.removeChild(c.element);
                        }
                    });
                }
                if (b && b.trail) scene.remove(b.trail);
            });
            bodies = [];
            
            // 파티클 제거
            particles.forEach(p => { if(p && p.mesh) scene.remove(p.mesh); });
            particles = [];
            
            // 새로운 distScale로 태양계 재생성
            initSolarSystem(DEFAULT_TYPES);
            
            // ★★★ 멀티모드: 서버 시간 기준으로 천체 위치 동기화 ★★★
            window.multiEpoch = new Date('2025-01-01T00:00:00Z').getTime();  // 고정 기준점

            // 서버 시간 동기화 후 천체 위치 계산
            async function syncCelestialPositions() {
                // 서버 시간 동기화 시도
                if (typeof syncServerTime === 'function') {
                    await syncServerTime();
                }

                // 동기화된 시간 사용 (getSyncedTime이 없으면 Date.now 사용)
                const syncedTime = typeof getSyncedTime === 'function' ? getSyncedTime() : Date.now();
                const elapsedDays = (syncedTime - window.multiEpoch) / (1000 * 60 * 60 * 24);

                // 각 천체의 궤도 위상을 서버 시간 기준으로 계산
                bodies.forEach(b => {
                    if (b.orbitalPeriod && b.orbitalPeriod > 0) {
                        const orbitsCompleted = elapsedDays / b.orbitalPeriod;
                        b.trueAnomaly = (orbitsCompleted * 2 * Math.PI) % (2 * Math.PI);
                    }
                });

                // 위성들도 동기화
                satellites.forEach(sat => {
                    if (sat.orbitalPeriod && sat.orbitalPeriod > 0) {
                        const orbitsCompleted = elapsedDays / sat.orbitalPeriod;
                        sat.angle = (orbitsCompleted * 2 * Math.PI) % (2 * Math.PI);
                    }
                });

                console.log('멀티모드: 서버 시간 동기화 완료 (경과:', elapsedDays.toFixed(2), '일, 오프셋:', serverTimeOffset, 'ms)');
            }

            syncCelestialPositions();
            
            // ISS 재생성
            setTimeout(() => {
                if (typeof createISS === 'function') createISS();
            }, 500);
            
            console.log('멀티모드: 태양계 재초기화 완료');
        }
        
        // ★★★ 태양계 완전 초기화 (사용자 버튼용) ★★★
        function resetSolarSystemComplete() {
            console.log('태양계 완전 초기화 시작...');
            
            // 우주선 도킹 해제
            if (playerShip && playerShip.isDocked) {
                playerShip.isDocked = false;
            }
            
            // 궤도 라인 제거
            clearOrbitLines();
            
            // 모든 위성 제거
            satellites.forEach(s => {
                if (s && s.mesh) {
                    scene.remove(s.mesh);
                    s.mesh.traverse(c => {
                        if (c.isCSS2DObject && c.element && c.element.parentNode) {
                            c.element.parentNode.removeChild(c.element);
                        }
                    });
                }
            });
            satellites = [];
            
            // 모든 천체 제거 (태양 포함)
            bodies.forEach(b => {
                if (b && b.mesh) {
                    scene.remove(b.mesh);
                    b.mesh.traverse(c => {
                        if (c.isCSS2DObject && c.element && c.element.parentNode) {
                            c.element.parentNode.removeChild(c.element);
                        }
                    });
                }
                if (b && b.trail) scene.remove(b.trail);
            });
            bodies = [];
            
            // 파티클 제거
            particles.forEach(p => { if(p && p.mesh) scene.remove(p.mesh); });
            particles = [];
            
            // 케플러 시간 리셋 (멀티모드는 Date.now 기준)
            keplerTime = window.gameMode === 'multi' ? Date.now() * 0.00000001 : Date.now() * 0.00001;
            
            // 태양계 재생성
            initSolarSystem(DEFAULT_TYPES);
            
            // 궤도 라인 재생성
            createAllOrbitLines();
            
            // ISS 재생성
            setTimeout(() => {
                if (typeof createISS === 'function') createISS();
            }, 300);
            
            // 카메라를 태양으로 포커스
            setTimeout(() => {
                const sun = bodies.find(b => b.name === '태양');
                if (sun) {
                    focusedBody = sun;
                    camera.position.set(0, 300, 500);
                    controls.target.set(0, 0, 0);
                }
            }, 500);
            
            console.log('태양계 완전 초기화 완료!');
        }
        window.resetSolarSystemComplete = resetSolarSystemComplete;

        function resetSimulation() {
            // 궤도 라인 제거
            clearOrbitLines();
            
            satellites.forEach(s => {
                if (s && s.mesh) {
                    scene.remove(s.mesh);
                    s.mesh.traverse(c => {
                        if (c.isCSS2DObject && c.element && c.element.parentNode) c.element.parentNode.removeChild(c.element);
                    });
                }
            });
            satellites = [];

            const toRemove = bodies.filter(b => b && !b.isStatic);
            toRemove.forEach(b => {
                if (b && b.mesh) {
                    scene.remove(b.mesh);
                    b.mesh.traverse(c => {
                        if (c.isCSS2DObject && c.element && c.element.parentNode) c.element.parentNode.removeChild(c.element);
                    });
                }
                if(b && b.trail) scene.remove(b.trail);
            });
            bodies = bodies.filter(b => b && b.isStatic);
            particles.forEach(p => { if(p && p.mesh) scene.remove(p.mesh); });
            particles = [];
            loadDataAndInit();
        }

        // ===== 1인칭 조종석 시스템 =====
        
        function createCockpitForShip() {
            if (!playerShip || !playerShip.mesh) return;
            
            // 이미 조종석이 있으면 제거
            if (cockpitGroup) {
                playerShip.mesh.remove(cockpitGroup);
            }
            
            // 헥스 텍스처 생성
            function createHexTexture() {
                const c = document.createElement('canvas'); c.width = 512; c.height = 512;
                const ctx = c.getContext('2d');
                ctx.fillStyle = '#050505'; ctx.fillRect(0, 0, 512, 512);
                ctx.strokeStyle = '#333'; ctx.lineWidth = 3;
                for (let y = 0; y < 512; y += 40) {
                    for (let x = 0; x < 512; x += 35) {
                        if ((Math.floor(y / 40)) % 2 == 0) ctx.strokeRect(x, y, 30, 30);
                        else ctx.strokeRect(x + 17, y, 30, 30);
                    }
                }
                const t = new THREE.CanvasTexture(c);
                t.wrapS = t.wrapT = THREE.RepeatWrapping; t.repeat.set(6, 4);
                return t;
            }
            const hexTex = createHexTexture();
            
            // 재질 정의 - ★ 모든 불투명 재질에 depthWrite 강제
            const mats = {
                hullInterior: new THREE.MeshStandardMaterial({ 
                    map: hexTex, color: 0x444444, roughness: 0.5, metalness: 0.7, side: THREE.BackSide 
                }),
                glass: new THREE.MeshStandardMaterial({ 
                    color: 0x88ccff, metalness: 0.1, roughness: 0.0, 
                    transparent: true, opacity: 0.15, side: THREE.DoubleSide
                }),
                frame: new THREE.MeshStandardMaterial({ 
                    color: 0x222222, roughness: 0.2, metalness: 0.9
                }),
                seat: new THREE.MeshStandardMaterial({ 
                    color: 0x333333, roughness: 0.4, metalness: 0.6
                }),
                glowBlue: new THREE.MeshBasicMaterial({ color: 0x00ffff }),
                glowOrange: new THREE.MeshBasicMaterial({ color: 0xffaa00 }),
                hologram: new THREE.MeshBasicMaterial({ 
                    color: 0x00ffff, transparent: true, opacity: 0.3, 
                    side: THREE.DoubleSide, blending: THREE.AdditiveBlending, depthWrite: false 
                })
            };
            
            cockpitGroup = new THREE.Group();
            cockpitGroup.name = 'cockpitGroup';  // ★ 이름 추가
            cockpitGroup.scale.set(0.4, 0.4, 0.4);  // 우주선 크기에 맞게 
            cockpitGroup.position.set(0, 0, -0.2);  // 우주선 전방 (콘 안쪽)
            
            // ★ 조종석이 항상 천체 위에 렌더링되도록 설정
            cockpitGroup.renderOrder = 999;
            
            // ★ 언도킹 연출 중이면 숨김
            if (undockingState && undockingState.active) {
                cockpitGroup.visible = false;
            }
            
            playerShip.mesh.add(cockpitGroup);
            
            // ★ 조종석 재질들의 depthTest 설정을 위한 함수
            function setCockpitMaterial(mat) {
                mat.depthTest = true;
                mat.depthWrite = true;
            }
            
            // 조명
            const innerLight = new THREE.PointLight(0x00aaff, 1.5, 10);
            innerLight.position.set(0, 1, 0);
            cockpitGroup.add(innerLight);
            const dashLight = new THREE.PointLight(0x00ffff, 0.8, 5);
            dashLight.position.set(0, -0.5, -1);
            cockpitGroup.add(dashLight);
            
            // --- 구형 쉘 (후방 반구) ---
            const rearGeo = new THREE.SphereGeometry(2, 64, 64, 0, Math.PI * 2, 0, Math.PI * 0.55);
            const rearShell = new THREE.Mesh(rearGeo, mats.hullInterior);
            rearShell.rotation.x = Math.PI / 2;
            cockpitGroup.add(rearShell);
            
            // 중앙 링
            const ringGeo = new THREE.TorusGeometry(1.9, 0.05, 16, 64);
            const ring = new THREE.Mesh(ringGeo, mats.frame);
            ring.position.z = 0.25;
            cockpitGroup.add(ring);
            
            // 전방 유리 (반투명 - 우주가 보임)
            const glassGeo = new THREE.SphereGeometry(1.95, 64, 64, 0, Math.PI * 2, 0, Math.PI * 0.48);
            const glassShell = new THREE.Mesh(glassGeo, mats.glass);
            glassShell.rotation.x = -Math.PI / 2;
            cockpitGroup.add(glassShell);
            
            // 테두리
            const borderGeo = new THREE.TorusGeometry(1.95, 0.08, 16, 100);
            const border = new THREE.Mesh(borderGeo, mats.frame);
            cockpitGroup.add(border);
            
            // --- 플로팅 플랫폼 ---
            const floatGroup = new THREE.Group();
            cockpitGroup.add(floatGroup);
            cockpitFloatGroup = floatGroup;  // 애니메이션용 참조
            
            // 베이스
            const baseGeo = new THREE.CylinderGeometry(0.4, 0.3, 0.15, 32);
            const base = new THREE.Mesh(baseGeo, mats.frame);
            base.position.set(0, -0.6, 0);
            floatGroup.add(base);
            
            // 이미터 (발광)
            const emitter = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.04, 0.2, 16), 
                new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.5 })
            );
            emitter.position.set(0, -0.75, 0);
            floatGroup.add(emitter);
            
            // --- 좌석 ---
            const seatGroup = new THREE.Group();
            seatGroup.position.set(0, -0.45, 0.15);
            floatGroup.add(seatGroup);
            
            // 쿠션
            seatGroup.add(new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.12, 0.5), mats.seat));
            
            // 등받이
            const back = new THREE.Mesh(new THREE.BoxGeometry(0.45, 0.65, 0.08), mats.seat);
            back.position.set(0, 0.35, 0.2);
            back.rotation.x = -0.15;
            seatGroup.add(back);
            
            // 헤드레스트
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.2, 0.08), mats.seat);
            head.position.set(0, 0.72, 0.28);
            seatGroup.add(head);
            
            // 팔걸이
            const armL = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.04, 0.35), mats.seat);
            armL.position.set(-0.38, 0.25, 0);
            seatGroup.add(armL);
            const armR = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.04, 0.35), mats.seat);
            armR.position.set(0.38, 0.25, 0);
            seatGroup.add(armR);
            
            // --- 대칭형 Yoke 조종간 ---
            cockpitStickGroup = new THREE.Group();
            cockpitStickGroup.position.set(0, -0.3, -0.4);
            floatGroup.add(cockpitStickGroup);
            
            // 메인 컬럼 (기둥)
            const colGeo = new THREE.CylinderGeometry(0.03, 0.04, 0.3, 16);
            const column = new THREE.Mesh(colGeo, mats.frame);
            column.position.y = -0.1;
            column.rotation.x = -0.3;
            cockpitStickGroup.add(column);
            
            // 중앙 허브
            const hubGeo = new THREE.BoxGeometry(0.1, 0.06, 0.06);
            const hub = new THREE.Mesh(hubGeo, mats.frame);
            hub.rotation.x = -0.3;
            cockpitStickGroup.add(hub);
            
            // 중앙 미니 스크린
            const hubScreen = new THREE.Mesh(new THREE.PlaneGeometry(0.08, 0.05), mats.hologram);
            hubScreen.position.set(0, 0.01, 0.035);
            hubScreen.rotation.x = -0.3;
            cockpitStickGroup.add(hubScreen);
            
            // 핸들 생성 함수
            function createYokeHandle(side) {
                const handleGrp = new THREE.Group();
                handleGrp.position.set(side * 0.18, 0, 0);
                handleGrp.rotation.x = -0.3;
                
                // 가로바
                const bar = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.02, 0.12, 8), mats.frame);
                bar.rotation.z = Math.PI / 2;
                bar.position.set(-side * 0.06, 0, 0);
                handleGrp.add(bar);
                
                // 그립
                const grip = new THREE.Mesh(new THREE.CylinderGeometry(0.028, 0.025, 0.15, 12), mats.seat);
                grip.rotation.z = side * 0.15;
                handleGrp.add(grip);
                
                // 상단 헤드
                const headMesh = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.05, 0.05), mats.frame);
                headMesh.position.set(side * 0.008, 0.08, 0.008);
                headMesh.rotation.z = side * 0.15;
                handleGrp.add(headMesh);
                
                // 엄지 버튼 (주황)
                const btn1 = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 0.008, 8), mats.glowOrange);
                btn1.position.set(side * 0.008, 0.11, 0.015);
                btn1.rotation.x = 0.5;
                handleGrp.add(btn1);
                
                // 보조 버튼 (파랑)
                const btn2 = new THREE.Mesh(new THREE.BoxGeometry(0.008, 0.015, 0.008), mats.glowBlue);
                btn2.position.set(-side * 0.015, 0.09, 0.015);
                handleGrp.add(btn2);
                
                // 전면 트리거
                const trigger = new THREE.Mesh(new THREE.BoxGeometry(0.015, 0.04, 0.015), mats.glowOrange);
                trigger.position.set(side * 0.008, 0.015, -0.028);
                trigger.rotation.x = 0.2;
                handleGrp.add(trigger);
                
                return handleGrp;
            }
            
            cockpitStickGroup.add(createYokeHandle(-1));  // 왼쪽
            cockpitStickGroup.add(createYokeHandle(1));   // 오른쪽
            
            // --- 곡면 홀로그램 HUD ---
            function createCurvedHUD(h, r, y, isMain) {
                const geometry = new THREE.CylinderGeometry(r, r, h, 32, 1, true, Math.PI * 1.2, Math.PI * 0.6);
                geometry.scale(-1, 1, 1);
                const canvas = document.createElement('canvas');
                canvas.width = 512; canvas.height = 256;
                const tex = new THREE.CanvasTexture(canvas);
                const mat = new THREE.MeshBasicMaterial({ 
                    map: tex, transparent: true, opacity: 0.6, 
                    side: THREE.DoubleSide, blending: THREE.AdditiveBlending, depthWrite: false
                });
                const mesh = new THREE.Mesh(geometry, mat);
                mesh.position.y = y;
                mesh.rotation.y = Math.PI / 2;
                return { ctx: canvas.getContext('2d'), tex, mesh, canvas };
            }
            
            cockpitMainHUD = createCurvedHUD(0.6, 1.1, -0.1, true);
            floatGroup.add(cockpitMainHUD.mesh);
            
            cockpitSubHUD = createCurvedHUD(0.3, 0.6, -0.35, false);
            cockpitSubHUD.mesh.rotation.x = -0.3;
            floatGroup.add(cockpitSubHUD.mesh);
            
            // 버튼 깜빡임용 (기존 호환)
            cockpitBtnMesh = null;
            cockpitBlinkIndices = [];
            cockpitMonitors = {};
        }
        
        function createCarbonTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#111'; ctx.fillRect(0, 0, 256, 256);
            ctx.fillStyle = '#1a1a1a';
            for (let y = 0; y < 256; y += 4) {
                for (let x = 0; x < 256; x += 4) {
                    if ((x + y) % 8 === 0) ctx.fillRect(x, y, 2, 2);
                }
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(4, 4);
            return tex;
        }
        
        function createCockpitMonitor(type, w, h, x, y, z, rotY) {
            const g = new THREE.Group();
            g.position.set(x, y, z);
            g.rotation.y = rotY;
            g.rotation.x = -0.3;
            
            const caseMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.5, metalness: 0.7 });
            g.add(new THREE.Mesh(new THREE.BoxGeometry(w + 0.02, h + 0.02, 0.015), caseMat));
            
            const cvs = document.createElement('canvas');
            cvs.width = 256;
            cvs.height = 256;
            const tex = new THREE.CanvasTexture(cvs);
            const scr = new THREE.Mesh(new THREE.PlaneGeometry(w, h), new THREE.MeshBasicMaterial({ map: tex }));
            scr.position.z = 0.009;
            g.add(scr);
            
            cockpitGroup.add(g);
            cockpitMonitors[type] = { ctx: cvs.getContext('2d'), tex, canvas: cvs };
        }
        
        function updateCockpitMonitors(time) {
            if (!playerShip) return;
            
            // 메인 HUD (속도, 고도, 자세)
            if (cockpitMainHUD && cockpitMainHUD.ctx) {
                const ctx = cockpitMainHUD.ctx;
                ctx.clearRect(0, 0, 512, 256);
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 2;
                
                // 중앙 십자선
                ctx.beginPath();
                ctx.arc(256, 128, 40, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(216, 128);
                ctx.lineTo(180, 128);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(296, 128);
                ctx.lineTo(332, 128);
                ctx.stroke();
                
                // 자세 라인 (피치)
                const pitch = Math.sin(time * 0.5) * 30 + (shipInputs.pitch || 0) * 30;
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
                ctx.beginPath();
                ctx.moveTo(100, 128 + pitch);
                ctx.lineTo(412, 128 + pitch);
                ctx.stroke();
                
                cockpitMainHUD.tex.needsUpdate = true;
            }
            
            // 서브 HUD (레이더)
            if (cockpitSubHUD && cockpitSubHUD.ctx) {
                const ctx = cockpitSubHUD.ctx;
                ctx.clearRect(0, 0, 512, 256);
                ctx.strokeStyle = '#ffaa00';
                ctx.lineWidth = 2;
                
                // 레이더 원
                ctx.beginPath();
                ctx.arc(256, 128, 80, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(256, 128, 40, 0, Math.PI * 2);
                ctx.stroke();
                
                // 스캔 라인
                ctx.beginPath();
                ctx.moveTo(256, 128);
                ctx.lineTo(256 + Math.cos(time * 3) * 80, 128 + Math.sin(time * 3) * 80);
                ctx.stroke();
                
                // 목표 표시
                if (shipTargetBody && playerShip.mesh) {
                    const dir = new THREE.Vector3().subVectors(shipTargetBody.mesh.position, playerShip.mesh.position);
                    dir.normalize();
                    const localDir = dir.clone().applyQuaternion(playerShip.mesh.quaternion.clone().invert());
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                    ctx.beginPath();
                    ctx.arc(256 + localDir.x * 60, 128 - localDir.z * 60, 6, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // 자신 표시
                ctx.fillStyle = '#00ffff';
                ctx.beginPath();
                ctx.arc(256, 128, 4, 0, Math.PI * 2);
                ctx.fill();
                
                cockpitSubHUD.tex.needsUpdate = true;
            }
        }
        
        function updateCockpitView(dt) {
            if (!cockpitGroup || !isPilotMode || isInteriorMode || isObservatoryMode) return;
            if (!playerShip || !playerShip.mesh) return;
            if (window.isDocking) return;  // ★ 도킹 중이면 카메라 업데이트 안 함
            
            const time = performance.now() * 0.001;
            
            // 카메라 회전 보간
            cockpitLookRotY += (cockpitTargetRotY - cockpitLookRotY) * COCKPIT_DAMPING;
            cockpitLookRotX += (cockpitTargetRotX - cockpitLookRotX) * COCKPIT_DAMPING;
            
            // 1인칭 시점일 때 카메라를 조종석 내부에 배치
            if (isCockpitView) {
                // 카메라를 우주선에서 분리하고 직접 위치 설정
                if (camera.parent === playerShip.mesh) {
                    scene.add(camera);
                }
                
                // 조종석 내부 좌석 위치 (cockpitGroup 로컬 좌표)
                const seatPos = new THREE.Vector3(0, 0, 0);  // 구 중앙
                
                // cockpitGroup의 월드 위치 계산
                const cockpitWorldPos = new THREE.Vector3();
                cockpitGroup.getWorldPosition(cockpitWorldPos);
                
                camera.position.copy(cockpitWorldPos);
                
                // 우주선 방향 + 고개 회전
                camera.quaternion.copy(playerShip.mesh.quaternion);
                const headQuat = new THREE.Quaternion().setFromEuler(new THREE.Euler(cockpitLookRotX, cockpitLookRotY, 0, 'YXZ'));
                camera.quaternion.multiply(headQuat);
            }
            
            // 플로팅 플랫폼 애니메이션 (살짝 떠다니는 효과)
            if (cockpitFloatGroup) {
                cockpitFloatGroup.position.y = Math.sin(time * 0.5) * 0.03;
                cockpitFloatGroup.rotation.z = Math.sin(time * 0.2) * 0.015;
            }
            
            // Yoke 조종간 움직임 (입력에 따라)
            if (cockpitStickGroup) {
                // Yoke는 앞뒤로 밀고 당기는 느낌
                cockpitStickGroup.rotation.x = -0.3 + shipInputs.pitch * 0.2 + Math.sin(time * 10) * 0.002;
                // 좌우 기울기
                cockpitStickGroup.rotation.z = -shipInputs.yaw * 0.15 + Math.sin(time * 8) * 0.002;
            }
            
            // 모니터/HUD 업데이트
            updateCockpitMonitors(time);
        }

        // ===== 선내 시스템 함수들 =====
        
        function initInteriorScene() {
            interiorScene = new THREE.Scene();
            interiorScene.background = new THREE.Color(0x050508);
            interiorCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            interiorRenderer = new THREE.WebGLRenderer({ antialias: true });
            interiorRenderer.setSize(window.innerWidth, window.innerHeight);
            interiorRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            interiorRenderer.shadowMap.enabled = true;
            
            interiorScene.add(new THREE.AmbientLight(0xffffff, 0.5));
            interiorScene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.4));
            
            // 전망대 카메라
            obsCamera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 300000000);
            
            createCorridor();
            createDetailedRooms();
        }
        
        function createStaticCollider(x, y, z, w, h, d, mat, name = null) {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
            mesh.position.set(x, y, z);
            mesh.userData.isStatic = true;
            mesh.userData.collider = { 
                min: new THREE.Vector3(x - w/2, y - h/2, z - d/2),
                max: new THREE.Vector3(x + w/2, y + h/2, z + d/2)
            };
            if (name) {
                mesh.userData.name = name;
                interactableObjects.push(mesh);
            }
            allColliders.push(mesh);
            interiorScene.add(mesh);
            return mesh;
        }
        
        function createPhysicsObject(x, y, z, w, h, d, name, color, mass) {
            const mesh = new THREE.Mesh(
                new THREE.BoxGeometry(w, h, d),
                new THREE.MeshStandardMaterial({ color, metalness: 0.3, roughness: 0.7 })
            );
            mesh.position.set(x, y, z);
            mesh.userData.isPhysics = true;
            mesh.userData.name = name;
            mesh.userData.mass = mass;
            mesh.userData.velocity = new THREE.Vector3();
            mesh.userData.size = { w, h, d };
            mesh.userData.collider = {
                min: new THREE.Vector3(x - w/2, y - h/2, z - d/2),
                max: new THREE.Vector3(x + w/2, y + h/2, z + d/2)
            };
            allColliders.push(mesh);
            physicsObjects.push(mesh);
            interactableObjects.push(mesh);
            interiorScene.add(mesh);
            return mesh;
        }
        
        function createDoorTrigger(x, z, side, label, roomId) {
            const frameMat = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.9, roughness: 0.1 });
            const doorMat = new THREE.MeshStandardMaterial({ color: 0x0088ff, metalness: 0.7, roughness: 0.3, emissive: 0x003366, emissiveIntensity: 0.3 });
            const isBack = side === 'back';
            const fw = isBack ? 1.8 : 0.2, fd = isBack ? 0.2 : 1.5;
            let fx = x, fz = z;
            if (side === 'left') fx += 0.1;
            else if (side === 'right') fx -= 0.1;
            
            const frame = new THREE.Mesh(new THREE.BoxGeometry(fw + 0.3, 2.5, fd + 0.15), frameMat);
            frame.position.set(fx, 1.25, fz);
            interiorScene.add(frame);
            
            const door = new THREE.Mesh(new THREE.BoxGeometry(fw, 2.2, fd), doorMat);
            door.position.set(fx, 1.1, fz);
            interiorScene.add(door);
            
            const labelDiv = document.createElement('div');
            labelDiv.className = 'door-label-3d';
            labelDiv.textContent = label;
            labelDiv.style.cssText = 'color:#0ff;font-size:10px;background:rgba(0,40,60,0.8);padding:3px 8px;border-radius:3px;border:1px solid #0ff;';
            const labelObj = new CSS2DObject(labelDiv);
            labelObj.position.set(fx, 2.3, fz);
            interiorScene.add(labelObj);
            
            rooms[roomId] = { 
                doorPosition: new THREE.Vector3(x + (side === 'left' ? 1 : side === 'right' ? -1 : 0), 1.6, z + (side === 'back' ? -1.5 : 0)),
                side: side,
                label: label
            };
        }
        
        function createCorridor() {
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.5, roughness: 0.5 });
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.7, roughness: 0.3 });
            
            // 바닥, 천장
            createStaticCollider(0, 0, 2, 8, 0.1, 35, floorMat);
            createStaticCollider(0, 3, 2, 8, 0.1, 35, new THREE.MeshStandardMaterial({ color: 0x777777 }));
            
            // 벽
            createStaticCollider(-4, 1.5, 2, 0.15, 3, 35, wallMat);
            createStaticCollider(4, 1.5, 2, 0.15, 3, 35, wallMat);
            createStaticCollider(0, 1.5, -15, 8, 3, 0.15, wallMat);
            createStaticCollider(0, 1.5, 19.5, 8, 3, 0.15, wallMat);
            
            // 조명
            [-12, -6, 0, 6, 12, 18].forEach(z => {
                const led = new THREE.Mesh(new THREE.BoxGeometry(2, 0.08, 0.5), new THREE.MeshBasicMaterial({ color: 0xffffff }));
                led.position.set(0, 2.9, z);
                interiorScene.add(led);
                const light = new THREE.PointLight(0xffffff, 1.2, 15);
                light.position.set(0, 2.7, z);
                interiorScene.add(light);
            });
            
            // 조종석 콘솔
            createStaticCollider(0, 0.6, -13.5, 5, 1.2, 1, new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8, roughness: 0.2 }), '조종석 콘솔');
            
            // 항법 디스플레이
            [-1.5, 0, 1.5].forEach(x => {
                const screen = new THREE.Mesh(new THREE.PlaneGeometry(1.2, 0.8), new THREE.MeshBasicMaterial({ color: 0x00ff88 }));
                screen.position.set(x, 1.4, -14);
                screen.userData.name = '항법 디스플레이';
                interactableObjects.push(screen);
                interiorScene.add(screen);
            });
            
            // 문 트리거
            createDoorTrigger(-3.92, -6, 'left', '🔬 연구실', 'lab');
            createDoorTrigger(-3.92, 4, 'left', '🛏️ 휴게실', 'rest');
            createDoorTrigger(3.92, -2, 'right', '⚙️ 엔진룸', 'engine');
            createDoorTrigger(3.92, 10, 'right', '📦 화물칸', 'cargo');
            createDoorTrigger(0, 19, 'back', t('observatory'), 'observatory');
        }
        
        function createDetailedRooms() {
            createLabRoom();
            createRestRoom();
            createEngineRoom();
            createCargoRoom();
            createObservatoryRoom();
        }
        
        function createLabRoom() {
            const cx = -12, cz = -6, w = 8, d = 8;
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x556688, metalness: 0.4, roughness: 0.6 });
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x777788, metalness: 0.6, roughness: 0.4 });
            
            createStaticCollider(cx, 0, cz, w, 0.1, d, floorMat);
            createStaticCollider(cx, 3, cz, w, 0.1, d, new THREE.MeshStandardMaterial({ color: 0x666677 }));
            createStaticCollider(cx - 4, 1.5, cz, 0.15, 3, d, wallMat);
            createStaticCollider(cx, 1.5, cz - 4, w, 3, 0.15, wallMat);
            createStaticCollider(cx, 1.5, cz + 4, w, 3, 0.15, wallMat);
            
            const light = new THREE.PointLight(0xaaccff, 1.5, 15);
            light.position.set(cx, 2.7, cz);
            interiorScene.add(light);
            
            createStaticCollider(cx - 2, 0.5, cz - 2, 2.5, 0.1, 1.2, new THREE.MeshStandardMaterial({ color: 0x445566 }), '연구 데스크');
            createPhysicsObject(cx - 2.5, 1.1, cz - 2, 0.3, 0.6, 0.3, '전자 현미경', 0x333344, 2);
            createPhysicsObject(cx - 1, 0.7, cz - 2, 0.4, 0.3, 0.3, '노트북', 0x222233, 1);
            
            // 홀로그램 프로젝터
            const holoBase = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 0.1, 16), new THREE.MeshStandardMaterial({ color: 0x333344, metalness: 0.9 }));
            holoBase.position.set(cx + 2, 0.8, cz);
            holoBase.userData.name = '홀로그램 프로젝터';
            interactableObjects.push(holoBase);
            interiorScene.add(holoBase);
            
            const holoDisplay = new THREE.Mesh(new THREE.IcosahedronGeometry(0.35, 1), new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.5, wireframe: true }));
            holoDisplay.position.set(cx + 2, 1.4, cz);
            holoDisplay.userData.name = 'DNA 분자 모델';
            holoDisplay.userData.animate = (t) => { holoDisplay.rotation.y = t; holoDisplay.rotation.x = t * 0.5; };
            interactableObjects.push(holoDisplay);
            interiorScene.add(holoDisplay);
            
            rooms['lab'].enterPosition = new THREE.Vector3(cx + 2, 1.6, cz);
            rooms['lab'].bounds = { minX: cx - 3.5, maxX: cx + 3.5, minZ: cz - 3.5, maxZ: cz + 3.5 };
        }
        
        function createRestRoom() {
            const cx = -12, cz = 4, w = 8, d = 8;
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x665555, metalness: 0.3, roughness: 0.7 });
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x776666, metalness: 0.5, roughness: 0.5 });
            
            createStaticCollider(cx, 0, cz, w, 0.1, d, floorMat);
            createStaticCollider(cx, 3, cz, w, 0.1, d, new THREE.MeshStandardMaterial({ color: 0x665555 }));
            createStaticCollider(cx - 4, 1.5, cz, 0.15, 3, d, wallMat);
            createStaticCollider(cx, 1.5, cz - 4, w, 3, 0.15, wallMat);
            createStaticCollider(cx, 1.5, cz + 4, w, 3, 0.15, wallMat);
            
            const light = new THREE.PointLight(0xffddaa, 1.2, 15);
            light.position.set(cx, 2.7, cz);
            interiorScene.add(light);
            
            createStaticCollider(cx - 2, 0.35, cz - 2, 1.8, 0.5, 2.2, new THREE.MeshStandardMaterial({ color: 0x334455 }), '수면 포드 A');
            createStaticCollider(cx - 2, 0.35, cz + 2, 1.8, 0.5, 2.2, new THREE.MeshStandardMaterial({ color: 0x334455 }), '수면 포드 B');
            createStaticCollider(cx + 1.5, 0.4, cz, 1.2, 0.08, 1.2, new THREE.MeshStandardMaterial({ color: 0x443322 }), '다용도 테이블');
            createPhysicsObject(cx + 1.3, 0.55, cz - 0.3, 0.08, 0.12, 0.08, '커피 머그', 0xdddddd, 0.15);
            
            rooms['rest'].enterPosition = new THREE.Vector3(cx + 2, 1.6, cz);
            rooms['rest'].bounds = { minX: cx - 3.5, maxX: cx + 3.5, minZ: cz - 3.5, maxZ: cz + 3.5 };
        }
        
        function createEngineRoom() {
            const cx = 12, cz = -2, w = 8, d = 8;
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x554444, metalness: 0.6, roughness: 0.4 });
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x665555, metalness: 0.7, roughness: 0.3 });
            
            createStaticCollider(cx, 0, cz, w, 0.1, d, floorMat);
            createStaticCollider(cx, 3, cz, w, 0.1, d, new THREE.MeshStandardMaterial({ color: 0x443333 }));
            createStaticCollider(cx + 4, 1.5, cz, 0.15, 3, d, wallMat);
            createStaticCollider(cx, 1.5, cz - 4, w, 3, 0.15, wallMat);
            createStaticCollider(cx, 1.5, cz + 4, w, 3, 0.15, wallMat);
            
            const light1 = new THREE.PointLight(0xff4400, 0.8, 15);
            light1.position.set(cx, 2.7, cz);
            interiorScene.add(light1);
            
            // 엔진 코어
            const coreGeo = new THREE.CylinderGeometry(0.8, 1.0, 2.5, 16);
            const coreMat = new THREE.MeshStandardMaterial({ color: 0x222233, metalness: 0.9, roughness: 0.1 });
            const core = new THREE.Mesh(coreGeo, coreMat);
            core.position.set(cx + 2, 1.25, cz);
            core.userData.name = '핵융합 엔진 코어';
            interactableObjects.push(core);
            interiorScene.add(core);
            
            // 엔진 글로우
            const glowGeo = new THREE.CylinderGeometry(0.5, 0.5, 2.0, 16);
            const glowMat = new THREE.MeshBasicMaterial({ color: 0x00aaff, transparent: true, opacity: 0.6 });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            glow.position.set(cx + 2, 1.25, cz);
            glow.userData.animate = (t) => { glow.material.opacity = 0.4 + Math.sin(t * 5) * 0.2; };
            engineParts.push(glow);
            interiorScene.add(glow);
            
            rooms['engine'].enterPosition = new THREE.Vector3(cx - 2, 1.6, cz);
            rooms['engine'].bounds = { minX: cx - 3.5, maxX: cx + 3.5, minZ: cz - 3.5, maxZ: cz + 3.5 };
        }
        
        function createCargoRoom() {
            const cx = 12, cz = 10, w = 8, d = 8;
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x555544, metalness: 0.4, roughness: 0.6 });
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x666655, metalness: 0.5, roughness: 0.5 });
            
            createStaticCollider(cx, 0, cz, w, 0.1, d, floorMat);
            createStaticCollider(cx, 3, cz, w, 0.1, d, new THREE.MeshStandardMaterial({ color: 0x555544 }));
            createStaticCollider(cx + 4, 1.5, cz, 0.15, 3, d, wallMat);
            createStaticCollider(cx, 1.5, cz - 4, w, 3, 0.15, wallMat);
            createStaticCollider(cx, 1.5, cz + 4, w, 3, 0.15, wallMat);
            
            const light = new THREE.PointLight(0xffffaa, 1.0, 15);
            light.position.set(cx, 2.7, cz);
            interiorScene.add(light);
            
            // 화물 상자들
            createPhysicsObject(cx - 2, 0.4, cz - 2, 0.8, 0.8, 0.8, '화물 상자 A', 0x886644, 5);
            createPhysicsObject(cx - 1, 0.4, cz + 1, 0.8, 0.8, 0.8, '화물 상자 B', 0x886644, 5);
            createPhysicsObject(cx + 1, 0.3, cz - 1, 0.6, 0.6, 0.6, '보급품 박스', 0x448844, 3);
            
            rooms['cargo'].enterPosition = new THREE.Vector3(cx - 2, 1.6, cz);
            rooms['cargo'].bounds = { minX: cx - 3.5, maxX: cx + 3.5, minZ: cz - 3.5, maxZ: cz + 3.5 };
        }
        
        function createObservatoryRoom() {
            const cx = 0, cz = 25, r = 5;
            
            // 돔 바닥
            const floorGeo = new THREE.CircleGeometry(r, 32);
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x333344, metalness: 0.6, roughness: 0.4 });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(cx, 0.05, cz);
            interiorScene.add(floor);
            
            // 유리 돔 (반투명)
            const domeGeo = new THREE.SphereGeometry(r, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const domeMat = new THREE.MeshBasicMaterial({ color: 0x000011, transparent: true, opacity: 0.3, side: THREE.DoubleSide });
            const dome = new THREE.Mesh(domeGeo, domeMat);
            dome.position.set(cx, 0, cz);
            interiorScene.add(dome);
            
            // 망원경
            const scopeBase = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 0.5, 16), new THREE.MeshStandardMaterial({ color: 0x444455, metalness: 0.8 }));
            scopeBase.position.set(cx, 0.25, cz);
            scopeBase.userData.name = '천체 망원경';
            interactableObjects.push(scopeBase);
            interiorScene.add(scopeBase);
            
            const scopeTube = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.2, 1.5, 16), new THREE.MeshStandardMaterial({ color: 0x222233, metalness: 0.9 }));
            scopeTube.position.set(cx, 1.2, cz);
            scopeTube.rotation.x = Math.PI / 4;
            interiorScene.add(scopeTube);
            
            rooms['observatory'].enterPosition = new THREE.Vector3(cx, 1.6, cz - 3);
            rooms['observatory'].bounds = { minX: cx - r + 0.5, maxX: cx + r - 0.5, minZ: cz - r + 0.5, maxZ: cz + r - 0.5 };
            rooms['observatory'].isObservatory = true;
        }
        
        // 선내 이동 관련 함수들
        function aabbIntersect(aMin, aMax, bMin, bMax) {
            return (aMin.x <= bMax.x && aMax.x >= bMin.x) &&
                   (aMin.y <= bMax.y && aMax.y >= bMin.y) &&
                   (aMin.z <= bMax.z && aMax.z >= bMin.z);
        }
        
        function updateInteriorPlayer(dt) {
            if (!isInteriorMode) return;
            const speed = 3.5;
            const playerRadius = 0.3;
            
            const fwd = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), interiorPlayer.rotationY);
            const right = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), interiorPlayer.rotationY);
            
            const vel = new THREE.Vector3();
            vel.add(fwd.clone().multiplyScalar(moveInput.z * speed * dt));  // 전진/후진 수정
            vel.add(right.clone().multiplyScalar(moveInput.x * speed * dt));
            
            const newPos = interiorPlayer.position.clone().add(vel);
            newPos.y = 1.6;
            
            let canMoveX = true, canMoveZ = true;
            
            for (const obj of allColliders) {
                if (!obj.userData.collider) continue;
                if (obj.userData.isPhysics) {
                    const s = obj.userData.size;
                    obj.userData.collider.min.set(obj.position.x - s.w/2, obj.position.y - s.h/2, obj.position.z - s.d/2);
                    obj.userData.collider.max.set(obj.position.x + s.w/2, obj.position.y + s.h/2, obj.position.z + s.d/2);
                }
                const col = obj.userData.collider;
                
                const testMinX = new THREE.Vector3(newPos.x - playerRadius, 0.5, interiorPlayer.position.z - playerRadius);
                const testMaxX = new THREE.Vector3(newPos.x + playerRadius, 1.8, interiorPlayer.position.z + playerRadius);
                if (aabbIntersect(testMinX, testMaxX, col.min, col.max)) canMoveX = false;
                
                const testMinZ = new THREE.Vector3(interiorPlayer.position.x - playerRadius, 0.5, newPos.z - playerRadius);
                const testMaxZ = new THREE.Vector3(interiorPlayer.position.x + playerRadius, 1.8, newPos.z + playerRadius);
                if (aabbIntersect(testMinZ, testMaxZ, col.min, col.max)) canMoveZ = false;
            }
            
            let bounds;
            if (currentRoom === 'corridor') {
                bounds = { minX: -3.5, maxX: 3.5, minZ: -14, maxZ: 18 };
            } else if (rooms[currentRoom] && rooms[currentRoom].bounds) {
                bounds = rooms[currentRoom].bounds;
            }
            
            if (bounds) {
                if (newPos.x - playerRadius < bounds.minX || newPos.x + playerRadius > bounds.maxX) canMoveX = false;
                if (newPos.z - playerRadius < bounds.minZ || newPos.z + playerRadius > bounds.maxZ) canMoveZ = false;
            }
            
            if (canMoveX) interiorPlayer.position.x = newPos.x;
            if (canMoveZ) interiorPlayer.position.z = newPos.z;
            
            interiorCamera.position.copy(interiorPlayer.position);
            updateCameraRotation();
            checkDoorProximity();
        }
        
        function updatePhysicsObjects(dt) {
            const gravity = 9.8;
            const friction = 0.92;
            const groundY = 0.05;
            
            for (const obj of physicsObjects) {
                if (!obj.userData.isPhysics) continue;
                const vel = obj.userData.velocity;
                const size = obj.userData.size;
                
                if (obj.position.y > groundY + size.h / 2 + 0.01) {
                    vel.y -= gravity * dt;
                } else {
                    obj.position.y = groundY + size.h / 2;
                    vel.y = 0;
                    vel.x *= friction;
                    vel.z *= friction;
                }
                
                obj.position.add(vel.clone().multiplyScalar(dt));
            }
        }
        
        function updateCameraRotation() {
            interiorCamera.rotation.order = 'YXZ';
            interiorCamera.rotation.y = interiorPlayer.rotationY;
            interiorCamera.rotation.x = interiorPlayer.pitchX;
        }
        
        function checkDoorProximity() {
            nearDoor = null;
            const playerPos = interiorPlayer.position;
            
            for (const [roomId, room] of Object.entries(rooms)) {
                if (room.doorPosition) {
                    const dist = playerPos.distanceTo(room.doorPosition);
                    if (dist < 2) {
                        nearDoor = roomId;
                        break;
                    }
                }
            }
            
            const doorPrompt = document.getElementById('door-prompt');
            if (doorPrompt) {
                if (nearDoor && currentRoom === 'corridor') {
                    doorPrompt.textContent = `[E] Enter ${rooms[nearDoor].label}`;
                    doorPrompt.classList.add('active');
                } else if (currentRoom !== 'corridor') {
                    doorPrompt.textContent = t('exitToCorridor');
                    doorPrompt.classList.add('active');
                } else {
                    doorPrompt.classList.remove('active');
                }
            }
        }
        
        function enterRoom(roomId) {
            if (!rooms[roomId]) return;
            currentRoom = roomId;
            
            if (rooms[roomId].enterPosition) {
                interiorPlayer.position.copy(rooms[roomId].enterPosition);
            }
            
            if (rooms[roomId].isObservatory) {
                enterObservatoryFromInterior();
            }
        }
        
        function exitCurrentRoom() {
            if (currentRoom !== 'corridor') {
                const room = rooms[currentRoom];
                if (room && room.doorPosition) {
                    interiorPlayer.position.copy(room.doorPosition);
                    if (room.side === 'left') interiorPlayer.rotationY = -Math.PI / 2;
                    else if (room.side === 'right') interiorPlayer.rotationY = Math.PI / 2;
                    else interiorPlayer.rotationY = Math.PI;
                    interiorPlayer.pitchX = 0;
                }
                currentRoom = 'corridor';
            } else {
                exitInteriorMode();
            }
        }
        
        function enterInteriorMode() {
            if (!autopilot.engaged) {
                showMsg('⚠️ Only available in autopilot mode');
                return;
            }
            
            isInteriorMode = true;
            isObservatoryMode = false;
            isCockpitView = false;
            document.getElementById('cockpit-hud').classList.remove('active');
            document.getElementById('observatory-hud').classList.remove('active');
            document.getElementById('interior-hud').classList.add('active');
            
            const container = document.getElementById('canvas-container');
            if (!container.contains(interiorRenderer.domElement)) {
                container.appendChild(interiorRenderer.domElement);
            }
            interiorRenderer.domElement.style.display = 'block';
            renderer.domElement.style.display = 'none';
            labelRenderer.domElement.style.display = 'none';
            
            // 모바일 조이스틱 표시
            if ('ontouchstart' in window) {
                document.getElementById('move-joystick').classList.add('active');
            }
            
            if (currentRoom === 'corridor') {
                interiorPlayer.position.set(0, 1.6, -10);
                interiorPlayer.rotationY = Math.PI;
                interiorPlayer.pitchX = 0;
            }
            interiorCamera.position.copy(interiorPlayer.position);
            updateCameraRotation();
            showMsg('🚀 Entered interior. WASD to move, mouse to look around');
        }
        
        function exitInteriorMode() {
            isInteriorMode = false;
            isCockpitView = true;  // 조종석 뷰로 복귀
            document.getElementById('interior-hud').classList.remove('active');
            document.getElementById('cockpit-hud').classList.add('active');
            document.getElementById('door-prompt').classList.remove('active');
            document.getElementById('move-joystick').classList.remove('active');
            
            interiorRenderer.domElement.style.display = 'none';
            renderer.domElement.style.display = 'block';
            labelRenderer.domElement.style.display = 'block';
            currentRoom = 'corridor';
            lookDragging = false;
        }
        
        // 전망대 모드
        function enterObservatoryMode() {
            if (!autopilot.engaged) {
                showMsg('⚠️ Observatory available only in autopilot mode');
                return;
            }
            
            isObservatoryMode = true;
            isInteriorMode = false;
            isCockpitView = false;
            document.getElementById('cockpit-hud').classList.remove('active');
            document.getElementById('interior-hud').classList.remove('active');
            document.getElementById('observatory-hud').classList.add('active');
            
            interiorRenderer.domElement.style.display = 'none';
            renderer.domElement.style.display = 'block';
            labelRenderer.domElement.style.display = 'block';
            
            if (playerShip && playerShip.mesh) {
                obsCamera.position.copy(playerShip.mesh.position);
            }
            obsCamRotation = { theta: 0, phi: Math.PI / 2 };
            showMsg('🔭 Observe the universe in 360° from the observatory');
        }
        
        function enterObservatoryFromInterior() {
            isObservatoryMode = true;
            isInteriorMode = false;
            document.getElementById('interior-hud').classList.remove('active');
            document.getElementById('observatory-hud').classList.add('active');
            
            interiorRenderer.domElement.style.display = 'none';
            renderer.domElement.style.display = 'block';
            labelRenderer.domElement.style.display = 'block';
            
            if (playerShip && playerShip.mesh) {
                obsCamera.position.copy(playerShip.mesh.position);
            }
            obsCamRotation = { theta: 0, phi: Math.PI / 2 };
        }
        
        function exitObservatoryMode() {
            isObservatoryMode = false;
            isCockpitView = true;  // 조종석 뷰로 복귀
            document.getElementById('observatory-hud').classList.remove('active');
            document.getElementById('cockpit-hud').classList.add('active');
        }
        
        function updateObservatoryCamera() {
            if (!isObservatoryMode || !playerShip || !playerShip.mesh) return;
            
            obsCamera.position.copy(playerShip.mesh.position);
            
            const x = Math.sin(obsCamRotation.phi) * Math.cos(obsCamRotation.theta);
            const y = Math.cos(obsCamRotation.phi);
            const z = Math.sin(obsCamRotation.phi) * Math.sin(obsCamRotation.theta);
            
            const target = new THREE.Vector3(x, y, z).add(obsCamera.position);
            obsCamera.lookAt(target);
        }
        
        function initInteriorControls() {
            // 버튼 연결
            document.getElementById('btn-int-back').onclick = exitInteriorMode;
            document.getElementById('btn-open-door').onclick = () => {
                if (nearDoor && currentRoom === 'corridor') enterRoom(nearDoor);
                else if (currentRoom !== 'corridor') exitCurrentRoom();
            };
            document.getElementById('btn-obs-back').onclick = () => {
                isObservatoryMode = false;
                enterInteriorMode();
            };
            
            // 모바일 이동 조이스틱
            const moveJS = document.getElementById('move-joystick');
            const moveKnob = document.getElementById('move-joystick-knob');
            
            moveJS.addEventListener('touchstart', (e) => {
                if (!isInteriorMode) return;
                e.preventDefault();
                moveJoystickActive = true;
                const rect = moveJS.getBoundingClientRect();
                moveJoystickCenter = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
            }, { passive: false });
            
            moveJS.addEventListener('touchmove', (e) => {
                if (!isInteriorMode || !moveJoystickActive) return;
                e.preventDefault();
                const touch = e.touches[0];
                let dx = touch.clientX - moveJoystickCenter.x;
                let dy = touch.clientY - moveJoystickCenter.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const maxR = 50;
                if (dist > maxR) { dx = dx / dist * maxR; dy = dy / dist * maxR; }
                moveKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                moveInput.x = dx / maxR;
                moveInput.z = dy / maxR;
            }, { passive: false });
            
            moveJS.addEventListener('touchend', () => {
                moveJoystickActive = false;
                moveKnob.style.transform = 'translate(-50%, -50%)';
                moveInput.x = 0;
                moveInput.z = 0;
            });
            
            // 키보드 이동 (WASD)
            window.addEventListener('keydown', (e) => {
                if (!isInteriorMode) return;
                if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') moveInput.z = 1;
                if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') moveInput.z = -1;
                if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') moveInput.x = -1;
                if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') moveInput.x = 1;
                if (e.key === 'e' || e.key === 'E') {
                    if (nearDoor && currentRoom === 'corridor') enterRoom(nearDoor);
                    else if (currentRoom !== 'corridor') exitCurrentRoom();
                }
                if (e.key === 'Escape') exitInteriorMode();
            });
            
            window.addEventListener('keyup', (e) => {
                if (!isInteriorMode) return;
                if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') moveInput.z = 0;
                if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') moveInput.z = 0;
                if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') moveInput.x = 0;
                if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') moveInput.x = 0;
            });
            
            // 마우스 시점 (선내)
            interiorRenderer.domElement.addEventListener('mousedown', (e) => {
                if (!isInteriorMode) return;
                lookDragging = true;
                lastLookPos = { x: e.clientX, y: e.clientY };
            });
            
            window.addEventListener('mousemove', (e) => {
                if (!isInteriorMode || !lookDragging) return;
                const dx = e.clientX - lastLookPos.x;
                const dy = e.clientY - lastLookPos.y;
                interiorPlayer.rotationY -= dx * 0.003;
                interiorPlayer.pitchX -= dy * 0.003;
                interiorPlayer.pitchX = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, interiorPlayer.pitchX));
                lastLookPos = { x: e.clientX, y: e.clientY };
                updateCameraRotation();
            });
            
            window.addEventListener('mouseup', () => { lookDragging = false; });
            
            // 터치 시점 (선내)
            interiorRenderer.domElement.addEventListener('touchstart', (e) => {
                if (!isInteriorMode) return;
                const touch = e.touches[0];
                if (touch.clientX < 160 && touch.clientY > window.innerHeight - 200) return;
                e.preventDefault();
                lookDragging = true;
                lastLookPos = { x: touch.clientX, y: touch.clientY };
            }, { passive: false });
            
            interiorRenderer.domElement.addEventListener('touchmove', (e) => {
                if (!isInteriorMode || !lookDragging) return;
                e.preventDefault();
                const touch = e.touches[0];
                const dx = touch.clientX - lastLookPos.x;
                const dy = touch.clientY - lastLookPos.y;
                interiorPlayer.rotationY -= dx * 0.005;
                interiorPlayer.pitchX -= dy * 0.005;
                interiorPlayer.pitchX = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, interiorPlayer.pitchX));
                lastLookPos = { x: touch.clientX, y: touch.clientY };
                updateCameraRotation();
            }, { passive: false });
            
            interiorRenderer.domElement.addEventListener('touchend', () => { lookDragging = false; });
        }
        
        function initObservatoryControls() {
            // 마우스 드래그 (전망대)
            renderer.domElement.addEventListener('mousedown', (e) => {
                if (!isObservatoryMode) return;
                obsDragging = true;
                obsLastPos = { x: e.clientX, y: e.clientY };
            });
            
            window.addEventListener('mousemove', (e) => {
                if (!isObservatoryMode || !obsDragging) return;
                const dx = e.clientX - obsLastPos.x;
                const dy = e.clientY - obsLastPos.y;
                obsCamRotation.theta -= dx * 0.005;
                obsCamRotation.phi -= dy * 0.005;
                obsCamRotation.phi = Math.max(0.1, Math.min(Math.PI - 0.1, obsCamRotation.phi));
                obsLastPos = { x: e.clientX, y: e.clientY };
            });
            
            window.addEventListener('mouseup', () => { obsDragging = false; });
            
            // 터치 (전망대)
            renderer.domElement.addEventListener('touchstart', (e) => {
                if (!isObservatoryMode) return;
                e.preventDefault();
                obsDragging = true;
                obsLastPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }, { passive: false });
            
            renderer.domElement.addEventListener('touchmove', (e) => {
                if (!isObservatoryMode || !obsDragging) return;
                e.preventDefault();
                const t = e.touches[0];
                const dx = t.clientX - obsLastPos.x;
                const dy = t.clientY - obsLastPos.y;
                obsCamRotation.theta -= dx * 0.005;
                obsCamRotation.phi -= dy * 0.005;
                obsCamRotation.phi = Math.max(0.1, Math.min(Math.PI - 0.1, obsCamRotation.phi));
                obsLastPos = { x: t.clientX, y: t.clientY };
            }, { passive: false });
            
            renderer.domElement.addEventListener('touchend', () => { obsDragging = false; });
        }

        // ===== 우주선 조종 시스템 함수들 =====
        
        // 강제 가로 모드 함수
        function forceLayoutOrientation() {
            // Screen Orientation API 시도
            if (screen.orientation && screen.orientation.lock) {
                screen.orientation.lock('landscape').catch(() => {
                    // 실패 시 CSS로 처리
                    showLandscapeWarning();
                });
            } else {
                showLandscapeWarning();
            }
        }
        
        // 화면 방향 잠금 해제
        function unlockOrientation() {
            if (screen.orientation && screen.orientation.unlock) {
                screen.orientation.unlock();
            }
            hideLandscapeWarning();
        }
        
        // 세로 모드 경고 표시
        function showLandscapeWarning() {
            let warning = document.getElementById('landscape-warning');
            if (!warning) {
                warning = document.createElement('div');
                warning.id = 'landscape-warning';
                warning.innerHTML = `
                    <div class="rotate-icon">📱↔️</div>
                    <div class="rotate-text">${t('rotateScreen')}</div>
                    <div class="rotate-sub">${t('rotateScreenSub')}</div>
                `;
                document.body.appendChild(warning);
            }
            warning.style.display = 'flex';
            checkOrientationForWarning();
        }
        
        // 세로 모드 경고 숨김
        function hideLandscapeWarning() {
            const warning = document.getElementById('landscape-warning');
            if (warning) warning.style.display = 'none';
        }
        
        // 방향 체크 및 경고 표시/숨김
        function checkOrientationForWarning() {
            if (!isPilotMode) {
                hideLandscapeWarning();
                return;
            }
            const warning = document.getElementById('landscape-warning');
            if (!warning) return;
            
            const isPortrait = window.innerHeight > window.innerWidth;
            warning.style.display = isPortrait ? 'flex' : 'none';
        }
        
        // 방향 변경 감지
        window.addEventListener('resize', () => {
            if (isPilotMode) {
                checkOrientationForWarning();
            }
        });
        
        function createDockedShip(station) {
            if (!station || !station.mesh) return null;
            
            // 정거장에 도킹된 우주선 생성
            const shipGroup = new THREE.Group();
            
            // 본체
            const bodyGeo = new THREE.ConeGeometry(0.015, 0.06, 8);
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x4fc3f7, metalness: 0.8, roughness: 0.2 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.rotation.x = Math.PI / 2;
            shipGroup.add(body);
            
            // 날개
            const wingGeo = new THREE.BoxGeometry(0.08, 0.003, 0.02);
            const wingMat = new THREE.MeshStandardMaterial({ color: 0x333344, metalness: 0.9, roughness: 0.1 });
            const wing = new THREE.Mesh(wingGeo, wingMat);
            wing.position.z = 0.01;
            shipGroup.add(wing);
            
            // 엔진
            const engineGeo = new THREE.CylinderGeometry(0.008, 0.006, 0.015, 8);
            const engineMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const engine = new THREE.Mesh(engineGeo, engineMat);
            engine.position.z = 0.035;
            engine.rotation.x = Math.PI / 2;
            shipGroup.add(engine);
            
            // 정거장 옆에 배치
            shipGroup.position.set(0.15, 0, 0);
            station.mesh.add(shipGroup);
            dockedShipMesh = shipGroup;
            
            return shipGroup;
        }
        
        // ★★★ engineConfig에서 지정한 엔진 불꽃 생성 ★★★
        // 참고: 모델은 rotation.y = Math.PI (180도) 회전되어 있음
        // 엔진 에디터는 원본 모델 좌표계 기준으로 설정됨
        function createConfiguredFlame(eng, size, length, color, sizeScale, idx) {
            const flameGroup = new THREE.Group();
            
            // 방향 벡터 (엔진 에디터에서 설정한 값)
            let dirX = eng.dirX || 0;
            let dirY = eng.dirY || 0;
            let dirZ = eng.dirZ || 1;
            
            console.log(`🔥 불꽃 ${idx}: 원본 방향 (${dirX}, ${dirY}, ${dirZ})`);
            
            const s = size * sizeScale;
            const l = length;
            
            // 기본 스케일 저장 (애니메이션에서 사용)
            flameGroup.userData.baseLength = l;
            flameGroup.userData.baseSize = s;
            
            // 외부 불꽃
            const outerGeo = new THREE.SphereGeometry(0.12 * s, 16, 12, 0, Math.PI * 2, 0, Math.PI / 2);
            outerGeo.rotateX(-Math.PI / 2);
            const outerMat = new THREE.MeshBasicMaterial({ 
                color: new THREE.Color(color), transparent: true, opacity: 0.4,
                blending: THREE.AdditiveBlending, depthWrite: false, side: THREE.DoubleSide
            });
            const outer = new THREE.Mesh(outerGeo, outerMat);
            outer.scale.set(1, 1, 3 * l);
            outer.userData.baseScaleZ = 3 * l;
            outer.name = 'flameOuter';
            flameGroup.add(outer);
            
            // 중간 불꽃
            const midGeo = new THREE.SphereGeometry(0.08 * s, 16, 12, 0, Math.PI * 2, 0, Math.PI / 2);
            midGeo.rotateX(-Math.PI / 2);
            const midMat = new THREE.MeshBasicMaterial({ 
                color: new THREE.Color(color).lerp(new THREE.Color(0xffffff), 0.3), 
                transparent: true, opacity: 0.6,
                blending: THREE.AdditiveBlending, depthWrite: false, side: THREE.DoubleSide
            });
            const mid = new THREE.Mesh(midGeo, midMat);
            mid.scale.set(1, 1, 2.5 * l);
            mid.userData.baseScaleZ = 2.5 * l;
            mid.name = 'flameMid';
            flameGroup.add(mid);
            
            // 코어 불꽃 (밝은 중심)
            const coreGeo = new THREE.SphereGeometry(0.04 * s, 16, 12, 0, Math.PI * 2, 0, Math.PI / 2);
            coreGeo.rotateX(-Math.PI / 2);
            const coreMat = new THREE.MeshBasicMaterial({ 
                color: new THREE.Color(color).lerp(new THREE.Color(0xffffff), 0.7), 
                transparent: true, opacity: 0.9,
                blending: THREE.AdditiveBlending, depthWrite: false, side: THREE.DoubleSide
            });
            const core = new THREE.Mesh(coreGeo, coreMat);
            core.scale.set(1, 1, 2 * l);
            core.userData.baseScaleZ = 2 * l;
            core.name = 'flameCore';
            flameGroup.add(core);
            
            // ★★★ 불꽃 방향 설정 ★★★
            // 기본 불꽃 방향: +Z (뒤쪽으로 분사)
            // dirZ=-1(앞)이면 불꽃은 앞으로 → 180도 회전 필요
            // dirZ=+1(뒤)이면 불꽃은 뒤로 → 회전 불필요
            
            if (dirZ < -0.5) {
                // -Z 방향 (앞쪽으로 분사) - 역추진
                flameGroup.rotation.y = Math.PI;
            } else if (dirZ > 0.5) {
                // +Z 방향 (뒤쪽으로 분사) - 정상 추진, 회전 없음
            } else if (dirY > 0.5) {
                // +Y 방향 (위로 분사)
                flameGroup.rotation.x = -Math.PI / 2;
            } else if (dirY < -0.5) {
                // -Y 방향 (아래로 분사)
                flameGroup.rotation.x = Math.PI / 2;
            } else if (dirX > 0.5) {
                // +X 방향 (오른쪽으로 분사)
                flameGroup.rotation.y = -Math.PI / 2;
            } else if (dirX < -0.5) {
                // -X 방향 (왼쪽으로 분사)
                flameGroup.rotation.y = Math.PI / 2;
            }
            
            return flameGroup;
        }
        
        function createPlayerShip(isReboard = false) {
            // ★★★ 기존 우주선 정리 (클론 방지) ★★★
            if (playerShip && playerShip.mesh) {
                console.log('🧹 기존 우주선 정리');
                scene.remove(playerShip.mesh);
                // 메모리 정리
                playerShip.mesh.traverse((child) => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
                playerShip.mesh = null;
            }
            
            const station = satellites.find(s => s.name === "ISS 우주정거장");
            console.log('createPlayerShip - station:', station, 'satellites:', satellites.length);
            if (!station || !station.mesh) {
                console.error('ISS 우주정거장을 찾을 수 없습니다!');
                return null;
            }
            
            const ship = currentShipType;
            const shipGroup = new THREE.Group();  // 메인 그룹 (위치/회전)
            const shipVisualGroup = new THREE.Group();  // 외형 그룹 (스케일 조정)
            shipVisualGroup.name = 'shipVisual';
            shipVisualGroup.rotation.y = Math.PI;  // ★ 180도 회전 - 우주모드에서 앞 방향 맞추기
            
            // ★★★ 외형 스케일 (정거장과 비슷하게) ★★★
            const isMultiMode = (typeof window.gameMode !== 'undefined' && window.gameMode === 'multi');
            const SHIP_VISUAL_SCALE = isMultiMode ? 0.8 : 1.0;  // 멀티모드: 0.08→0.8 (10배 증가)
            
            // 크기 배율 결정
            const sizeScale = {
                'small': 1.0,
                'medium': 1.3,
                'large': 1.6,
                'huge': 2.0
            }[ship.size] || 1.0;
            
            // ★★★ GLB 모델이 있으면 로드 ★★★
            if (ship.model && ship.model.length > 0) {
                const gltfLoader = new GLTFLoader();
                
                // ★ Draco 압축 지원 (선택적)
                try {
                    const dracoLoader = new DRACOLoader();
                    dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
                    gltfLoader.setDRACOLoader(dracoLoader);
                } catch(e) {
                    console.log('DRACO 로더 없이 진행');
                }
                
                // ★ URL을 Supabase Storage로 변환
                const modelUrl = convertToSupabaseUrl(ship.model);
                console.log('🚀 플레이어 우주선 GLB 로드 시도:', modelUrl);
                
                gltfLoader.load(modelUrl, (gltf) => {
                    console.log('✅ 플레이어 우주선 GLB 로드 성공:', modelUrl);
                    const model = gltf.scene;
                    model.scale.setScalar(sizeScale * 0.5);  // 모델 크기 조절
                    
                    // ★ 모델 회전은 shipVisualGroup에서 처리됨
                    // model.rotation.y = Math.PI;  // 제거
                    
                    // ★ 메탈릭 재질 설정 - 리얼한 금속 반사
                    model.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            
                            if (child.material) {
                                // 기존 재질이 있으면 메탈릭 속성 강화
                                if (child.material.isMeshStandardMaterial || child.material.isMeshPhysicalMaterial) {
                                    // 기존 색상 유지하면서 메탈릭 강화
                                    child.material.metalness = Math.max(child.material.metalness || 0, 0.7);
                                    child.material.roughness = Math.min(child.material.roughness || 1, 0.35);
                                    child.material.envMapIntensity = 1.5;  // 환경 반사 강화
                                } else {
                                    // 기본 재질을 MeshStandardMaterial로 교체
                                    const oldMat = child.material;
                                    const newMat = new THREE.MeshStandardMaterial({
                                        color: oldMat.color || 0x888888,
                                        map: oldMat.map || null,
                                        metalness: 0.8,
                                        roughness: 0.3,
                                        envMapIntensity: 1.5
                                    });
                                    child.material = newMat;
                                }
                                child.material.needsUpdate = true;
                            }
                        }
                    });
                    
                    // 기존 기하학적 형태 제거 (엔진 불꽃 제외)
                    const toRemove = [];
                    shipVisualGroup.children.forEach(child => {
                        if (child.name !== 'engineFlame' && child.name !== 'reverseFlameGroup' && 
                            child.name !== 'glbThrustFlames' && child.name !== 'glbReverseFlames') {
                            toRemove.push(child);
                        }
                    });
                    toRemove.forEach(child => shipVisualGroup.remove(child));
                    
                    model.name = 'glbModel';
                    shipVisualGroup.add(model);
                    
                    // ★★★ engineConfig가 있으면 사용자 지정 엔진 불꽃 생성 ★★★
                    if (ship.engineConfig) {
                        const cfg = ship.engineConfig;
                        console.log('🔧 engineConfig 사용:', cfg);
                        
                        // ★★★ 모델 전방 방향에 따른 회전 계산 ★★★
                        const modelForward = cfg.modelForward || '+Z';
                        let modelRotationY = Math.PI;  // 기본값: 180도 (게임에서 -Z가 전방)
                        
                        switch(modelForward) {
                            case '+Z': modelRotationY = Math.PI; break;      // 모델의 +Z가 전방 → 180도 회전
                            case '-Z': modelRotationY = 0; break;            // 모델의 -Z가 전방 → 회전 없음
                            case '+X': modelRotationY = -Math.PI / 2; break; // 모델의 +X가 전방 → -90도
                            case '-X': modelRotationY = Math.PI / 2; break;  // 모델의 -X가 전방 → +90도
                        }
                        
                        // 모델 회전 적용
                        model.rotation.y = modelRotationY;
                        console.log('🧭 모델 전방:', modelForward, '→ 회전:', (modelRotationY * 180 / Math.PI).toFixed(0) + '도');
                        
                        // 모델 스케일 (불꽃 위치 계산에 사용)
                        const modelScale = sizeScale * 0.5;
                        
                        // 추진 엔진 불꽃
                        if (cfg.thrust && cfg.thrust.length > 0) {
                            const thrustGroup = new THREE.Group();
                            thrustGroup.name = 'glbThrustFlames';
                            
                            cfg.thrust.forEach(function(eng, idx) {
                                // 불꽃 크기는 고정 스케일 사용
                                var flameGroup = createConfiguredFlame(
                                    eng, cfg.size || 1, cfg.length || 1, 
                                    cfg.thrustColor || '#00aaff', 1, idx
                                );
                                // 위치는 모델 스케일 적용
                                flameGroup.position.set(
                                    eng.x * modelScale,
                                    eng.y * modelScale,
                                    eng.z * modelScale
                                );
                                flameGroup.name = 'thrustFlame_' + idx;
                                flameGroup.visible = false;
                                thrustGroup.add(flameGroup);
                            });
                            
                            // shipVisualGroup에 추가
                            // ★ 모델 회전과 동일하게 불꽃 그룹도 회전
                            thrustGroup.rotation.y = modelRotationY;
                            shipVisualGroup.add(thrustGroup);
                            
                            // ★ 전역 변수에 저장
                            configuredThrustFlames = thrustGroup;
                            hasEngineConfig = true;
                            
                            console.log('🔵 추진 엔진 ' + cfg.thrust.length + '개 생성');
                        }
                        
                        // 역추진 엔진 불꽃
                        if (cfg.reverse && cfg.reverse.length > 0) {
                            const reverseGroup = new THREE.Group();
                            reverseGroup.name = 'glbReverseFlames';
                            
                            cfg.reverse.forEach(function(eng, idx) {
                                var flameGroup = createConfiguredFlame(
                                    eng, cfg.size || 1, cfg.length || 1, 
                                    cfg.reverseColor || '#ffaa00', 1, idx
                                );
                                flameGroup.position.set(
                                    eng.x * modelScale,
                                    eng.y * modelScale,
                                    eng.z * modelScale
                                );
                                flameGroup.name = 'reverseFlame_' + idx;
                                flameGroup.visible = false;
                                reverseGroup.add(flameGroup);
                            });
                            
                            // ★ 모델 회전과 동일하게 불꽃 그룹도 회전
                            reverseGroup.rotation.y = modelRotationY;
                            shipVisualGroup.add(reverseGroup);
                            
                            // ★ 전역 변수에 저장
                            configuredReverseFlames = reverseGroup;
                            
                            console.log('🟠 역추진 엔진 ' + cfg.reverse.length + '개 생성');
                        }
                        
                        // 기본 불꽃 완전히 제거
                        const defaultFlame = shipVisualGroup.getObjectByName('engineFlame');
                        if (defaultFlame) {
                            shipVisualGroup.remove(defaultFlame);
                            console.log('🔴 기본 추진 불꽃 제거됨');
                        }
                        const defaultReverse = shipVisualGroup.getObjectByName('reverseFlameGroup');
                        if (defaultReverse) {
                            shipVisualGroup.remove(defaultReverse);
                            console.log('🔴 기본 역추진 불꽃 제거됨');
                        }
                        
                    } else {
                        // ★ engineConfig 없으면 바운딩 박스로 기본 불꽃 위치 결정
                        console.log('⚠️ engineConfig 없음. 기본 불꽃 사용.');
                        const box = new THREE.Box3().setFromObject(model);
                        const modelSize = new THREE.Vector3();
                        box.getSize(modelSize);
                        
                        const flame = shipVisualGroup.getObjectByName('engineFlame');
                        if (flame) {
                            flame.position.z = (box.max.z + 0.1) / model.scale.x;
                            flame.scale.setScalar(Math.max(0.5, modelSize.x * 0.3));
                        }
                        
                        const reverseGroup = shipVisualGroup.getObjectByName('reverseFlameGroup');
                        if (reverseGroup) {
                            reverseGroup.position.z = (box.min.z - 0.1) / model.scale.x;
                        }
                    }
                    
                    console.log('✅ GLB 모델 로드 완료:', ship.model);
                }, undefined, (error) => {
                    console.warn('GLB 모델 로드 실패, 기본 형태 사용:', error);
                });
            }
            
            // 우주선 타입별 외형 생성 (GLB 없을 때 기본 형태)
            const mainColor = ship.color;
            const accentColor = ship.accentColor;
            
            // 본체
            let bodyGeo;
            switch(ship.id) {
                case 'shuttle':
                case 'scout':
                    bodyGeo = new THREE.ConeGeometry(0.25 * sizeScale, 1.0 * sizeScale, 8);
                    break;
                case 'interceptor':
                case 'racer':
                    bodyGeo = new THREE.ConeGeometry(0.2 * sizeScale, 1.3 * sizeScale, 6);
                    break;
                case 'freighter':
                    bodyGeo = new THREE.BoxGeometry(0.5 * sizeScale, 0.4 * sizeScale, 1.2 * sizeScale);
                    break;
                case 'corvette':
                case 'frigate':
                    bodyGeo = new THREE.ConeGeometry(0.3 * sizeScale, 1.1 * sizeScale, 8);
                    break;
                case 'cruiser':
                    bodyGeo = new THREE.CylinderGeometry(0.25 * sizeScale, 0.35 * sizeScale, 1.4 * sizeScale, 8);
                    break;
                case 'battleship':
                case 'flagship':
                    bodyGeo = new THREE.BoxGeometry(0.6 * sizeScale, 0.3 * sizeScale, 1.5 * sizeScale);
                    break;
                default:
                    bodyGeo = new THREE.ConeGeometry(0.3 * sizeScale, 1.2 * sizeScale, 8);
            }
            
            const bodyMat = new THREE.MeshStandardMaterial({ 
                color: mainColor, 
                metalness: 0.8, 
                roughness: 0.2, 
                emissive: mainColor, 
                emissiveIntensity: 0.1 
            });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            if (ship.id !== 'freighter' && ship.id !== 'battleship' && ship.id !== 'flagship' && ship.id !== 'cruiser') {
                body.rotation.x = Math.PI / 2;
            } else if (ship.id === 'cruiser') {
                body.rotation.x = Math.PI / 2;
            }
            shipVisualGroup.add(body);  // ★ shipVisualGroup에 추가
            
            // 날개 (타입별로 다름)
            const wingMat = new THREE.MeshStandardMaterial({ color: accentColor, metalness: 0.9, roughness: 0.1 });
            
            if (ship.id === 'interceptor' || ship.id === 'racer') {
                // 삼각형 날개
                const wingGeo = new THREE.BoxGeometry(1.8 * sizeScale, 0.03 * sizeScale, 0.5 * sizeScale);
                const wing = new THREE.Mesh(wingGeo, wingMat);
                wing.position.z = 0.3 * sizeScale;
                shipVisualGroup.add(wing);
            } else if (ship.id === 'freighter') {
                // 컨테이너 스타일
                const cargoGeo = new THREE.BoxGeometry(0.35 * sizeScale, 0.3 * sizeScale, 0.4 * sizeScale);
                const cargo = new THREE.Mesh(cargoGeo, wingMat);
                cargo.position.z = 0.3 * sizeScale;
                shipVisualGroup.add(cargo);
            } else if (ship.id === 'battleship' || ship.id === 'flagship') {
                // 큰 날개
                const wingGeo = new THREE.BoxGeometry(2.2 * sizeScale, 0.06 * sizeScale, 0.6 * sizeScale);
                const wing = new THREE.Mesh(wingGeo, wingMat);
                wing.position.z = 0.2 * sizeScale;
                shipVisualGroup.add(wing);
                
                // 추가 구조물
                const towerGeo = new THREE.BoxGeometry(0.15 * sizeScale, 0.25 * sizeScale, 0.3 * sizeScale);
                const tower = new THREE.Mesh(towerGeo, wingMat);
                tower.position.y = 0.2 * sizeScale;
                shipVisualGroup.add(tower);
            } else {
                // 기본 날개
                const wingGeo = new THREE.BoxGeometry(1.4 * sizeScale, 0.04 * sizeScale, 0.35 * sizeScale);
                const wing = new THREE.Mesh(wingGeo, wingMat);
                wing.position.z = 0.2 * sizeScale;
                shipVisualGroup.add(wing);
            }
            
            // 엔진 (크기/개수 다름)
            const engineMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const engineCount = ship.size === 'huge' ? 3 : (ship.size === 'large' ? 2 : 1);
            
            for (let i = 0; i < engineCount; i++) {
                const engineGeo = new THREE.CylinderGeometry(0.1 * sizeScale, 0.08 * sizeScale, 0.25 * sizeScale, 8);
                const engine = new THREE.Mesh(engineGeo, engineMat);
                engine.position.z = 0.6 * sizeScale;
                engine.rotation.x = Math.PI / 2;
                if (engineCount === 2) {
                    engine.position.x = (i === 0 ? -0.2 : 0.2) * sizeScale;
                } else if (engineCount === 3) {
                    engine.position.x = (i - 1) * 0.25 * sizeScale;
                }
                shipVisualGroup.add(engine);
            }
            
            // 엔진 불꽃 (후방 - 가속) - ★ 넓은 부분이 엔진, 뾰족한 부분이 뒤
            const flameGeo = new THREE.ConeGeometry(0.15 * sizeScale, 0.5 * sizeScale, 8);
            const flameMat = new THREE.MeshBasicMaterial({ 
                color: ship.id === 'racer' ? 0xff4400 : 0x00aaff, 
                transparent: true, 
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            const flame = new THREE.Mesh(flameGeo, flameMat);
            flame.position.z = 0.55 * sizeScale;  // ★ 우주선 바로 뒤에
            flame.rotation.x = Math.PI / 2;  // ★ 뾰족한 부분이 뒤로 (z+ 방향)
            flame.visible = false;
            flame.name = 'engineFlame';
            shipVisualGroup.add(flame);
            
            // 역추진 엔진 불꽃 (하단 양쪽에서 전방 외부로 분사) - 뭉툭한 형태
            const reverseFlameGroup = new THREE.Group();
            reverseFlameGroup.name = 'reverseFlameGroup';
            reverseFlameGroup.visible = false;
            
            // 불꽃 레이어 생성 함수 (뭉툭한 원통형 - 끝이 뾰족하지 않음)
            function createFlameLayer(offsetX, offsetY, baseZ, length, radiusTop, radiusBottom, color, opacity) {
                // CylinderGeometry: radiusTop, radiusBottom으로 테이퍼 조절
                const geo = new THREE.CylinderGeometry(radiusTop * sizeScale, radiusBottom * sizeScale, length * sizeScale, 12);
                const mat = new THREE.MeshBasicMaterial({ 
                    color: color,
                    transparent: true, 
                    opacity: opacity,
                    side: THREE.DoubleSide
                });
                const flame = new THREE.Mesh(geo, mat);
                flame.position.set(offsetX * sizeScale, offsetY * sizeScale, baseZ * sizeScale);
                flame.rotation.x = Math.PI / 2; // 전방으로 향하게
                return flame;
            }
            
            // 왼쪽 역추진 불꽃 (3개 레이어) - 우주선 전방 외부에서 분사
            const leftFlameOuter = createFlameLayer(-0.22, -0.12, -0.9, 0.9, 0.04, 0.1, 0xff3300, 0.5);
            leftFlameOuter.name = 'leftOuter';
            reverseFlameGroup.add(leftFlameOuter);
            
            const leftFlameMiddle = createFlameLayer(-0.22, -0.12, -0.8, 0.7, 0.025, 0.07, 0xff6600, 0.7);
            leftFlameMiddle.name = 'leftMiddle';
            reverseFlameGroup.add(leftFlameMiddle);
            
            const leftFlameCore = createFlameLayer(-0.22, -0.12, -0.7, 0.5, 0.015, 0.04, 0xffcc00, 0.9);
            leftFlameCore.name = 'leftCore';
            reverseFlameGroup.add(leftFlameCore);
            
            // 오른쪽 역추진 불꽃 (3개 레이어)
            const rightFlameOuter = createFlameLayer(0.22, -0.12, -0.9, 0.9, 0.04, 0.1, 0xff3300, 0.5);
            rightFlameOuter.name = 'rightOuter';
            reverseFlameGroup.add(rightFlameOuter);
            
            const rightFlameMiddle = createFlameLayer(0.22, -0.12, -0.8, 0.7, 0.025, 0.07, 0xff6600, 0.7);
            rightFlameMiddle.name = 'rightMiddle';
            reverseFlameGroup.add(rightFlameMiddle);
            
            const rightFlameCore = createFlameLayer(0.22, -0.12, -0.7, 0.5, 0.015, 0.04, 0xffcc00, 0.9);
            rightFlameCore.name = 'rightCore';
            reverseFlameGroup.add(rightFlameCore);
            
            // 분사구 발광체 (왼쪽) - 우주선 앞쪽 외부
            const nozzleGeoL = new THREE.SphereGeometry(0.055 * sizeScale, 12, 12);
            const nozzleMatL = new THREE.MeshBasicMaterial({ color: 0xffffcc, transparent: true, opacity: 0.95 });
            const nozzleL = new THREE.Mesh(nozzleGeoL, nozzleMatL);
            nozzleL.position.set(-0.22 * sizeScale, -0.12 * sizeScale, -0.45 * sizeScale);
            nozzleL.name = 'nozzleL';
            reverseFlameGroup.add(nozzleL);
            
            // 분사구 발광체 (오른쪽)
            const nozzleR = new THREE.Mesh(nozzleGeoL.clone(), nozzleMatL.clone());
            nozzleR.position.set(0.22 * sizeScale, -0.12 * sizeScale, -0.45 * sizeScale);
            nozzleR.name = 'nozzleR';
            reverseFlameGroup.add(nozzleR);
            
            shipVisualGroup.add(reverseFlameGroup);
            
            // 조종석 조명
            const cockpitLight = new THREE.PointLight(accentColor, 0.3, 3 * sizeScale);
            cockpitLight.position.set(0, 0, -0.3 * sizeScale);
            shipVisualGroup.add(cockpitLight);
            
            // ★ 태양빛 조명 (태양 방향에서 오는 빛 - 물리 기반)
            const sunLight = new THREE.DirectionalLight(0xfffaf0, 2.5);  // 따뜻한 햇빛, 강도 증가
            sunLight.position.set(10, 5, 10);  // 초기 위치
            sunLight.target = shipVisualGroup;  // 우주선을 타겟으로
            sunLight.name = 'sunLight';
            sunLight.castShadow = true;
            shipGroup.add(sunLight);
            shipGroup.add(sunLight.target);
            
            // ★ 은은한 환경광 (우주 공간 - 매우 어둡게)
            const ambientLight = new THREE.AmbientLight(0x111122, 0.15);  // 더 어둡게
            ambientLight.name = 'shipAmbient';
            shipGroup.add(ambientLight);
            
            // ★ 반대쪽 약한 보조광 (완전 어둡지 않게)
            const fillLight = new THREE.DirectionalLight(0x4466aa, 0.2);  // 차가운 푸른빛
            fillLight.position.set(-5, -2, -5);
            fillLight.name = 'fillLight';
            shipGroup.add(fillLight);
            
            // 쉴드 효과 (코르벳 등)
            if (ship.special === 'shield' || ship.special === 'allInOne') {
                const shieldGeo = new THREE.SphereGeometry(1.2 * sizeScale, 16, 16);
                const shieldMat = new THREE.MeshBasicMaterial({ 
                    color: 0x00ffff, 
                    transparent: true, 
                    opacity: 0.1,
                    side: THREE.DoubleSide
                });
                const shield = new THREE.Mesh(shieldGeo, shieldMat);
                shield.visible = false;
                shield.name = 'shield';
                shipVisualGroup.add(shield);
            }
            
            // ★★★ 외형 스케일 적용 ★★★
            shipVisualGroup.scale.setScalar(SHIP_VISUAL_SCALE);
            shipGroup.add(shipVisualGroup);
            
            // 저장된 위치가 있으면 복원 (재탑승 시)
            const hasParkedShip = isReboard && parkedShip && parkedShip.type === ship.id;
            const hasSavedState = savedShipState && savedShipState.shipTypeIndex === selectedShipIndex && savedShipState.position;
            
            console.log('createPlayerShip 호출:', { isReboard, hasParkedShip, hasSavedState, savedShipState });
            
            if (hasParkedShip) {
                // 주차된 위치에서 재탑승
                shipGroup.position.copy(parkedShip.position);
                shipGroup.quaternion.copy(parkedShip.quaternion);
                shipGroup.rotation.copy(parkedShip.rotation);
                console.log('주차된 우주선에서 재탑승');
            } else if (hasSavedState) {
                shipGroup.position.copy(savedShipState.position);
                shipGroup.quaternion.copy(savedShipState.quaternion);
                console.log('저장된 상태에서 복원');
            } else {
                // 최초 탑승: 정거장에 도킹된 상태에서 시작

                // ★★★ 멀티모드: 스폰 전 모든 천체 위치 강제 업데이트 ★★★
                if (window.gameMode === 'multi') {
                    // 1. 먼저 행성들 위치 업데이트 (keplerTime 기준)
                    if (typeof updateKeplerOrbits === 'function') {
                        updateKeplerOrbits(0);
                    }

                    // 2. 그 다음 위성/정거장 위치 업데이트
                    if (station.parentBody && station.parentBody.mesh) {
                        const seed = station.name ? station.name.split('').reduce((a, c) => a + c.charCodeAt(0), 0) : 0;
                        const baseTime = Date.now() * 0.0000001;
                        station.angle = (seed * 0.1 + baseTime * station.orbitSpeed) % (Math.PI * 2);

                        const isRealMode = CONFIG.distScale > 1.0;
                        const parentScale = station.parentBody.visualScale || 1;
                        const r = isRealMode && station.realOrbitRadius
                            ? station.realOrbitRadius * (station.parentBody.radius || 1) * parentScale
                            : station.orbitRadius;

                        station.mesh.position.x = station.parentBody.mesh.position.x + Math.cos(station.angle) * r;
                        station.mesh.position.z = station.parentBody.mesh.position.z + Math.sin(station.angle) * r;
                        station.mesh.position.y = station.parentBody.mesh.position.y;

                        console.log('★ 스폰 전 강제 동기화 - 지구:', station.parentBody.mesh.position, '정거장:', station.mesh.position);
                    }
                }

                const stationWorldPos = new THREE.Vector3();
                station.mesh.getWorldPosition(stationWorldPos);
                
                // ★ 지구 반대 방향 계산
                const earth = bodies.find(b => b.name === '지구' || b.name === 'Earth');
                let undockDir;
                if (earth && earth.mesh) {
                    // 지구 → 정거장 방향 = 지구 반대 방향
                    undockDir = new THREE.Vector3()
                        .subVectors(stationWorldPos, earth.mesh.position)
                        .normalize();
                } else {
                    // 지구 못 찾으면 기본 방향
                    undockDir = new THREE.Vector3(1, 0, 0);
                }
                
                // 지구 반대 방향으로 우주선 배치
                shipGroup.position.copy(stationWorldPos);
                shipGroup.position.add(undockDir.clone().multiplyScalar(0.5 * sizeScale * SHIP_VISUAL_SCALE));
                
                // 이탈 방향을 바라보도록 회전
                const lookTarget = shipGroup.position.clone().add(undockDir.clone().multiplyScalar(10));
                shipGroup.lookAt(lookTarget);
                
                savedShipState = null;  // 새 우주선이면 저장 상태 초기화
                parkedShip = null;  // 주차 상태도 초기화
                
                // ★ 언도킹 연출 시작
                undockingState.active = true;
                undockingState.phase = 'undocking';
                undockingState.startTime = Date.now();
                undockingState.startPos = shipGroup.position.clone();
                undockingState.stationPos = stationWorldPos.clone();
                undockingState.undockDirection = undockDir;  // ★ 방향 저장
                
                console.log('★ 언도킹 연출 시작!', undockingState);
            }
            
            scene.add(shipGroup);
            
            // ★★★ 카메라는 shipGroup에 직접 추가 (스케일 영향 안 받음) ★★★
            shipGroup.add(camera);
            // 카메라 위치는 스케일과 무관하게 고정 (조종석 내부 느낌)
            const camOffset = 0.15;  // 스케일 없이 고정
            camera.position.set(0, 0.08, camOffset);
            camera.rotation.set(0, Math.PI, 0);  // ★ 180도 회전 - 앞 방향 바라보기
            
            // 특수능력 초기화
            shipAbility.cooldown = 0;
            shipAbility.shieldActive = ship.special === 'shield' || ship.special === 'allInOne';
            shipAbility.afterburnerActive = false;
            shipAbility.warpReady = true;
            
            playerShip = {
                mesh: shipGroup,
                visualMesh: shipVisualGroup,  // ★ 외형 그룹 참조 추가
                speed: (isReboard && parkedShip) ? parkedShip.speed : (savedShipState ? savedShipState.speed : 0),
                fuel: (isReboard && parkedShip) ? parkedShip.fuel : (savedShipState ? savedShipState.fuel : SHIP_CONFIG.maxFuel),
                hull: (isReboard && parkedShip) ? (parkedShip.hull || SHIP_CONFIG.maxHull) : (savedShipState ? (savedShipState.hull || SHIP_CONFIG.maxHull) : SHIP_CONFIG.maxHull),  // ★ 내구도 추가
                euler: new THREE.Euler(0, 0, 0, 'YXZ'),
                flame: flame,
                velocity: new THREE.Vector3(),
                mass: 0.001 * sizeScale,
                shipType: ship,
                sizeScale: sizeScale,
                visualScale: SHIP_VISUAL_SCALE  // ★ 외형 스케일 저장
            };
            
            // 전역으로 노출
            window.playerShip = playerShip;
            
            // 도킹된 우주선 숨기기
            if (dockedShipMesh) dockedShipMesh.visible = false;
            
            return playerShip;
        }
        
        function boardShip() {
            if (isPilotMode) return;
            
            // ★ Supabase 로그인 상태 체크 (mpUser가 있으면 로그인됨)
            const isLoggedIn = window.mpUser || window.mpUserId;
            
            // 멀티모드에서는 반드시 로그인 필요 (게스트 제외)
            if (window.gameMode === 'multi') {
                if (!isLoggedIn) {
                    showMsg('🔐 Login required for multiplayer mode.');
                    const authOverlay = document.getElementById('auth-overlay');
                    if (authOverlay) {
                        authOverlay.style.display = 'flex';
                    }
                    return;
                }
            }
            
            // 싱글모드는 로그인 없이도 플레이 가능
            // (로그인하면 데이터 저장됨)
            
            // 충돌로 인한 하선 후 재탑승인 경우 메시지 표시
            if (window.lastExitReason === 'collision') {
                const destroyedName = window.destroyedShipName || '우주선';
                showMsg(`💥 ${destroyedName}이(가) 파괴되어 소유권이 사라졌습니다. 새 우주선을 구매하세요.`);
                // 기본 셔틀로 강제 설정
                selectedShipIndex = 0;
                currentShipType = SHIP_TYPES[0];
                window.currentShipType = currentShipType;  // ★ 전역 업데이트
                window.lastExitReason = null;
                window.destroyedShipName = null;
            }
            
            // 주차된 우주선 클릭 후 재탑승인 경우 (바로 탑승)
            if (focusedBody && focusedBody.isParkedShip && parkedShip) {
                // 주차된 우주선으로 바로 재탑승
                directReboard();
                return;
            }
            
            // ISS 정거장에서 탑승 - 우주선 선택 모달 표시
            openShipSelectModal();
        }
        
        // 주차된 우주선 정리
        function clearParkedShip() {
            if (parkedShipMesh) {
                scene.remove(parkedShipMesh);
                parkedShipMesh = null;
            }
            parkedShip = null;
            
            // Supabase에서 주차 정보 삭제
            if (window.mpUser && window.supabaseClient) {
                window.supabaseClient
                    .from('profiles')
                    .update({ parked_ship: null })
                    .eq('id', window.mpUserId)
                    .then(function() {})
                    .catch(function(e) {
                        console.warn('주차 정보 삭제 실패:', e);
                    });
            }
        }
        
        // 주차된 우주선으로 바로 재탑승
        function directReboard() {
            if (!parkedShip || !parkedShipMesh) return;
            
            // ★ 운항 중인 상태 저장
            const wasMoving = parkedShipMesh.userData.isMoving;
            const savedVelocity = parkedShipMesh.userData.velocity ? parkedShipMesh.userData.velocity.clone() : null;
            const savedSpeed = parkedShipMesh.userData.speed || 0;
            const savedFuel = parkedShipMesh.userData.fuel || 100;
            const savedPosition = parkedShipMesh.position.clone();
            const savedQuaternion = parkedShipMesh.quaternion.clone();
            
            // 주차된 우주선 타입으로 설정
            const shipIdx = parkedShipMesh.userData.shipTypeIndex;
            selectedShipIndex = shipIdx;
            currentShipType = SHIP_TYPES[shipIdx];
            window.currentShipType = currentShipType;  // ★ 전역 업데이트
            
            // ★ parkedShip 데이터 업데이트 (현재 위치로)
            parkedShip.position = savedPosition;
            parkedShip.quaternion = savedQuaternion;
            parkedShip.rotation = new THREE.Euler().setFromQuaternion(savedQuaternion);
            parkedShip.speed = savedSpeed;
            parkedShip.fuel = savedFuel;
            
            // 기존 주차 메시 제거
            scene.remove(parkedShipMesh);
            
            // ★ bodies 배열에서도 제거
            const parkedBodyIdx = bodies.findIndex(b => b.isParkedShip);
            if (parkedBodyIdx >= 0) {
                bodies.splice(parkedBodyIdx, 1);
            }
            
            parkedShipMesh = null;
            
            // 실제 거리 모드 유지
            if (CONFIG.distScale < 50.0) {
                CONFIG.distScale = 50.0;
                const scaleBtn = document.getElementById('btn-scale-mode');
                if (scaleBtn) {
                    scaleBtn.textContent = t('distReal');
                    scaleBtn.classList.add('active');
                }
            }
            
            // ★ 마커 숨기기
            hideShipLocationMarker();
            
            // 바로 탑승
            setTimeout(() => {
                actualBoardShip(true);  // 재탑승 모드
            }, 100);
        }
        
        // ★★★ 우주정거장 시스템 ★★★
        
        // 정거장 모달 열기
        function openStationModal() {
            // ★ 멀티모드 튜토리얼 가이드
            if (typeof MultiTutorial !== 'undefined') {
                MultiTutorial.showFeatureGuide('station-modal');
            }
            
            const modal = document.getElementById('station-modal');
            const planetList = document.getElementById('planet-stations');
            const fuelList = document.getElementById('fuel-stations');
            
            // 정거장 목록 분류
            const planetStations = satellites.filter(s => s.type === 'station' && !s.isFuelDepot);
            const fuelDepots = satellites.filter(s => s.type === 'station' && s.isFuelDepot);
            
            // 행성 궤도 정거장 렌더링
            planetList.innerHTML = '';
            planetStations.forEach(station => {
                const parentName = station.parentBody ? translateBodyName(station.parentBody.name) : t('unknown');
                const dist = playerShip ? 
                    playerShip.mesh.position.distanceTo(station.mesh.position).toFixed(0) : '---';
                
                // 방문 여부 확인 (ISS는 항상 방문)
                const isISS = station.name.includes('ISS');
                const visited = isISS || (typeof visitedSatellites !== 'undefined' && visitedSatellites.has(station.name));
                
                const item = document.createElement('div');
                item.className = 'station-item' + (visited ? '' : ' locked');
                item.innerHTML = `
                    <div class="station-info">
                        <div class="station-name">${visited ? '🛰️' : '🔒'} ${translateBodyName(station.name)}</div>
                        <div class="station-desc">${parentName} ${t('orbitSuffixText')} | ${t('distance')}: ${dist} km</div>
                    </div>
                    <div class="station-actions">
                        <button class="station-btn go ${visited ? '' : 'disabled'}" onclick="goToStation('${station.name}')">${visited ? t('goToStationBtn') : '🔒'}</button>
                        <button class="station-btn dock ${visited ? '' : 'disabled'}" onclick="${visited ? `dockAtStation('${station.name}')` : ''}">${visited ? t('docking') : '🔒'}</button>
                    </div>
                `;
                planetList.appendChild(item);
            });
            
            // 연료 정거장 렌더링
            fuelList.innerHTML = '';
            fuelDepots.forEach(depot => {
                const dist = playerShip ? 
                    playerShip.mesh.position.distanceTo(depot.mesh.position).toFixed(0) : '---';
                
                // 방문 여부 확인
                const visited = typeof visitedSatellites !== 'undefined' && visitedSatellites.has(depot.name);
                
                const item = document.createElement('div');
                item.className = 'station-item fuel-depot' + (visited ? '' : ' locked');
                item.innerHTML = `
                    <div class="station-info">
                        <div class="station-name">${visited ? '⛽' : '🔒'} ${translateBodyName(depot.name)}</div>
                        <div class="station-desc">${depot.description || t('orbitSuffixText')} | ${t('distance')}: ${dist} km</div>
                    </div>
                    <div class="station-actions">
                        <button class="station-btn go ${visited ? '' : 'disabled'}" onclick="goToStation('${depot.name}')">${visited ? t('goToStationBtn') : '🔒'}</button>
                        <button class="station-btn dock ${visited ? '' : 'disabled'}" onclick="${visited ? `dockAtStation('${depot.name}')` : ''}">${visited ? t('docking') : '🔒'}</button>
                    </div>
                `;
                fuelList.appendChild(item);
            });
            
            modal.classList.add('open');
        }
        
        // 정거장으로 카메라 이동 (가까이서 보기)
        window.goToStation = function(stationName) {
            const station = satellites.find(s => s.name === stationName);
            if (station) {
                // ISS는 항상 이동 가능
                const isISS = stationName.includes('ISS');
                
                // 방문 여부 체크 (ISS 제외)
                if (!isISS) {
                    const visited = typeof visitedSatellites !== 'undefined' && visitedSatellites.has(stationName);
                    if (!visited) {
                        // 친절한 안내 팝업
                        showStationLockedPopup(stationName);
                        return;
                    }
                }
                
                document.getElementById('station-modal').classList.remove('open');
                
                // ★ 정거장 가까이로 카메라 이동
                if (station.mesh && controls) {
                    const stationPos = station.mesh.position.clone();
                    const stationSize = station.r || 5;
                    const viewDistance = stationSize * 15;  // 정거장 크기의 15배 거리에서 보기
                    
                    // 카메라 위치 설정 (정거장 옆에서 비스듬히 보기)
                    const offset = new THREE.Vector3(viewDistance * 0.7, viewDistance * 0.5, viewDistance * 0.7);
                    camera.position.copy(stationPos).add(offset);
                    controls.target.copy(stationPos);
                    controls.update();
                    
                    showMsg(`📍 ${translateBodyName(stationName)}(으)로 이동했습니다.`);
                } else {
                    focusBody(station);
                    showMsg(`${translateBodyName(stationName)}(으)로 이동합니다.`);
                }
            }
        }
        
        // 잠긴 정거장 안내 팝업
        function showStationLockedPopup(stationName) {
            // 기존 팝업 제거
            const existingPopup = document.getElementById('station-locked-popup');
            if (existingPopup) existingPopup.remove();
            
            const popup = document.createElement('div');
            popup.id = 'station-locked-popup';
            popup.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(10, 20, 40, 0.95);
                border: 2px solid #f90;
                border-radius: 15px;
                padding: 25px;
                z-index: 10002;
                min-width: 300px;
                max-width: 90vw;
                text-align: center;
                font-family: 'Orbitron', sans-serif;
                color: white;
                box-shadow: 0 0 30px rgba(255, 150, 0, 0.3);
            `;
            
            popup.innerHTML = `
                <div style="font-size: 40px; margin-bottom: 15px;">🔒</div>
                <div style="font-size: 16px; color: #f90; margin-bottom: 10px;">미방문 정거장</div>
                <div style="font-size: 14px; color: #fff; margin-bottom: 15px;">${stationName}</div>
                <div style="font-size: 12px; color: #aaa; line-height: 1.6; margin-bottom: 20px;">
                    이 정거장은 아직 방문하지 않았습니다.<br><br>
                    <span style="color: #0ff;">📍 정거장 근처로 직접 비행</span>하여<br>
                    <span style="color: #0f0;">🚀 도킹</span>을 완료하면<br>
                    다음부터 바로 이동할 수 있습니다!
                </div>
                <button onclick="this.parentElement.remove()" style="
                    background: linear-gradient(135deg, #f90 0%, #f60 100%);
                    border: none;
                    color: #000;
                    padding: 12px 30px;
                    border-radius: 25px;
                    font-size: 14px;
                    font-weight: bold;
                    cursor: pointer;
                    font-family: 'Orbitron', sans-serif;
                ">${t('confirm')}</button>
            `;
            
            document.body.appendChild(popup);
            
            // 배경 클릭 시 닫기
            popup.addEventListener('click', (e) => {
                if (e.target === popup) popup.remove();
            });
        }
        
        // 정거장 도킹 (자동 항해 + 자동 도킹)
        function dockAtStation(stationName) {
            const station = satellites.find(s => s.name === stationName);
            if (!station) return;
            
            document.getElementById('station-modal').classList.remove('open');
            
            // 로그인 체크 (Supabase)
            const isLoggedIn = window.mpUser || window.mpUserId;
            if (!isLoggedIn) {
                showMsg('🔐 Login required.');
                const authOverlay = document.getElementById('auth-overlay');
                if (authOverlay) authOverlay.style.display = 'flex';
                return;
            }
            
            // 우주선이 없으면 먼저 탑승해야 함
            if (!playerShip || !playerShip.mesh) {
                showMsg('🚀 먼저 우주선에 탑승하세요.');
                openShipSelectModal();
                window.pendingDockStation = station;  // 우주선 선택 후 도킹할 정거장 저장
                return;
            }
            
            // ★★★ 자동 항해 시작 ★★★
            startAutoPilotToStation(station);
        }
        
        // ★★★ 자동 항해 시스템 ★★★
        let autoPilotActive = false;
        let autoPilotTarget = null;
        let autoPilotInterval = null;
        
        function startAutoPilotToStation(station) {
            if (!playerShip || !playerShip.mesh || !station || !station.mesh) {
                showMsg('❌ 자동 항해를 시작할 수 없습니다.');
                return;
            }
            
            autoPilotActive = true;
            autoPilotTarget = station;
            
            // 파일럿 모드로 전환
            if (!window.isPilotMode) {
                if (typeof enterCockpitView === 'function') {
                    enterCockpitView();
                }
            }
            
            showMsg(`🚀 ${translateBodyName(station.name)}(으)로 자동 항해를 시작합니다...`);
            
            // 자동 항해 UI 표시
            showAutoPilotUI(station);
            
            // 자동 항해 루프 시작
            if (autoPilotInterval) clearInterval(autoPilotInterval);
            autoPilotInterval = setInterval(() => updateAutoPilot(), 50);  // 20fps
        }
        
        function updateAutoPilot() {
            if (!autoPilotActive || !autoPilotTarget || !playerShip || !playerShip.mesh) {
                stopAutoPilot();
                return;
            }
            
            const shipPos = playerShip.mesh.position;
            const targetPos = autoPilotTarget.mesh.position;
            const distance = shipPos.distanceTo(targetPos);
            
            // 정거장 크기 기반 도킹 거리
            const stationSize = autoPilotTarget.r || 5;
            const dockingDistance = stationSize * 3;
            
            // UI 업데이트
            updateAutoPilotUI(distance);
            
            // 도킹 거리 도달
            if (distance < dockingDistance) {
                stopAutoPilot();
                completeAutoDocking(autoPilotTarget);
                return;
            }
            
            // ★ 방향 계산 및 회전
            const direction = new THREE.Vector3().subVectors(targetPos, shipPos).normalize();
            
            // 목표 방향으로 우주선 회전
            const targetQuaternion = new THREE.Quaternion();
            const rotMatrix = new THREE.Matrix4().lookAt(shipPos, targetPos, new THREE.Vector3(0, 1, 0));
            targetQuaternion.setFromRotationMatrix(rotMatrix);
            
            // 부드러운 회전
            playerShip.mesh.quaternion.slerp(targetQuaternion, 0.02);
            
            // ★ 속도 조절 (거리에 따라)
            let speed;
            if (distance > 10000) {
                speed = playerShip.maxSpeed * 0.9;  // 먼 거리: 최고 속도
            } else if (distance > 1000) {
                speed = playerShip.maxSpeed * 0.6;  // 중간 거리
            } else if (distance > 100) {
                speed = playerShip.maxSpeed * 0.3;  // 가까운 거리
            } else {
                speed = Math.max(50, playerShip.maxSpeed * 0.1);  // 도킹 접근
            }
            
            // 이동
            const velocity = direction.multiplyScalar(speed * 0.05);
            playerShip.mesh.position.add(velocity);
            
            // 연료 소비 (자동 항해는 연료 효율 좋음)
            if (playerShip.fuel > 0) {
                playerShip.fuel -= 0.01;
            } else {
                showMsg('⚠️ 연료 부족! 자동 항해 중단.');
                stopAutoPilot();
            }
        }
        
        function stopAutoPilot() {
            autoPilotActive = false;
            autoPilotTarget = null;
            if (autoPilotInterval) {
                clearInterval(autoPilotInterval);
                autoPilotInterval = null;
            }
            hideAutoPilotUI();
        }
        
        function completeAutoDocking(station) {
            showMsg(`✅ ${translateBodyName(station.name)}에 도킹 완료!`);
            
            // 도킹 상태 설정
            window.isDockedToStation = true;
            window.dockedStation = station;
            playerShip.isDocked = true;
            
            // 방문 기록 추가
            if (typeof visitedSatellites !== 'undefined') {
                const wasVisited = visitedSatellites.has(station.name);
                visitedSatellites.add(station.name);
                
                if (typeof saveVisitedStations === 'function') {
                    saveVisitedStations();
                }
                
                if (!wasVisited) {
                    setTimeout(() => {
                        showMsg(`🎉 ${translateBodyName(station.name)} 첫 방문! 이제 빠른 이동이 가능합니다.`);
                    }, 1000);
                }
            }
            
            // 연료 충전 시작 (연료 정거장인 경우)
            if (station.isFuelDepot || station.type === 'station') {
                setTimeout(() => {
                    if (playerShip.fuel < playerShip.maxFuel) {
                        showMsg('⛽ 연료 충전 중...');
                        startAutoRefuel();
                    }
                }, 500);
            }
            
            // 도킹 UI 표시
            showDockedUI(station);
        }
        
        // 자동 항해 UI
        function showAutoPilotUI(station) {
            let ui = document.getElementById('autopilot-ui');
            if (!ui) {
                ui = document.createElement('div');
                ui.id = 'autopilot-ui';
                ui.style.cssText = `
                    position: fixed;
                    top: 120px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(0, 50, 100, 0.9);
                    border: 2px solid #00ffff;
                    border-radius: 15px;
                    padding: 15px 25px;
                    z-index: 9999;
                    font-family: 'Orbitron', sans-serif;
                    color: #fff;
                    text-align: center;
                    min-width: 250px;
                `;
                document.body.appendChild(ui);
            }
            
            ui.innerHTML = `
                <div style="font-size: 14px; color: #00ffff; margin-bottom: 8px;">🚀 자동 항해 중</div>
                <div style="font-size: 16px; font-weight: bold; margin-bottom: 10px;">${translateBodyName(station.name)}</div>
                <div id="autopilot-distance" style="font-size: 20px; color: #0f0;">--- km</div>
                <div style="margin-top: 10px;">
                    <button onclick="stopAutoPilot(); showMsg('자동 항해 취소');" style="
                        background: #f44;
                        border: none;
                        color: #fff;
                        padding: 8px 20px;
                        border-radius: 20px;
                        cursor: pointer;
                        font-family: 'Orbitron', sans-serif;
                    ">✕ 취소</button>
                </div>
            `;
            ui.style.display = 'block';
        }
        
        function updateAutoPilotUI(distance) {
            const distEl = document.getElementById('autopilot-distance');
            if (distEl) {
                if (distance > 1000) {
                    distEl.textContent = `${(distance / 1000).toFixed(1)} 천 km`;
                } else {
                    distEl.textContent = `${distance.toFixed(0)} km`;
                }
            }
        }
        
        function hideAutoPilotUI() {
            const ui = document.getElementById('autopilot-ui');
            if (ui) ui.style.display = 'none';
        }
        
        // 자동 연료 충전
        function startAutoRefuel() {
            const refuelInterval = setInterval(() => {
                if (!playerShip || !window.isDockedToStation) {
                    clearInterval(refuelInterval);
                    return;
                }
                
                if (playerShip.fuel < playerShip.maxFuel) {
                    playerShip.fuel = Math.min(playerShip.maxFuel, playerShip.fuel + 5);
                    updateShipUI();
                } else {
                    clearInterval(refuelInterval);
                    showMsg('⛽ 연료 충전 완료!');
                }
            }, 200);
        }
        
        // 도킹 상태 UI
        function showDockedUI(station) {
            let ui = document.getElementById('docked-ui');
            if (!ui) {
                ui = document.createElement('div');
                ui.id = 'docked-ui';
                ui.style.cssText = `
                    position: fixed;
                    bottom: 100px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(0, 80, 40, 0.9);
                    border: 2px solid #0f0;
                    border-radius: 15px;
                    padding: 12px 25px;
                    z-index: 9998;
                    font-family: 'Orbitron', sans-serif;
                    color: #fff;
                    text-align: center;
                `;
                document.body.appendChild(ui);
            }
            
            ui.innerHTML = `
                <div style="font-size: 14px;">✅ ${translateBodyName(station.name)} 도킹됨</div>
                <button onclick="undockFromStation();" style="
                    margin-top: 8px;
                    background: #f90;
                    border: none;
                    color: #000;
                    padding: 6px 15px;
                    border-radius: 15px;
                    cursor: pointer;
                    font-family: 'Orbitron', sans-serif;
                    font-size: 12px;
                ">🚀 도킹 해제</button>
            `;
            ui.style.display = 'block';
        }
        
        // 전역 함수 노출
        window.stopAutoPilot = stopAutoPilot;
        
        // 연료 충전 관련 (오래된 코드 - 참조용으로 유지)
        let refuelInterval = null;
        
        // 연료 충전 중단
        function stopRefueling() {
            if (refuelInterval) {
                clearInterval(refuelInterval);
                refuelInterval = null;
            }
            const panel = document.getElementById('refuel-panel');
            if (panel) panel.classList.remove('show');
        }
        
        // ★★★ 근처 연료 정거장 감지 시스템 ★★★
        let nearbyFuelStation = null;
        let lastRefuelCheck = 0;
        
        function checkNearbyFuelStation() {
            if (!playerShip || !playerShip.mesh || !isPilotMode) {
                hideDockingButton();
                return;
            }
            
            // 이미 도킹 중이거나 도킹된 상태면 체크 안함
            if (window.isDocking || window.isDockedToStation) {
                hideDockingButton();
                return;
            }
            
            // 0.5초마다 체크 (성능 최적화)
            const now = Date.now();
            if (now - lastRefuelCheck < 500) return;
            lastRefuelCheck = now;
            
            const shipPos = playerShip.mesh.position;
            let closestStation = null;
            let closestDist = Infinity;
            
            // 모든 위성(정거장 포함) 검사
            satellites.forEach(sat => {
                if (sat.isSpaceStation && sat.hasFuel && sat.mesh) {
                    const dist = shipPos.distanceTo(sat.mesh.position);
                    const visualSize = sat.mesh.scale.x || 0.05;
                    const detectRange = Math.max(visualSize * 20, 2.0);
                    
                    if (dist < detectRange && dist < closestDist) {
                        closestDist = dist;
                        closestStation = sat;
                    }
                }
            });
            
            // 연료 정거장 (중간 궤도) 검사
            bodies.forEach(body => {
                if (body.isStation && body.hasFuel && body.mesh) {
                    const dist = shipPos.distanceTo(body.mesh.position);
                    const visualSize = body.mesh.scale.x || 0.015;
                    const detectRange = Math.max(visualSize * 30, 1.5);
                    
                    if (dist < detectRange && dist < closestDist) {
                        closestDist = dist;
                        closestStation = body;
                    }
                }
            });
            
            if (closestStation) {
                if (nearbyFuelStation !== closestStation) {
                    // 아리아 알림
                    if (typeof aiTypeMessage === 'function') {
                        aiTypeMessage(`⛽ ${closestStation.name} 접근 중. 도킹이 가능합니다.`);
                    }
                }
                nearbyFuelStation = closestStation;
                showDockingButton();  // ★ 화면 중앙 도킹 버튼 표시
            } else {
                nearbyFuelStation = null;
                hideDockingButton();
            }
        }
        
        function showRefuelButton(stationName) {
            // 기존 함수 - 더 이상 사용 안함
        }
        
        function hideRefuelButton() {
            // 기존 함수 - 더 이상 사용 안함
        }
        
        // ★★★ 새로운 도킹 시스템 ★★★
        window.isDocking = false;
        window.isDockedToStation = false;  // 정거장에 도킹된 상태
        window.dockedStationRef = null;    // 도킹된 정거장 참조
        window.dockingOffset = null;       // 정거장 기준 우주선 오프셋
        
        // 화면 중앙 도킹 버튼 표시
        function showDockingButton() {
            const btn = document.getElementById('docking-center-btn');
            if (btn && !window.isDocking && !window.isDockedToStation) {
                btn.classList.add('show');
            }
        }
        
        // 도킹 버튼 숨기기
        function hideDockingButton() {
            const btn = document.getElementById('docking-center-btn');
            if (btn) btn.classList.remove('show');
        }
        
        // 도킹 메뉴 표시
        function showDockingMenu() {
            document.getElementById('docking-menu').classList.add('show');
        }
        
        // 도킹 메뉴 숨기기
        function hideDockingMenu() {
            document.getElementById('docking-menu').classList.remove('show');
        }
        
        // 도킹해제 버튼 표시
        function showUndockButton() {
            document.getElementById('undock-btn').classList.add('show');
        }
        
        // 도킹해제 버튼 숨기기
        function hideUndockButton() {
            document.getElementById('undock-btn').classList.remove('show');
        }
        
        // ★ 도킹 시작 (버튼 클릭 시)
        function startDocking() {
            console.log('★★★ startDocking 호출됨');
            
            if (!nearbyFuelStation || !playerShip || !playerShip.mesh) {
                showMsg('⚠️ No dockable station nearby.');
                return;
            }
            
            if (window.isDocking || window.isDockedToStation) {
                showMsg('⚠️ Already docking or docked.');
                return;
            }
            
            const station = nearbyFuelStation;
            window.isDocking = true;
            
            // ★ 3인칭 뷰로 전환
            isCockpitView = false;
            
            // 도킹 버튼 숨기기
            hideDockingButton();
            
            // ★ 3인칭 카메라로 전환
            if (camera.parent) {
                camera.parent.remove(camera);
            }
            scene.add(camera);
            
            const shipPos = playerShip.mesh.position.clone();
            const stationPos = station.mesh.position.clone();
            
            // 카메라 초기 위치
            const midPoint = new THREE.Vector3().addVectors(shipPos, stationPos).multiplyScalar(0.5);
            const viewDir = new THREE.Vector3().subVectors(stationPos, shipPos).normalize();
            const sideDir = new THREE.Vector3().crossVectors(viewDir, new THREE.Vector3(0, 1, 0)).normalize();
            const camOffset = sideDir.multiplyScalar(4).add(new THREE.Vector3(0, 2, 0));
            camera.position.copy(midPoint).add(camOffset);
            camera.lookAt(midPoint);
            
            // 조종석 숨기기
            const cockpit = playerShip.mesh.getObjectByName('cockpitGroup');
            if (cockpit) cockpit.visible = false;
            
            // 도킹 애니메이션 설정
            const initialSpeed = playerShip.speed || 0;
            const startPos = shipPos.clone();
            const dockDir = new THREE.Vector3().subVectors(startPos, stationPos).normalize();
            const dockDistance = (station.mesh.scale.x || 0.05) * 3 + 0.15;
            const dockPos = stationPos.clone().add(dockDir.multiplyScalar(dockDistance));
            
            const dockDuration = 5000;
            const dockStartTime = Date.now();
            
            showMsg(`🔗 ${station.name}에 도킹 시도 중...`);
            if (typeof aiTypeMessage === 'function') {
                aiTypeMessage(`🚀 ${station.name}에 접근 중입니다. 도킹 시퀀스 시작...`);
            }
            
            const statusEl = document.getElementById('info-status');
            if (statusEl) {
                statusEl.textContent = t('docking');
                statusEl.style.color = '#ffaa00';
            }
            
            function dockAnimation() {
                if (!window.isDocking) return;
                
                const elapsed = Date.now() - dockStartTime;
                const progress = Math.min(elapsed / dockDuration, 1.0);
                const ease = progress < 0.5 
                    ? 2 * progress * progress 
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                
                playerShip.speed = initialSpeed * (1 - ease);
                playerShip.velocity.set(0, 0, 0);
                playerShip.mesh.position.lerpVectors(startPos, dockPos, ease);
                playerShip.mesh.lookAt(stationPos);
                
                // 3인칭 카메라 따라가기
                const shipCurrentPos = playerShip.mesh.position.clone();
                const toStation = new THREE.Vector3().subVectors(stationPos, shipCurrentPos).normalize();
                const behindShip = toStation.clone().multiplyScalar(-3);
                const upOffset = new THREE.Vector3(0, 1.5, 0);
                const sideOffset = new THREE.Vector3().crossVectors(toStation, new THREE.Vector3(0, 1, 0)).normalize().multiplyScalar(2);
                
                const targetCamPos = shipCurrentPos.clone().add(behindShip).add(upOffset).add(sideOffset);
                camera.position.lerp(targetCamPos, 0.03);
                
                const lookPoint = new THREE.Vector3().addVectors(shipCurrentPos, stationPos).multiplyScalar(0.5);
                camera.lookAt(lookPoint);
                
                if (progress < 1.0) {
                    requestAnimationFrame(dockAnimation);
                } else {
                    // ★ 도킹 완료
                    onDockingComplete(station);
                }
            }
            
            dockAnimation();
        }
        
        // ★ 도킹 완료 처리
        function onDockingComplete(station) {
            playerShip.speed = 0;
            window.dockedStation = station;
            window.dockedStationRef = station;
            window.isDockedToStation = true;
            
            // 정거장 기준 오프셋 저장 (함께 이동하기 위해)
            window.dockingOffset = new THREE.Vector3().subVectors(
                playerShip.mesh.position,
                station.mesh.position
            );
            
            showMsg(`✅ ${station.name} 도킹 완료!`);
            
            const statusEl = document.getElementById('info-status');
            if (statusEl) {
                statusEl.textContent = t('docked');
                statusEl.style.color = '#00ffff';
            }
            
            if (typeof aiTypeMessage === 'function') {
                aiTypeMessage(`✅ 도킹 완료! 연료 보충 또는 정거장 내부를 선택하세요.`);
            }
            
            // 도킹 메뉴 표시 (1초 후)
            setTimeout(() => {
                showDockingMenu();
            }, 1000);
        }
        
        // ★ 정거장과 함께 이동 (animate에서 호출)
        function updateDockedPosition() {
            if (!window.isDockedToStation || !window.dockedStationRef || !playerShip || !playerShip.mesh) return;
            
            const station = window.dockedStationRef;
            if (!station.mesh) return;
            
            // 우주선을 정거장과 함께 이동
            const newPos = station.mesh.position.clone().add(window.dockingOffset);
            playerShip.mesh.position.copy(newPos);
            
            // 정거장 바라보기 유지
            playerShip.mesh.lookAt(station.mesh.position);
            
            // 3인칭 카메라도 따라가기 (도킹 중일 때)
            if (window.isDocking && camera.parent === scene) {
                const shipPos = playerShip.mesh.position.clone();
                const stationPos = station.mesh.position.clone();
                const toStation = new THREE.Vector3().subVectors(stationPos, shipPos).normalize();
                const behindShip = toStation.clone().multiplyScalar(-3);
                const upOffset = new THREE.Vector3(0, 1.5, 0);
                const sideOffset = new THREE.Vector3().crossVectors(toStation, new THREE.Vector3(0, 1, 0)).normalize().multiplyScalar(1.5);
                
                const targetCamPos = shipPos.clone().add(behindShip).add(upOffset).add(sideOffset);
                camera.position.lerp(targetCamPos, 0.02);
                
                const lookPoint = new THREE.Vector3().addVectors(shipPos, stationPos).multiplyScalar(0.5);
                camera.lookAt(lookPoint);
            }
        }
        
        // ★ 연료 보충 시작
        function startRefueling() {
            if (!playerShip) return;
            
            hideDockingMenu();
            
            const maxFuel = SHIP_CONFIG.maxFuel;
            const currentFuel = Math.round(playerShip.fuel);
            const neededFuel = maxFuel - currentFuel;
            
            if (neededFuel <= 0) {
                showMsg('⛽ Fuel tank already full!');
                if (typeof aiTypeMessage === 'function') {
                    aiTypeMessage('연료 탱크가 이미 만충 상태입니다!');
                }
                completeRefueling();
                return;
            }
            
            // 비용 계산 (1 연료당 1 코인)
            const cost = neededFuel;
            const currentCoins = getUserCoins();
            
            if (currentCoins <= 0) {
                showMsg(`💰 코인이 부족합니다! (필요: ${cost} 코인)`);
                if (typeof aiTypeMessage === 'function') {
                    aiTypeMessage(`⚠️ 코인이 부족합니다. 현재 ${currentCoins} 코인.`);
                }
                completeRefueling();
                return;
            }
            
            // 연료 보급 오버레이 표시
            const overlay = document.getElementById('refuel-overlay');
            const barFill = document.getElementById('refuel-bar-fill');
            const amountText = document.getElementById('refuel-amount');
            const costText = document.getElementById('refuel-cost');
            
            overlay.classList.add('show');
            
            const startFuel = currentFuel;
            const affordableFuel = Math.min(neededFuel, currentCoins);  // 코인만큼만
            const targetFuel = currentFuel + affordableFuel;
            const totalToFill = affordableFuel;
            const totalCost = totalToFill;
            
            costText.textContent = `Cost: ${totalCost} coins`;
            
            let filledAmount = 0;
            
            if (typeof aiTypeMessage === 'function') {
                aiTypeMessage(`⛽ 연료 보급을 시작합니다. 예상 Cost: ${totalCost} coins`);
            }
            
            // 연료 충전 애니메이션
            const refuelInterval = setInterval(() => {
                if (!playerShip || filledAmount >= totalToFill) {
                    clearInterval(refuelInterval);
                    overlay.classList.remove('show');
                    
                    if (playerShip) {
                        const finalFuel = Math.round(playerShip.fuel);
                        const spent = finalFuel - startFuel;
                        spendCoins(spent);  // ★ spendCoins 함수 사용
                        updateLoginUI();    // UI 업데이트
                        
                        showMsg(`⛽ 연료 보급 완료! ${finalFuel}/${maxFuel} (-${spent} 코인)`);
                        
                        if (typeof aiTypeMessage === 'function') {
                            aiTypeMessage(`✅ 연료 보급 완료! 연료 ${finalFuel}/${maxFuel}. 사용 코인: ${spent}. 안전한 비행 되세요!`);
                        }
                    }
                    
                    // 1인칭 복귀 후 도킹해제 버튼 표시
                    setTimeout(completeRefueling, 1000);
                    return;
                }
                
                // 1회당 2씩 충전 (느린 연출)
                const fillAmount = Math.min(2, totalToFill - filledAmount);
                playerShip.fuel = Math.min(maxFuel, playerShip.fuel + fillAmount);
                filledAmount += fillAmount;
                
                const currentAmount = Math.round(playerShip.fuel);
                const percent = Math.round((currentAmount / maxFuel) * 100);
                barFill.style.width = percent + '%';
                amountText.textContent = `${currentAmount}/${maxFuel}`;
            }, 80);
        }
        
        // ★ 연료 보충 완료 (1인칭 복귀 + 도킹해제 버튼)
        function completeRefueling() {
            if (!playerShip || !playerShip.mesh) return;
            
            // 1인칭 카메라로 복귀
            scene.remove(camera);
            playerShip.mesh.add(camera);
            
            // ★ 카메라 위치: 조종석 앞쪽에서 전방을 보도록
            camera.position.set(0, 0.08, -0.15);  // Z를 음수로 (앞쪽)
            camera.rotation.set(0, 0, 0);
            
            // 조종석 다시 보이기
            const cockpit = playerShip.mesh.getObjectByName('cockpitGroup');
            if (cockpit) cockpit.visible = true;
            
            // 조종석 시점 초기화
            cockpitTargetRotY = 0;
            cockpitTargetRotX = 0;
            cockpitLookRotY = 0;
            cockpitLookRotX = 0;
            
            // isDocking은 false로 (카메라 업데이트 허용)
            window.isDocking = false;
            
            // HUD 상태
            const statusEl = document.getElementById('info-status');
            if (statusEl) {
                statusEl.textContent = t('docked');
                statusEl.style.color = '#00ffff';
            }
            
            showMsg('🚀 Returning to cockpit');
            
            // 도킹해제 버튼 표시
            setTimeout(showUndockButton, 500);
        }
        
        // ★★★ 선체 수리 시작 ★★★
        function startRepair() {
            if (!playerShip) return;
            
            hideDockingMenu();
            
            const maxHull = SHIP_CONFIG.maxHull;
            const currentHull = Math.round(playerShip.hull);
            const neededRepair = maxHull - currentHull;
            
            if (neededRepair <= 0) {
                showMsg('🔧 Hull already in perfect condition!');
                if (typeof aiTypeMessage === 'function') {
                    aiTypeMessage('선체 내구도가 이미 만점입니다!');
                }
                completeRepair();
                return;
            }
            
            // 비용 계산 (1 내구도당 2 코인)
            const costPerHull = 2;
            const totalCost = neededRepair * costPerHull;
            const currentCoins = getUserCoins();
            
            if (currentCoins <= 0) {
                showMsg(`💰 코인이 부족합니다! (필요: ${totalCost} 코인)`);
                if (typeof aiTypeMessage === 'function') {
                    aiTypeMessage(`⚠️ 코인이 부족합니다. 현재 ${currentCoins} 코인.`);
                }
                completeRepair();
                return;
            }
            
            // 수리 오버레이 표시
            const overlay = document.getElementById('repair-overlay');
            const barFill = document.getElementById('repair-bar-fill');
            const amountText = document.getElementById('repair-amount');
            const costText = document.getElementById('repair-cost');
            
            overlay.classList.add('show');
            
            const startHull = currentHull;
            const affordableRepair = Math.min(neededRepair, Math.floor(currentCoins / costPerHull));
            const targetHull = currentHull + affordableRepair;
            const totalToRepair = affordableRepair;
            const actualCost = totalToRepair * costPerHull;
            
            costText.textContent = `Cost: ${actualCost} coins`;
            
            let repairedAmount = 0;
            
            if (typeof aiTypeMessage === 'function') {
                aiTypeMessage(`🔧 선체 수리를 시작합니다. 예상 Cost: ${actualCost} coins`);
            }
            
            // 수리 애니메이션
            const repairInterval = setInterval(() => {
                if (!playerShip || repairedAmount >= totalToRepair) {
                    clearInterval(repairInterval);
                    overlay.classList.remove('show');
                    
                    if (playerShip) {
                        const finalHull = Math.round(playerShip.hull);
                        const repaired = finalHull - startHull;
                        const spent = repaired * costPerHull;
                        spendCoins(spent);
                        updateLoginUI();
                        
                        showMsg(`🔧 선체 수리 완료! ${finalHull}/${maxHull} (-${spent} 코인)`);
                        
                        if (typeof aiTypeMessage === 'function') {
                            aiTypeMessage(`✅ 선체 수리 완료! 내구도 ${finalHull}/${maxHull}. 사용 코인: ${spent}. 안전한 비행 되세요!`);
                        }
                    }
                    
                    setTimeout(completeRepair, 1000);
                    return;
                }
                
                // 1회당 1씩 수리
                const repairAmount = Math.min(1, totalToRepair - repairedAmount);
                playerShip.hull = Math.min(maxHull, playerShip.hull + repairAmount);
                repairedAmount += repairAmount;
                
                const currentAmount = Math.round(playerShip.hull);
                const percent = Math.round((currentAmount / maxHull) * 100);
                barFill.style.width = percent + '%';
                amountText.textContent = `${currentAmount}/${maxHull}`;
            }, 100);
        }
        
        // ★ 수리 완료 (1인칭 복귀 + 도킹해제 버튼)
        function completeRepair() {
            if (!playerShip || !playerShip.mesh) return;
            
            // 1인칭 카메라로 복귀
            scene.remove(camera);
            playerShip.mesh.add(camera);
            camera.position.set(0, 0.08, -0.15);  // ★ Z를 음수로 (앞쪽)
            camera.rotation.set(0, 0, 0);
            
            // 조종석 다시 보이기
            const cockpit = playerShip.mesh.getObjectByName('cockpitGroup');
            if (cockpit) cockpit.visible = true;
            
            // 조종석 시점 초기화
            cockpitTargetRotY = 0;
            cockpitTargetRotX = 0;
            cockpitLookRotY = 0;
            cockpitLookRotX = 0;
            
            window.isDocking = false;
            
            const statusEl = document.getElementById('info-status');
            if (statusEl) {
                statusEl.textContent = t('docked');
                statusEl.style.color = '#00ffff';
            }
            
            showMsg('🚀 Returning to cockpit');
            setTimeout(showUndockButton, 500);
        }
        
        // ★ 정거장 내부 (개발중)
        function enterStationInterior() {
            showMsg('🔧 Station interior is under development.');
            if (typeof aiTypeMessage === 'function') {
                aiTypeMessage('🔧 정거장 내부 기능은 현재 개발 중입니다. 조금만 기다려 주세요!');
            }
        }
        
        // ★ 도킹해제
        function undockFromStation() {
            if (!playerShip || !playerShip.mesh) return;
            
            hideUndockButton();
            
            // ★ 3인칭 뷰로 전환
            isCockpitView = false;
            
            // 정거장 위치 저장 (연출용)
            const stationRef = window.dockedStationRef;
            const stationPos = stationRef && stationRef.mesh ? 
                stationRef.mesh.position.clone() : 
                playerShip.mesh.position.clone();
            
            // 도킹 상태 해제
            window.isDockedToStation = false;
            window.dockedStationRef = null;
            window.dockingOffset = null;
            window.dockedStation = null;
            
            // ★ 언도킹 연출 시작 (게임 시작 때와 동일)
            undockingState.active = true;
            undockingState.phase = 'undocking';
            undockingState.startTime = Date.now();
            undockingState.startPos = playerShip.mesh.position.clone();
            undockingState.stationPos = stationPos;
            
            // ★ 지구 반대 방향 계산
            const earth = bodies.find(b => b.name === '지구' || b.name === 'Earth');
            if (earth && earth.mesh) {
                undockingState.undockDirection = new THREE.Vector3()
                    .subVectors(stationPos, earth.mesh.position)
                    .normalize();
            } else {
                undockingState.undockDirection = new THREE.Vector3()
                    .subVectors(playerShip.mesh.position, stationPos)
                    .normalize();
            }
            
            // 3인칭 카메라로 전환
            if (camera.parent) {
                camera.parent.remove(camera);
            }
            scene.add(camera);
            
            // 조종석 숨기기
            const cockpit = playerShip.mesh.getObjectByName('cockpitGroup');
            if (cockpit) cockpit.visible = false;
            
            // 상태 표시
            const statusEl = document.getElementById('info-status');
            if (statusEl) {
                statusEl.textContent = t('launching');
                statusEl.style.color = '#ffaa00';
            }
            
            showMsg('🚀 Undocking...');
            if (typeof aiTypeMessage === 'function') {
                aiTypeMessage('🚀 도킹 해제 시퀀스를 시작합니다. 발진 준비!');
            }
        }
        window.undockFromStation = undockFromStation;  // ★ 전역 노출
        
        // 1인칭 카메라로 복귀 (기존 함수 유지 - 다른 곳에서 사용)
        function returnToFirstPerson() {
            if (!playerShip || !playerShip.mesh) return;
            
            window.isDocking = false;
            
            scene.remove(camera);
            playerShip.mesh.add(camera);
            camera.position.set(0, 0.08, 0.15);
            camera.rotation.set(0, 0, 0);
            
            const cockpit = playerShip.mesh.getObjectByName('cockpitGroup');
            if (cockpit) cockpit.visible = true;
            
            cockpitTargetRotY = 0;
            cockpitTargetRotX = 0;
            cockpitLookRotY = 0;
            cockpitLookRotX = 0;
            
            showMsg('🚀 Returning to pilot mode');
        }
        
        function openShipSelectModal() {
            // ★ 멀티모드 튜토리얼 가이드
            if (typeof MultiTutorial !== 'undefined') {
                MultiTutorial.showFeatureGuide('ship-select');
            }
            
            // ★★★ 기존 운항중인 우주선이 있는지 확인 ★★★
            const savedShipData = ShipPositionManager.load();
            if (savedShipData && savedShipData.position) {
                const shipName = savedShipData.shipName || '우주선';
                const distFromISS = Math.sqrt(
                    savedShipData.position.x ** 2 + 
                    savedShipData.position.y ** 2 + 
                    savedShipData.position.z ** 2
                );
                
                // ISS 근처가 아니면 (거리 100 이상) 운항중으로 간주
                if (distFromISS > 100) {
                    // ★★★ 게임 내 커스텀 팝업 표시 ★★★
                    showActiveShipPopup(savedShipData, shipName, distFromISS);
                    return;
                }
            }
            
            // ★ ships.json이 아직 로드 안됐으면 대기 후 열기
            if (!shipsDataLoaded) {
                console.log('⏳ ships.json 로딩 대기 중...');
                setTimeout(openShipSelectModal, 100);
                return;
            }
            
            // 디버그: 현재 SHIP_TYPES 이미지 상태 출력
            console.log('🚀 우주선 선택 모달 열기 - 현재 이미지 상태:');
            SHIP_TYPES.forEach(s => {
                console.log(`  ${s.id}: image=${s.image || '없음'}`);
            });
            
            const modal = document.getElementById('ship-select-modal');
            const shipList = document.getElementById('ship-list');
            
            // 우주선 목록 생성
            shipList.innerHTML = '';
            SHIP_TYPES.forEach((ship, idx) => {
                const isOwned = ownsShip(ship.id);
                const card = document.createElement('div');
                card.className = `ship-card ${idx === selectedShipIndex ? 'selected' : ''} ${!ship.unlocked ? 'locked' : ''} ${isOwned ? 'owned' : ''}`;
                
                // ★ 이미지가 있으면 크게 표시, 없으면 이모지 (잠긴 우주선도 로켓 아이콘)
                const hasImage = ship.image && ship.image.length > 0;
                const iconContent = hasImage 
                    ? `<img src="${ship.image}" alt="${ship.name}">`
                    : '🚀';  // 잠긴 우주선도 로켓 아이콘 표시
                
                // ★ 항상 색상 배경 표시
                const bgStyle = hasImage ? '' : `background: #${ship.color.toString(16).padStart(6, '0')}40;`;
                
                card.innerHTML = `
                    ${isOwned ? '<div class="ship-card-owned">✓</div>' : ''}
                    <div class="ship-card-icon" style="${bgStyle}">
                        ${iconContent}
                    </div>
                    <div class="ship-card-name">${getShipName(ship)}</div>
                    <div class="ship-card-tier">${'⭐'.repeat(ship.tier)}</div>
                    ${!ship.unlocked ? '<div class="ship-card-dev">🔧</div>' : ''}
                `;
                if (ship.unlocked) {
                    card.onclick = () => selectShipType(idx);
                } else {
                    card.onclick = () => showMsg(`🔧 ${getShipName(ship)} - ${t('upgradeAtStation')}`);
                }
                shipList.appendChild(card);
            });
            
            // 현재 선택된 우주선 상세 정보 표시
            updateShipDetail(selectedShipIndex);
            
            modal.classList.add('open');
        }
        
        function selectShipType(idx) {
            selectedShipIndex = idx;
            currentShipType = SHIP_TYPES[idx];
            window.currentShipType = currentShipType;  // ★ 전역 업데이트
            
            // 카드 선택 상태 업데이트
            document.querySelectorAll('.ship-card').forEach((card, i) => {
                card.classList.toggle('selected', i === idx);
            });
            
            updateShipDetail(idx);
        }
        
        function updateShipDetail(idx) {
            const ship = SHIP_TYPES[idx];
            const isOwned = ownsShip(ship.id);
            
            document.getElementById('ship-detail-name').textContent = `${getShipName(ship)} (${ship.nameEn})`;
            // 다국어 설명
            const lang = window.currentLang || 'en';
            const descKey = 'desc' + lang.charAt(0).toUpperCase() + lang.slice(1);
            document.getElementById('ship-detail-desc').textContent = ship[descKey] || ship.descEn || ship.description;
            
            // 가격 표시
            const priceEl = document.getElementById('ship-price-value');
            const ownedBadge = document.getElementById('ship-owned-badge');
            
            if (ship.id === 'shuttle' && isOwned) {
                // 셔틀은 회원가입 시 기본 지급
                priceEl.textContent = '0';
                ownedBadge.textContent = '🎁 ' + t('freeShip');
                ownedBadge.style.display = 'inline';
                ownedBadge.style.background = '#9b59b6';
            } else {
                priceEl.textContent = ship.price.toLocaleString();
                ownedBadge.textContent = t('owned');
                ownedBadge.style.display = isOwned ? 'inline' : 'none';
                ownedBadge.style.background = '#27ae60';
            }
            
            // 버튼 상태 업데이트
            const buyBtn = document.getElementById('btn-buy-ship');
            const launchBtn = document.getElementById('btn-select-ship');
            
            if (isOwned) {
                buyBtn.style.display = 'none';
                launchBtn.style.display = 'block';
                launchBtn.disabled = false;
            } else {
                buyBtn.style.display = 'block';
                buyBtn.textContent = `🪙 ${t('buy')} (${ship.price.toLocaleString()})`;
                buyBtn.disabled = getUserCoins() < ship.price;
                launchBtn.style.display = 'none';
            }
            
            // 스탯 바 업데이트 (최대값 대비 비율)
            const maxSpeed = 225, maxAccel = 6.0, maxTurn = 0.25, maxFuel = 2500;
            
            document.querySelector('.stat-fill.speed').style.width = (ship.maxSpeed / maxSpeed * 100) + '%';
            document.querySelector('.stat-fill.accel').style.width = (ship.acceleration / maxAccel * 100) + '%';
            document.querySelector('.stat-fill.turn').style.width = (ship.turnSpeed / maxTurn * 100) + '%';
            document.querySelector('.stat-fill.fuel').style.width = (ship.maxFuel / maxFuel * 100) + '%';
            
            document.getElementById('stat-speed').textContent = ship.maxSpeed + ' km/s';
            document.getElementById('stat-accel').textContent = ship.acceleration.toFixed(2);
            document.getElementById('stat-turn').textContent = ship.turnSpeed.toFixed(3);
            document.getElementById('stat-fuel').textContent = ship.maxFuel;
            
            // 특수 능력
            const specialEl = document.getElementById('ship-special');
            if (ship.special && ship.specialDesc) {
                specialEl.innerHTML = `✨ <strong>${t('specialAbility') || '특수능력'}:</strong> ${ship.specialDesc}`;
            } else {
                specialEl.innerHTML = '';
            }
            
            // 프리뷰 업데이트 (이미지가 있으면 이미지, 없으면 이모지)
            const preview = document.getElementById('ship-preview');
            if (ship.image && ship.image.length > 0) {
                preview.innerHTML = `<img src="${ship.image}" alt="${ship.name}" style="max-width:100%;max-height:100%;object-fit:contain;filter: drop-shadow(0 0 20px #${ship.color.toString(16).padStart(6, '0')});">`;
            } else {
                preview.innerHTML = `<div style="font-size: 60px; filter: drop-shadow(0 0 20px #${ship.color.toString(16).padStart(6, '0')});">🚀</div>`;
            }
        }
        
        function closeShipSelectModal() {
            document.getElementById('ship-select-modal').classList.remove('open');
        }
        
        // ★ 무장 시스템 함수들
        let currentArmoryTab = 'weapons';
        let selectedArmoryItem = null;
        let selectedArmorySlot = 0;
        
        function openArmoryModal() {
            const isLoggedIn = window.mpUser || window.mpUserId;
            if (!isLoggedIn) {
                showMsg('🔐 Login required.');
                const authOverlay = document.getElementById('auth-overlay');
                if (authOverlay) authOverlay.style.display = 'flex';
                return;
            }
            if (!ownsShip(currentShipType.id)) {
                showMsg('⚠️ You must own this ship to equip weapons.');
                return;
            }
            document.getElementById('armory-modal').classList.add('open');
            currentArmoryTab = 'weapons';
            selectedArmoryItem = null;
            selectedArmorySlot = 0;
            renderArmoryList();
            renderEquippedSlots();
            updateArmoryDetail();
        }
        
        function closeArmoryModal() {
            document.getElementById('armory-modal').classList.remove('open');
        }
        
        function switchArmoryTab(tab) {
            currentArmoryTab = tab;
            selectedArmoryItem = null;
            document.querySelectorAll('.armory-tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.armory-tab[data-tab="${tab}"]`).classList.add('active');
            renderArmoryList();
            updateArmoryDetail();
        }
        
        function renderArmoryList() {
            const list = document.getElementById('armory-list');
            const shipId = currentShipType.id;
            const combatStats = SHIP_COMBAT_STATS[shipId];
            const equipped = getEquipped(shipId);
            
            if (currentArmoryTab === 'weapons') {
                list.innerHTML = WEAPONS.map(weapon => {
                    const owned = ownsWeapon(weapon.id);
                    const canEquip = weapon.tier <= combatStats.maxWeaponTier;
                    const isEquipped = equipped.weapons.includes(weapon.id);
                    const icon = WEAPON_ICONS[weapon.id] || '🔫';
                    
                    return `<div class="armory-item ${!canEquip ? 'locked' : ''} ${isEquipped ? 'equipped' : ''} ${selectedArmoryItem === weapon.id ? 'selected' : ''}" 
                        data-id="${weapon.id}" onclick="selectArmoryItem('${weapon.id}')">
                        <div class="armory-item-icon">${icon}</div>
                        <div class="armory-item-info">
                            <div class="armory-item-name">${weapon.name}</div>
                            <div class="armory-item-tier">Tier ${weapon.tier} ${!canEquip ? '(' + t('locked') + ')' : ''}</div>
                            <div class="armory-item-stats">DMG:${weapon.damage} | ${t('range')}:${weapon.range}m</div>
                        </div>
                        ${owned ? '<span class="armory-item-owned">' + t('ownedMark') + '</span>' : `<span class="armory-item-price">🪙 ${weapon.price.toLocaleString()}</span>`}
                    </div>`;
                }).join('');
            } else {
                list.innerHTML = ARMORS.map(armor => {
                    const owned = ownsArmor(armor.id);
                    const canEquip = armor.tier <= combatStats.maxArmorTier;
                    const isEquipped = equipped.armor === armor.id;
                    const icon = ARMOR_ICONS[armor.id] || '🛡️';
                    
                    return `<div class="armory-item ${!canEquip ? 'locked' : ''} ${isEquipped ? 'equipped' : ''} ${selectedArmoryItem === armor.id ? 'selected' : ''}" 
                        data-id="${armor.id}" onclick="selectArmoryItem('${armor.id}')">
                        <div class="armory-item-icon">${icon}</div>
                        <div class="armory-item-info">
                            <div class="armory-item-name">${armor.name}</div>
                            <div class="armory-item-tier">Tier ${armor.tier} ${!canEquip ? '(' + t('locked') + ')' : ''}</div>
                            <div class="armory-item-stats">${t('defense')}:${armor.defense} | HP:+${armor.hpBonus}</div>
                        </div>
                        ${owned ? '<span class="armory-item-owned">' + t('ownedMark') + '</span>' : `<span class="armory-item-price">🪙 ${armor.price.toLocaleString()}</span>`}
                    </div>`;
                }).join('');
            }
        }
        
        function renderEquippedSlots() {
            const container = document.getElementById('armory-equipped-slots');
            const shipId = currentShipType.id;
            const combatStats = SHIP_COMBAT_STATS[shipId];
            const equipped = getEquipped(shipId);
            
            let html = '<div style="font-size:11px;color:#888;margin-bottom:5px;">🔫 무기 슬롯 (Tier 1~' + combatStats.maxWeaponTier + ')</div>';
            for (let i = 0; i < combatStats.weaponSlots; i++) {
                const weaponId = equipped.weapons[i];
                const weapon = weaponId ? WEAPONS.find(w => w.id === weaponId) : null;
                html += `<div class="armory-equipped-slot" onclick="selectArmorySlot(${i})">
                    <span>${i + 1}.</span>
                    <span class="${weapon ? '' : 'armory-slot-empty'}">${weapon ? (WEAPON_ICONS[weaponId] || '🔫') + ' ' + weapon.name : '빈 슬롯'}</span>
                </div>`;
            }
            
            html += '<div style="font-size:11px;color:#888;margin:10px 0 5px;">🛡️ 장갑 (Tier 1~' + combatStats.maxArmorTier + ')</div>';
            const armor = equipped.armor ? ARMORS.find(a => a.id === equipped.armor) : null;
            html += `<div class="armory-equipped-slot">
                <span class="${armor ? '' : 'armory-slot-empty'}">${armor ? (ARMOR_ICONS[equipped.armor] || '🛡️') + ' ' + armor.name : '장착 안됨'}</span>
            </div>`;
            
            container.innerHTML = html;
        }
        
        function selectArmoryItem(itemId) {
            selectedArmoryItem = itemId;
            renderArmoryList();
            updateArmoryDetail();
        }
        window.selectArmoryItem = selectArmoryItem;
        
        function selectArmorySlot(slotIndex) {
            selectedArmorySlot = slotIndex;
            showMsg(`슬롯 ${slotIndex + 1} 선택됨`);
        }
        window.selectArmorySlot = selectArmorySlot;
        
        function updateArmoryDetail() {
            const shipId = currentShipType.id;
            const combatStats = SHIP_COMBAT_STATS[shipId];
            const equipped = getEquipped(shipId);
            
            const iconEl = document.getElementById('armory-detail-icon');
            const nameEl = document.getElementById('armory-detail-name');
            const descEl = document.getElementById('armory-detail-desc');
            const statsEl = document.getElementById('armory-detail-stats');
            const effectEl = document.getElementById('armory-detail-effect');
            const priceEl = document.getElementById('armory-detail-price');
            const buyBtn = document.getElementById('btn-armory-buy');
            const equipBtn = document.getElementById('btn-armory-equip');
            const unequipBtn = document.getElementById('btn-armory-unequip');
            
            buyBtn.style.display = 'none';
            equipBtn.style.display = 'none';
            unequipBtn.style.display = 'none';
            effectEl.style.display = 'none';
            
            if (!selectedArmoryItem) {
                iconEl.textContent = currentArmoryTab === 'weapons' ? '🔫' : '🛡️';
                nameEl.textContent = currentArmoryTab === 'weapons' ? t('selectWeapon') : t('selectArmor');
                descEl.textContent = t('selectFromList');
                statsEl.innerHTML = '';
                priceEl.innerHTML = '';
                return;
            }
            
            if (currentArmoryTab === 'weapons') {
                const weapon = WEAPONS.find(w => w.id === selectedArmoryItem);
                const owned = ownsWeapon(weapon.id);
                const canEquip = weapon.tier <= combatStats.maxWeaponTier;
                const isEquipped = equipped.weapons.includes(weapon.id);
                
                iconEl.textContent = WEAPON_ICONS[weapon.id] || '🔫';
                nameEl.textContent = weapon.name;
                descEl.textContent = weapon.desc;
                statsEl.innerHTML = `
                    <div class="armory-stat-row"><span>${t('damage')}</span><span>${weapon.damage}</span></div>
                    <div class="armory-stat-row"><span>${t('fireRate')}</span><span>${weapon.fireRate}/s</span></div>
                    <div class="armory-stat-row"><span>${t('range')}</span><span>${weapon.range}m</span></div>
                    <div class="armory-stat-row"><span>${t('energy')}</span><span>${weapon.energy}</span></div>
                    <div class="armory-stat-row"><span>${t('tier')}</span><span>Tier ${weapon.tier}</span></div>
                `;
                
                if (!owned) {
                    priceEl.innerHTML = `<span style="color:#f39c12;font-size:14px;">🪙 ${weapon.price.toLocaleString()}</span>`;
                    buyBtn.style.display = 'inline-block';
                    buyBtn.disabled = getCoins() < weapon.price;
                } else {
                    priceEl.innerHTML = '<span style="color:#27ae60;">' + t('ownedMark') + '</span>';
                    if (canEquip) {
                        if (isEquipped) {
                            unequipBtn.style.display = 'inline-block';
                        } else {
                            equipBtn.style.display = 'inline-block';
                        }
                    }
                }
            } else {
                const armor = ARMORS.find(a => a.id === selectedArmoryItem);
                const owned = ownsArmor(armor.id);
                const canEquip = armor.tier <= combatStats.maxArmorTier;
                const isEquipped = equipped.armor === armor.id;
                
                iconEl.textContent = ARMOR_ICONS[armor.id] || '🛡️';
                nameEl.textContent = armor.name;
                descEl.textContent = armor.desc;
                statsEl.innerHTML = `
                    <div class="armory-stat-row"><span>${t('defense')}</span><span>${armor.defense}</span></div>
                    <div class="armory-stat-row"><span>${t('hpBonus')}</span><span>+${armor.hpBonus}</span></div>
                    <div class="armory-stat-row"><span>${t('weightFactor')}</span><span>×${armor.weight}</span></div>
                    <div class="armory-stat-row"><span>${t('tier')}</span><span>Tier ${armor.tier}</span></div>
                `;
                
                if (armor.effect) {
                    effectEl.textContent = '✨ ' + armor.effect;
                    effectEl.style.display = 'block';
                }
                
                if (!owned) {
                    priceEl.innerHTML = `<span style="color:#f39c12;font-size:14px;">🪙 ${armor.price.toLocaleString()}</span>`;
                    buyBtn.style.display = 'inline-block';
                    buyBtn.disabled = getCoins() < armor.price;
                } else {
                    priceEl.innerHTML = '<span style="color:#27ae60;">✓ 보유중</span>';
                    if (canEquip) {
                        if (isEquipped) {
                            unequipBtn.style.display = 'inline-block';
                        } else {
                            equipBtn.style.display = 'inline-block';
                        }
                    }
                }
            }
        }
        
        function handleArmoryBuy() {
            if (!selectedArmoryItem) return;
            
            if (currentArmoryTab === 'weapons') {
                if (buyWeapon(selectedArmoryItem)) {
                    showMsg('✅ Weapon purchased!');
                } else {
                    showMsg('❌ Purchase failed (insufficient coins or already owned)');
                }
            } else {
                if (buyArmor(selectedArmoryItem)) {
                    showMsg('✅ Armor purchased!');
                } else {
                    showMsg('❌ Purchase failed (insufficient coins or already owned)');
                }
            }
            
            renderArmoryList();
            renderEquippedSlots();
            updateArmoryDetail();
            updateUI();
        }
        
        function handleArmoryEquip() {
            if (!selectedArmoryItem) return;
            const shipId = currentShipType.id;
            
            if (currentArmoryTab === 'weapons') {
                if (equipWeapon(shipId, selectedArmoryItem, selectedArmorySlot)) {
                    showMsg(`✅ 슬롯 ${selectedArmorySlot + 1}에 장착 완료!`);
                } else {
                    showMsg('❌ Equip failed');
                }
            } else {
                if (equipArmor(shipId, selectedArmoryItem)) {
                    showMsg('✅ Armor equipped!');
                } else {
                    showMsg('❌ Equip failed');
                }
            }
            
            renderArmoryList();
            renderEquippedSlots();
            updateArmoryDetail();
        }
        
        function handleArmoryUnequip() {
            if (!selectedArmoryItem) return;
            const shipId = currentShipType.id;
            const equipped = getEquipped(shipId);
            
            if (currentArmoryTab === 'weapons') {
                const slotIndex = equipped.weapons.indexOf(selectedArmoryItem);
                if (slotIndex >= 0) {
                    unequipWeapon(shipId, slotIndex);
                    showMsg('✅ Weapon unequipped!');
                }
            } else {
                unequipArmor(shipId);
                showMsg('✅ Armor unequipped!');
            }
            
            renderArmoryList();
            renderEquippedSlots();
            updateArmoryDetail();
        }
        
        function confirmShipSelection() {
            // 주차된 우주선이 같은 타입이면 재탑승
            const isReboard = parkedShip && parkedShip.type === currentShipType.id;
            
            // 주차된 우주선이 있고, 다른 타입의 우주선을 선택한 경우 처분 확인
            if (parkedShip && !isReboard) {
                // 처분 확인 모달 표시
                showSellShipModal();
                return;
            }
            
            // 기존 주차 우주선 정리 (같은 타입 재탑승 시)
            if (isReboard && parkedShipMesh) {
                scene.remove(parkedShipMesh);
                parkedShipMesh = null;
            }
            
            closeShipSelectModal();
            proceedToBoard(isReboard);
        }
        
        // 함선 처분 모달 표시
        function showSellShipModal() {
            const modal = document.getElementById('sell-ship-modal');
            const parkedType = SHIP_TYPES.find(s => s.id === parkedShip.type);
            const sellPrice = Math.floor(parkedType.price * 0.5);
            
            document.getElementById('sell-current-ship').textContent = getShipName(parkedType);
            document.getElementById('sell-price-value').textContent = `🪙 ${sellPrice.toLocaleString()}`;
            document.getElementById('sell-ship-message').textContent = t('sellMessage');
            
            modal.classList.add('open');
        }
        
        // 함선 처분 확인
        function confirmSellShip() {
            const parkedType = SHIP_TYPES.find(s => s.id === parkedShip.type);
            const sellPrice = Math.floor(parkedType.price * 0.5);
            
            // 판매 금액 지급
            addCoins(sellPrice);
            showMsg(`💰 ${getShipName(parkedType)} ${t('sellPrice')}: +${sellPrice.toLocaleString()} 🪙`);
            
            // 주차된 우주선 정리
            clearParkedShip();
            
            // 모달 닫기
            document.getElementById('sell-ship-modal').classList.remove('open');
            closeShipSelectModal();
            
            // 탑승 진행
            proceedToBoard(false);
        }
        
        // 탑승 진행
        function proceedToBoard(isReboard) {
            // 실제 거리 모드로 전환 (최초 탑승 시에만)
            if (!isReboard) {
                savedDistScale = CONFIG.distScale;
                if (CONFIG.distScale < 50.0) {
                    CONFIG.distScale = 50.0;
                    const scaleBtn = document.getElementById('btn-scale-mode');
                    if (scaleBtn) {
                        scaleBtn.textContent = t('distReal');
                        scaleBtn.classList.add('active');
                    }
                    resetSimulation();
                    showMsg(t('msgRealMode'));
                }
            }
            
            // 잠시 후 우주선 생성 (시뮬레이션 안정화 대기)
            setTimeout(() => {
                actualBoardShip(isReboard);
            }, isReboard ? 100 : 500);
        }
        
        // 구매 버튼 처리
        function handleBuyShip() {
            const ship = SHIP_TYPES[selectedShipIndex];
            if (buyShip(ship.id)) {
                updateShipDetail(selectedShipIndex);
                openShipSelectModal();  // 목록 새로고침
            }
        }
        
        function actualBoardShip(isReboard = false) {
            // ===== 실제 거리 모드 강제 =====
            CONFIG.distScale = 50;
            if (window.gameMode === 'multi') {
                CONFIG.timeScale = 0.01;  // 멀티는 0.01배속 고정 (10배 더 느리게)
            }
            createAllOrbitLines();  // 궤도 재생성
            
            // ★ 재탑승 시 기존 라벨 제거
            if (isReboard && parkedShipMesh) {
                const existingLabel = parkedShipMesh.getObjectByName('parkedLabel');
                if (existingLabel) {
                    parkedShipMesh.remove(existingLabel);
                    if (existingLabel.element) existingLabel.element.remove();
                }
            }
            
            createPlayerShip(isReboard);
            if (!playerShip) {
                showMsg("Cannot create ship.");
                return;
            }
            
            isPilotMode = true;
            window.isPilotMode = true;  // 전역 변수로도 설정
            if (typeof SpaceAudio !== 'undefined' && SpaceAudio.isPlaying) SpaceAudio.playCockpit();
            document.body.classList.add('pilot-mode');  // CSS용 클래스 추가
            isCockpitView = true;  // 1인칭 조종석 뷰 활성화
            focusedBody = null;
            controls.enabled = false;
            
            // 정거장에서 도킹한 경우 연료 충전 시작
            if (window.dockedStation && window.dockedStation.hasFuel) {
                setTimeout(startRefueling, 1000);
            }
            
            // 모바일에서 강제 가로 모드
            forceLayoutOrientation();
            
            // 1인칭 조종석 생성 (playerShip.mesh에 추가)
            createCockpitForShip();
            
            // 조종석 시점 초기화
            cockpitTargetRotY = 0;
            cockpitTargetRotX = 0;
            cockpitLookRotY = 0;
            cockpitLookRotX = 0;
            
            // 카메라 near plane 조정 (조종석 내부 렌더링 + 줌인 클리핑 방지)
            camera.near = 0.001;
            camera.updateProjectionMatrix();
            
            // HUD 활성화
            document.getElementById('cockpit-hud').classList.add('active');
            document.getElementById('board-ship-btn').style.display = 'none';
            document.getElementById('top-bar').style.display = 'none';
            document.getElementById('nav-container').style.display = 'none';
            document.getElementById('spawn-dock').style.display = 'none';
            document.getElementById('chat-toggle').style.display = 'none';
            document.getElementById('chat-panel').classList.remove('open');
            document.getElementById('focus-distance-panel').classList.remove('visible');  // 포커스 거리 패널 숨김
            
            // 목표 선택 드롭다운 채우기
            populateShipTargets();
            
            // 조종 컨트롤 초기화
            initPilotControls();
            initCockpitControls();
            
            // 특수능력 버튼 설정
            const abilityBtn = document.getElementById('btn-ability');
            const activeAbilities = ['boost', 'afterburner', 'warp'];  // 활성 사용 가능한 특수능력
            
            if (currentShipType.special && activeAbilities.includes(currentShipType.special)) {
                abilityBtn.style.display = 'flex';
                const abilityIcons = { 'boost': '🚀', 'afterburner': '🔥', 'warp': '⚡' };
                const abilityNames = { 'boost': 'Boost', 'afterburner': 'Afterburner', 'warp': 'Warp' };
                document.getElementById('ability-icon').textContent = abilityIcons[currentShipType.special] || '✨';
                document.getElementById('ability-name').textContent = abilityNames[currentShipType.special] || t('specialAbility');
                document.getElementById('ability-cooldown').textContent = '';
            } else if (currentShipType.special === 'allInOne') {
                abilityBtn.style.display = 'flex';
                document.getElementById('ability-icon').textContent = '⚡';
                document.getElementById('ability-name').textContent = t('warpAbility');
                document.getElementById('ability-cooldown').textContent = '';
            } else {
                abilityBtn.style.display = 'none';
            }
            
            // 드래그 UI 시스템 초기화
            setTimeout(() => {
                if (typeof window.initDraggableUI === 'function') {
                    window.initDraggableUI();
                }
            }, 500);
            
            // ★ 언도킹 연출 중이면 3인칭 카메라로 전환
            console.log('actualBoardShip - undockingState:', undockingState);
            if (undockingState.active) {
                console.log('★ 3인칭 카메라로 전환 시작');
                // 카메라를 우주선에서 분리하고 3인칭으로
                playerShip.mesh.remove(camera);
                
                // 정거장과 우주선이 함께 보이는 위치
                const stationPos = undockingState.stationPos;
                camera.position.set(
                    stationPos.x + 3,
                    stationPos.y + 2,
                    stationPos.z + 5
                );
                camera.lookAt(stationPos);
                
                // 역추진 불꽃 켜기
                if (playerShip.flame) playerShip.flame.visible = true;
                const reverseFlame = playerShip.mesh.getObjectByName('reverseFlameGroup');
                if (reverseFlame) reverseFlame.visible = true;
                
                showMsg('🔓 도킹 해제 중...');
            } else {
                showMsg(`🚀 ${currentShipType.name} 탑승 완료! 드래그로 주변을 둘러보세요.`);
                
                // ★ 저장된 UI 위치 로드
                if (typeof uiRearrangeSystem !== 'undefined') {
                    setTimeout(() => uiRearrangeSystem.loadPositions(), 500);
                }
                
                // ★ SSIL 미션 시스템 초기화
                loadSSILState();
                generateDailyMission();
                updateDailyMissionIcon();
                
                // ★ 이동 거리 측정 초기화
                ssilMissionState.lastPosition = playerShip.mesh.position.clone();
                
                // 첫 탑승 시 SSIL 인트로, 아니면 미션 버튼만 표시
                if (ssilMissionState.isFirstBoarding) {
                    setTimeout(() => showSSILIntro(), 3000);
                } else {
                    setTimeout(() => showMissionButton(), 1000);
                }
            }
        }
        
        // ★★★ 우주 모드 토글 (3인칭 뷰 전환) ★★★
        var lastShipPosition = null;  // 3인칭 뷰에서 우주선 이전 위치 추적
        
        function toggleSpaceView() {
            if (!isPilotMode || !playerShip || !playerShip.mesh) return;
            if (isInteriorMode || isObservatoryMode) return;
            
            isCockpitView = !isCockpitView;
            window.isCockpitView = isCockpitView;  // 전역 접근용
            
            const btn = document.getElementById('btn-exit-pilot');
            const mobileBtn = document.getElementById('mobile-space-mode');
            const spaceViewControls = document.getElementById('space-view-controls');
            
            if (isCockpitView) {
                // 1인칭 조종석으로 복귀
                if (btn) btn.innerHTML = t('spaceMode');
                if (mobileBtn) mobileBtn.innerHTML = '🌌 ' + t('spaceMode').replace('🌌 ', '');
                
                // 방향 조작만 초기화 (속도는 유지)
                shipInputs.pitch = 0;
                shipInputs.yaw = 0;
                
                // 카메라를 조종석으로
                camera.position.set(0, 0.15, 0.1);
                camera.rotation.set(0, 0, 0);
                playerShip.mesh.add(camera);
                controls.enabled = false;
                lastShipPosition = null;
                
                // 조종 UI 표시
                document.getElementById('pilot-hud').style.display = 'block';
                document.getElementById('pilot-console').style.display = 'flex';
                if (spaceViewControls) spaceViewControls.style.display = 'none';
                
                showMsg('🎮 조종 모드');
            } else {
                // 3인칭 우주 뷰
                if (btn) btn.innerHTML = t('pilotMode');
                if (mobileBtn) mobileBtn.innerHTML = '🎮 ' + t('pilotMode').replace('🎮 ', '');
                
                // 방향 조작만 초기화 (속도는 유지!)
                shipInputs.pitch = 0;
                shipInputs.yaw = 0;
                
                // 카메라를 우주선 뒤쪽으로
                playerShip.mesh.remove(camera);
                const shipPos = playerShip.mesh.position.clone();
                const backward = new THREE.Vector3(0, 0, 1).applyQuaternion(playerShip.mesh.quaternion);
                const up = new THREE.Vector3(0, 1, 0).applyQuaternion(playerShip.mesh.quaternion);
                camera.position.copy(shipPos).add(backward.multiplyScalar(15)).add(up.multiplyScalar(5));
                camera.lookAt(shipPos);
                controls.target.copy(shipPos);
                controls.enabled = true;
                
                // ★★★ 우주선 줌인 가능하게 minDistance 설정 (선체 크기에 따라) ★★★
                // 우주선 크기 계산 (바운딩 박스 기준)
                let shipMinDist = 0.02;  // 기본값 (코앞까지)
                if (playerShip.mesh) {
                    const box = new THREE.Box3().setFromObject(playerShip.mesh);
                    const size = new THREE.Vector3();
                    box.getSize(size);
                    const maxDim = Math.max(size.x, size.y, size.z);
                    shipMinDist = maxDim * 0.05;  // 선체 크기의 5% (코앞까지!)
                    if (shipMinDist < 0.01) shipMinDist = 0.01;  // 최소값
                }
                controls.minDistance = shipMinDist;
                
                lastShipPosition = shipPos.clone();
                
                // ★ 조종실 UI 유지 (우주 모드에서도 하단 컨트롤 표시)
                document.getElementById('pilot-console').style.display = 'flex';
                document.getElementById('pilot-hud').style.display = 'block';

                showMsg('🌌 우주 모드 (속도 조절 가능)');
            }
        }
        
        function exitPilotMode() {
            if (!isPilotMode || !playerShip || !playerShip.mesh) return;
            
            // 화면 방향 잠금 해제
            unlockOrientation();
            
            // ★ 우주선 운항 상태 저장 (계속 움직이도록)
            const shipVelocity = new THREE.Vector3(0, 0, -1)
                .applyQuaternion(playerShip.mesh.quaternion)
                .multiplyScalar(playerShip.speed);
            
            // 우주선 주차 (위치/방향 저장)
            parkShip();
            
            // 우주선 위치/방향 저장 (기존 시스템 호환)
            savedShipState = {
                position: playerShip.mesh.position.clone(),
                quaternion: playerShip.mesh.quaternion.clone(),
                speed: playerShip.speed,
                fuel: playerShip.fuel,
                hull: playerShip.hull,  // ★ 내구도 저장
                shipTypeIndex: selectedShipIndex
            };
            
            // 조종석 제거
            if (cockpitGroup) {
                playerShip.mesh.remove(cockpitGroup);
                cockpitGroup = null;
            }
            
            // 카메라 분리
            playerShip.mesh.remove(camera);
            const shipPos = playerShip.mesh.position.clone();
            camera.position.copy(shipPos).add(new THREE.Vector3(10, 5, 10));
            controls.target.copy(shipPos);
            
            // 카메라 near plane 복원 (줌인 클리핑 방지)
            camera.near = 0.01;
            camera.updateProjectionMatrix();
            
            // 주차된 우주선을 씬에 남겨두기 (제거하지 않음)
            // 엔진 불꽃 유지 (속도가 있으면)
            const flame = playerShip.mesh.getObjectByName('engineFlame');
            if (flame) flame.visible = playerShip.speed > 0.1;
            const reverseFlame = playerShip.mesh.getObjectByName('reverseFlameGroup');
            if (reverseFlame) reverseFlame.visible = false;
            
            // 라벨 추가 (주차된 우주선 표시)
            // ★ 기존 라벨 제거
            const existingLabel = playerShip.mesh.getObjectByName('parkedLabel');
            if (existingLabel) {
                playerShip.mesh.remove(existingLabel);
                if (existingLabel.element) existingLabel.element.remove();
            }
            
            const label = document.createElement('div');
            label.className = 'label ship-parked-label';
            label.textContent = `🚀 ${getShipName(currentShipType)}`;
            label.style.color = '#f39c12';
            
            // ★ 라벨 클릭 시 해당 위치로 카메라 이동
            label.addEventListener('click', (e) => {
                e.stopPropagation();
                if (parkedShipMesh) {
                    const shipPos = parkedShipMesh.position.clone();
                    // 부드러운 카메라 이동
                    const targetCamPos = shipPos.clone().add(new THREE.Vector3(15, 8, 15));
                    
                    // GSAP 또는 간단한 애니메이션
                    const startPos = camera.position.clone();
                    const startTarget = controls.target.clone();
                    const duration = 1000;
                    const startTime = Date.now();
                    
                    function animateCamera() {
                        const elapsed = Date.now() - startTime;
                        const t = Math.min(elapsed / duration, 1);
                        const easeT = 1 - Math.pow(1 - t, 3);  // ease-out-cubic
                        
                        camera.position.lerpVectors(startPos, targetCamPos, easeT);
                        controls.target.lerpVectors(startTarget, shipPos, easeT);
                        
                        if (t < 1) {
                            requestAnimationFrame(animateCamera);
                        } else {
                            // 포커스 설정
                            focusedBody = {
                                mesh: parkedShipMesh,
                                name: `🚀 ${getShipName(currentShipType)}`,
                                type: 'ship'
                            };
                            if (typeof showMessage === 'function') {
                                showMessage(`🚀 내 우주선으로 이동`);
                            }
                        }
                    }
                    animateCamera();
                }
            });
            label.addEventListener('touchstart', (e) => {
                e.stopPropagation();
                label.click();
            }, { passive: false });
            
            const labelObj = new CSS2DObject(label);
            labelObj.position.set(0, 1.5, 0);
            labelObj.name = 'parkedLabel';
            playerShip.mesh.add(labelObj);
            
            // 주차된 우주선 메시 저장 (클릭 감지용)
            parkedShipMesh = playerShip.mesh;
            parkedShipMesh.userData.isParkedShip = true;
            parkedShipMesh.userData.shipType = currentShipType.id;
            parkedShipMesh.userData.shipTypeIndex = selectedShipIndex;
            
            // ★ 운항 상태 저장 (실시간 이동용)
            parkedShipMesh.userData.velocity = shipVelocity;
            parkedShipMesh.userData.speed = playerShip.speed;
            parkedShipMesh.userData.fuel = playerShip.fuel;
            parkedShipMesh.userData.isMoving = playerShip.speed > 0.01;
            
            playerShip = null;
            
            // ★ engineConfig 불꽃 전역 변수 초기화
            configuredThrustFlames = null;
            configuredReverseFlames = null;
            hasEngineConfig = false;
            
            // 도킹된 우주선 다시 표시
            if (dockedShipMesh) dockedShipMesh.visible = true;
            
            isPilotMode = false;
            window.isPilotMode = false;  // 전역 변수로도 설정
            if (typeof SpaceAudio !== 'undefined' && SpaceAudio.isPlaying) SpaceAudio.playSpace();
            
            // ★ 미션 버튼 숨기기
            const missionBtn = document.getElementById('mission-float-btn');
            if (missionBtn) missionBtn.remove();
            
            // 연료 충전 중단
            stopRefueling();
            window.dockedStation = null;
            
            document.body.classList.remove('pilot-mode');  // CSS용 클래스 제거
            isCockpitView = false;
            isInteriorMode = false;
            isObservatoryMode = false;
            controls.enabled = true;
            
            // 멀티모드에서는 실제 거리 모드 강제 유지
            if (window.gameMode === 'multi') {
                CONFIG.distScale = 50;
                CONFIG.timeScale = 0.01;  // 멀티는 0.01배속 고정
            }
            
            // HUD 비활성화
            document.getElementById('cockpit-hud').classList.remove('active');
            document.getElementById('interior-hud').classList.remove('active');
            document.getElementById('observatory-hud').classList.remove('active');
            document.getElementById('top-bar').style.display = '';
            document.getElementById('nav-container').style.display = '';
            // 멀티모드에서는 천체 생성 버튼 숨김 유지
            if (window.gameMode !== 'multi') {
                document.getElementById('spawn-dock').style.display = '';
            }
            document.getElementById('chat-toggle').style.display = '';
            
            // ★ 우주선 자동 추적 시작
            if (parkedShipMesh) {
                focusBody({
                    name: `🚀 ${getShipName(currentShipType)}`,
                    mesh: parkedShipMesh,
                    isParkedShip: true,
                    shipTypeIndex: selectedShipIndex,
                    radius: 0.5
                });
            }
            
            // 탑승 버튼 표시 (바로 재탑승 가능)
            const boardBtn = document.getElementById('board-ship-btn');
            if (boardBtn) {
                boardBtn.style.display = 'block';
                boardBtn.textContent = `🚀 ${t('reboard')}`;
            }
            
            // 경고 비활성화
            stopGravityWarning();
            
            // 특수능력 상태 초기화
            shipAbility.cooldown = 0;
            shipAbility.shieldActive = false;
            shipAbility.afterburnerActive = false;
            
            // AI 부조종사 상태 초기화
            aiCopilot.isTyping = false;
            aiCopilot.lastBodyCheck = null;
            aiCopilot.commEvent = null;
            document.getElementById('ai-comm-modal').classList.remove('open');
            resetAIButtons();
            
            showMsg(`🌌 Space Simulation Mode - ${getShipName(currentShipType)} parked`);
        }
        
        function populateShipTargets() {
            const select = document.getElementById('ship-target-select');
            select.innerHTML = '<option value="">' + t('navTargetSelect') + '</option>';
            
            bodies.forEach((body, idx) => {
                if (!body || !body.mesh) return;
                const opt = document.createElement('option');
                opt.value = idx;
                opt.textContent = translateBodyName(body.name);
                select.appendChild(opt);
            });
            
            satellites.forEach((sat, idx) => {
                if (!sat || !sat.mesh) return;
                if (sat.type !== 'station') {
                    const opt = document.createElement('option');
                    opt.value = 'sat_' + idx;
                    opt.textContent = translateBodyName(sat.name);
                    select.appendChild(opt);
                }
            });
            
            select.onchange = (e) => {
                const val = e.target.value;
                if (!val) {
                    shipTargetBody = null;
                } else if (val.startsWith('sat_')) {
                    shipTargetBody = satellites[parseInt(val.replace('sat_', ''))];
                } else {
                    shipTargetBody = bodies[parseInt(val)];
                }
                updateShipTargetInfo();
            };
        }
        
        function initCockpitControls() {
            const canvas = renderer.domElement;
            
            // 마우스로 고개 돌리기 (1인칭 조종석 뷰)
            canvas.addEventListener('mousedown', (e) => {
                if (!isPilotMode || isInteriorMode || isObservatoryMode || !isCockpitView) return;
                cockpitDragging = true;
                cockpitPrevMouse = { x: e.clientX, y: e.clientY };
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (!cockpitDragging || !isPilotMode || isInteriorMode || isObservatoryMode || !isCockpitView) return;
                const dx = e.clientX - cockpitPrevMouse.x;
                const dy = e.clientY - cockpitPrevMouse.y;
                cockpitTargetRotY -= dx * COCKPIT_LOOK_SPEED;
                cockpitTargetRotX -= dy * COCKPIT_LOOK_SPEED;
                cockpitTargetRotY = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cockpitTargetRotY));
                cockpitTargetRotX = Math.max(-Math.PI / 3, Math.min(Math.PI / 3.5, cockpitTargetRotX));
                cockpitPrevMouse = { x: e.clientX, y: e.clientY };
            });
            
            canvas.addEventListener('mouseup', () => { cockpitDragging = false; });
            canvas.addEventListener('mouseleave', () => { cockpitDragging = false; });
            
            // 터치로 고개 돌리기
            canvas.addEventListener('touchstart', (e) => {
                if (!isPilotMode || isInteriorMode || isObservatoryMode || !isCockpitView) return;
                // ★ UI 재배치 모드에서는 작동 안함
                if (typeof uiRearrangeSystem !== 'undefined' && uiRearrangeSystem.isActive) return;
                
                const t = e.touches[0];
                // 왼쪽 30%는 조종용, 나머지는 고개 돌리기
                if (t.clientX < window.innerWidth * 0.3) return;
                
                // ★ UI 요소 위에서는 작동 안함
                const targetEl = document.elementFromPoint(t.clientX, t.clientY);
                if (targetEl && (
                    targetEl.closest('#pilot-bottom') ||
                    targetEl.closest('#mobile-tab-bar') ||
                    targetEl.closest('#mobile-tab-panel') ||
                    targetEl.closest('#ai-copilot-panel') ||
                    targetEl.closest('#unified-chat-panel') ||
                    targetEl.closest('#cockpit-radio') ||
                    targetEl.closest('#multiplayer-ui') ||
                    targetEl.closest('#pilot-right') ||
                    targetEl.closest('#pilot-target-select') ||
                    targetEl.closest('#ssil-mission-panel') ||
                    targetEl.closest('#daily-mission-modal') ||
                    targetEl.closest('#mobile-mini-hud') ||
                    targetEl.closest('#pilot-left-console') ||
                    targetEl.closest('#pilot-center-console') ||
                    targetEl.closest('#pilot-right-console') ||
                    targetEl.closest('#ui-settings-panel') ||
                    targetEl.closest('#ui-rearrange-overlay') ||
                    targetEl.id === 'ui-settings-btn' ||
                    targetEl.tagName === 'BUTTON' ||
                    targetEl.tagName === 'INPUT' ||
                    targetEl.tagName === 'SELECT' ||
                    targetEl.tagName === 'LABEL'
                )) return;
                
                e.preventDefault();
                cockpitDragging = true;
                cockpitPrevMouse = { x: t.clientX, y: t.clientY };
            }, { passive: false });
            
            canvas.addEventListener('touchmove', (e) => {
                if (!cockpitDragging || !isPilotMode || isInteriorMode || isObservatoryMode || !isCockpitView) return;
                e.preventDefault();
                const t = e.touches[0];
                const dx = t.clientX - cockpitPrevMouse.x;
                const dy = t.clientY - cockpitPrevMouse.y;
                cockpitTargetRotY -= dx * COCKPIT_LOOK_SPEED;
                cockpitTargetRotX -= dy * COCKPIT_LOOK_SPEED;
                cockpitTargetRotY = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cockpitTargetRotY));
                cockpitTargetRotX = Math.max(-Math.PI / 3, Math.min(Math.PI / 3.5, cockpitTargetRotX));
                cockpitPrevMouse = { x: t.clientX, y: t.clientY };
            }, { passive: false });
            
            canvas.addEventListener('touchend', () => { cockpitDragging = false; });
        }
        
        function initPilotControls() {
            const canvas = renderer.domElement;
            
            // 마우스 드래그
            let drag = false, lx = 0, ly = 0;
            canvas.addEventListener('mousedown', (e) => {
                if (isObservatoryMode || isInteriorMode || !isPilotMode) return;
                drag = true; lx = e.clientX; ly = e.clientY;
            });
            canvas.addEventListener('mousemove', (e) => {
                if (isObservatoryMode || isInteriorMode || !isPilotMode || !drag) return;
                if (!autopilot.engaged) {
                    shipInputs.yaw = -(e.clientX - lx) * 0.004;
                    shipInputs.pitch = -(e.clientY - ly) * 0.004;
                }
                lx = e.clientX; ly = e.clientY;
            });
            canvas.addEventListener('mouseup', () => { drag = false; shipInputs.yaw = 0; shipInputs.pitch = 0; });
            canvas.addEventListener('mouseleave', () => { drag = false; shipInputs.yaw = 0; shipInputs.pitch = 0; });
            
            // 마우스 휠
            canvas.addEventListener('wheel', (e) => {
                if (!isPilotMode || isInteriorMode || isObservatoryMode || autopilot.engaged) return;
                e.preventDefault();
                shipInputs.throttle += e.deltaY > 0 ? -0.05 : 0.05;
                shipInputs.throttle = Math.max(-0.5, Math.min(1, shipInputs.throttle));
            }, { passive: false });
            
            // 터치 조이스틱
            canvas.addEventListener('touchstart', (e) => {
                if (!isPilotMode || isInteriorMode || isObservatoryMode) return;
                const t = e.changedTouches[0];
                if (t.clientX > window.innerWidth * 0.7) return;
                
                // ★ UI 요소 위에서는 작동 안함
                const targetEl = document.elementFromPoint(t.clientX, t.clientY);
                if (targetEl && (
                    targetEl.closest('#pilot-bottom') ||
                    targetEl.closest('#mobile-tab-bar') ||
                    targetEl.closest('#mobile-tab-panel') ||
                    targetEl.closest('#ai-copilot-panel') ||
                    targetEl.closest('#unified-chat-panel') ||
                    targetEl.closest('#cockpit-radio') ||
                    targetEl.closest('#multiplayer-ui') ||
                    targetEl.closest('#pilot-right') ||
                    targetEl.closest('#pilot-target-select') ||
                    targetEl.closest('.draggable-ui') ||
                    targetEl.tagName === 'BUTTON' ||
                    targetEl.tagName === 'INPUT' ||
                    targetEl.tagName === 'SELECT'
                )) return;
                
                e.preventDefault();
                joystickActive = true;
                joystickCenter = { x: t.clientX, y: t.clientY };
                const js = document.getElementById('virtual-joystick');
                js.style.display = 'block';
                js.style.left = (t.clientX - 50) + 'px';
                js.style.top = (t.clientY - 50) + 'px';
            }, { passive: false });
            
            canvas.addEventListener('touchmove', (e) => {
                if (!isPilotMode || !joystickActive || isInteriorMode || isObservatoryMode) return;
                e.preventDefault();
                const t = e.changedTouches[0];
                let dx = t.clientX - joystickCenter.x;
                let dy = t.clientY - joystickCenter.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const maxR = 40;
                if (dist > maxR) { dx = dx / dist * maxR; dy = dy / dist * maxR; }
                document.getElementById('joystick-knob').style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                if (!autopilot.engaged) {
                    shipInputs.yaw = -(dx / maxR) * 0.08;
                    shipInputs.pitch = -(dy / maxR) * 0.08;
                }
            }, { passive: false });
            
            canvas.addEventListener('touchend', () => {
                joystickActive = false;
                document.getElementById('virtual-joystick').style.display = 'none';
                document.getElementById('joystick-knob').style.transform = 'translate(-50%, -50%)';
                shipInputs.yaw = 0;
                shipInputs.pitch = 0;
            });
            
            // 키보드
            window.addEventListener('keydown', (e) => {
                if (!isPilotMode || isInteriorMode || isObservatoryMode || autopilot.engaged) return;
                // 속도 조절은 3인칭에서도 허용
                if (e.key === 'w' || e.key === 'ArrowUp') shipInputs.throttle = Math.min(1, shipInputs.throttle + 0.05);
                if (e.key === 's' || e.key === 'ArrowDown') shipInputs.throttle = Math.max(-0.5, shipInputs.throttle - 0.05);
                if (e.key === ' ') shipInputs.emergencyReverse = true;
            });
            window.addEventListener('keyup', (e) => { if (e.key === ' ') shipInputs.emergencyReverse = false; });
            
            // 모바일용 동적 조이스틱 (터치 위치에 생성)
            const touchArea = document.getElementById('touch-area-left');
            const pilotJS = document.getElementById('pilot-joystick');
            const pilotKnob = document.getElementById('pilot-joystick-knob');
            let pilotJSActive = false;
            let pilotJSCenter = { x: 0, y: 0 };
            let pilotJSTouchId = null;
            
            touchArea.addEventListener('touchstart', (e) => {
                if (!isPilotMode || isInteriorMode || isObservatoryMode || !isCockpitView) return;
                // ★ UI 재배치 모드에서는 작동 안함
                if (typeof uiRearrangeSystem !== 'undefined' && uiRearrangeSystem.isActive) return;
                
                const touch = e.changedTouches[0];
                
                // ★ UI 요소 위에서는 조이스틱 동작 안함
                const targetEl = document.elementFromPoint(touch.clientX, touch.clientY);
                if (targetEl && (
                    targetEl.closest('#ai-copilot-panel') ||
                    targetEl.closest('#unified-chat-panel') ||
                    targetEl.closest('#pilot-bottom') ||
                    targetEl.closest('#mobile-tab-bar') ||
                    targetEl.closest('#mobile-tab-panel') ||
                    targetEl.closest('#mobile-mini-hud') ||
                    targetEl.closest('#cockpit-radio') ||
                    targetEl.closest('#multiplayer-ui') ||
                    targetEl.closest('#ssil-mission-panel') ||
                    targetEl.closest('#daily-mission-modal') ||
                    targetEl.closest('#pilot-left-console') ||
                    targetEl.closest('#pilot-center-console') ||
                    targetEl.closest('#pilot-right-console') ||
                    targetEl.closest('#ui-settings-panel') ||
                    targetEl.closest('#ui-rearrange-overlay') ||
                    targetEl.id === 'ui-settings-btn' ||
                    targetEl.tagName === 'BUTTON' ||
                    targetEl.tagName === 'INPUT' ||
                    targetEl.tagName === 'SELECT' ||
                    targetEl.tagName === 'LABEL'
                )) return;
                
                e.preventDefault(); e.stopPropagation();
                
                pilotJSTouchId = touch.identifier;
                pilotJSActive = true;
                
                // 터치 위치에 조이스틱 생성 (80x150 크기)
                const x = touch.clientX - 40;  // 조이스틱 중심 (가로)
                const y = touch.clientY - 75;  // 조이스틱 중심 (세로)
                pilotJS.style.left = x + 'px';
                pilotJS.style.top = y + 'px';
                pilotJS.classList.add('visible');
                
                pilotJSCenter = { x: touch.clientX, y: touch.clientY };
            }, { passive: false });
            
            touchArea.addEventListener('touchmove', (e) => {
                if (!isPilotMode || !pilotJSActive || isInteriorMode || isObservatoryMode) return;
                e.preventDefault(); e.stopPropagation();
                
                // 올바른 터치 찾기
                let touch = null;
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === pilotJSTouchId) {
                        touch = e.changedTouches[i];
                        break;
                    }
                }
                if (!touch) return;
                
                let dy = touch.clientY - pilotJSCenter.y;
                const maxR = 50;
                
                // 상하 범위 제한 (좌우는 무시)
                if (dy > maxR) dy = maxR;
                if (dy < -maxR) dy = -maxR;
                
                // 노브는 상하로만 이동
                pilotKnob.style.transform = `translate(-50%, calc(-50% + ${dy}px))`;
                
                if (!autopilot.engaged) {
                    // 위로 올리면 전진(+), 아래로 내리면 후진(-)
                    const throttleValue = -dy / maxR;  // -1 ~ 1
                    if (throttleValue > 0) {
                        shipInputs.throttle = throttleValue;  // 전진: 0 ~ 1
                    } else {
                        shipInputs.throttle = throttleValue * 0.5;  // 후진: 0 ~ -0.5
                    }
                }
            }, { passive: false });
            
            touchArea.addEventListener('touchend', (e) => {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === pilotJSTouchId) {
                        pilotJSActive = false;
                        pilotJSTouchId = null;
                        pilotKnob.style.transform = 'translate(-50%, -50%)';
                        pilotJS.classList.remove('visible');
                        break;
                    }
                }
            });
            
            touchArea.addEventListener('touchcancel', (e) => {
                pilotJSActive = false;
                pilotJSTouchId = null;
                pilotKnob.style.transform = 'translate(-50%, -50%)';
                pilotJS.classList.remove('visible');
            });
            
            // 버튼 이벤트
            setupPilotButtons();
        }
        
        function setupPilotButtons() {
            const ba = document.getElementById('btn-accel');
            const bd = document.getElementById('btn-decel');
            let ai, di;
            
            const sa = () => { if (autopilot.engaged) return; ai = setInterval(() => { shipInputs.throttle = Math.min(1, shipInputs.throttle + 0.02); }, 50); };
            const xa = () => clearInterval(ai);
            const sd = () => { if (autopilot.engaged) return; di = setInterval(() => { shipInputs.throttle = Math.max(-0.5, shipInputs.throttle - 0.02); }, 50); };
            const xd = () => clearInterval(di);
            
            ba.addEventListener('touchstart', (e) => { e.preventDefault(); sa(); }); ba.addEventListener('touchend', xa);
            ba.addEventListener('mousedown', sa); ba.addEventListener('mouseup', xa); ba.addEventListener('mouseleave', xa);
            bd.addEventListener('touchstart', (e) => { e.preventDefault(); sd(); }); bd.addEventListener('touchend', xd);
            bd.addEventListener('mousedown', sd); bd.addEventListener('mouseup', xd); bd.addEventListener('mouseleave', xd);
            
            document.getElementById('btn-autopilot').onclick = toggleAutopilot;
            document.getElementById('btn-interior').onclick = tryEnterInteriorMode;
            document.getElementById('btn-exit-pilot').onclick = toggleSpaceView;

            // ★ space-view-controls 제거됨 - 조종실 UI 사용
            
            document.getElementById('btn-telescope').onclick = function() {
                if (typeof enterTelescopeMode === 'function') enterTelescopeMode();
            };
            
            // 궤도 진입 버튼
            document.getElementById('btn-orbit-entry').onclick = () => {
                if (orbitState.active) {
                    exitOrbit();
                } else {
                    const targetName = document.getElementById('btn-orbit-entry').dataset.targetBody;
                    if (targetName) {
                        enterOrbit(targetName);
                    }
                }
            };
            
            // ★ 모바일 궤도 진입 버튼
            const mobileOrbitBtn = document.getElementById('mobile-orbit');
            if (mobileOrbitBtn) {
                mobileOrbitBtn.onclick = () => {
                    if (orbitState.active) {
                        exitOrbit();
                    } else {
                        const targetName = mobileOrbitBtn.dataset.targetBody;
                        if (targetName) {
                            enterOrbit(targetName);
                        }
                    }
                };
            }
            
            document.getElementById('btn-escape').onclick = emergencyEscape;
            document.getElementById('btn-enter-orbit').onclick = enterOrbit;
            document.getElementById('btn-cancel-orbit').onclick = cancelOrbitPrompt;
            
            // 특수능력 버튼
            document.getElementById('btn-ability').onclick = useSpecialAbility;
            
            // ★ 새로운 도킹 시스템 버튼들
            document.getElementById('docking-center-btn').onclick = startDocking;
            document.getElementById('btn-refuel-menu').onclick = startRefueling;
            document.getElementById('btn-repair-menu').onclick = startRepair;  // ★ 수리 버튼
            document.getElementById('btn-station-shop').onclick = openStationShop;  // ★ 상점 버튼
            document.getElementById('btn-station-interior').onclick = enterStationInterior;
            document.getElementById('undock-btn').onclick = undockFromStation;
        }
        
        // ★★★ 정거장 상점 시스템 ★★★
        function openStationShop() {
            const modal = document.getElementById('station-shop-modal');
            if (!modal) return;
            
            // 코인 업데이트
            const coinsEl = document.getElementById('shop-user-coins');
            if (coinsEl) coinsEl.textContent = getUserCoins().toLocaleString();
            
            // 망원경 상태 업데이트
            updateShopTelescopeStatus();
            
            modal.style.display = 'flex';
            
            // 탭 버튼 이벤트
            document.querySelectorAll('.shop-tab-btn').forEach(btn => {
                btn.onclick = function() {
                    const tab = this.dataset.tab;
                    document.querySelectorAll('.shop-tab-btn').forEach(b => {
                        b.style.background = '#333';
                        b.style.color = '#aaa';
                        b.classList.remove('active');
                    });
                    this.style.background = '#f39c12';
                    this.style.color = 'white';
                    this.classList.add('active');
                    
                    document.querySelectorAll('.shop-tab-content').forEach(c => c.style.display = 'none');
                    const content = document.getElementById('shop-tab-' + tab);
                    if (content) content.style.display = 'block';
                };
            });
            
            // 망원경 구매 버튼
            document.querySelectorAll('.shop-buy-btn').forEach(btn => {
                btn.onclick = function() {
                    const type = this.dataset.telescope;
                    const price = parseInt(this.dataset.price);
                    
                    if (confirm(`${telescopeUpgrades[type].name} ${t('confirmPurchase')} (${price.toLocaleString()} ${t('coinsUnit')})`)) {
                        if (buyTelescopeUpgrade(type)) {
                            updateShopTelescopeStatus();
                            document.getElementById('shop-user-coins').textContent = getUserCoins().toLocaleString();
                        }
                    }
                };
            });
            
            // 망원경 장착 버튼
            document.querySelectorAll('.shop-equip-btn').forEach(btn => {
                btn.onclick = function() {
                    const type = this.dataset.telescope;
                    equipTelescope(type);
                    updateShopTelescopeStatus();
                };
            });
            
            // 닫기 버튼
            document.getElementById('btn-close-shop').onclick = closeStationShop;
        }
        
        function closeStationShop() {
            const modal = document.getElementById('station-shop-modal');
            if (modal) modal.style.display = 'none';
        }
        
        function updateShopTelescopeStatus() {
            // 표준 망원경 (30x)
            const stdStatus = document.getElementById('shop-standard-status');
            if (stdStatus) {
                if (telescopeUpgrades.standard.owned) {
                    const isEquipped = telescopeMode.equippedTelescope === 'standard';
                    stdStatus.innerHTML = `
                        <div style="color: #2ecc71; font-weight: bold;">${isEquipped ? '✅ 장착중' : '✅ 보유중'}</div>
                        <button class="shop-equip-btn" data-telescope="standard" style="margin-top: 5px; padding: 5px 15px; background: ${isEquipped ? '#27ae60' : '#f1c40f'}; color: white; border: none; border-radius: 5px; cursor: pointer;">${isEquipped ? '장착됨' : '장착'}</button>
                    `;
                }
            }
            
            // 고급 망원경
            const advStatus = document.getElementById('shop-advanced-status');
            if (advStatus) {
                if (telescopeUpgrades.advanced.owned) {
                    const isEquipped = telescopeMode.equippedTelescope === 'advanced';
                    advStatus.innerHTML = `
                        <div style="color: #2ecc71; font-weight: bold;">${isEquipped ? '✅ 장착중' : '✅ 보유중'}</div>
                        <button class="shop-equip-btn" data-telescope="advanced" style="margin-top: 5px; padding: 5px 15px; background: ${isEquipped ? '#27ae60' : '#3498db'}; color: white; border: none; border-radius: 5px; cursor: pointer;">${isEquipped ? '장착됨' : '장착'}</button>
                    `;
                }
            }
            
            // 전문가 망원경
            const proStatus = document.getElementById('shop-professional-status');
            if (proStatus) {
                if (telescopeUpgrades.professional.owned) {
                    const isEquipped = telescopeMode.equippedTelescope === 'professional';
                    proStatus.innerHTML = `
                        <div style="color: #2ecc71; font-weight: bold;">${isEquipped ? '✅ 장착중' : '✅ 보유중'}</div>
                        <button class="shop-equip-btn" data-telescope="professional" style="margin-top: 5px; padding: 5px 15px; background: ${isEquipped ? '#27ae60' : '#9b59b6'}; color: white; border: none; border-radius: 5px; cursor: pointer;">${isEquipped ? '장착됨' : '장착'}</button>
                    `;
                }
            }
            
            // 장착 버튼 이벤트 재연결
            setTimeout(() => {
                document.querySelectorAll('.shop-equip-btn').forEach(btn => {
                    btn.onclick = function() {
                        const type = this.dataset.telescope;
                        equipTelescope(type);
                        updateShopTelescopeStatus();
                    };
                });
            }, 100);
        }
        
        // 특수능력 사용
        function useSpecialAbility() {
            if (!playerShip || !currentShipType.special) return;
            if (shipAbility.cooldown > 0) {
                showMsg('Special ability recharging...');
                return;
            }
            
            const special = currentShipType.special;
            
            switch(special) {
                case 'boost':
                case 'allInOne':
                    // 긴급 부스트 - 3초간 속도 2배
                    activateBoost();
                    break;
                case 'afterburner':
                    // 애프터버너 토글
                    toggleAfterburner();
                    break;
                case 'warp':
                    // 워프 드라이브
                    activateWarp();
                    break;
            }
        }
        
        // 자동 궤도 진입
        function enterOrbit(targetBodyName) {
            // 파라미터가 없으면 기존 프롬프트 시스템의 shipTargetBody 사용
            let targetBody;
            if (targetBodyName) {
                targetBody = bodies.find(b => b.name === targetBodyName);
            } else if (shipTargetBody) {
                targetBody = shipTargetBody;
                document.getElementById('orbit-prompt').classList.remove('active');
            }
            
            if (!targetBody || !playerShip) {
                showMsg('Orbit target not found.');
                return;
            }
            
            // 현재 위치에서 궤도 반경 계산
            const shipPos = playerShip.mesh.position;
            const bodyPos = targetBody.mesh.position;
            const currentDist = shipPos.distanceTo(bodyPos);
            
            // 안정 궤도 반경 설정 (현재 거리 또는 최소 안전 거리)
            const minOrbitRadius = targetBody.radius * 2.5;
            const targetOrbitRadius = Math.max(currentDist * 0.8, minOrbitRadius);
            
            // ===== 호만 전이 궤도 계산 =====
            const mass = targetBody.mass || 1e24;
            const currentOrbitVelocity = Math.sqrt(CONFIG.G * mass / currentDist) * 0.3;
            const targetOrbitVelocity = Math.sqrt(CONFIG.G * mass / targetOrbitRadius) * 0.3;
            
            // 델타V 계산 (속도 변화량)
            const deltaV = Math.abs(playerShip.speed - targetOrbitVelocity * 0.3) + 
                          Math.abs(currentOrbitVelocity - targetOrbitVelocity) * 0.5;
            
            // 연료 소모 계산 (델타V당 0.5%)
            const fuelRequired = deltaV * 0.5;
            
            // 연료 체크
            if (playerShip.fuel < fuelRequired) {
                showMsg(`❌ 연료 부족! 궤도 진입에 ${fuelRequired.toFixed(1)}% 필요`);
                return;
            }
            
            // 연료 소모
            playerShip.fuel -= fuelRequired;
            showMsg(`⛽ 궤도 전이: 연료 ${fuelRequired.toFixed(1)}% 소모`);
            
            // 궤도 속도 계산 (중력 기반)
            const orbitSpeed = targetOrbitVelocity;
            
            // 현재 각도 계산
            const dx = shipPos.x - bodyPos.x;
            const dz = shipPos.z - bodyPos.z;
            const currentAngle = Math.atan2(dz, dx);
            
            // 궤도 상태 설정
            orbitState.active = true;
            orbitState.inOrbit = false;  // 아직 전이 중
            orbitState.enteringOrbit = true;
            orbitState.orbitBody = targetBody;
            orbitState.orbitRadius = currentDist;  // 현재 반경에서 시작
            orbitState.targetOrbitRadius = targetOrbitRadius;  // 목표 반경
            orbitState.orbitAngle = currentAngle;
            orbitState.orbitSpeed = orbitSpeed;
            orbitState.targetOrbitSpeed = orbitSpeed;
            orbitState.currentOrbitSpeed = 0;
            orbitState.orbitTransitionTime = 0;
            orbitState.transitionDuration = 5.0;  // 5초 전이
            
            // 우주선 상태 초기화
            shipInputs.throttle = 0;
            shipInputs.emergencyReverse = false;
            playerShip.speed = 0;
            playerShip.velocity.set(0, 0, 0);
            
            // 선내 이동 허용
            const interiorBtn = document.getElementById('btn-interior');
            interiorBtn.classList.remove('disabled');
            
            // 버튼 상태 변경
            const orbitEntryBtn = document.getElementById('btn-orbit-entry');
            orbitEntryBtn.textContent = t('orbitExit');
            orbitEntryBtn.classList.add('active');
            
            // 자동항법 상태 업데이트 (궤도 모드는 자동항법 유사)
            autopilot.phase = 'orbit_insertion';
            document.getElementById('ap-phase').textContent = t('orbitTransfer') + ' 0%';
            
            updateInteriorButtonState();
            showMsg(`🌍 ${targetBody.name} - 궤도 전이 시작...`);
        }
        
        function exitOrbit() {
            if (!orbitState.active && !orbitState.inOrbit && !orbitState.enteringOrbit) return;
            
            orbitState.active = false;
            orbitState.inOrbit = false;
            orbitState.enteringOrbit = false;
            
            // 현재 궤도 속도를 추진 속도로 변환 (접선 방향)
            if (playerShip && playerShip.mesh && orbitState.orbitBody) {
                const tangent = new THREE.Vector3(-Math.sin(orbitState.orbitAngle), 0, Math.cos(orbitState.orbitAngle));
                playerShip.speed = orbitState.orbitRadius * orbitState.orbitSpeed * 10;
                playerShip.mesh.lookAt(playerShip.mesh.position.clone().add(tangent));
                playerShip.euler.setFromQuaternion(playerShip.mesh.quaternion, 'YXZ');
            }
            
            orbitState.orbitBody = null;
            
            // 자동항법 해제
            if (autopilot.engaged) {
                disableAutopilot();
            }
            
            const orbitEntryBtn = document.getElementById('btn-orbit-entry');
            orbitEntryBtn.style.display = 'none';
            orbitEntryBtn.classList.remove('active');
            
            showMsg(t('msgOrbitExit'));
            updateInteriorButtonState();
        }
        
        function updateOrbitMotion(dt) {
            // 새로운 시스템(active) 또는 기존 시스템(inOrbit) 체크
            if ((!orbitState.active && !orbitState.inOrbit && !orbitState.enteringOrbit) || !orbitState.orbitBody || !playerShip) return;
            
            const body = orbitState.orbitBody;
            const bodyPos = body.mesh.position;
            
            // 궤도 진입 전환 (물리 기반 점진적 전이)
            if (orbitState.enteringOrbit) {
                orbitState.orbitTransitionTime += dt;
                const transitionDuration = orbitState.transitionDuration || 5.0;
                const progress = Math.min(orbitState.orbitTransitionTime / transitionDuration, 1);
                
                // 궤도 반경 점진적 전이
                const targetRadius = orbitState.targetOrbitRadius || orbitState.orbitRadius;
                orbitState.orbitRadius += (targetRadius - orbitState.orbitRadius) * dt * 0.5;
                
                // 궤도 속도 점진적 증가
                orbitState.currentOrbitSpeed += (orbitState.targetOrbitSpeed - orbitState.currentOrbitSpeed) * dt * 0.8;
                
                // 진행률 표시
                const percent = Math.round(progress * 100);
                document.getElementById('ap-phase').textContent = t('orbitTransfer') + ` ${percent}%`;
                
                if (progress >= 1) {
                    orbitState.enteringOrbit = false;
                    orbitState.inOrbit = true;
                    orbitState.orbitRadius = targetRadius;
                    orbitState.currentOrbitSpeed = orbitState.targetOrbitSpeed;
                    autopilot.phase = 'orbiting';
                    document.getElementById('ap-phase').textContent = t('stableOrbitReached');
                    showMsg(`✅ ${body.name} - 궤도 진입 완료!`);
                }
            }
            
            // 궤도 각도 업데이트
            orbitState.orbitAngle += orbitState.currentOrbitSpeed * dt * CONFIG.timeScale;
            
            // 새 위치 계산
            const newX = bodyPos.x + Math.cos(orbitState.orbitAngle) * orbitState.orbitRadius;
            const newZ = bodyPos.z + Math.sin(orbitState.orbitAngle) * orbitState.orbitRadius;
            
            // 스무스하게 위치 이동 (전이 중에는 더 빠르게)
            const lerpFactor = orbitState.enteringOrbit ? dt * 2 : 0.1;
            playerShip.mesh.position.x += (newX - playerShip.mesh.position.x) * lerpFactor;
            playerShip.mesh.position.z += (newZ - playerShip.mesh.position.z) * lerpFactor;
            playerShip.mesh.position.y = bodyPos.y;
            
            // 접선 방향으로 회전 (궤도 진행 방향)
            if (orbitState.enteringOrbit) {
                const tangent = new THREE.Vector3(-Math.sin(orbitState.orbitAngle), 0, Math.cos(orbitState.orbitAngle));
                const targetQuat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, -1), tangent);
                playerShip.mesh.quaternion.slerp(targetQuat, dt * 2);
                playerShip.euler.setFromQuaternion(playerShip.mesh.quaternion, 'YXZ');
            }
            // 조석 고정 (항상 행성을 바라봄) - 선내/전망대 모드에서도 우주선 자체는 회전
            else if (orbitState.tidalLocked) {
                // 행성 방향 계산
                const dir = new THREE.Vector3().subVectors(bodyPos, playerShip.mesh.position).normalize();
                const targetQuat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, -1), dir);
                // 부드럽게 회전
                playerShip.mesh.quaternion.slerp(targetQuat, 0.05);
                playerShip.euler.setFromQuaternion(playerShip.mesh.quaternion, 'YXZ');
            }
            
            // 속도 표시 업데이트
            playerShip.speed = orbitState.currentOrbitSpeed * orbitState.orbitRadius * 10;
        }
        
        function activateBoost() {
            if (playerShip.fuel < 20) {
                showMsg('Insufficient fuel! (20% minimum required)');
                return;
            }
            
            const originalMaxSpeed = SHIP_CONFIG.maxSpeed;
            playerShip.speed = Math.min(playerShip.speed * 2, originalMaxSpeed * 2);
            playerShip.fuel -= 20;
            
            showMsg('🚀 긴급 부스트 활성화!');
            
            // 3초 후 속도 제한 복구
            setTimeout(() => {
                if (playerShip) {
                    playerShip.speed = Math.min(playerShip.speed, originalMaxSpeed);
                    showMsg('Boost ended');
                }
            }, 3000);
            
            // 쿨다운 설정
            shipAbility.cooldown = currentShipType.specialCooldown || 30;
            updateAbilityCooldown();
        }
        
        function toggleAfterburner() {
            shipAbility.afterburnerActive = !shipAbility.afterburnerActive;
            
            if (shipAbility.afterburnerActive) {
                showMsg('🔥 애프터버너 ON! (연료 3배 소모, 속도 1.5배)');
                document.getElementById('btn-ability').style.borderColor = '#ff0000';
            } else {
                showMsg('Afterburner OFF');
                document.getElementById('btn-ability').style.borderColor = '#ff6600';
            }
        }
        
        function activateWarp() {
            if (!shipTargetBody || !shipTargetBody.mesh) {
                showMsg('Select warp target first!');
                if (typeof SpaceAudio !== 'undefined') SpaceAudio.playError();
                return;
            }
            
            if (playerShip.fuel < 50) {
                showMsg('Insufficient fuel! (50% minimum required)');
                if (typeof SpaceAudio !== 'undefined') SpaceAudio.playError();
                return;
            }
            
            // 워프 효과음
            if (typeof SpaceAudio !== 'undefined') SpaceAudio.playWarp();
            
            // 목표 근처로 순간이동
            const targetPos = shipTargetBody.mesh.position.clone();
            const safeDistance = (shipTargetBody.radius || 1) * 3;
            const offset = new THREE.Vector3(safeDistance, safeDistance * 0.5, safeDistance);
            
            playerShip.mesh.position.copy(targetPos).add(offset);
            playerShip.velocity.set(0, 0, 0);
            playerShip.speed = 0;
            playerShip.fuel -= 50;
            
            // 목표를 바라보도록 회전
            const dir = new THREE.Vector3().subVectors(targetPos, playerShip.mesh.position).normalize();
            const targetQuat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, -1), dir);
            playerShip.mesh.quaternion.copy(targetQuat);
            playerShip.euler.setFromQuaternion(targetQuat, 'YXZ');
            
            showMsg(`⚡ ${shipTargetBody.name}(으)로 워프 완료!`);
            
            // 쿨다운 설정
            shipAbility.cooldown = currentShipType.specialCooldown || 60;
            updateAbilityCooldown();
        }
        
        function updateAbilityCooldown() {
            const cooldownEl = document.getElementById('ability-cooldown');
            const abilityBtn = document.getElementById('btn-ability');
            
            if (shipAbility.cooldown > 0) {
                abilityBtn.classList.add('on-cooldown');
                
                const interval = setInterval(() => {
                    shipAbility.cooldown--;
                    cooldownEl.textContent = `(${shipAbility.cooldown}s)`;
                    
                    if (shipAbility.cooldown <= 0) {
                        clearInterval(interval);
                        cooldownEl.textContent = '';
                        abilityBtn.classList.remove('on-cooldown');
                        showMsg('Special ability ready!');
                    }
                }, 1000);
            }
        }
        
        function toggleAutopilot() {
            if (!shipTargetBody) { showMsg('Select a target first'); return; }
            autopilot.engaged ? disableAutopilot() : enableAutopilot();
        }
        
        function enableAutopilot() {
            if (!shipTargetBody || !playerShip) return;
            
            // ★ 멀티모드 튜토리얼 가이드
            if (typeof MultiTutorial !== 'undefined') {
                MultiTutorial.showFeatureGuide('autopilot');
            }
            
            autopilot.engaged = true;
            autopilot.phase = 'accelerating';
            document.getElementById('btn-autopilot').classList.add('engaged');
            document.getElementById('pilot-autopilot-info').classList.remove('inactive');
            document.getElementById('ap-status').textContent = t('on');
            document.getElementById('pilot-eta-box').classList.add('active');
            document.getElementById('eta-target-name').textContent = t('targetPrefix') + translateBodyName(shipTargetBody.name);
            updateInteriorButtonState();
        }
        
        function disableAutopilot() {
            autopilot.engaged = false;
            autopilot.phase = 'idle';
            document.getElementById('btn-autopilot').classList.remove('engaged');
            document.getElementById('pilot-autopilot-info').classList.add('inactive');
            document.getElementById('ap-status').textContent = t('off');
            document.getElementById('ap-phase').textContent = '';
            document.getElementById('warn-decel').classList.remove('active');
            document.getElementById('pilot-eta-box').classList.remove('active');
            updateInteriorButtonState();
            
            if (isInteriorMode || isObservatoryMode) {
                exitInteriorMode();
                showMsg('Autopilot disengaged, returning to cockpit.');
            }
        }
        
        function updateInteriorButtonState() {
            const btn = document.getElementById('btn-interior');
            if (autopilot.engaged) {
                btn.classList.remove('disabled');
                btn.title = '자동항법 중 - 선내 이동 가능';
            } else {
                btn.classList.add('disabled');
                btn.title = '자동항법 활성화 후 선내 이동 가능';
            }
        }
        
        function tryEnterInteriorMode() {
            // 선내 기능 업데이트 예정 알림
            showMsg('🚧 선내 기능은 업데이트 예정입니다. 조금만 기다려주세요!');
            return;
            
            /* 아래 코드는 업데이트 후 활성화 예정
            if (!autopilot.engaged && !orbitState.active) {
                showMsg(t('msgNeedAuto'));
                return;
            }
            enterInteriorMode();
            */
        }
        
        // exitInteriorMode는 선내 시스템 함수에서 정의됨
        
        function emergencyEscape() {
            if (!playerShip || !playerShip.mesh || !isGravityWarning) return;
            
            // ===== 연료/충전 조건 체크 =====
            const minFuelRequired = SHIP_CONFIG.maxFuel / 3;  // 1/3 필요
            
            // 광고 충전이 없고 연료도 부족한 경우
            if (typeof emergencyEscapeCharge !== 'undefined' && !emergencyEscapeCharge.charged && playerShip.fuel < minFuelRequired) {
                showMessage('❌ Insufficient fuel! (minimum ' + Math.round(minFuelRequired) + '% required)');
                showMessage('💡 광고를 시청하여 긴급탈출을 충전하세요!');
                return;
            }
            
            // 충전 사용 또는 연료 소모
            if (typeof emergencyEscapeCharge !== 'undefined' && emergencyEscapeCharge.charged) {
                emergencyEscapeCharge.charged = false;  // 충전 소모
                showMessage('⚡ Emergency escape charge used!');
                if (typeof updateAdUI === 'function') updateAdUI();
            } else {
                playerShip.fuel -= minFuelRequired;  // 연료 1/3 소모
            }
            
            // 긴급 탈출 - 위험 천체에서 멀어지는 방향으로 가속
            let closestBody = null;
            let minDist = Infinity;
            
            bodies.forEach(b => {
                if (!b || !b.mesh) return;
                if (b.type === 'star' || b.type === 'blackhole' || b.mass > 1) {
                    const d = playerShip.mesh.position.distanceTo(b.mesh.position);
                    if (d < minDist) {
                        minDist = d;
                        closestBody = b;
                    }
                }
            });
            
            if (!closestBody || !closestBody.mesh) return;
            
            // 탈출 방향 계산 (행성에서 멀어지는 방향)
            const escapeDir = new THREE.Vector3().subVectors(playerShip.mesh.position, closestBody.mesh.position).normalize();
            
            // 우주선을 탈출 방향으로 회전
            const targetQuat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, -1), escapeDir);
            playerShip.mesh.quaternion.copy(targetQuat);
            playerShip.euler.setFromQuaternion(playerShip.mesh.quaternion, 'YXZ');
            
            // 긴급 회피 상태 활성화 (중력권 탈출용)
            emergencyEvasion.active = true;
            emergencyEvasion.phase = 'escaping';
            emergencyEvasion.targetBody = closestBody;
            emergencyEvasion.escapeRadius = closestBody.radius * 6;  // 탈출 기준 거리
            
            // 중력 속도 제거하고 초기 탈출 속도 부여
            playerShip.velocity.set(0, 0, 0);
            playerShip.speed = 10;  // 초기 속도만 부여, 이후 가속은 updatePilotMode에서
            
            // 자동항법 해제
            if (autopilot.engaged) disableAutopilot();
            
            showMsg('🆘 긴급 탈출! 중력권 이탈 중... (5배 가속)');
        }
        
        function startGravityWarning() {
            if (isGravityWarning) return;
            isGravityWarning = true;
            
            document.getElementById('warn-gravity').classList.add('active');
            document.getElementById('btn-escape').classList.add('active');
            
            // 비프음 시작
            beepInterval = setInterval(() => {
                playBeep();
            }, 400);
        }
        
        function stopGravityWarning() {
            if (!isGravityWarning) return;
            isGravityWarning = false;
            
            document.getElementById('warn-gravity').classList.remove('active');
            document.getElementById('btn-escape').classList.remove('active');
            
            if (beepInterval) {
                clearInterval(beepInterval);
                beepInterval = null;
            }
        }
        
        function updatePilotMode(dt) {
            if (!playerShip || !playerShip.mesh || isInteriorMode || isObservatoryMode) return;
            
            // ★ 태양 방향 조명 업데이트 (물리 기반)
            const sunLight = playerShip.mesh.getObjectByName('sunLight');
            const fillLight = playerShip.mesh.getObjectByName('fillLight');
            if (sunLight) {
                const sun = bodies.find(b => b.name === '태양' || b.name === 'Sun');
                if (sun && sun.mesh) {
                    // 우주선에서 태양으로의 방향 계산 (빛이 오는 방향)
                    const sunDir = new THREE.Vector3()
                        .subVectors(sun.mesh.position, playerShip.mesh.position)
                        .normalize();
                    
                    // 조명 위치를 태양 방향으로 설정 (월드 좌표)
                    sunLight.position.copy(sunDir.clone().multiplyScalar(20));
                    
                    // 거리에 따른 밝기 조절 (태양에서 멀어질수록 약해짐)
                    const distToSun = playerShip.mesh.position.distanceTo(sun.mesh.position);
                    const intensity = Math.max(0.8, Math.min(3.0, 800 / distToSun));
                    sunLight.intensity = intensity;
                    
                    // 반대쪽 보조광 위치 업데이트
                    if (fillLight) {
                        fillLight.position.copy(sunDir.clone().multiplyScalar(-10));
                        fillLight.intensity = Math.max(0.1, 0.3 - intensity * 0.05);  // 태양빛이 강하면 보조광 약하게
                    }
                }
            }
            
            // ★ 도킹 중이거나 도킹된 상태면 우주선 이동 없음
            if (window.isDocking || window.isDockedToStation) {
                updateShipHUD();
                return;
            }
            
            // 궤도 진입 중이면 별도 처리
            if (orbitState.enteringOrbit) {
                updateOrbitInsertion(dt);
                updateShipHUD();
                return;
            }
            
            // 궤도 비행 중이면 별도 처리
            if (orbitState.inOrbit) {
                updateOrbitFlight(dt);
                updateShipHUD();
                return;
            }
            
            // 긴급 탈출 중일 때 처리
            if (emergencyEvasion.active && emergencyEvasion.phase === 'escaping') {
                const targetBody = emergencyEvasion.targetBody;
                if (targetBody && targetBody.mesh) {
                    const dist = playerShip.mesh.position.distanceTo(targetBody.mesh.position);
                    
                    // 중력권 내에서만 5배 가속 (연료 5배 소모)
                    if (dist < emergencyEvasion.escapeRadius && playerShip.fuel > 0) {
                        const escapeAccel = SHIP_CONFIG.acceleration * 5;  // 5배 가속
                        playerShip.speed += escapeAccel * dt;
                        playerShip.fuel -= SHIP_CONFIG.fuelConsumption * dt * SHIP_CONFIG.reverseFuelMult;  // 5배 연료 소모
                        
                        // 탈출 방향 유지
                        const escapeDir = new THREE.Vector3().subVectors(playerShip.mesh.position, targetBody.mesh.position).normalize();
                        const targetQuat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, -1), escapeDir);
                        playerShip.mesh.quaternion.slerp(targetQuat, dt * 2);
                        playerShip.euler.setFromQuaternion(playerShip.mesh.quaternion, 'YXZ');
                        
                        // 엔진 불꽃 활성화
                        playerShip.flame.visible = true;
                        playerShip.flame.scale.setScalar(1.5 + Math.random() * 0.5);
                        
                        document.getElementById('warn-emergency').classList.add('active');
                    } else {
                        // 중력권 탈출 완료 - 관성 속도로 전환
                        emergencyEvasion.active = false;
                        emergencyEvasion.phase = 'idle';
                        emergencyEvasion.targetBody = null;
                        stopGravityWarning();
                        document.getElementById('warn-emergency').classList.remove('active');
                        showMsg('✅ Escaped gravity well! Coasting...');
                    }
                } else {
                    // 대상 천체가 없으면 탈출 종료
                    emergencyEvasion.active = false;
                    emergencyEvasion.phase = 'idle';
                }
                
                // 긴급 탈출 중에도 이동 처리
                playerShip.speed = Math.min(playerShip.speed, SHIP_CONFIG.maxSpeed * 2);  // 탈출 시 최대 속도 2배
                playerShip.fuel = Math.max(0, playerShip.fuel);
                
                const fwd = new THREE.Vector3(0, 0, -1).applyQuaternion(playerShip.mesh.quaternion);
                playerShip.mesh.position.add(fwd.multiplyScalar(playerShip.speed * dt));
                playerShip.mesh.position.add(playerShip.velocity.clone().multiplyScalar(dt));
                
                applyGravityToShip(dt);
                checkShipCollision();
                updateShipHUD();
                updateShipRadar();
                return;
            }
            
            // 자동항법
            if (autopilot.engaged) updateShipAutopilot(dt);
            
            // 방향 조종 (자동항법 아닐 때, 1인칭 조종석 뷰에서만)
            if (!autopilot.engaged && isCockpitView) {
                playerShip.euler.y += shipInputs.yaw * SHIP_CONFIG.turnSpeed;
                playerShip.euler.x += shipInputs.pitch * SHIP_CONFIG.turnSpeed;
                playerShip.euler.x = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, playerShip.euler.x));
                playerShip.mesh.quaternion.setFromEuler(playerShip.euler);
            }
            
            // 수동 속도 조절 (3인칭에서도 허용, 자동항법 아닐 때)
            if (!autopilot.engaged && shipInputs.throttle !== 0 && playerShip.fuel > 0) {
                // 연료 효율 특수능력 확인
                const hasFuelEfficiency = currentShipType.special === 'fuelEfficiency' || currentShipType.special === 'allInOne';
                let fuelMult = hasFuelEfficiency ? 0.7 : 1.0;  // 30% 절약
                
                // 게임 모드 배율 (멀티: 0.5 = 2배 적게 소모)
                if (window.gameMode && window.MODE_CONFIG && window.MODE_CONFIG[window.gameMode]) {
                    fuelMult *= window.MODE_CONFIG[window.gameMode].fuelMultiplier;
                }
                
                // 애프터버너 효과 (연료 3배 소모)
                if (shipAbility.afterburnerActive) {
                    fuelMult *= 3;
                }
                
                // 기본 연료 소모량 (눈에 띄게 증가)
                const baseFuelConsumption = 1.0;  // ★ 0.5 → 1.0
                
                if (shipInputs.throttle > 0) {
                    // 전진 가속
                    let accelMult = shipAbility.afterburnerActive ? 1.5 : 1.0;
                    if (typeof adBooster !== 'undefined' && adBooster.active) {
                        accelMult *= adBooster.multiplier;
                    }
                    playerShip.speed += SHIP_CONFIG.acceleration * shipInputs.throttle * dt * accelMult;
                    playerShip.fuel -= baseFuelConsumption * shipInputs.throttle * dt * fuelMult;
                    console.log('🔥 연료 소모:', baseFuelConsumption * shipInputs.throttle * dt * fuelMult, '남은 연료:', playerShip.fuel);
                } else if (shipInputs.throttle < 0) {
                    // 역추진
                    const reverseThrust = SHIP_CONFIG.acceleration * Math.abs(shipInputs.throttle) * dt * 0.5;
                    if (playerShip.speed > 0) {
                        playerShip.speed = Math.max(0, playerShip.speed - reverseThrust * 2);
                    } else {
                        playerShip.speed -= reverseThrust;
                        playerShip.speed = Math.max(-SHIP_CONFIG.maxSpeed * 0.3, playerShip.speed);
                    }
                    playerShip.fuel -= baseFuelConsumption * Math.abs(shipInputs.throttle) * dt * fuelMult * 1.5;
                }
            }
            
            // ★★★ 속도 유지 시 연료 소모 (스로틀 안 눌러도 소모) ★★★
            if (!autopilot.engaged && Math.abs(playerShip.speed) > 0.1 && playerShip.fuel > 0) {
                const hasFuelEfficiency = currentShipType.special === 'fuelEfficiency' || currentShipType.special === 'allInOne';
                let fuelMult = hasFuelEfficiency ? 0.7 : 1.0;
                if (window.gameMode && window.MODE_CONFIG && window.MODE_CONFIG[window.gameMode]) {
                    fuelMult *= window.MODE_CONFIG[window.gameMode].fuelMultiplier;
                }
                const speedRatio = Math.abs(playerShip.speed) / SHIP_CONFIG.maxSpeed;
                playerShip.fuel -= 0.3 * speedRatio * dt * fuelMult;  // ★ 0.15*0.3 → 0.3
            }
            
            // 자동 수리 특수능력 (프리깃, 플래그십)
            const hasAutoRepair = currentShipType.special === 'autoRepair' || currentShipType.special === 'allInOne';
            if (hasAutoRepair) {
                // 연료 자동 회복
                if (playerShip.fuel < SHIP_CONFIG.maxFuel) {
                    playerShip.fuel += dt * 0.1;  // 10초당 1% 회복
                }
                // ★ 내구도 자동 회복
                if (playerShip.hull < SHIP_CONFIG.maxHull) {
                    playerShip.hull += dt * 0.05;  // 20초당 1% 회복
                    playerShip.hull = Math.min(playerShip.hull, SHIP_CONFIG.maxHull);
                }
            }
            
            // 긴급 역추진 (연료 5배 소모, 효율 3배)
            if (shipInputs.emergencyReverse) {
                if (playerShip.fuel > 0 && Math.abs(playerShip.speed) > 0.1) {
                    // 속도를 0으로 수렴
                    if (playerShip.speed > 0) {
                        playerShip.speed = Math.max(0, playerShip.speed - SHIP_CONFIG.reverseThrust * dt * 3);
                    } else {
                        playerShip.speed = Math.min(0, playerShip.speed + SHIP_CONFIG.reverseThrust * dt * 3);
                    }
                    // 긴급 역추진 연료 소모 (기본의 5배)
                    playerShip.fuel -= 0.5 * dt;  // 초당 0.5% 소모
                    document.getElementById('warn-emergency').classList.add('active');
                } else {
                    document.getElementById('warn-emergency').classList.remove('active');
                }
            } else {
                document.getElementById('warn-emergency').classList.remove('active');
            }
            
            // 애프터버너 활성 시 최대 속도 1.5배
            let maxSpeedMult = shipAbility.afterburnerActive ? 1.5 : 1.0;
            // 광고 부스터 효과 (2배)
            if (typeof adBooster !== 'undefined' && adBooster.active) {
                maxSpeedMult *= adBooster.multiplier;
            }
            playerShip.speed = Math.min(playerShip.speed, SHIP_CONFIG.maxSpeed * maxSpeedMult);
            playerShip.fuel = Math.max(0, playerShip.fuel);
            
            // 연료 부족 시 애프터버너 자동 해제
            if (shipAbility.afterburnerActive && playerShip.fuel <= 0) {
                shipAbility.afterburnerActive = false;
                document.getElementById('btn-ability').style.borderColor = '#ff6600';
                showMsg(t('lowFuel') + ' ' + t('afterburnerOff'));
            }
            
            // 중력 영향 계산
            applyGravityToShip(dt);
            
            // 엔진 추력에 의한 이동
            const fwd = new THREE.Vector3(0, 0, -1).applyQuaternion(playerShip.mesh.quaternion);
            playerShip.mesh.position.add(fwd.multiplyScalar(playerShip.speed * dt));
            
            // 중력에 의한 이동
            playerShip.mesh.position.add(playerShip.velocity.clone().multiplyScalar(dt));
            
            // ★ 기본 불꽃 제어 (engineConfig 없을 때만)
            var engineFlame = playerShip.mesh.getObjectByName('engineFlame');
            var reverseFlameGroup = playerShip.mesh.getObjectByName('reverseFlameGroup');
            
            // ★ currentShipType.engineConfig로 체크 (GLB 로드 전에도 작동)
            var shipHasEngineConfig = currentShipType && currentShipType.engineConfig;
            
            if (!shipHasEngineConfig && engineFlame) {
                // engineConfig 없을 때만 기본 불꽃 사용
                if (isInteriorMode || isObservatoryMode) {
                    engineFlame.visible = false;
                } else {
                    // 수동 조작 또는 자동항해 가속 중
                    var showFlame = (shipInputs.throttle > 0.1 || autopilot.phase === 'accelerating') && playerShip.fuel > 0;
                    engineFlame.visible = showFlame;
                    if (engineFlame.visible) {
                        var flameThrottle = autopilot.phase === 'accelerating' ? 1.0 : shipInputs.throttle;
                        engineFlame.scale.setScalar(0.5 + flameThrottle * 0.5 + Math.random() * 0.2);
                    }
                }
            } else if (shipHasEngineConfig && engineFlame) {
                // engineConfig 있으면 기본 불꽃 항상 숨김
                engineFlame.visible = false;
            }
            
            // ★★★ engineConfig 추진 불꽃 애니메이션 ★★★
            if (configuredThrustFlames && configuredThrustFlames.children) {
                // 수동 조작 또는 자동항해 가속 중일 때 추진 불꽃 표시
                var isThrottling = (shipInputs.throttle > 0.1 || autopilot.phase === 'accelerating') && playerShip.fuel > 0;
                var throttleValue = autopilot.phase === 'accelerating' ? 1.0 : shipInputs.throttle;
                var t = performance.now() * 0.01;
                
                for (var i = 0; i < configuredThrustFlames.children.length; i++) {
                    var flameGroup = configuredThrustFlames.children[i];
                    
                    if (isInteriorMode || isObservatoryMode) {
                        flameGroup.visible = false;
                    } else {
                        flameGroup.visible = isThrottling;
                        
                        if (isThrottling && flameGroup.children && flameGroup.children.length > 0) {
                            // 빠른 떨림 효과
                            var flicker = 0.7 + Math.sin(t * 10 + i * 100) * 0.2 + Math.random() * 0.3;
                            var lengthMult = 0.8 + throttleValue * 0.8 + Math.sin(t * 8 + i * 50) * 0.2 + Math.random() * 0.3;
                            
                            for (var j = 0; j < flameGroup.children.length; j++) {
                                var flame = flameGroup.children[j];
                                var baseZ = flame.userData.baseScaleZ || 3;
                                
                                flame.scale.x = flicker;
                                flame.scale.y = flicker;
                                flame.scale.z = baseZ * lengthMult;
                                
                                if (flame.material) {
                                    flame.material.opacity = 0.4 + throttleValue * 0.4 + Math.random() * 0.15;
                                }
                            }
                        }
                    }
                }
            }
            
            // ★★★ engineConfig 역추진 불꽃 애니메이션 ★★★
            if (configuredReverseFlames && configuredReverseFlames.children) {
                // 수동 역추진 또는 자동항해 감속 중일 때 역추진 불꽃 표시
                var showReverse = (shipInputs.throttle < -0.05 || shipInputs.emergencyReverse || autopilot.phase === 'decelerating') && playerShip.fuel > 0;
                var reverseThrottleValue = autopilot.phase === 'decelerating' ? 1.0 : Math.abs(shipInputs.throttle) * 2;
                var t = performance.now() * 0.01;
                
                for (var i = 0; i < configuredReverseFlames.children.length; i++) {
                    var flameGroup = configuredReverseFlames.children[i];
                    
                    if (isInteriorMode || isObservatoryMode) {
                        flameGroup.visible = false;
                    } else {
                        flameGroup.visible = showReverse;
                        
                        if (showReverse && flameGroup.children) {
                            var emergencyMult = shipInputs.emergencyReverse ? 1.5 : 1.0;
                            
                            var flicker = (0.8 + Math.sin(t * 7 + i * 40) * 0.15 + Math.random() * 0.25) * emergencyMult;
                            var lengthMult = (0.9 + reverseThrottleValue * 0.5 + Math.sin(t * 5 + i * 25) * 0.15 + Math.random() * 0.2) * emergencyMult;
                            
                            for (var j = 0; j < flameGroup.children.length; j++) {
                                var flame = flameGroup.children[j];
                                var baseZ = flame.userData.baseScaleZ || 3;
                                
                                flame.scale.x = flicker;
                                flame.scale.y = flicker;
                                flame.scale.z = baseZ * lengthMult;
                                
                                if (flame.material) {
                                    flame.material.opacity = 0.4 + reverseThrottleValue * 0.4 + Math.random() * 0.1;
                                }
                            }
                        }
                    }
                }
            }
            
            // 기본 역추진 불꽃 (engineConfig 없을 때만)
            if (!shipHasEngineConfig && reverseFlameGroup) {
                // engineConfig 없을 때만 기본 불꽃 사용
                // 선내 모드나 전망대 모드에서는 역추진 불꽃 숨김
                if (isInteriorMode || isObservatoryMode) {
                    reverseFlameGroup.visible = false;
                } else {
                    const showReverse = (shipInputs.throttle < -0.05 || shipInputs.emergencyReverse) && playerShip.fuel > 0;
                    reverseFlameGroup.visible = showReverse;
                    
                    if (reverseFlameGroup.visible) {
                        // 게이지 강도 계산 (0.0 ~ 1.0) - throttle이 -0.5까지 가므로
                        // 긴급 역추진 시 불꽃 2배
                        const emergencyMult = shipInputs.emergencyReverse ? 2.0 : 1.0;
                        const throttleStrength = shipInputs.emergencyReverse ? 1.0 : Math.abs(shipInputs.throttle) * 2; // 0~1 범위로
                        const time = performance.now() * 0.001;
                        
                        reverseFlameGroup.children.forEach(child => {
                            // 외부 불꽃 (Outer) - 가장 큰 반응
                            if (child.name.includes('Outer')) {
                                const flicker = 0.9 + Math.sin(time * 18) * 0.1 + Math.random() * 0.1;
                                // 게이지 약할 때 작게, 강할 때 크게, 긴급 역추진 시 2배
                                const scaleY = (0.3 + throttleStrength * 0.9) * emergencyMult; // 0.3 ~ 1.2 → 긴급시 2배
                                const scaleXZ = (0.5 + throttleStrength * 0.6) * emergencyMult; // 0.5 ~ 1.1 → 긴급시 2배
                                child.scale.set(scaleXZ * flicker, scaleY * flicker, scaleXZ * flicker);
                                child.material.opacity = 0.3 + throttleStrength * 0.4;
                            }
                            // 중간 불꽃 (Middle)
                            else if (child.name.includes('Middle')) {
                                const flicker = 0.92 + Math.sin(time * 22 + 1) * 0.08 + Math.random() * 0.08;
                                const scaleY = 0.4 + throttleStrength * 0.8;
                                const scaleXZ = 0.6 + throttleStrength * 0.5;
                                child.scale.set(scaleXZ * flicker, scaleY * flicker, scaleXZ * flicker);
                                child.material.opacity = 0.4 + throttleStrength * 0.4;
                            }
                            // 코어 불꽃 (Core) - 가장 안정적이지만 여전히 크기 변화
                            else if (child.name.includes('Core')) {
                                const flicker = 0.95 + Math.sin(time * 25 + 2) * 0.05 + Math.random() * 0.05;
                                const scaleY = 0.5 + throttleStrength * 0.7;
                                const scaleXZ = 0.7 + throttleStrength * 0.4;
                                child.scale.set(scaleXZ, scaleY * flicker, scaleXZ);
                                child.material.opacity = 0.6 + throttleStrength * 0.35;
                            }
                            // 분사구 발광체 (Nozzle) - 게이지에 따라 밝기 변화
                            else if (child.name.includes('nozzle')) {
                                const pulse = 0.85 + Math.sin(time * 12) * 0.15 + Math.random() * 0.05;
                                const nozzleScale = 0.6 + throttleStrength * 0.5;
                                child.scale.setScalar(nozzleScale * pulse);
                                child.material.opacity = 0.5 + throttleStrength * 0.5;
                            }
                        });
                    }
                }
            } else if (shipHasEngineConfig && reverseFlameGroup) {
                // engineConfig 있으면 기본 역추진 불꽃 항상 숨김
                reverseFlameGroup.visible = false;
            }
            
            // 충돌 체크
            checkShipCollision();
            
            // HUD 업데이트
            updateShipHUD();
            updateShipRadar();
            updateShipTargetInfo();
            
            // AI 부조종사 업데이트
            updateAICopilot(dt);
            
            // 근처 연료 정거장 감지
            checkNearbyFuelStation();
        }
        
        function applyGravityToShip(dt) {
            if (!playerShip || !playerShip.mesh) return;
            
            const shipPos = playerShip.mesh.position;
            let totalForce = new THREE.Vector3();
            let inGravityDanger = false;
            
            // 중력 저항 특수능력 확인
            const hasGravityResist = currentShipType.special === 'gravityResist' || currentShipType.special === 'allInOne';
            const gravityMult = hasGravityResist ? 0.5 : 1.0;  // 50% 감소
            
            let nearestBody = null;
            let nearestDist = Infinity;
            
            bodies.forEach(b => {
                if (!b || !b.mesh) return;
                const distVec = new THREE.Vector3().subVectors(b.mesh.position, shipPos);
                const distSq = distVec.lengthSq();
                const dist = Math.sqrt(distSq);
                
                // 중력 계산 (중력 저항 적용)
                const f = (CONFIG.G * b.mass * playerShip.mass) / (distSq + CONFIG.softening) * gravityMult;
                const fVec = distVec.normalize().multiplyScalar(f);
                totalForce.add(fVec);
                
                // 위험 거리 체크 (반지름의 5배 이내)
                const dangerDist = b.radius * 5;
                if (dist < dangerDist && b.mass > 0.5) {
                    // 중력 강도 체크
                    const gravityStrength = f / playerShip.mass;
                    if (gravityStrength > SHIP_CONFIG.gravityWarningThreshold || dist < b.radius * 2) {
                        inGravityDanger = true;
                    }
                }
                
                // 궤도 진입 가능 거리 체크 (반지름의 3~10배)
                const orbitMinDist = b.radius * 2;
                const orbitMaxDist = b.radius * 15;
                if (dist > orbitMinDist && dist < orbitMaxDist && b.mass > 0.1 && dist < nearestDist) {
                    nearestBody = b;
                    nearestDist = dist;
                }
            });
            
            // 궤도 진입 버튼 표시/숨김 (데스크톱 + 모바일)
            const orbitEntryBtn = document.getElementById('btn-orbit-entry');
            const mobileOrbitBtn = document.getElementById('mobile-orbit');
            if (nearestBody && !autopilot.engaged && !orbitState.active) {
                if (orbitEntryBtn) {
                    orbitEntryBtn.style.display = 'block';
                    orbitEntryBtn.textContent = '🌍 ' + translateBodyName(nearestBody.name) + t('orbitSuffixText');
                    orbitEntryBtn.dataset.targetBody = nearestBody.name;
                }
                if (mobileOrbitBtn) {
                    mobileOrbitBtn.style.display = 'block';
                    mobileOrbitBtn.textContent = '🌍 ' + translateBodyName(nearestBody.name);
                    mobileOrbitBtn.dataset.targetBody = nearestBody.name;
                }
            } else if (!orbitState.active) {
                if (orbitEntryBtn) orbitEntryBtn.style.display = 'none';
                if (mobileOrbitBtn) mobileOrbitBtn.style.display = 'none';
            }
            
            // 속도에 중력 적용
            playerShip.velocity.add(totalForce.divideScalar(playerShip.mass).multiplyScalar(dt));
            
            // 속도 감쇠 (공기저항 시뮬레이션은 없지만, 안정성을 위해)
            playerShip.velocity.multiplyScalar(0.999);
            
            // 중력 경고
            if (inGravityDanger) {
                startGravityWarning();
            } else {
                stopGravityWarning();
            }
        }
        
        // ★★★ 천체 접근 위험 경고 시스템 ★★★
        let crashWarningState = {
            active: false,
            targetBody: null,
            warningLevel: 0  // 0: 안전, 1: 경고(깜빡임), 2: 위험(추락 임박)
        };
        
        function checkShipCollision() {
            if (!playerShip || !playerShip.mesh) return;
            
            // bodies와 satellites(moon 타입) 모두 체크
            const allBodies = [...bodies, ...satellites.filter(s => s.isPhysicsEnabled)];
            
            let closestDanger = null;
            let closestDangerDist = Infinity;
            let closestDangerRadius = 0;
            
            allBodies.forEach(b => {
                if (!b || !b.mesh) return;
                const r = b.radius || 0.5;
                const dist = playerShip.mesh.position.distanceTo(b.mesh.position);
                
                // 충돌 파괴 거리 (반지름의 1.2배)
                if (dist < r * 1.2) {
                    triggerShipCrash(b);  // 추락 연출과 함께 파괴
                    return;
                }
                
                // 위험 거리 체크 (반지름의 3배 이내)
                if (dist < r * 3 && dist < closestDangerDist) {
                    closestDanger = b;
                    closestDangerDist = dist;
                    closestDangerRadius = r;
                }
                
                // 근접 밀어내기 거리 (반지름의 2.5배) - 오브젝트가 조종석으로 뚫고 들어오지 않게
                const pushDistance = r * 2.5;
                if (dist < pushDistance) {
                    // 천체에서 멀어지는 방향으로 밀어내기
                    const pushDir = new THREE.Vector3()
                        .subVectors(playerShip.mesh.position, b.mesh.position)
                        .normalize();
                    
                    // 부족한 거리만큼 밀어내기
                    const pushAmount = (pushDistance - dist) * 1.2;
                    playerShip.mesh.position.add(pushDir.multiplyScalar(pushAmount));
                    
                    // 충돌 경고 표시
                    const warnCollision = document.getElementById('warn-collision');
                    if (warnCollision) {
                        warnCollision.style.display = 'block';
                        setTimeout(() => warnCollision.style.display = 'none', 500);
                    }
                    
                    // 속도 감소
                    playerShip.speed *= 0.8;
                }
            });
            
            // ★★★ 위험 경고 UI 업데이트 ★★★
            updateCrashWarning(closestDanger, closestDangerDist, closestDangerRadius);
        }
        
        // ★★★ 추락 경고 UI 업데이트 ★★★
        function updateCrashWarning(dangerBody, dist, radius) {
            let crashWarningUI = document.getElementById('crash-warning-ui');
            
            if (!crashWarningUI) {
                // 경고 UI 생성
                crashWarningUI = document.createElement('div');
                crashWarningUI.id = 'crash-warning-ui';
                crashWarningUI.innerHTML = `
                    <div class="crash-warning-content">
                        <div class="crash-icon">⚠️</div>
                        <div class="crash-text">
                            <div class="crash-title">${t('crashWarning')}</div>
                            <div class="crash-body-name"></div>
                            <div class="crash-distance"></div>
                        </div>
                        <button class="crash-escape-btn" id="crash-escape-btn" style="display:none;">${t('emergency')}</button>
                    </div>
                `;
                crashWarningUI.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(200, 0, 0, 0.9);
                    border: 3px solid #ff0000;
                    border-radius: 15px;
                    padding: 20px 30px;
                    z-index: 10000;
                    display: none;
                    font-family: 'Orbitron', sans-serif;
                    color: white;
                    text-align: center;
                    box-shadow: 0 0 50px rgba(255, 0, 0, 0.8);
                `;
                
                const style = document.createElement('style');
                style.textContent = `
                    .crash-warning-content { display: flex; flex-direction: column; align-items: center; gap: 10px; }
                    .crash-icon { font-size: 48px; animation: crashBlink 0.3s infinite; }
                    .crash-title { font-size: 24px; font-weight: bold; color: #ffff00; }
                    .crash-body-name { font-size: 18px; color: #ffcccc; }
                    .crash-distance { font-size: 14px; color: #ff8888; }
                    .crash-escape-btn {
                        margin-top: 10px;
                        padding: 10px 25px;
                        background: linear-gradient(135deg, #ff6600, #ff0000);
                        border: 2px solid #ffff00;
                        border-radius: 8px;
                        color: white;
                        font-size: 16px;
                        font-weight: bold;
                        cursor: pointer;
                        animation: crashBlink 0.5s infinite;
                    }
                    .crash-escape-btn:hover { background: linear-gradient(135deg, #ff8800, #ff2200); }
                    @keyframes crashBlink {
                        0%, 100% { opacity: 1; }
                        50% { opacity: 0.5; }
                    }
                    #crash-warning-ui.level1 { background: rgba(200, 100, 0, 0.9); border-color: #ff8800; box-shadow: 0 0 30px rgba(255, 136, 0, 0.6); }
                    #crash-warning-ui.level2 { background: rgba(200, 0, 0, 0.95); border-color: #ff0000; box-shadow: 0 0 50px rgba(255, 0, 0, 0.9); }
                `;
                document.head.appendChild(style);
                document.body.appendChild(crashWarningUI);
                
                // 긴급 탈출 버튼 이벤트
                document.getElementById('crash-escape-btn').onclick = () => {
                    if (typeof emergencyEscape === 'function') {
                        emergencyEscape();
                    }
                };
            }
            
            if (!dangerBody || dist >= radius * 3) {
                // 안전 - 경고 숨김
                crashWarningUI.style.display = 'none';
                crashWarningState.active = false;
                crashWarningState.warningLevel = 0;
                return;
            }
            
            // 경고 레벨 계산
            const dangerRatio = dist / radius;
            let level = 0;
            if (dangerRatio < 1.5) {
                level = 2;  // 극도로 위험
            } else if (dangerRatio < 2.5) {
                level = 1;  // 경고
            }
            
            if (level > 0) {
                crashWarningUI.style.display = 'block';
                crashWarningUI.className = 'level' + level;
                
                crashWarningUI.querySelector('.crash-body-name').textContent = dangerBody.name;
                crashWarningUI.querySelector('.crash-distance').textContent = `거리: ${dist.toFixed(1)} (한계: ${(radius * 1.2).toFixed(1)})`;
                
                // 긴급 탈출 버튼 표시 (탈출권 있을 때만)
                const escapeBtn = document.getElementById('crash-escape-btn');
                const hasEscapeTicket = window.escapeBoosterActive || (window.adRewardItems && window.adRewardItems.escapeTicket > 0);
                if (escapeBtn) {
                    escapeBtn.style.display = hasEscapeTicket ? 'block' : 'none';
                    escapeBtn.textContent = hasEscapeTicket ? t('emergency') : t('noEscapeTicket');
                }
                
                crashWarningState.active = true;
                crashWarningState.targetBody = dangerBody;
                crashWarningState.warningLevel = level;
            } else {
                crashWarningUI.style.display = 'none';
                crashWarningState.active = false;
                crashWarningState.warningLevel = 0;
            }
        }
        
        // ★★★ 추락 연출과 함께 우주선 파괴 ★★★
        function triggerShipCrash(collidedBody) {
            // 추락 오버레이 표시
            let crashOverlay = document.getElementById('crash-overlay');
            if (!crashOverlay) {
                crashOverlay = document.createElement('div');
                crashOverlay.id = 'crash-overlay';
                crashOverlay.innerHTML = `
                    <div class="crash-overlay-content">
                        <div class="crash-explosion">💥</div>
                        <div class="crash-ship">🚀</div>
                        <div class="crash-message">${t('hullDestroyed')}</div>
                        <div class="crash-body-hit"></div>
                    </div>
                `;
                crashOverlay.style.cssText = `
                    position: fixed;
                    top: 0; left: 0; right: 0; bottom: 0;
                    background: rgba(0, 0, 0, 0.9);
                    z-index: 100000;
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    animation: crashFadeIn 0.3s ease-out;
                `;
                
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes crashFadeIn { from { opacity: 0; } to { opacity: 1; } }
                    @keyframes crashExplosion { 
                        0% { transform: scale(1); opacity: 1; }
                        50% { transform: scale(3); opacity: 1; }
                        100% { transform: scale(5); opacity: 0; }
                    }
                    @keyframes crashShipFall {
                        0% { transform: translateY(0) rotate(0deg); opacity: 1; }
                        100% { transform: translateY(100px) rotate(180deg); opacity: 0; }
                    }
                    .crash-overlay-content { text-align: center; color: white; font-family: 'Orbitron', sans-serif; }
                    .crash-explosion { font-size: 100px; animation: crashExplosion 1s ease-out forwards; }
                    .crash-ship { font-size: 60px; animation: crashShipFall 1s ease-in forwards; margin-top: -50px; }
                    .crash-message { font-size: 36px; color: #ff4444; font-weight: bold; margin-top: 20px; text-shadow: 0 0 20px #ff0000; }
                    .crash-body-hit { font-size: 20px; color: #ffaaaa; margin-top: 10px; }
                `;
                document.head.appendChild(style);
                document.body.appendChild(crashOverlay);
            }
            
            crashOverlay.style.display = 'flex';
            crashOverlay.querySelector('.crash-body-hit').textContent = `${collidedBody.name}에 추락`;
            
            // 추락 경고 UI 숨기기
            const crashWarningUI = document.getElementById('crash-warning-ui');
            if (crashWarningUI) crashWarningUI.style.display = 'none';
            
            // 2초 후 실제 파괴 처리
            setTimeout(() => {
                crashOverlay.style.display = 'none';
                triggerShipDestruction(collidedBody);
            }, 2000);
        }
        
        // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
        // ★★★ 물리 충돌 시스템 & 우주정거장 보호막 시스템 ★★★
        // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
        
        // ★ 충돌/보호막 반경 설정 (1.5km)
        const STATION_COLLISION_RADIUS = 1.5;   // 충돌 반경 1.5km
        const STATION_SHIELD_RADIUS = 9.0;      // 보호막 반경 (5배 확대)
        
        // 충돌 가능한 오브젝트 목록 (행성/항성/블랙홀 제외)
        function getCollidableObjects() {
            const collidables = [];
            
            // 우주정거장 (satellites에서)
            satellites.forEach(sat => {
                if (sat.isSpaceStation && sat.mesh) {
                    collidables.push({
                        mesh: sat.mesh,
                        name: sat.name,
                        type: 'station',
                        mass: 1000,
                        radius: STATION_COLLISION_RADIUS,
                        isStation: true,
                        ref: sat
                    });
                }
            });
            
            // 연료 정거장 (bodies에서)
            bodies.forEach(body => {
                if (body.isStation && body.mesh) {
                    collidables.push({
                        mesh: body.mesh,
                        name: body.name,
                        type: 'fuelDepot',
                        mass: 500,
                        radius: STATION_COLLISION_RADIUS * 0.6,
                        isStation: true,
                        ref: body
                    });
                }
            });
            
            // 주차된 우주선
            if (parkedShipMesh && !isPilotMode) {
                collidables.push({
                    mesh: parkedShipMesh,
                    name: '주차된 우주선',
                    type: 'parkedShip',
                    mass: 1,
                    radius: 0.1,
                    isStation: false,
                    ref: parkedShip
                });
            }
            
            return collidables;
        }
        
        // ★★★ 6각형 벌집 패턴 보호막 메쉬 생성 (쉐이더 버전) ★★★
        function createHexShieldMesh(radius) {
            const shieldGeo = new THREE.SphereGeometry(radius, 64, 32);
            
            // 6각형 벌집 패턴 쉐이더
            const shieldMat = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    impactStrength: { value: 0 },
                    impactPoint: { value: new THREE.Vector3(0, 0, 0) }
                },
                vertexShader: `
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    
                    void main() {
                        vPosition = position;
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float impactStrength;
                    uniform vec3 impactPoint;
                    
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    
                    // 6각형 거리 함수
                    float hexDist(vec2 p) {
                        p = abs(p);
                        return max(dot(p, vec2(0.866, 0.5)), p.x);
                    }
                    
                    // 6각형 그리드
                    float hexGrid(vec2 uv, float scale) {
                        vec2 r = vec2(1.0, 1.732);
                        vec2 h = r * 0.5;
                        vec2 a = mod(uv, r) - h;
                        vec2 b = mod(uv - h, r) - h;
                        vec2 gv = length(a) < length(b) ? a : b;
                        float d = hexDist(gv);
                        float line = smoothstep(0.0, 0.05, 0.5 - d);
                        return line;
                    }
                    
                    void main() {
                        // 구면 좌표 → UV
                        vec3 n = normalize(vPosition);
                        float u = atan(n.x, n.z) / 6.2832 + 0.5;
                        float v = n.y * 0.5 + 0.5;
                        vec2 hexUV = vec2(u * 30.0, v * 18.0);
                        
                        // 6각형 라인
                        float hex = hexGrid(hexUV, 1.0);
                        
                        // 프레넬 (가장자리 강조)
                        float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 2.0);
                        
                        // ★ 충돌 파동 효과 (개선)
                        float dist = length(vPosition - impactPoint);
                        float radius = length(vPosition);  // 보호막 반경
                        
                        // 파동이 충돌 지점에서 퍼져나감
                        float waveRadius = time * radius * 0.8;  // 시간에 따라 확장
                        float waveWidth = radius * 0.15;  // 파동 두께
                        float wave = 1.0 - smoothstep(0.0, waveWidth, abs(dist - waveRadius));
                        
                        // 여러 겹의 파동
                        float wave2 = 1.0 - smoothstep(0.0, waveWidth * 0.7, abs(dist - waveRadius * 0.6));
                        float ripple = max(wave, wave2 * 0.5);
                        
                        // 기본 상태: 거의 투명
                        float baseAlpha = hex * 0.015 + fresnel * 0.02;
                        
                        // 충돌 시: 밝게 발광
                        float impactAlpha = impactStrength * (hex * 0.85 + ripple * 0.9 + fresnel * 0.4);
                        
                        float alpha = baseAlpha + impactAlpha;
                        
                        // 색상
                        vec3 baseColor = vec3(0.0, 0.3, 0.8);
                        vec3 glowColor = vec3(0.0, 0.8, 1.0);
                        vec3 white = vec3(1.0, 1.0, 1.0);
                        
                        vec3 color = mix(baseColor, glowColor, fresnel + impactStrength * 0.3);
                        color = mix(color, white, ripple * impactStrength * 0.8);
                        color += glowColor * hex * impactStrength * 0.4;
                        
                        gl_FragColor = vec4(color, alpha);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                depthTest: false  // ★ 깊이 테스트 비활성화
            });
            
            const shieldMesh = new THREE.Mesh(shieldGeo, shieldMat);
            shieldMesh.name = 'hexShield';
            shieldMesh.renderOrder = 999;  // ★ 맨 나중에 렌더링 (다른 객체 위에)
            
            return shieldMesh;
        }
        
        // ★★★ 우주정거장에 보호막 추가 (초기화 시 호출) ★★★
        function addShieldsToStations() {
            console.log('🛡️ 보호막 초기화 시작...');
            let count = 0;
            
            satellites.forEach(sat => {
                if (sat.isSpaceStation && sat.mesh && !sat.shieldMesh) {
                    const shield = createHexShieldMesh(STATION_SHIELD_RADIUS);
                    sat.mesh.add(shield);
                    sat.shieldMesh = shield;
                    sat.shieldImpactTime = 0;
                    count++;
                    console.log('🛡️ 보호막 추가:', sat.name);
                }
            });
            
            // 연료 정거장에도 보호막 추가
            bodies.forEach(body => {
                if (body.isStation && body.mesh && !body.shieldMesh) {
                    const shield = createHexShieldMesh(STATION_SHIELD_RADIUS * 0.7);
                    body.mesh.add(shield);
                    body.shieldMesh = shield;
                    body.shieldImpactTime = 0;
                    count++;
                    console.log('🛡️ 연료기지 보호막 추가:', body.name);
                }
            });
            
            console.log('🛡️ 보호막 초기화 완료! 총', count, '개');
        }
        
        // ★★★ 보호막 충돌 효과 ★★★
        function triggerShieldImpact(station, impactPoint, impactSpeed) {
            if (!station) {
                console.log('⚠️ station 없음');
                return;
            }
            
            // ★ 보호막이 없으면 즉시 생성!
            if (!station.shieldMesh && station.mesh) {
                console.log('🛡️ 보호막 즉시 생성:', station.name);
                const shield = createHexShieldMesh(STATION_SHIELD_RADIUS);
                station.mesh.add(shield);
                station.shieldMesh = shield;
                station.shieldImpactTime = 0;
            }
            
            if (!station.shieldMesh) {
                console.log('⚠️ 보호막 생성 실패:', station.name);
                return;
            }
            
            const shield = station.shieldMesh;
            const mat = shield.material;
            
            // ★ 충돌 지점을 로컬 좌표로 변환
            const localImpact = shield.worldToLocal(impactPoint.clone());
            
            // ★ 쉐이더 uniform 설정
            mat.uniforms.impactPoint.value.copy(localImpact);
            mat.uniforms.impactStrength.value = 1.0;
            mat.uniforms.time.value = 0;
            
            // 화면 플래시 효과
            const overlay = document.getElementById('shield-impact-overlay');
            if (overlay) {
                overlay.classList.add('active');
                setTimeout(() => overlay.classList.remove('active'), 500);
            }
            
            // 페이드아웃 애니메이션 시작
            station.shieldImpactTime = Date.now();
            
            // 효과음
            playShieldSound();
            
            console.log('🛡️ 보호막 충돌!', station.name);
        }
        
        // ★ 보호막 충돌 효과음
        function playShieldSound() {
            try {
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                
                osc.frequency.value = 800;
                osc.type = 'sine';
                gain.gain.value = 0.15;
                
                osc.start();
                osc.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.3);
                gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);
                osc.stop(audioCtx.currentTime + 0.5);
            } catch (e) { }
        }
        
        // ★★★ 보호막 애니메이션 업데이트 (매 프레임) ★★★
        function updateShieldAnimations(dt) {
            const fadeDuration = 1.5;  // 1.5초 동안 페이드아웃
            
            satellites.forEach(sat => {
                if (sat.shieldMesh && sat.shieldImpactTime > 0) {
                    const elapsed = (Date.now() - sat.shieldImpactTime) / 1000;
                    const mat = sat.shieldMesh.material;
                    
                    // 쉐이더 uniform 업데이트
                    mat.uniforms.time.value = elapsed;
                    mat.uniforms.impactStrength.value = Math.max(0, 1.0 - elapsed / fadeDuration);
                    
                    if (elapsed > fadeDuration) {
                        sat.shieldImpactTime = 0;
                        mat.uniforms.impactStrength.value = 0;
                    }
                }
            });
            
            bodies.forEach(body => {
                if (body.shieldMesh && body.shieldImpactTime > 0) {
                    const elapsed = (Date.now() - body.shieldImpactTime) / 1000;
                    const mat = body.shieldMesh.material;
                    
                    // 쉐이더 uniform 업데이트
                    mat.uniforms.time.value = elapsed;
                    mat.uniforms.impactStrength.value = Math.max(0, 1.0 - elapsed / fadeDuration);
                    
                    if (elapsed > fadeDuration) {
                        body.shieldImpactTime = 0;
                        mat.uniforms.impactStrength.value = 0;
                    }
                }
            });
        }
        
        // ★★★ 우주선과 정거장/오브젝트 간 충돌 물리 ★★★
        function checkStationCollisions() {
            if (!playerShip || !playerShip.mesh || !isPilotMode) return;
            if (window.isDockedToStation || window.isDocking) return;  // 도킹 중이면 무시
            
            // ★ 충돌 쿨다운 (0.5초)
            if (window.lastStationCollision && Date.now() - window.lastStationCollision < 500) {
                return;
            }
            
            const shipPos = playerShip.mesh.position;
            const shipSpeed = Math.abs(playerShip.speed);
            const shipRadius = 0.1 * (playerShip.sizeScale || 1);  // 우주선 충돌 반경
            
            const collidables = getCollidableObjects();
            
            collidables.forEach(obj => {
                if (!obj.mesh) return;
                
                const objPos = obj.mesh.position;
                const dist = shipPos.distanceTo(objPos);
                const collisionDist = shipRadius + obj.radius;
                
                // 충돌 감지
                if (dist < collisionDist) {
                    // 충돌 지점 계산
                    const impactPoint = shipPos.clone().add(
                        new THREE.Vector3().subVectors(objPos, shipPos).normalize().multiplyScalar(shipRadius)
                    );
                    
                    // 정거장인 경우 - 보호막 발동 + 튕겨나감
                    if (obj.isStation) {
                        // 보호막 효과 발동
                        triggerShieldImpact(obj.ref, impactPoint, shipSpeed);
                        
                        // ★ 내구도 감소 (속도 비례)
                        const damage = Math.min(shipSpeed * 0.5, 30);  // 최대 30 데미지
                        if (damage > 0) {
                            playerShip.hull = Math.max(0, playerShip.hull - damage);
                            showMsg(`💥 정거장 보호막 충돌! 내구도 -${damage.toFixed(0)}`);
                            
                            // 내구도 0이면 파괴
                            if (playerShip.hull <= 0) {
                                triggerShipDestruction({ name: obj.name, mesh: obj.mesh, radius: obj.radius });
                                return;
                            }
                        }
                        
                        // ★★★ 단순 반발 물리 ★★★
                        
                        // 충돌면 법선 (정거장 → 우주선)
                        const normal = new THREE.Vector3().subVectors(shipPos, objPos).normalize();
                        
                        // 반발 계수
                        const restitution = 0.5;
                        
                        // ★ 충분히 밀어내기 (충돌 거리 + 여유)
                        const safeDistance = collisionDist + 0.5;
                        const pushAmount = safeDistance - dist;
                        playerShip.mesh.position.add(normal.clone().multiplyScalar(pushAmount));
                        
                        // ★ 속도를 음수로 (뒤로 밀려남) + 감속
                        playerShip.speed = -Math.abs(playerShip.speed) * restitution;
                        
                        // ★ 충돌 쿨다운 (0.5초간 재충돌 방지)
                        window.lastStationCollision = Date.now();
                        
                    } else {
                        // 주차된 우주선 등 - 일반 충돌 물리
                        const normal = new THREE.Vector3().subVectors(shipPos, objPos).normalize();
                        const overlap = collisionDist - dist;
                        
                        // 질량 비율에 따른 밀어내기
                        const totalMass = playerShip.mass + obj.mass;
                        const shipPushRatio = obj.mass / totalMass;
                        const objPushRatio = playerShip.mass / totalMass;
                        
                        // 위치 조정
                        playerShip.mesh.position.add(normal.clone().multiplyScalar(overlap * shipPushRatio));
                        if (obj.mesh.position) {
                            obj.mesh.position.sub(normal.clone().multiplyScalar(overlap * objPushRatio));
                        }
                        
                        // 내구도 감소 (작은 피해)
                        const damage = Math.min(shipSpeed * 0.2, 10);
                        if (damage > 0.5) {
                            playerShip.hull = Math.max(0, playerShip.hull - damage);
                            showMsg(`⚠️ 충돌! 내구도 -${damage.toFixed(0)}`);
                        }
                        
                        // 속도 감소
                        playerShip.speed *= 0.5;
                    }
                }
            });
        }
        
        // ★★★ 내구도 HUD 업데이트 ★★★
        function updateHullHUD() {
            if (!playerShip) return;
            
            const maxHull = SHIP_CONFIG.maxHull;
            const currentHull = playerShip.hull;
            const percent = (currentHull / maxHull) * 100;
            
            // 게이지 업데이트
            const hullFill = document.getElementById('hull-fill');
            const hullVal = document.getElementById('hull-val');
            const hullGauge = document.getElementById('hull-gauge');
            
            if (hullFill) {
                hullFill.style.height = percent + '%';
            }
            if (hullVal) {
                hullVal.textContent = Math.round(currentHull);
            }
            
            // 위험 상태 표시
            if (hullGauge) {
                if (percent < 30) {
                    hullGauge.classList.add('critical');
                } else {
                    hullGauge.classList.remove('critical');
                }
            }
            
            // 경고 표시
            const warnHull = document.getElementById('warn-hull');
            if (warnHull) {
                if (percent < 30) {
                    warnHull.style.display = 'block';
                    warnHull.classList.add('active');
                } else {
                    warnHull.style.display = 'none';
                    warnHull.classList.remove('active');
                }
            }
        }
        
        // ★★★ 정거장 보호막 초기화 플래그 ★★★
        window.stationShieldsInitialized = false;
        
        // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
        
        function triggerShipDestruction(collidedBody) {
            // 쉴드가 있으면 쉴드로 방어
            if (shipAbility.shieldActive && (currentShipType.special === 'shield' || currentShipType.special === 'allInOne')) {
                shipAbility.shieldActive = false;
                const shield = playerShip.mesh.getObjectByName('shield');
                if (shield) shield.visible = false;
                showMsg(`🛡️ 쉴드로 ${collidedBody.name}과의 충돌을 방어했습니다!`);
                
                // 충돌 반발
                const pushDir = new THREE.Vector3().subVectors(playerShip.mesh.position, collidedBody.mesh.position).normalize();
                playerShip.mesh.position.add(pushDir.multiplyScalar(collidedBody.radius * 2));
                playerShip.velocity.set(0, 0, 0);
                playerShip.speed = 0;
                return;
            }
            
            // 파괴된 우주선 이름 저장
            const destroyedShipName = getShipName(currentShipType);
            const destroyedShipId = currentShipType.id;
            
            // 충돌로 인한 우주선 파괴
            showMsg(`💥 ${collidedBody.name}과 충돌! ${destroyedShipName}이(가) 파괴되었습니다!`);
            
            // ★ 카메라 위치 저장 후 분리
            let cameraTargetPos = new THREE.Vector3();
            if (playerShip && playerShip.mesh) {
                cameraTargetPos = playerShip.mesh.position.clone();
                
                // 조종석 제거
                if (cockpitGroup) {
                    playerShip.mesh.remove(cockpitGroup);
                    cockpitGroup = null;
                }
                
                // 카메라 분리
                if (camera.parent === playerShip.mesh) {
                    playerShip.mesh.remove(camera);
                }
                
                // 씬에서 우주선 즉시 제거
                scene.remove(playerShip.mesh);
            }
            
            // 카메라 재배치
            scene.add(camera);
            camera.position.copy(cameraTargetPos).add(new THREE.Vector3(10, 5, 10));
            controls.target.copy(cameraTargetPos);
            camera.near = 0.01;
            camera.updateProjectionMatrix();
            
            // 해당 우주선 소유권 삭제 (다시 구매해야 함)
            if (window.mpUser && destroyedShipId !== 'shuttle') {
                const ships = window.mpUser.unlockedShips || [];
                const idx = ships.indexOf(destroyedShipId);
                if (idx > -1) {
                    ships.splice(idx, 1);
                    window.mpUser.unlockedShips = ships;
                    if (window.supabaseClient) {
                        window.supabaseClient
                            .from('profiles')
                            .update({ unlocked_ships: ships })
                            .eq('id', window.mpUserId)
                            .then(() => console.log('우주선 소유권 삭제됨'))
                            .catch(e => console.warn('우주선 소유권 삭제 실패:', e));
                    }
                }
            }
            
            // 주차된 우주선 정보 삭제
            clearParkedShip();
            
            // 저장된 상태 초기화
            savedShipState = null;
            selectedShipIndex = 0;
            currentShipType = SHIP_TYPES[0];
            window.currentShipType = currentShipType;  // ★ 전역 업데이트
            playerShip = null;
            
            // 도킹된 우주선 다시 표시
            if (dockedShipMesh) dockedShipMesh.visible = true;
            
            // ★ 조종석 HUD 비활성화
            document.getElementById('cockpit-hud').classList.remove('active');
            document.getElementById('interior-hud').classList.remove('active');
            document.getElementById('observatory-hud').classList.remove('active');
            
            // ★ 기본 UI 복원
            document.getElementById('top-bar').style.display = '';
            document.getElementById('nav-container').style.display = '';
            // 멀티모드에서는 천체 생성 버튼 숨김 유지
            if (window.gameMode !== 'multi') {
                document.getElementById('spawn-dock').style.display = '';
            }
            document.getElementById('chat-toggle').style.display = '';
            document.getElementById('board-ship-btn').style.display = 'none';
            
            // 경고 비활성화
            stopGravityWarning();
            
            // 특수능력 상태 초기화
            shipAbility.cooldown = 0;
            shipAbility.shieldActive = false;
            shipAbility.afterburnerActive = false;
            
            // 모드 초기화
            isPilotMode = false;
            document.body.classList.remove('pilot-mode');
            isCockpitView = false;
            isInteriorMode = false;
            isObservatoryMode = false;
            controls.enabled = true;
            
            // 충돌 플래그 설정
            window.lastExitReason = 'collision';
            window.destroyedShipName = destroyedShipName;
            
            // 충돌 메시지 표시
            setTimeout(() => {
                showMsg(`⚠️ ${destroyedShipName}이(가) 파괴되었습니다! 우주정거장에서 새 우주선을 구매하세요.`);
            }, 1500);
        }
        
        function updateShipAutopilot(dt) {
            if (!autopilot.engaged || !shipTargetBody || !shipTargetBody.mesh || !playerShip || !playerShip.mesh) return;
            
            const targetPos = shipTargetBody.mesh.position.clone();
            const dist = playerShip.mesh.position.distanceTo(targetPos);
            const safeDist = (shipTargetBody.radius || 1) * 1.5;  // 더 가까이 도착 (1.5배 반지름)
            const decelDist = (playerShip.speed * playerShip.speed) / (2 * SHIP_CONFIG.deceleration) + safeDist;
            
            // ETA 계산 (실제 대기 시간으로 변환)
            const gameTimeETA = playerShip.speed > 0.1 ? dist / playerShip.speed : Infinity;
            // timeScale이 0.1이면 실제로 10배 더 기다려야 함
            currentETA = CONFIG.timeScale > 0 ? gameTimeETA / CONFIG.timeScale : gameTimeETA;
            
            // 목표 방향으로 회전 (빠른 방향 전환)
            const dir = new THREE.Vector3().subVectors(targetPos, playerShip.mesh.position).normalize();
            const tq = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, -1), dir);
            playerShip.mesh.quaternion.slerp(tq, dt * 5.0);  // 10배 빠른 회전
            playerShip.euler.setFromQuaternion(playerShip.mesh.quaternion, 'YXZ');
            
            if (autopilot.phase === 'accelerating') {
                if (playerShip.fuel > 0 && playerShip.speed < SHIP_CONFIG.maxSpeed * 0.9 && dist > decelDist * 1.5) {
                    playerShip.speed += SHIP_CONFIG.acceleration * dt;
                    playerShip.fuel -= SHIP_CONFIG.fuelConsumption * dt;
                    document.getElementById('ap-phase').textContent = t('accelerating');
                } else if (dist > decelDist) {
                    autopilot.phase = 'cruising';
                } else {
                    autopilot.phase = 'decelerating';
                }
            } else if (autopilot.phase === 'cruising') {
                document.getElementById('ap-phase').textContent = t('cruising');
                if (dist <= decelDist) {
                    autopilot.phase = 'decelerating';
                }
            } else if (autopilot.phase === 'decelerating') {
                document.getElementById('ap-phase').textContent = t('decelerating');
                document.getElementById('warn-decel').classList.add('active');
                if (playerShip.speed > 1) {
                    playerShip.speed -= SHIP_CONFIG.deceleration * dt;
                    playerShip.fuel -= SHIP_CONFIG.fuelConsumption * dt * 0.5;
                }
                if (dist <= safeDist || playerShip.speed < 1) {
                    autopilot.phase = 'arrived';
                    playerShip.speed = 0;
                    document.getElementById('warn-decel').classList.remove('active');
                    showMsg(`✅ ${shipTargetBody.name} 도착! 선내/전망대 이용 가능`);
                }
            } else if (autopilot.phase === 'arrived') {
                document.getElementById('ap-phase').textContent = t('arrived');
                playerShip.speed = 0;
            }
            
            updateETADisplay();
        }
        
        function showOrbitPrompt(targetBody) {
            const prompt = document.getElementById('orbit-prompt');
            document.getElementById('orbit-target-name').textContent = targetBody.name;
            prompt.classList.add('active');
            showMsg(`🌍 ${targetBody.name} 궤도 조석 고정 가능!`);
        }
        
        function cancelOrbitPrompt() {
            document.getElementById('orbit-prompt').classList.remove('active');
            autopilot.phase = 'arrived';
            shipInputs.emergencyReverse = true;
            showMsg(t('orbitEntryCanceled'));
        }
        
        function updateOrbitFlight(dt) {
            if (!orbitState.inOrbit || !orbitState.orbitBody || !orbitState.orbitBody.mesh || !playerShip || !playerShip.mesh) return;
            
            // 각도 업데이트
            orbitState.orbitAngle += orbitState.orbitSpeed * dt * CONFIG.timeScale;
            
            // 새 위치 계산
            const bodyPos = orbitState.orbitBody.mesh.position;
            const newX = bodyPos.x + Math.cos(orbitState.orbitAngle) * orbitState.orbitRadius;
            const newZ = bodyPos.z + Math.sin(orbitState.orbitAngle) * orbitState.orbitRadius;
            playerShip.mesh.position.set(newX, bodyPos.y, newZ);
            
            // 조석 고정 (행성을 바라봄) - 부드럽게 회전
            if (orbitState.tidalLocked) {
                const dir = new THREE.Vector3().subVectors(bodyPos, playerShip.mesh.position).normalize();
                const targetQuat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, -1), dir);
                playerShip.mesh.quaternion.slerp(targetQuat, 0.1);
                playerShip.euler.setFromQuaternion(playerShip.mesh.quaternion, 'YXZ');
            }
        }
        
        // 물리 기반 궤도 진입 업데이트 (자동항법용)
        function updateOrbitInsertion(dt) {
            if (!orbitState.enteringOrbit || !orbitState.orbitBody || !playerShip || !playerShip.mesh) return;
            
            orbitState.orbitTransitionTime += dt;
            const transitionDuration = 5.0;  // 5초간 전환
            const progress = Math.min(1, orbitState.orbitTransitionTime / transitionDuration);
            
            // 부드러운 이징
            const eased = 1 - Math.pow(1 - progress, 3);
            
            // 궤도 속도 점진적 증가
            orbitState.currentOrbitSpeed = orbitState.targetOrbitSpeed * eased;
            orbitState.orbitSpeed = orbitState.currentOrbitSpeed;
            
            // 우주선 직진 속도 점진적 감소
            if (playerShip.speed > 0.1) {
                playerShip.speed *= (1 - dt * 2);
            } else {
                playerShip.speed = 0;
            }
            
            // 궤도 각도 업데이트 (접선 방향 이동)
            orbitState.orbitAngle += orbitState.currentOrbitSpeed * dt;
            
            // 우주선 위치 업데이트 (궤도 상에서)
            const targetCenter = orbitState.orbitBody.mesh.position;
            const newX = targetCenter.x + Math.cos(orbitState.orbitAngle) * orbitState.orbitRadius;
            const newZ = targetCenter.z + Math.sin(orbitState.orbitAngle) * orbitState.orbitRadius;
            
            // 현재 위치에서 새 위치로 부드럽게 이동
            playerShip.mesh.position.x += (newX - playerShip.mesh.position.x) * dt * 2;
            playerShip.mesh.position.z += (newZ - playerShip.mesh.position.z) * dt * 2;
            playerShip.mesh.position.y = targetCenter.y;
            
            // 조석 고정: 행성을 바라보도록 회전
            const lookTarget = targetCenter.clone();
            const shipPos = playerShip.mesh.position.clone();
            const dir = new THREE.Vector3().subVectors(lookTarget, shipPos).normalize();
            const targetQuat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, -1), dir);
            playerShip.mesh.quaternion.slerp(targetQuat, dt * 8);  // 더 빠른 회전
            playerShip.euler.setFromQuaternion(playerShip.mesh.quaternion, 'YXZ');
            
            // 전환 완료
            if (progress >= 1) {
                orbitState.enteringOrbit = false;
                orbitState.inOrbit = true;
                orbitState.orbitSpeed = orbitState.targetOrbitSpeed;
                autopilot.phase = 'orbiting';
                document.getElementById('ap-phase').textContent = '🌍 ' + t('statusOrbiting');
                showMsg(`✅ ${orbitState.orbitBody.name} orbit stabilized! Interior/Observatory available`);
            }
        }
        
        function updateETADisplay() {
            const etaStr = formatETATime(currentETA);
            document.getElementById('eta-time-display').textContent = etaStr;
            document.getElementById('interior-eta').textContent = '⏱️ ' + etaStr;
            document.getElementById('obs-eta').textContent = '⏱️ ' + etaStr;
        }
        
        function formatETATime(seconds) {
            if (seconds <= 0 || !isFinite(seconds)) return '--:--:--';
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            if (h > 99) return `${Math.floor(h/24)}일 ${h%24}시간`;
            return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        }
        
        function formatShipDistance(d) {
            // d는 시뮬레이션 단위 (AU 기반)
            // 1 AU = 149,597,870.7 km
            const kmPerAU = 149597870.7;
            const distKm = d * kmPerAU;
            
            if (distKm < 1000000) {
                // 1,000,000 km 미만: km 단위로 소수점 3자리까지 표시
                return distKm.toFixed(3).replace(/\B(?=(\d{3})+(?!\d))/g, ',') + ' km';
            } else if (d < 100) {
                // 100 AU 미만: AU 단위
                return d.toFixed(4) + ' AU';
            }
            // 100 AU 이상: 광년 단위
            return (d / 63241).toFixed(4) + ' ly';
        }
        
        function updateShipHUD() {
            if (!playerShip || !playerShip.mesh) return;
            
            const sp = playerShip.speed;
            const fuel = playerShip.fuel;
            const thr = shipInputs.throttle;
            
            // ★★★ 3D 좌표 표시 업데이트 ★★★
            const coordsDisplay = document.getElementById('pilot-coords-display');
            if (coordsDisplay && playerShip.mesh) {
                const pos = playerShip.mesh.position;
                coordsDisplay.textContent = `X: ${pos.x.toFixed(1)} | Y: ${pos.y.toFixed(1)} | Z: ${pos.z.toFixed(1)}`;
            }
            
            // THR 게이지 - 중앙 0 방식 (가속: 위, 역추진: 아래)
            const thrUpFill = document.getElementById('throttle-up-fill');
            const thrDownFill = document.getElementById('throttle-down-fill');
            if (thrUpFill && thrDownFill) {
                if (thr >= 0) {
                    thrUpFill.style.height = (thr * 50) + '%';
                    thrDownFill.style.height = '0%';
                } else {
                    thrUpFill.style.height = '0%';
                    thrDownFill.style.height = (Math.abs(thr) * 50) + '%';
                }
            }
            const thrPercent = Math.round(thr * 100);
            document.getElementById('throttle-val').textContent = (thrPercent >= 0 ? '+' : '') + thrPercent + '%';
            const fuelPercent = (fuel / SHIP_CONFIG.maxFuel) * 100;
            document.getElementById('fuel-fill').style.height = fuelPercent + '%';
            document.getElementById('fuel-val').textContent = Math.round(fuel) + '/' + SHIP_CONFIG.maxFuel;
            
            // 메인 속도 표시 (유일한 속도 표시)
            document.getElementById('main-speed-val').textContent = (sp >= 0 ? '' : '-') + Math.abs(sp).toFixed(0);
            
            // km/h 변환 표시
            const speedKmh = Math.abs(sp) * 3600;
            let kmhStr;
            if (speedKmh >= 1e9) {
                kmhStr = (speedKmh / 1e9).toFixed(1) + 'B';
            } else if (speedKmh >= 1e6) {
                kmhStr = (speedKmh / 1e6).toFixed(1) + 'M';
            } else if (speedKmh >= 1e3) {
                kmhStr = (speedKmh / 1e3).toFixed(1) + 'K';
            } else {
                kmhStr = speedKmh.toFixed(0);
            }
            document.getElementById('speed-kmh').textContent = '(' + kmhStr + ' km/h)';
            
            // 연료 경고
            document.getElementById('warn-fuel').classList.toggle('active', fuel < 15);
            
            // 상태 (언어별 표시)
            let stKey = 'statusNominal', sc = '#0f0';
            if (shipInputs.emergencyReverse) { stKey = 'statusBraking'; sc = '#f00'; }
            else if (orbitState.active) { stKey = 'statusOrbiting'; sc = '#0ff'; }
            else if (isGravityWarning) { stKey = 'statusNominal'; sc = '#f00'; }
            else if (autopilot.engaged) { stKey = 'statusAuto'; sc = '#0f8'; }
            else if (Math.abs(sp) > 50) { stKey = 'statusCruising'; sc = '#0ff'; }
            else if (fuel < 15) { stKey = 'statusLowFuel'; sc = '#f90'; }
            document.getElementById('info-status').textContent = t(stKey);
            document.getElementById('info-status').style.color = sc;
        }
        
        function updateShipRadar() {
            const r = document.getElementById('pilot-radar');
            if (!r) return;
            r.querySelectorAll('.radar-blip').forEach(b => b.remove());
            if (!playerShip || !playerShip.mesh) return;
            
            const range = 500;
            const sp = playerShip.mesh.position;
            const qi = playerShip.mesh.quaternion.clone().invert();
            
            bodies.forEach(b => {
                if (!b || !b.mesh) return;
                const rp = b.mesh.position.clone().sub(sp);
                const d = rp.length();
                if (d < range && d > 1) {
                    rp.applyQuaternion(qi);
                    const x = (rp.x / range) * 40;
                    const z = (-rp.z / range) * 40;
                    const bl = document.createElement('div');
                    bl.className = 'radar-blip';
                    bl.style.left = `calc(50% + ${x}px)`;
                    bl.style.top = `calc(50% + ${z}px)`;
                    bl.style.width = shipTargetBody === b ? '8px' : '5px';
                    bl.style.height = shipTargetBody === b ? '8px' : '5px';
                    bl.style.background = b.type === 'star' ? '#ffaa00' : (shipTargetBody === b ? '#f00' : '#0ff');
                    bl.style.boxShadow = `0 0 4px ${bl.style.background}`;
                    r.appendChild(bl);
                }
            });
        }
        
        function updateShipTargetInfo() {
            if (shipTargetBody && shipTargetBody.mesh && playerShip && playerShip.mesh) {
                const d = playerShip.mesh.position.distanceTo(shipTargetBody.mesh.position);
                document.getElementById('pilot-target-name').textContent = shipTargetBody.name;
                document.getElementById('pilot-target-dist').textContent = formatShipDistance(d);
                if (playerShip.speed > 0.1) {
                    const eta = d / playerShip.speed;
                    const hours = Math.floor(eta / 3600);
                    if (hours > 24) document.getElementById('pilot-target-eta').textContent = `ETA: ${(hours/24).toFixed(1)}일`;
                    else document.getElementById('pilot-target-eta').textContent = `ETA: ${hours}h ${Math.floor((eta % 3600) / 60)}m`;
                } else {
                    document.getElementById('pilot-target-eta').textContent = t('etaLabel') + ': ---';
                }
            } else {
                document.getElementById('pilot-target-name').textContent = t('none');
                document.getElementById('pilot-target-dist').textContent = '---';
                document.getElementById('pilot-target-eta').textContent = '';
            }
        }
        
        // 탑승 버튼은 focusBody에서만 관리 (터치/클릭 시에만 표시)
        
        function toScreenPosition(obj, cam) {
            if (!obj || !cam) return { x: 0, y: 0 };
            const vector = new THREE.Vector3();
            try {
                obj.getWorldPosition(vector);
                vector.project(cam);
            } catch(e) {
                return { x: 0, y: 0 };
            }
            return {
                x: (vector.x * 0.5 + 0.5) * window.innerWidth,
                y: (-vector.y * 0.5 + 0.5) * window.innerHeight
            };
        }

        // ★★★ 백그라운드 이동 보정 시스템 ★★★
        let backgroundState = {
            lastActiveTime: Date.now(),
            wasInPilotMode: false,
            lastPosition: null,
            lastDirection: null,
            lastSpeed: 0,
            autopilotTarget: null
        };

        // 백그라운드/포그라운드 상태 관리
        let isPageVisible = true;
        document.addEventListener('visibilitychange', () => {
            const wasVisible = isPageVisible;
            isPageVisible = !document.hidden;
            
            if (!isPageVisible) {
                // ★ 백그라운드로 전환 시 상태 저장
                backgroundState.lastActiveTime = Date.now();
                backgroundState.wasInPilotMode = isPilotMode;
                
                if (isPilotMode && playerShip && playerShip.mesh) {
                    backgroundState.lastPosition = playerShip.mesh.position.clone();
                    backgroundState.lastSpeed = playerShip.speed || 0;
                    
                    // 현재 진행 방향 저장
                    const fwd = new THREE.Vector3(0, 0, -1).applyQuaternion(playerShip.mesh.quaternion);
                    backgroundState.lastDirection = fwd.clone();
                    
                    // 자동항법 목표 저장
                    if (autopilot.engaged && shipTargetBody) {
                        backgroundState.autopilotTarget = shipTargetBody.name;
                    } else {
                        backgroundState.autopilotTarget = null;
                    }
                    
                    console.log('📱 백그라운드 전환 - 상태 저장:', {
                        speed: backgroundState.lastSpeed,
                        position: backgroundState.lastPosition,
                        autopilot: backgroundState.autopilotTarget
                    });
                }
            } else if (wasVisible === false) {
                // ★ 포그라운드 복귀 시 위치 보정
                const elapsedMs = Date.now() - backgroundState.lastActiveTime;
                const elapsedSec = elapsedMs / 1000;
                
                // clock 리셋 (누적된 시간 버리기)
                clock.getDelta();
                
                // 조종 모드였고 이동 중이었으면 위치 보정
                if (backgroundState.wasInPilotMode && playerShip && playerShip.mesh && backgroundState.lastSpeed > 0.1) {
                    compensateBackgroundMovement(elapsedSec);
                }
                
                console.log('📱 포그라운드 복귀 - 경과 시간:', elapsedSec.toFixed(1) + '초');
            }
        });
        
        // ★★★ 백그라운드 이동 보정 함수 ★★★
        function compensateBackgroundMovement(elapsedSec) {
            if (!playerShip || !playerShip.mesh || !backgroundState.lastDirection) return;
            
            // 최대 보정 시간 제한 (5분)
            const maxCompensationTime = 300;
            const compensationTime = Math.min(elapsedSec, maxCompensationTime);
            
            // 자동항법 모드
            if (backgroundState.autopilotTarget && autopilot.engaged) {
                const targetBody = bodies.find(b => b.name === backgroundState.autopilotTarget) ||
                                   satellites.find(s => s.name === backgroundState.autopilotTarget);
                
                if (targetBody && targetBody.mesh) {
                    // 목표까지의 거리와 예상 이동 거리 계산
                    const toTarget = new THREE.Vector3().subVectors(targetBody.mesh.position, playerShip.mesh.position);
                    const distToTarget = toTarget.length();
                    const expectedTravel = backgroundState.lastSpeed * compensationTime;
                    
                    if (expectedTravel >= distToTarget * 0.9) {
                        // 목표에 거의 도착 - 목표 근처에 배치
                        const arrivalOffset = toTarget.normalize().multiplyScalar(-50);  // 목표 50 단위 앞
                        playerShip.mesh.position.copy(targetBody.mesh.position).add(arrivalOffset);
                        playerShip.speed = 5;  // 감속 완료
                        
                        showMsg(`🎯 ${backgroundState.autopilotTarget} 근처에 도착했습니다! (${Math.round(elapsedSec)}초 경과)`);
                    } else {
                        // 아직 이동 중 - 예상 위치로 이동
                        const moveDir = toTarget.normalize();
                        playerShip.mesh.position.add(moveDir.multiplyScalar(expectedTravel));
                        
                        const remainingDist = distToTarget - expectedTravel;
                        showMsg(`🚀 ${Math.round(expectedTravel)} 단위 이동됨 (목표까지 ${Math.round(remainingDist)} 남음)`);
                    }
                    
                    console.log('자동항법 보정:', { expectedTravel, distToTarget, compensationTime });
                    return;
                }
            }
            
            // 수동 비행 모드 - 위치 유지 (순간이동 방지)
            // 자동항해가 아니면 앱 복귀 시 제자리
            if (elapsedSec > 1) {
                showMsg(`📱 앱 복귀 (${Math.round(elapsedSec)}초 경과)`);
            }
            console.log('수동 비행 - 위치 유지 (순간이동 방지)');
            
            // 위치 저장
            if (typeof ShipPositionManager !== 'undefined') {
                ShipPositionManager.save();
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // 탭이 백그라운드면 시뮬레이션 일시정지
            if (!isPageVisible) return;
            
            let rawDt = clock.getDelta();  // 실제 델타 타임 (선내 이동용)
            
            // 델타 상한 (백그라운드 복귀 시 순간이동 방지)
            rawDt = Math.min(rawDt, 0.1);  // 최대 100ms
            
            const dt = rawDt * CONFIG.timeScale;  // 시뮬레이션용 델타 타임
            const elapsedTime = clock.getElapsedTime(); 
            const prevPos=(focusedBody && focusedBody.mesh)?focusedBody.mesh.position.clone():null;
            
            // ★★★ 대기 천체 펄스 애니메이션 ★★★
            if (pendingBodyMesh) {
                const pulse = 0.8 + Math.sin(elapsedTime * 4) * 0.2;
                pendingBodyMesh.material.opacity = 0.4 + Math.sin(elapsedTime * 3) * 0.2;
                
                // 링 펄스
                const ring = pendingBodyMesh.getObjectByName('pendingRing');
                if (ring) {
                    ring.rotation.z = elapsedTime;
                    ring.scale.setScalar(pulse);
                    ring.material.opacity = 0.3 + Math.sin(elapsedTime * 5) * 0.2;
                }
            }
            
            // ★★★ 화살표 핸들 애니메이션 (빌보드 + 펄스) ★★★
            if (velocityHandle) {
                // 핸들 링이 항상 카메라를 향하도록
                const handleRing = velocityHandle.getObjectByName('handleRing');
                if (handleRing) {
                    handleRing.lookAt(camera.position);
                    handleRing.rotation.z = elapsedTime * 2;  // 회전 효과
                    const handlePulse = 0.9 + Math.sin(elapsedTime * 6) * 0.2;
                    handleRing.scale.setScalar(handlePulse);
                }
                
                // 핸들 자체 펄스
                const basePulse = 1.0 + Math.sin(elapsedTime * 4) * 0.15;
                velocityHandle.scale.setScalar(basePulse);
            }
            
            if(dt>0){ updatePhysics(dt); updateTrails(); }

            // ★★★ 멀티플레이어: 다른 플레이어 부드러운 보간 ★★★
            if (typeof mpInterpolateOtherPlayers === 'function') {
                mpInterpolateOtherPlayers(rawDt);
            }

            // ★★★ 태양 그림자 조명 업데이트 ★★★
            if (window.solarShadowLight) {
                const sun = bodies.find(b => b.name === '태양' || b.name === 'Sun');
                if (sun && sun.mesh) {
                    // 태양 위치에서 조명 발사
                    window.solarShadowLight.position.copy(sun.mesh.position);
                    
                    // 포커스된 천체 또는 지구 방향으로 타겟 설정
                    let targetBody = focusedBody;
                    if (!targetBody || targetBody === sun) {
                        targetBody = bodies.find(b => b.name === '지구' || b.name === 'Earth');
                    }
                    
                    if (targetBody && targetBody.mesh && targetBody !== sun) {
                        window.solarShadowLight.target.position.copy(targetBody.mesh.position);
                        
                        // 그림자 카메라 범위를 대상 거리에 맞게 조정
                        const dist = sun.mesh.position.distanceTo(targetBody.mesh.position);
                        // 위성 그림자를 위해 범위를 넓게 설정
                        const range = Math.max(50, Math.min(5000, targetBody.radius * 100));
                        window.solarShadowLight.shadow.camera.left = -range;
                        window.solarShadowLight.shadow.camera.right = range;
                        window.solarShadowLight.shadow.camera.top = range;
                        window.solarShadowLight.shadow.camera.bottom = -range;
                        window.solarShadowLight.shadow.camera.near = Math.max(1, dist - range * 2);
                        window.solarShadowLight.shadow.camera.far = dist + range * 2;
                        window.solarShadowLight.shadow.camera.updateProjectionMatrix();
                    }
                }
            }
            
            // ★★★ 정거장 보호막 초기화 (최초 1회) ★★★
            if (!window.stationShieldsInitialized && satellites.length > 0) {
                const hasStations = satellites.some(s => s.isSpaceStation);
                if (hasStations) {
                    addShieldsToStations();
                    window.stationShieldsInitialized = true;
                }
            }
            
            // ★★★ 보호막 애니메이션 업데이트 ★★★
            updateShieldAnimations(dt);
            
            // ★★★ 일식/월식 그림자 시스템 업데이트 ★★★
            if (typeof EclipseSystem !== 'undefined' && EclipseSystem.update) {
                EclipseSystem.update();
            }

            bodies.forEach(b => { 
                if (!b || !b.mesh) return;
                if(b.rotSpeed && !b.isStatic) { 
                    b.mesh.rotation.y += b.rotSpeed * 0.01 * CONFIG.timeScale; 
                } 
                if(b.type === 'star') { 
                    if(b.mesh.material && b.mesh.material.uniforms) b.mesh.material.uniforms.time.value = elapsedTime; 
                    if(b.corona && b.corona.material && b.corona.material.uniforms) { 
                        b.corona.material.uniforms.time.value = elapsedTime; 
                        b.corona.lookAt(camera.position); 
                    } 
                } 
                
                // ★★★ 지구 대기/구름 쉐이더 업데이트 ★★★
                if (b.mesh.userData.hasAtmosphere) {
                    const sun = bodies.find(s => s.name === '태양');
                    if (sun && sun.mesh) {
                        // 태양 방향 계산
                        const sunDir = new THREE.Vector3()
                            .subVectors(sun.mesh.position, b.mesh.position)
                            .normalize();
                        
                        // 대기 쉐이더 업데이트
                        if (b.mesh.userData.atmosphereMat) {
                            b.mesh.userData.atmosphereMat.uniforms.sunDirection.value.copy(sunDir);
                            b.mesh.userData.atmosphereMat.uniforms.time.value = elapsedTime;
                        }
                        
                        // 다층 구름 쉐이더 업데이트
                        if (b.mesh.userData.cloudLayers) {
                            b.mesh.userData.cloudLayers.forEach((cloudMat, idx) => {
                                cloudMat.uniforms.sunDirection.value.copy(sunDir);
                                // 레이어별로 다른 속도로 시간 진행 (입체감)
                                cloudMat.uniforms.time.value = elapsedTime * (1.0 + idx * 0.3) + idx * 100;
                            });
                        }
                        
                        // 이전 버전 호환 (단일 구름)
                        if (b.mesh.userData.cloudMat) {
                            b.mesh.userData.cloudMat.uniforms.sunDirection.value.copy(sunDir);
                            b.mesh.userData.cloudMat.uniforms.time.value = elapsedTime;
                        }
                    }
                }
                
                if(b.type === 'blackhole') { 
                    // 제트 애니메이션 (은하 중심 블랙홀만)
                    if (b.jets) {
                        const s = 1.0 + Math.random()*0.05; 
                        b.jets.up.scale.y=s; 
                        b.jets.down.scale.y=s;
                    }
                    
                    // ★ 심플한 불의 고리 애니메이션
                    if (b.mesh.userData.fireRings) {
                        b.mesh.userData.fireRings.forEach(ring => {
                            ring.rotation.z += ring.userData.rotationSpeed || 0.003;
                        });
                    }
                    if (b.mesh.userData.innerGlow) {
                        b.mesh.userData.innerGlow.rotation.z += b.mesh.userData.innerGlow.userData.rotationSpeed || 0.01;
                    }
                    
                    // 기존 강착원반 호환 (은하 중심)
                    if (b.mesh.userData.diskLayers) {
                        b.mesh.userData.diskLayers.forEach(ring => {
                            ring.rotation.z += ring.userData.rotationSpeed;
                        });
                    }
                    if (b.mesh.userData.mainDisk) {
                        b.mesh.userData.mainDisk.rotation.z += b.mesh.userData.mainDisk.userData.rotationSpeed || 0.002;
                    }
                } 
            });

            satellites.forEach(sat => {
                if (sat && sat.parentBody && sat.parentBody.mesh && sat.mesh) {
                    // 물리 활성화된 위성(moon)은 궤도 계산 건너뛰기 - 물리 법칙으로 이동
                    if (sat.isPhysicsEnabled) {
                        // 자전만 적용
                        sat.mesh.rotation.y += 0.01;
                        return;
                    }

                    // ★★★ 멀티모드: Date.now() 기준 공전 (동기화) ★★★
                    if (window.gameMode === 'multi') {
                        // 위성별 고유 시드 (이름 기반) + 시간 기반 공전
                        const seed = sat.name ? sat.name.split('').reduce((a, c) => a + c.charCodeAt(0), 0) : 0;
                        const baseTime = Date.now() * 0.0000001;  // 느린 공전
                        sat.angle = (seed * 0.1 + baseTime * sat.orbitSpeed) % (Math.PI * 2);
                    } else {
                        // 싱글모드: 기존 방식 (상대적 누적)
                        const satelliteSpeedMultiplier = CONFIG.timeScale;
                        sat.angle += sat.orbitSpeed * rawDt * satelliteSpeedMultiplier * 0.033;
                    } 
                    
                    // 실제 거리 모드에서는 실제 비율 사용, 체험 모드에서는 기본 비율
                    const isRealMode = CONFIG.distScale > 1.0;
                    let r;
                    if (isRealMode && sat.realOrbitRadius) {
                        // 실제 모드: 모행성 반지름 × 실제 비율 × visualScale
                        const parentScale = sat.parentBody.visualScale || 1;
                        r = sat.realOrbitRadius * (sat.parentBody.radius || 1) * parentScale;
                    } else {
                        // 체험 모드: 이미 계산된 orbitRadius 사용
                        r = sat.orbitRadius;
                    }
                    sat.mesh.position.x = sat.parentBody.mesh.position.x + Math.cos(sat.angle) * r; 
                    sat.mesh.position.z = sat.parentBody.mesh.position.z + Math.sin(sat.angle) * r; 
                    sat.mesh.position.y = sat.parentBody.mesh.position.y; 
                    if (sat.type === 'station') { 
                        sat.mesh.lookAt(sat.parentBody.mesh.position); 
                        sat.mesh.rotateY(Math.PI/2); 
                        
                        // 우주정거장 링 회전 애니메이션
                        if (sat.mesh.userData && sat.mesh.userData.isStation && sat.mesh.userData.ringMesh) {
                            sat.mesh.userData.ringMesh.rotation.z += rawDt * 0.15;  // 링 천천히 회전
                        }
                        
                        // 태양광 패널 태양 추적 (90도 틸트)
                        const solarArray = sat.mesh.getObjectByName('solarArrayGroup');
                        if (solarArray) {
                            // 정거장에서 태양(원점) 방향 계산
                            const stationPos = sat.mesh.position.clone();
                            const toSun = new THREE.Vector3(0, 0, 0).sub(stationPos).normalize();
                            
                            // 로컬 좌표계로 변환
                            const invQuat = sat.mesh.quaternion.clone().invert();
                            const localSunDir = toSun.applyQuaternion(invQuat);
                            
                            // Y축 회전으로 태양 방향 맞추기
                            const sunAngle = Math.atan2(localSunDir.x, localSunDir.z);
                            solarArray.rotation.y = sunAngle;
                            
                            // X축 90도 틸트 (패널 면이 태양을 향하게)
                            solarArray.rotation.x = Math.PI / 2;
                        }
                        
                        // 스트로브 조명 깜빡임
                        const time = Date.now() * 0.001;
                        sat.mesh.children.forEach(child => {
                            if (child.name && child.name.startsWith('strobe_')) {
                                const strobeIndex = parseInt(child.name.split('_')[1]);
                                const blinkPhase = (time + strobeIndex * 0.5) % 2;
                                child.visible = blinkPhase < 0.1;  // 짧게 깜빡임
                            }
                        });
                    } else { 
                        sat.mesh.rotation.y += 0.01; 
                    } 
                } 
            });
            
            // ★★★ 주차된 우주선 실시간 이동 업데이트 ★★★
            if (parkedShipMesh && parkedShipMesh.userData.isMoving && !isPilotMode) {
                const velocity = parkedShipMesh.userData.velocity;
                const speed = parkedShipMesh.userData.speed || 0;
                
                if (velocity && speed > 0.01) {
                    // 실시간으로 위치 업데이트
                    const moveAmount = velocity.clone().multiplyScalar(dt);
                    parkedShipMesh.position.add(moveAmount);
                    
                    // 엔진 불꽃 애니메이션
                    const flame = parkedShipMesh.getObjectByName('engineFlame');
                    if (flame) {
                        flame.visible = true;
                        const flicker = 0.9 + Math.sin(elapsedTime * 10) * 0.2;
                        flame.scale.z = flicker * (0.5 + speed * 0.1);
                    }
                    
                    // 포커스된 상태면 카메라도 따라가기
                    if (focusedBody && focusedBody.mesh === parkedShipMesh) {
                        controls.target.copy(parkedShipMesh.position);
                    }
                    
                    // parkedShip 데이터도 업데이트
                    if (parkedShip) {
                        parkedShip.position = parkedShipMesh.position.clone();
                    }
                }
            }
            
            // ★★★ SSIL 미션 체크 (2초마다) ★★★
            if (isPilotMode && playerShip) {
                if (!window.lastMissionCheck) window.lastMissionCheck = 0;
                if (elapsedTime - window.lastMissionCheck > 2) {
                    window.lastMissionCheck = elapsedTime;
                    checkTrainingMissions();
                    checkDailyMission();
                }
            }
            
            // ===== 도킹 해제 연출 =====
            if (undockingState.active && undockingState.phase === 'undocking') {
                if (!playerShip || !playerShip.mesh) {
                    console.error('언도킹 중 playerShip 없음!');
                    undockingState.active = false;
                } else {
                    const elapsed = Date.now() - undockingState.startTime;
                    const progress = Math.min(elapsed / undockingState.duration, 1.0);
                    
                    // ★ 더 스무스한 이징 함수 (ease-in-out-quart)
                    const easeProgress = progress < 0.5
                        ? 8 * progress * progress * progress * progress
                        : 1 - Math.pow(-2 * progress + 2, 4) / 2;
                    
                    // ★ 저장된 지구 반대 방향 사용
                    const direction = undockingState.undockDirection ? 
                        undockingState.undockDirection.clone() :
                        new THREE.Vector3().subVectors(
                            undockingState.startPos, 
                            undockingState.stationPos
                        ).normalize();
                    
                    // 현재 위치 계산 (0.3 → targetDist) - 시작점도 더 가깝게
                    const currentDist = 0.3 + (undockingState.targetDist - 0.3) * easeProgress;
                    const newPos = undockingState.stationPos.clone().add(
                        direction.clone().multiplyScalar(currentDist)
                    );
                    playerShip.mesh.position.copy(newPos);
                    
                    // 우주선이 이탈 방향 바라보기 (부드럽게 회전)
                    const lookTarget = newPos.clone().add(
                        (undockingState.undockDirection || direction).clone().multiplyScalar(10)
                    );
                    
                    // ★ 부드러운 회전 보간
                    const targetQuat = new THREE.Quaternion();
                    const tempObj = new THREE.Object3D();
                    tempObj.position.copy(newPos);
                    tempObj.lookAt(lookTarget);
                    targetQuat.copy(tempObj.quaternion);
                    playerShip.mesh.quaternion.slerp(targetQuat, 0.05);
                    
                    // 역추진 불꽃 효과 (부드러운 깜빡임)
                    const reverseFlame = playerShip.mesh.getObjectByName('reverseFlameGroup');
                    if (reverseFlame) {
                        reverseFlame.visible = true;
                        // 불꽃 크기 변화 (더 부드럽게)
                        const flicker = 0.9 + Math.sin(elapsed * 0.02) * 0.2;
                        reverseFlame.scale.setScalar(flicker);
                    }
                    
                    // ★ 3인칭 카메라: 더 스무스하게 따라가기
                    const camTarget = playerShip.mesh.position.clone();
                    const idealCamPos = camTarget.clone().add(
                        direction.clone().multiplyScalar(-3)  // 이동 방향 뒤쪽
                    ).add(new THREE.Vector3(0, 1.5, 0));  // 위쪽
                    
                    // 측면 오프셋 추가
                    const sideDir = new THREE.Vector3().crossVectors(direction, new THREE.Vector3(0, 1, 0)).normalize();
                    idealCamPos.add(sideDir.multiplyScalar(2));
                    
                    camera.position.lerp(idealCamPos, 0.03);  // 더 부드럽게
                    camera.lookAt(camTarget);
                    
                    // 연출 완료
                    if (progress >= 1.0) {
                        undockingState.phase = 'complete';
                        undockingState.active = false;
                        
                        // 1인칭 카메라로 전환
                        scene.remove(camera);
                        playerShip.mesh.add(camera);
                        // ★ 카메라 위치는 스케일과 무관하게 고정
                        camera.position.set(0, 0.08, 0.15);
                        camera.rotation.set(0, 0, 0);
                        
                        // 역추진 불꽃 끄기
                        if (reverseFlame) reverseFlame.visible = false;
                        if (playerShip.flame) playerShip.flame.visible = false;
                        
                        // ★ 조종석 다시 보이기
                        const cockpit = playerShip.mesh.getObjectByName('cockpitGroup');
                        if (cockpit) cockpit.visible = true;
                        
                        // 조종석 시점 초기화
                        cockpitTargetRotY = 0;
                        cockpitTargetRotX = 0;
                        cockpitLookRotY = 0;
                        cockpitLookRotX = 0;
                        
                        // 상태 복구
                        const statusEl = document.getElementById('info-status');
                        if (statusEl) {
                            statusEl.textContent = t('statusNormal');
                            statusEl.style.color = '#00ff00';
                        }
                        
                        // ★ 1인칭 조종석 뷰로 복귀
                        isCockpitView = true;
                        
                        console.log('★ 언도킹 완료!');
                        showMsg(`✅ 발진 준비 완료! ${currentShipType.name} 조종을 시작하세요.`);
                    }
                    
                    // 언도킹 중에는 조종 입력 무시
                    // ★ 3인칭이므로 조종석 숨기기
                    const cockpit = playerShip?.mesh?.getObjectByName('cockpitGroup');
                    if (cockpit) cockpit.visible = false;
                    
                    renderer.render(scene, camera);
                    labelRenderer.render(scene, camera);
                    return;  // 조종 모드 처리 건너뛰기
                }
            }
            
            // ===== 우주선 조종 모드 =====
            if (isPilotMode && playerShip) {
                // 자동항법 업데이트 (선내/전망대에서도 우주선 이동)
                if (autopilot.engaged && playerShip.mesh) {
                    if (isInteriorMode || isObservatoryMode) {
                        updateShipAutopilot(dt);
                        const fwd = new THREE.Vector3(0, 0, -1).applyQuaternion(playerShip.mesh.quaternion);
                        playerShip.mesh.position.add(fwd.multiplyScalar(playerShip.speed * dt));
                        checkShipCollision();
                    }
                }
                
                // 궤도 운행 업데이트 (선내/전망대에서도 가능)
                if (orbitState.active && playerShip.mesh) {
                    updateOrbitMotion(dt);
                    updateShipHUD();
                }
                
                if (isObservatoryMode) {
                    // 전망대 모드 - 360도 우주 관찰
                    // ★ 조종석 숨기기
                    const cockpit = playerShip?.mesh?.getObjectByName('cockpitGroup');
                    if (cockpit) cockpit.visible = false;
                    
                    updateObservatoryCamera();
                    updateShipHUD();
                    renderer.render(scene, obsCamera);
                    labelRenderer.render(scene, obsCamera);
                } else if (isInteriorMode) {
                    // 선내 모드 - 1인칭 탐험
                    updateInteriorPlayer(rawDt);  // 실제 시간 사용 (시간배속 무관)
                    updatePhysicsObjects(rawDt);  // 실제 시간 사용
                    
                    // 엔진/홀로그램 애니메이션
                    engineParts.forEach(part => {
                        if (part.userData && part.userData.animate) part.userData.animate(elapsedTime);
                    });
                    interactableObjects.forEach(obj => {
                        if (obj.userData && obj.userData.animate) obj.userData.animate(elapsedTime);
                    });
                    
                    interiorRenderer.render(interiorScene, interiorCamera);
                } else {
                    // 1인칭 조종석 모드 (도킹 중이 아닐 때만)
                    
                    // ★ 정거장에 도킹된 상태면 함께 이동
                    if (window.isDockedToStation) {
                        updateDockedPosition();
                    }
                    
                    updatePilotMode(dt);
                    
                    // ★★★ 정거장/오브젝트 충돌 체크 및 내구도 업데이트 ★★★
                    checkStationCollisions();
                    updateHullHUD();
                    
                    if (!window.isDocking) {
                        updateCockpitView(dt);
                    }
                    
                    // ★ 2패스 렌더링: 조종석이 천체에 가려지지 않도록
                    const cockpit = playerShip?.mesh?.getObjectByName('cockpitGroup');
                    if (cockpit) {
                        if (isCockpitView) {
                            // 1인칭 조종석 뷰 - 2패스 렌더링
                            // ★ shipVisualGroup 숨김 (1인칭에서는 우주선 본체 안보임)
                            const shipVisual = playerShip?.mesh?.getObjectByName('shipVisual');
                            if (shipVisual) shipVisual.visible = false;

                            // 1단계: 조종석 숨기고 우주/천체 렌더링
                            cockpit.visible = false;
                            renderer.render(scene, camera);

                            // 2단계: 깊이 버퍼 클리어 후 조종석만 렌더링
                            // ★ playerShip 외 모든 메시 숨기기
                            const hiddenObjects = [];
                            scene.traverse(obj => {
                                // playerShip의 자식이 아니고 visible인 메시만 숨김
                                if (obj.isMesh && obj.visible) {
                                    let isPartOfShip = false;
                                    let parent = obj.parent;
                                    while (parent) {
                                        if (parent === playerShip.mesh) {
                                            isPartOfShip = true;
                                            break;
                                        }
                                        parent = parent.parent;
                                    }
                                    if (!isPartOfShip) {
                                        obj.visible = false;
                                        hiddenObjects.push(obj);
                                    }
                                }
                            });

                            cockpit.visible = true;
                            renderer.autoClear = false;
                            renderer.clearDepth();
                            renderer.render(scene, camera);
                            renderer.autoClear = true;

                            // ★ 숨긴 객체 복원
                            hiddenObjects.forEach(obj => obj.visible = true);
                        } else {
                            // 3인칭 뷰 - 우주선 본체만 표시 (조종석 숨김)
                            cockpit.visible = false;  // ★ 조종석 숨김
                            
                            // ★ shipVisualGroup 표시 (우주선 본체/GLB 모델)
                            const shipVisual = playerShip?.mesh?.getObjectByName('shipVisual');
                            if (shipVisual) shipVisual.visible = true;
                            
                            // ★ 카메라가 우주선을 따라가되 상대 위치(거리/각도) 유지
                            const shipPos = playerShip.mesh.position.clone();
                            if (lastShipPosition) {
                                const diff = new THREE.Vector3().subVectors(shipPos, lastShipPosition);
                                camera.position.add(diff);
                                controls.target.copy(shipPos);
                            }
                            lastShipPosition = shipPos.clone();
                            
                            controls.update();
                            renderer.render(scene, camera);
                        }
                    } else {
                        renderer.render(scene, camera);
                    }
                    
                    labelRenderer.render(scene, camera);
                }
            } else {
                // 일반 모드
                if(focusedBody && focusedBody.mesh && prevPos){ 
                    const diff = new THREE.Vector3().subVectors(focusedBody.mesh.position, prevPos); 
                    camera.position.add(diff); 
                    controls.target.copy(focusedBody.mesh.position); 
                }
                
                // 포커스된 천체와의 거리 표시 업데이트
                updateFocusDistance();
                
                // 탑승 버튼은 focusBody에서만 관리 (깜박임 방지)
                
                controls.update(); 
                renderer.render(scene, camera); 
                labelRenderer.render(scene, camera);
            }
        }

        function init() {
            try {
                scene = new THREE.Scene();
                scene.fog = new THREE.FogExp2(0x000000, 0.00000007);
                window.scene = scene;  // ★ 멀티플레이어에서 사용

                camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.001, 30000000000);
                camera.position.set(0, 500, 800);
                window.camera = camera;  // ★ 망원경 모드에서 사용

                // 모바일 감지
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                
                renderer = new THREE.WebGLRenderer({ 
                    antialias: !isMobile,  // 모바일에서 안티앨리어싱 비활성화 (성능)
                    logarithmicDepthBuffer: true,
                    powerPreference: 'high-performance'
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                renderer.toneMapping = THREE.ACESFilmicToneMapping;  // ★ 영화 같은 톤매핑
                renderer.toneMappingExposure = 1.2;  // ★ 노출 조정
                document.getElementById('canvas-container').appendChild(renderer.domElement);
                
                // ★ 우주 환경맵 생성 (메탈릭 반사용)
                const pmremGenerator = new THREE.PMREMGenerator(renderer);
                pmremGenerator.compileEquirectangularShader();
                
                // 우주 배경색 기반 환경맵 생성
                const spaceEnvScene = new THREE.Scene();
                spaceEnvScene.background = new THREE.Color(0x000510);
                
                // 별빛 포인트 추가
                const starGeom = new THREE.BufferGeometry();
                const starCount = 200;
                const starPositions = new Float32Array(starCount * 3);
                for (let i = 0; i < starCount; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const r = 50;
                    starPositions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                    starPositions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                    starPositions[i * 3 + 2] = r * Math.cos(phi);
                }
                starGeom.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
                const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 2 });
                spaceEnvScene.add(new THREE.Points(starGeom, starMat));
                
                // 은은한 조명 추가
                spaceEnvScene.add(new THREE.AmbientLight(0x334455, 0.5));
                const envSunLight = new THREE.DirectionalLight(0xffffee, 1.5);
                envSunLight.position.set(10, 10, 10);
                spaceEnvScene.add(envSunLight);
                
                // 환경맵 생성 및 적용
                const spaceEnvMap = pmremGenerator.fromScene(spaceEnvScene, 0.04).texture;
                scene.environment = spaceEnvMap;  // ★ 씬 전체에 환경맵 적용
                pmremGenerator.dispose();

                labelRenderer = new CSS2DRenderer();
                labelRenderer.setSize(window.innerWidth, window.innerHeight);
                labelRenderer.domElement.style.position = 'absolute';
                labelRenderer.domElement.style.top = '0px';
                labelRenderer.domElement.style.pointerEvents = 'none';
                document.getElementById('canvas-container').appendChild(labelRenderer.domElement);

                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.minDistance = 0.05;  // ★ 최소 거리 줄임 (줌인 가능)
                controls.maxDistance = 300000000;  // 3억 단위 (은하 바깥까지 볼 수 있게) - 10배 확대 
                window.controls = controls;  // ★ 망원경 모드에서 사용 

                const ambient = new THREE.AmbientLight(0xffffff, 0.4);  // ★ 0.05 → 0.4 (밝기 증가)
                scene.add(ambient);
                
                // ★★★ 태양 그림자 조명 시스템 ★★★
                const solarShadowLight = new THREE.DirectionalLight(0xfffaf0, 2.0);
                solarShadowLight.name = 'solarShadowLight';
                solarShadowLight.castShadow = true;
                
                // 그림자 맵 품질 설정
                solarShadowLight.shadow.mapSize.width = 2048;
                solarShadowLight.shadow.mapSize.height = 2048;
                solarShadowLight.shadow.camera.near = 1;
                solarShadowLight.shadow.camera.far = 50000;
                solarShadowLight.shadow.camera.left = -5000;
                solarShadowLight.shadow.camera.right = 5000;
                solarShadowLight.shadow.camera.top = 5000;
                solarShadowLight.shadow.camera.bottom = -5000;
                solarShadowLight.shadow.bias = -0.0005;
                solarShadowLight.shadow.normalBias = 0.02;
                
                scene.add(solarShadowLight);
                scene.add(solarShadowLight.target);
                window.solarShadowLight = solarShadowLight;
                
                createDetailedGalaxy();
                loadDataAndInit();
                initUI();
                initChat();
                initBodyInfoSystem();  // ★ 천체 정보 시스템 초기화
                
                const toggleBtn = document.getElementById('nav-toggle');
                const navContainer = document.getElementById('nav-container');
                toggleBtn.onclick = () => {
                    navContainer.classList.toggle('closed');
                    toggleBtn.textContent = navContainer.classList.contains('closed') ? '▶' : '◀';
                };
                
                // 모바일에서 네비게이션 패널 기본적으로 닫힘
                if (window.innerWidth <= 768) {
                    navContainer.classList.add('closed');
                    toggleBtn.textContent = '▶';
                }

                const scaleBtn = document.getElementById('btn-scale-mode');
                scaleBtn.onclick = () => {
                    const isReal = CONFIG.distScale > 1.0;
                    if (isReal) {
                        CONFIG.distScale = 1.0;
                        scaleBtn.textContent = t('distExp');
                        scaleBtn.classList.remove('active');
                        resetSimulation();
                        camera.position.set(0, 500, 800);
                        controls.target.set(0,0,0);
                        showMsg(t('msgExpMode'));
                    } else {
                        CONFIG.distScale = 50.0;
                        scaleBtn.textContent = t('distReal');
                        scaleBtn.classList.add('active');
                        resetSimulation();
                        camera.position.set(0, 5000, 8000);
                        controls.target.set(0,0,0);
                        showMsg(t('msgRealMode'));
                    }
                };

                document.getElementById('btn-station').onclick = () => {
                    openStationModal();
                };
                
                document.getElementById('station-close').onclick = () => {
                    document.getElementById('station-modal').classList.remove('open');
                };
                
                // 정거장 모달 외부 클릭 시 닫기
                document.getElementById('station-modal').onclick = (e) => {
                    if (e.target.id === 'station-modal') {
                        document.getElementById('station-modal').classList.remove('open');
                    }
                };

                const catalogModal = document.getElementById('catalog-modal');
                document.getElementById('btn-catalog').onclick = () => {
                    // ★ 멀티모드 튜토리얼 가이드
                    if (typeof MultiTutorial !== 'undefined') {
                        MultiTutorial.showFeatureGuide('catalog-modal');
                    }
                    
                    catalogModal.classList.add('open');
                    renderCatalog();
                    // 멀티모드에서 도감 제목 변경
                    if (typeof updateCatalogTitle === 'function') {
                        updateCatalogTitle();
                    }
                };
                document.getElementById('catalog-close').onclick = () => {
                    catalogModal.classList.remove('open');
                };

                // 언어 선택
                const langSelect = document.getElementById('lang-select');
                const savedLang = localStorage.getItem('milkyway-lang');
                if (savedLang && translations[savedLang]) {
                    langSelect.value = savedLang;
                    setLanguage(savedLang);
                } else {
                    // 저장된 언어가 없으면 기본 언어(영어) 적용
                    setLanguage('en');
                }
                langSelect.onchange = (e) => {
                    setLanguage(e.target.value);
                };

                // 전체화면 버튼
                const fullscreenBtn = document.getElementById('btn-fullscreen');
                fullscreenBtn.onclick = () => {
                    if (!document.fullscreenElement) {
                        document.documentElement.requestFullscreen().then(() => {
                            fullscreenBtn.textContent = t('windowMode');
                            fullscreenBtn.classList.add('active');
                        }).catch(err => {
                            showMsg('Fullscreen failed: ' + err.message);
                        });
                    } else {
                        document.exitFullscreen().then(() => {
                            fullscreenBtn.textContent = t('fullscreen');
                            fullscreenBtn.classList.remove('active');
                        });
                    }
                };
                
                // ★★★ 태양계 초기화 버튼 ★★★
                const resetSolarBtn = document.getElementById('btn-reset-solar');
                if (resetSolarBtn) {
                    resetSolarBtn.onclick = () => {
                        if (confirm(t('confirmResetSolar') + '\n' + t('resetSolarDesc'))) {
                            resetSolarSystemComplete();
                            showMsg('🔄 ' + t('resetSolarSystem'));
                        }
                    };
                }
                document.addEventListener('fullscreenchange', () => {
                    if (!document.fullscreenElement) {
                        fullscreenBtn.textContent = t('fullscreen');
                        fullscreenBtn.classList.remove('active');
                    }
                });

                // 긴급 역추진 버튼 (모바일)
                const emergencyBrakeBtn = document.getElementById('btn-emergency-brake');
                emergencyBrakeBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    shipInputs.emergencyReverse = true;
                });
                emergencyBrakeBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    shipInputs.emergencyReverse = false;
                });
                emergencyBrakeBtn.addEventListener('mousedown', () => { shipInputs.emergencyReverse = true; });
                emergencyBrakeBtn.addEventListener('mouseup', () => { shipInputs.emergencyReverse = false; });
                emergencyBrakeBtn.addEventListener('mouseleave', () => { shipInputs.emergencyReverse = false; });

                window.addEventListener('resize', onResize);
                window.addEventListener('mousemove', onMouseMove);
                
                // ★ 마우스 드래그/클릭 구분
                let mouseStartPos = null;
                let mouseStartTime = 0;
                let isMouseDragging = false;
                
                renderer.domElement.addEventListener('mousedown', (e) => {
                    if (isPilotMode) return;
                    mouseStartPos = { x: e.clientX, y: e.clientY };
                    mouseStartTime = Date.now();
                    isMouseDragging = false;
                    
                    // 천체 생성 드래그 시작
                    if (isPlacing && ghostMesh) {
                        onMouseDown(e);
                    }
                });
                
                window.addEventListener('mousemove', (e) => {
                    if (!mouseStartPos) return;
                    const dx = e.clientX - mouseStartPos.x;
                    const dy = e.clientY - mouseStartPos.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist > 5) {
                        isMouseDragging = true;
                    }
                });
                
                window.addEventListener('mouseup', (e) => {
                    // 천체 생성 드래그 완료
                    if (isPlacing && ghostMesh && isDraggingBody) {
                        onMouseUp(e);
                        mouseStartPos = null;
                        isMouseDragging = false;
                        return;
                    }
                });
                
                window.addEventListener('click', (e) => {
                    if (isPilotMode) return;
                    
                    // 천체 생성 모드에서는 click 무시 (mousedown/mouseup으로 처리)
                    if (isPlacing && ghostMesh) return;
                    
                    // 드래그였으면 클릭 무시
                    if (isMouseDragging) {
                        mouseStartPos = null;
                        isMouseDragging = false;
                        return;
                    }
                    
                    // 짧은 클릭만 허용 (300ms 이하)
                    const elapsed = Date.now() - mouseStartTime;
                    if (elapsed > 300) {
                        mouseStartPos = null;
                        isMouseDragging = false;
                        return;
                    }
                    
                    mouseStartPos = null;
                    isMouseDragging = false;
                    onMouseClick(e);
                });
                
                // 모바일 터치 선택 (OrbitControls와 분리)
                let touchStartPos = null;
                let touchStartTime = 0;
                let isTouchDragging = false;
                
                renderer.domElement.addEventListener('touchstart', (e) => {
                    if (isPilotMode || e.touches.length !== 1) return;
                    touchStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    touchStartTime = Date.now();
                    isTouchDragging = false;
                    
                    // ★★★ 2단계 천체 생성: 화살표 핸들 또는 천체 드래그 시작 체크 ★★★
                    if (pendingBody) {
                        const touchX = e.touches[0].clientX;
                        const touchY = e.touches[0].clientY;
                        if (checkPendingBodyTouch(touchX, touchY)) {
                            isPendingDrag = true;
                            pendingDragStart = touchTo3D(touchX, touchY);
                            if (e.cancelable) e.preventDefault();
                            return;
                        }
                    }
                    
                    // 천체 생성 드래그 시작 (모바일)
                    if (isPlacing && ghostMesh) {
                        const fakeEvent = { 
                            clientX: e.touches[0].clientX, 
                            clientY: e.touches[0].clientY,
                            target: { closest: () => null }
                        };
                        onMouseDown(fakeEvent);
                    }
                }, { passive: false });
                
                renderer.domElement.addEventListener('touchmove', (e) => {
                    // ★★★ 2단계 천체 생성: 화살표 핸들 드래그 중 ★★★
                    if (isPendingDrag && pendingBody && pendingDragStart) {
                        const touch = e.touches[0];
                        const currentPos = touchTo3D(touch.clientX, touch.clientY);
                        if (currentPos) {
                            // 화살표와 핸들 위치 업데이트
                            updateArrowAndHandle(currentPos);
                        }
                        if (e.cancelable) e.preventDefault();
                        return;
                    }
                    
                    // 천체 생성 드래그 중 (모바일)
                    if (isPlacing && ghostMesh && isDraggingBody) {
                        const touch = e.touches[0];
                        const fakeEvent = { clientX: touch.clientX, clientY: touch.clientY };
                        onMouseMove(fakeEvent);
                    }
                    
                    if (!touchStartPos) return;
                    const touch = e.touches[0];
                    const dx = touch.clientX - touchStartPos.x;
                    const dy = touch.clientY - touchStartPos.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    // 3px 이상 움직이면 드래그로 판정 (더 민감하게)
                    if (dist > 3) {
                        isTouchDragging = true;
                    }
                }, { passive: true });  // passive: true로 변경하여 스크롤 최적화
                
                renderer.domElement.addEventListener('touchend', (e) => {
                    // ★★★ 2단계 천체 생성: 화살표 핸들 드래그 완료 ★★★
                    if (isPendingDrag && pendingBody && pendingDragStart) {
                        const touch = e.changedTouches[0];
                        const endPos = touchTo3D(touch.clientX, touch.clientY);
                        
                        if (endPos && velocityHandle) {
                            // ★★★ 화살표 핸들 위치 기반으로 속도 계산 ★★★
                            const handlePos = velocityHandle.position.clone();
                            const dragVec = new THREE.Vector3().subVectors(handlePos, pendingBody.position);
                            const dragLen = dragVec.length();
                            
                            // ★★★ 속도 스케일 대폭 증가 (중력에 대응) ★★★
                            // 드래그 길이 50 = 약 0.5 속도
                            // 드래그 길이 100 = 약 1.0 속도
                            // 드래그 길이 200+ = 약 2.0 속도 (최대)
                            const speedScale = Math.min(dragLen * 0.01, 2.0);
                            const velocity = dragVec.clone().normalize().multiplyScalar(speedScale);
                            
                            console.log(`★ 천체 생성 ★`);
                            console.log(`  - 핸들 위치: (${handlePos.x.toFixed(2)}, ${handlePos.y.toFixed(2)}, ${handlePos.z.toFixed(2)})`);
                            console.log(`  - 천체 위치: (${pendingBody.position.x.toFixed(2)}, ${pendingBody.position.y.toFixed(2)}, ${pendingBody.position.z.toFixed(2)})`);
                            console.log(`  - 드래그 길이: ${dragLen.toFixed(2)}`);
                            console.log(`  - 속도 스케일: ${speedScale.toFixed(6)}`);
                            console.log(`  - 최종 속도: (${velocity.x.toFixed(6)}, ${velocity.y.toFixed(6)}, ${velocity.z.toFixed(6)})`);
                            console.log(`  - 속도 크기: ${velocity.length().toFixed(6)}`);
                            
                            // 천체 확정 생성
                            confirmPendingBody(velocity);
                        } else if (endPos) {
                            // 핸들이 없으면 터치 위치 사용 (fallback)
                            const dragVec = new THREE.Vector3().subVectors(endPos, pendingBody.position);
                            const dragLen = dragVec.length();
                            const speedScale = Math.min(dragLen * 0.01, 2.0);
                            const velocity = dragVec.clone().normalize().multiplyScalar(speedScale);
                            confirmPendingBody(velocity);
                        }
                        
                        isPendingDrag = false;
                        pendingDragStart = null;
                        touchStartPos = null;
                        isTouchDragging = false;
                        return;
                    }
                    
                    // 천체 생성 드래그 완료 (모바일)
                    if (isPlacing && ghostMesh && isDraggingBody) {
                        const touch = e.changedTouches[0];
                        const fakeEvent = { clientX: touch.clientX, clientY: touch.clientY };
                        onMouseUp(fakeEvent);
                        touchStartPos = null;
                        isTouchDragging = false;
                        return;
                    }
                    
                    if (isPilotMode || !touchStartPos) {
                        touchStartPos = null;
                        isTouchDragging = false;
                        return;
                    }
                    
                    const touch = e.changedTouches[0];
                    const dx = touch.clientX - touchStartPos.x;
                    const dy = touch.clientY - touchStartPos.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    const elapsed = Date.now() - touchStartTime;
                    
                    // ★★★ 대기 천체가 있는데 다른 곳 탭하면 현재 화살표 방향으로 생성 ★★★
                    if (pendingBody && !isTouchDragging && dist < 5 && elapsed < 150) {
                        const tapPos = touchTo3D(touch.clientX, touch.clientY);
                        if (tapPos) {
                            const distToBody = tapPos.distanceTo(pendingBody.position);
                            const bodyRadius = pendingBody.typeData.r || 1;
                            
                            if (distToBody > bodyRadius * 3) {
                                // 멀리 탭 = 현재 화살표 방향과 길이로 속도 계산
                                let velocity = new THREE.Vector3(0, 0, 0);
                                
                                if (velocityHandle && pendingBody.position) {
                                    const dragVec = new THREE.Vector3().subVectors(
                                        velocityHandle.position, 
                                        pendingBody.position
                                    );
                                    const dragLen = dragVec.length();
                                    const speedScale = Math.min(dragLen * 0.01, 2.0);
                                    velocity = dragVec.clone().normalize().multiplyScalar(speedScale);
                                }
                                
                                confirmPendingBody(velocity);
                                touchStartPos = null;
                                isTouchDragging = false;
                                return;
                            }
                        }
                    }
                    
                    // 드래그가 아닌 경우에만 클릭 처리 (이동 거리 5px 이하, 시간 150ms 이하)
                    if (!isTouchDragging && dist < 5 && elapsed < 150) {
                        e.preventDefault();
                        controls.enabled = false;
                        setTimeout(() => { controls.enabled = true; }, 50);
                        
                        // 천체 선택 처리
                        const fakeEvent = {
                            clientX: touch.clientX,
                            clientY: touch.clientY,
                            target: { closest: () => null }
                        };
                        onMouseClick(fakeEvent);
                    }
                    touchStartPos = null;
                    isTouchDragging = false;
                });
                
                document.getElementById('reset-cam').onclick = resetCamera;
                
                const fineSlider = document.getElementById('time-slider-fine');
                const coarseSlider = document.getElementById('time-slider-coarse');
                const timeVal = document.getElementById('time-val');

                fineSlider.oninput = (e) => {
                    const val = parseFloat(e.target.value);
                    CONFIG.timeScale = val;
                    timeVal.innerText = val.toFixed(1) + 'x';
                };

                coarseSlider.oninput = (e) => {
                    const val = parseFloat(e.target.value);
                    CONFIG.timeScale = val;
                    timeVal.innerText = val.toFixed(1) + 'x';
                };

                // 모바일용 시간 조절 버튼
                const timeValMobile = document.getElementById('time-val-mobile');
                const timeSteps = [0, 0.1, 0.25, 0.5, 1, 2, 5, 10, 25, 50, 100];
                
                function updateTimeDisplay() {
                    const display = CONFIG.timeScale.toFixed(1) + 'x';
                    timeVal.innerText = display;
                    timeValMobile.innerText = display;
                }
                
                document.getElementById('time-slower').onclick = () => {
                    const currentIdx = timeSteps.findIndex(v => v >= CONFIG.timeScale);
                    const newIdx = Math.max(0, currentIdx - 1);
                    CONFIG.timeScale = timeSteps[newIdx];
                    fineSlider.value = Math.min(CONFIG.timeScale, 2);
                    coarseSlider.value = Math.max(CONFIG.timeScale, 1);
                    updateTimeDisplay();
                };
                
                document.getElementById('time-faster').onclick = () => {
                    const currentIdx = timeSteps.findIndex(v => v > CONFIG.timeScale);
                    const newIdx = Math.min(timeSteps.length - 1, currentIdx === -1 ? timeSteps.length - 1 : currentIdx);
                    CONFIG.timeScale = timeSteps[newIdx];
                    fineSlider.value = Math.min(CONFIG.timeScale, 2);
                    coarseSlider.value = Math.max(CONFIG.timeScale, 1);
                    updateTimeDisplay();
                };

                // ===== 우주선 시스템 초기화 =====
                document.getElementById('board-ship-btn').onclick = boardShip;
                document.getElementById('btn-select-ship').onclick = confirmShipSelection;
                document.getElementById('btn-cancel-ship').onclick = closeShipSelectModal;
                document.getElementById('btn-buy-ship').onclick = handleBuyShip;
                document.getElementById('btn-armory').onclick = openArmoryModal;
                
                // ===== 무장 시스템 초기화 =====
                document.getElementById('btn-armory-close').onclick = closeArmoryModal;
                document.getElementById('btn-armory-buy').onclick = handleArmoryBuy;
                document.getElementById('btn-armory-equip').onclick = handleArmoryEquip;
                document.getElementById('btn-armory-unequip').onclick = handleArmoryUnequip;
                document.querySelectorAll('.armory-tab').forEach(tab => {
                    tab.onclick = () => switchArmoryTab(tab.dataset.tab);
                });
                
                // ===== 함선 처분 모달 =====
                document.getElementById('btn-sell-confirm').onclick = confirmSellShip;
                document.getElementById('btn-sell-cancel').onclick = () => {
                    document.getElementById('sell-ship-modal').classList.remove('open');
                };
                
                // ===== 로그인 시스템 초기화 =====
                const loginModal = document.getElementById('login-modal');
                const loginBtn = document.getElementById('btn-login');
                const logoutBtn = document.getElementById('btn-logout');
                const loginClose = document.getElementById('login-close');
                const tabLogin = document.getElementById('tab-login');
                const tabRegister = document.getElementById('tab-register');
                const loginSubmit = document.getElementById('btn-login-submit');
                const emailInput = document.getElementById('input-email');
                const passwordConfirm = document.getElementById('input-password-confirm');
                let isRegisterMode = false;
                
                loginBtn.onclick = () => {
                    openAuthUI();
                };
                loginClose.onclick = () => loginModal.classList.remove('open');
                logoutBtn.onclick = () => {
                    logoutUser();
                    showMsg(t('logout') + '!');
                };
                
                tabLogin.onclick = () => {
                    isRegisterMode = false;
                    tabLogin.classList.add('active');
                    tabRegister.classList.remove('active');
                    loginSubmit.textContent = t('login');
                    emailInput.style.display = 'none';
                    passwordConfirm.style.display = 'none';
                    document.getElementById('terms-agree-section').style.display = 'none';  // ★ 약관 숨김
                    document.getElementById('find-links').style.display = 'flex';
                    document.getElementById('login-error').textContent = '';
                    document.getElementById('login-success').textContent = '';
                };
                tabRegister.onclick = () => {
                    isRegisterMode = true;
                    tabRegister.classList.add('active');
                    tabLogin.classList.remove('active');
                    loginSubmit.textContent = t('register');
                    emailInput.style.display = 'block';
                    passwordConfirm.style.display = 'block';
                    document.getElementById('terms-agree-section').style.display = 'block';  // ★ 약관 표시
                    document.getElementById('find-links').style.display = 'none';
                    document.getElementById('login-error').textContent = '';
                    document.getElementById('login-success').textContent = '';
                };
                
                loginSubmit.onclick = () => {
                    const username = document.getElementById('input-username').value.trim();
                    const password = document.getElementById('input-password').value;
                    loginUser(username, password, isRegisterMode);
                };
                
                // 엔터키로 로그인
                document.getElementById('input-password').onkeypress = (e) => {
                    if (e.key === 'Enter') loginSubmit.click();
                };
                document.getElementById('input-password-confirm').onkeypress = (e) => {
                    if (e.key === 'Enter') loginSubmit.click();
                };
                
                // ★ 아이디/비밀번호 찾기 이벤트
                document.getElementById('link-find-id').onclick = showFindIdForm;
                document.getElementById('link-find-pw').onclick = showFindPwForm;
                document.getElementById('back-from-find-id').onclick = showLoginForm;
                document.getElementById('back-from-find-pw').onclick = showLoginForm;
                
                document.getElementById('btn-find-id').onclick = () => {
                    const email = document.getElementById('find-id-email').value.trim();
                    findUserId(email);
                };
                document.getElementById('btn-find-pw').onclick = () => {
                    const username = document.getElementById('find-pw-username').value.trim();
                    const email = document.getElementById('find-pw-email').value.trim();
                    findUserPassword(username, email);
                };
                
                // 엔터키로 찾기
                document.getElementById('find-id-email').onkeypress = (e) => {
                    if (e.key === 'Enter') document.getElementById('btn-find-id').click();
                };
                document.getElementById('find-pw-email').onkeypress = (e) => {
                    if (e.key === 'Enter') document.getElementById('btn-find-pw').click();
                };
                
                // ★ Supabase 자동 로그인은 loadSavedLogin()에서 처리됨
                // 구형 localStorage 로그인은 더 이상 사용하지 않음
                
                // 도킹된 우주선 생성 (ISS 생성 후)
                setTimeout(() => {
                    const station = satellites.find(s => s.name === "ISS 우주정거장");
                    if (station) {
                        createDockedShip(station);
                    }
                }, 1000);
                
                // ===== 선내 시스템 초기화 =====
                initInteriorScene();
                initInteriorControls();
                initObservatoryControls();

                animate();
            } catch (err) {
                console.error("Initialization Error:", err);
            }
        }
        
        // ===== 게임 모드 시작 함수 (module 내부) =====
        let gameMode = null;
        const MODE_CONFIG = {
            single: {
                fuelMultiplier: 1.0,
                timeSpeedFixed: false,
                canCreateBodies: true,
                canDisembark: true,
                showChat: false
            },
            multi: {
                fuelMultiplier: 0.5,      // ★ 연료 2배 적게 소모 (0.2 → 0.5)
                timeSpeedFixed: true,
                canCreateBodies: false,
                canDisembark: false,
                showChat: true
            }
        };
        // 전역으로 노출
        window.MODE_CONFIG = MODE_CONFIG;
        
        // 방문한 위성 기록 (localStorage에서 불러오기)
        let visitedSatellites;
        try {
            const savedVisited = localStorage.getItem('visitedStations');
            if (savedVisited) {
                visitedSatellites = new Set(JSON.parse(savedVisited));
                // ISS는 항상 포함
                visitedSatellites.add('ISS');
                visitedSatellites.add('ISS 우주정거장');
            } else {
                visitedSatellites = new Set(['ISS', 'ISS 우주정거장']);
            }
        } catch (e) {
            visitedSatellites = new Set(['ISS', 'ISS 우주정거장']);
        }
        window.visitedSatellites = visitedSatellites;
        
        // 방문 기록 저장 함수 (로그인 시 서버, 아니면 로컬)
        window.saveVisitedStations = function() {
            var visitedArray = Array.from(visitedSatellites);
            
            // 로컬에도 항상 저장 (백업)
            localStorage.setItem('visitedStations', JSON.stringify(visitedArray));
            
            // 로그인된 경우 Supabase에 저장
            var userId = window.mpUserId || (window.mpUser && window.mpUser.id);
            var isGuest = userId && userId.indexOf('guest_') === 0;
            if (userId && supabase && !isGuest) {
                // 모든 방문 기록을 한번에 저장
                var upsertPromises = visitedArray.map(function(bodyName) {
                    return supabase
                        .from('visited_bodies')
                        .upsert({
                            user_id: userId,
                            body_name: bodyName,
                            last_visited_at: new Date().toISOString()
                        }, {
                            onConflict: 'user_id,body_name'
                        });
                });
                
                Promise.all(upsertPromises)
                    .then(function() {
                        console.log('방문 기록 Supabase 저장 완료');
                    })
                    .catch(function(e) {
                        console.warn('Supabase 저장 실패, 로컬에만 저장됨:', e);
                    });
            }
        };
        
        // 방문 기록 불러오기 함수 (로그인 시 Supabase에서)
        window.loadVisitedStations = function() {
            var userId = window.mpUserId || (window.mpUser && window.mpUser.id);
            var isGuest = userId && userId.indexOf('guest_') === 0;
            
            if (userId && supabase && !isGuest) {
                return supabase
                    .from('visited_bodies')
                    .select('body_name')
                    .eq('user_id', userId)
                    .then(function(result) {
                        var data = result.data;
                        var error = result.error;
                        
                        if (!error && data && data.length > 0) {
                            visitedSatellites = new Set(data.map(function(d) { return d.body_name; }));
                            // ISS는 항상 포함
                            visitedSatellites.add('ISS');
                            visitedSatellites.add('ISS 우주정거장');
                            window.visitedSatellites = visitedSatellites;
                            
                            // 로컬에도 동기화
                            localStorage.setItem('visitedStations', JSON.stringify(Array.from(visitedSatellites)));
                            console.log('Supabase에서 방문 기록 불러옴:', visitedSatellites.size, '개');
                            return;
                        }
                        
                        // 서버에서 못 가져온 경우 로컬에서
                        loadFromLocal();
                    })
                    .catch(function(e) {
                        console.warn('Supabase 불러오기 실패, 로컬 데이터 사용:', e);
                        loadFromLocal();
                    });
            } else {
                loadFromLocal();
                return Promise.resolve();
            }
            
            function loadFromLocal() {
                try {
                    var savedVisited = localStorage.getItem('visitedStations');
                    if (savedVisited) {
                        visitedSatellites = new Set(JSON.parse(savedVisited));
                        visitedSatellites.add('ISS');
                        visitedSatellites.add('ISS 우주정거장');
                        window.visitedSatellites = visitedSatellites;
                    }
                } catch (e) {
                    console.warn('로컬 불러오기 실패');
                }
            }
        };
        
        window.gameMode = null;
        
        function startGameMode(mode) {
            gameMode = mode;
            window.gameMode = mode;
            const config = MODE_CONFIG[mode];
            
            console.log('startGameMode 호출됨:', mode);
            
            // ★★★ 전체화면 + 가로모드 강제 ★★★
            document.body.classList.add('game-mode');
            document.body.classList.add('game-started');  // ★ 상단 버튼 표시용
            
            // 전체화면 진입 후 가로모드 잠금
            const elem = document.documentElement;
            const requestFS = elem.requestFullscreen || elem.webkitRequestFullscreen || elem.msRequestFullscreen;
            
            if (requestFS) {
                requestFS.call(elem).then(() => {
                    // 전체화면 성공 시 가로모드 잠금
                    if (screen.orientation && screen.orientation.lock) {
                        screen.orientation.lock('landscape').catch(e => {
                            console.log('가로모드 잠금:', e.message);
                        });
                    }
                }).catch(e => {
                    console.log('전체화면 전환:', e.message);
                    // 전체화면 실패해도 게임은 진행
                });
            }
            
            // 오버레이 숨기기
            document.getElementById('mode-select-overlay').style.display = 'none';
            
            // 멀티 모드 설정
            if (mode === 'multi') {
                // 실제 거리 모드 강제 (distScale이 실제 사용되는 변수!)
                CONFIG.distScale = 50;
                CONFIG.timeScale = 0.01;  // ★ 멀티모드: 0.01배속 (10배 더 느리게)
                
                // ★★★ 태양계 재초기화 (실제 거리로) ★★★
                reinitSolarSystemForMulti();
                
                // 시간 배속 컨트롤 숨기기
                const mobileTimeControls = document.getElementById('mobile-time-controls');
                if (mobileTimeControls) {
                    mobileTimeControls.style.display = 'none';
                    console.log('배속 컨트롤 숨김');
                }
                
                // 데스크톱 슬라이더 컨테이너도 숨기기
                const sliderContainers = document.querySelectorAll('.slider-container');
                sliderContainers.forEach(c => c.style.display = 'none');
                
                // ★★★ 배속 표시 숨기기 ★★★
                const timeVal = document.getElementById('time-val');
                if (timeVal) timeVal.style.display = 'none';
                const timeValMobile = document.getElementById('time-val-mobile');
                if (timeValMobile) timeValMobile.style.display = 'none';
                
                // 거리 모드 버튼 숨기기
                const distanceBtn = document.getElementById('btn-scale-mode');
                if (distanceBtn) {
                    distanceBtn.style.display = 'none';
                    console.log('거리 버튼 숨김');
                }
                
                // ★★★ 멀티모드: 태양계 초기화 버튼 숨기기 ★★★
                const resetSolarBtn = document.getElementById('btn-reset-solar');
                if (resetSolarBtn) {
                    resetSolarBtn.style.display = 'none';
                    console.log('태양계 초기화 버튼 숨김 (멀티모드)');
                }
                
                // 오른쪽 행성 생성 버튼들 숨기기
                const spawnDock = document.getElementById('spawn-dock');
                if (spawnDock) {
                    spawnDock.style.display = 'none';
                    console.log('행성 생성 버튼 숨김');
                }
                
                // ★★★ 멀티모드: ARIA + 멀티 탭 모두 표시 ★★★
                const unifiedChat = document.getElementById('unified-chat-panel');
                if (unifiedChat) {
                    // 채팅창 표시
                    unifiedChat.style.display = 'block';
                    
                    // ARIA 탭과 멀티 탭 모두 표시
                    const ariaTabBtn = unifiedChat.querySelector('[data-tab="aria"]');
                    const multiTabBtn = unifiedChat.querySelector('[data-tab="multi"]');
                    const ariaTab = document.getElementById('aria-tab');
                    const multiTab = document.getElementById('multi-tab');
                    
                    // 두 탭 버튼 모두 표시
                    if (ariaTabBtn) ariaTabBtn.style.display = 'block';
                    if (multiTabBtn) multiTabBtn.style.display = 'block';
                    
                    // 멀티 탭을 기본 활성화
                    if (ariaTabBtn) ariaTabBtn.classList.remove('active');
                    if (multiTabBtn) multiTabBtn.classList.add('active');
                    if (ariaTab) ariaTab.classList.remove('active');
                    if (multiTab) multiTab.classList.add('active');
                    
                    console.log('멀티모드: ARIA + 멀티 탭 활성화');
                }
                const aiCopilot = document.getElementById('ai-copilot-panel');
                if (aiCopilot) {
                    aiCopilot.style.display = 'none';
                }
                
                // ★★★ 멀티모드: 우주 지식 가이드 (싱글모드용) 숨기기 ★★★
                const chatToggle = document.getElementById('chat-toggle');
                const chatPanel = document.getElementById('chat-panel');
                if (chatToggle) {
                    chatToggle.style.display = 'none';
                    console.log('우주 지식 가이드 버튼 숨김 (멀티모드)');
                }
                if (chatPanel) {
                    chatPanel.style.display = 'none';
                }
                
                // ★★★ 멀티모드 튜토리얼 시작 ★★★
                setTimeout(() => {
                    if (typeof MultiTutorial !== 'undefined') {
                        MultiTutorial.checkAndStart();
                    }
                }, 500);
                
                // 카메라 위치 조정 - 기존 유저는 우주선으로, 첫 가입자만 전체 뷰
                setTimeout(() => {
                    // ★★★ 첫 방문 여부 확인 ★★★
                    const isFirstVisit = !localStorage.getItem('starwalker_visited');
                    
                    if (isFirstVisit) {
                        // 첫 방문: 전체 뷰 + 튜토리얼
                        camera.position.set(0, 15000, 25000);
                        controls.target.set(0, 0, 0);
                        controls.update();
                        localStorage.setItem('starwalker_visited', 'true');
                        console.log('🆕 첫 방문: 전체 뷰 표시');
                    } else {
                        // 기존 유저: 바로 우주선으로 이동
                        if (playerShip && playerShip.mesh) {
                            const shipPos = playerShip.mesh.position;
                            camera.position.set(shipPos.x, shipPos.y + 50, shipPos.z + 100);
                            controls.target.copy(shipPos);
                            controls.update();
                            console.log('🚀 기존 유저: 우주선으로 이동');
                        } else {
                            // 우주선 생성 대기 후 이동
                            setTimeout(() => {
                                if (playerShip && playerShip.mesh) {
                                    const shipPos = playerShip.mesh.position;
                                    camera.position.set(shipPos.x, shipPos.y + 50, shipPos.z + 100);
                                    controls.target.copy(shipPos);
                                    controls.update();
                                }
                            }, 1500);
                        }
                    }
                }, 200);
            } else {
                // 싱글 모드: 기본 거리
                CONFIG.distScale = 1.0;
                
                // 싱글 모드: 모든 UI 표시
                const mobileTimeControls = document.getElementById('mobile-time-controls');
                if (mobileTimeControls) mobileTimeControls.style.display = '';
                
                const sliderContainers = document.querySelectorAll('.slider-container');
                sliderContainers.forEach(c => c.style.display = '');
                
                const distanceBtn = document.getElementById('btn-scale-mode');
                if (distanceBtn) distanceBtn.style.display = '';
                
                const spawnDock = document.getElementById('spawn-dock');
                if (spawnDock) spawnDock.style.display = 'flex';
                
                // ★★★ 싱글모드: 통합채팅 ARIA만 표시, 채팅 탭 숨김 ★★★
                const unifiedChat = document.getElementById('unified-chat-panel');
                if (unifiedChat) {
                    unifiedChat.style.display = 'block';
                    
                    const ariaTabBtn = unifiedChat.querySelector('[data-tab="aria"]');
                    const multiTabBtn = unifiedChat.querySelector('[data-tab="multi"]');
                    const ariaTab = document.getElementById('aria-tab');
                    const multiTab = document.getElementById('multi-tab');
                    
                    // ARIA 탭만 표시, 채팅 탭 숨김
                    if (ariaTabBtn) {
                        ariaTabBtn.style.display = 'block';
                        ariaTabBtn.classList.add('active');
                    }
                    if (multiTabBtn) {
                        multiTabBtn.style.display = 'none';  // ★ 채팅 탭 숨김
                        multiTabBtn.classList.remove('active');
                    }
                    if (ariaTab) ariaTab.classList.add('active');
                    if (multiTab) multiTab.classList.remove('active');
                    
                    console.log('싱글모드: ARIA만 표시, 채팅 탭 숨김');
                }
                
                // ★★★ 싱글모드 튜토리얼 시작 ★★★
                setTimeout(() => {
                    if (typeof MultiTutorial !== 'undefined') {
                        MultiTutorial.checkAndStart();
                    }
                }, 500);
            }
            
            // 멀티플레이어 채팅 패널 - 전체 UI 숨김/표시
            const mpUI = document.getElementById('multiplayer-ui');
            if (mpUI) {
                mpUI.style.display = config.showChat ? 'block' : 'none';
            }
            
            // ★★★ 멀티모드: multiplayer-ui가 없으면 생성 ★★★
            if (mode === 'multi' && !document.getElementById('multiplayer-ui')) {
                if (typeof createMultiplayerUI === 'function') {
                    createMultiplayerUI();
                    const newMpUI = document.getElementById('multiplayer-ui');
                    if (newMpUI) newMpUI.style.display = 'block';
                    console.log('멀티플레이어 UI 생성됨');
                }
            }
            
            // 멀티 모드일 때만 멀티플레이어 시작
            if (mode === 'multi') {
                // 로그인 체크 (비동기)
                loadSavedLogin().then(function(loggedIn) {
                    // UI 업데이트 (로그인 상태 반영) - 여러 번 호출하여 확실하게
                    if (typeof updateUserUI === 'function') {
                        updateUserUI();
                        setTimeout(updateUserUI, 500);
                        setTimeout(updateUserUI, 1500);
                    }
                    
                    if (!loggedIn && !mpUserId) {
                        // 로그인 안 되어 있으면 인증 UI 표시
                        if (typeof createAuthUI === 'function') {
                            createAuthUI();
                        }
                    } else {
                        // 로그인 되어 있으면 멀티플레이어 시작
                        if (typeof startMultiplayer === 'function' && !window.mpStarted) {
                            startMultiplayer();
                            window.mpStarted = true;
                        }
                        
                        // ★★★ 로그인 후 우주선 위치로 카메라 이동 ★★★
                        setTimeout(function() {
                            if (playerShip && playerShip.mesh) {
                                const shipPos = playerShip.mesh.position;
                                camera.position.set(shipPos.x + 3, shipPos.y + 2, shipPos.z + 5);
                                controls.target.copy(shipPos);
                                controls.update();
                                console.log('🚀 우주선 위치로 카메라 이동:', shipPos);
                            }
                        }, 2000);
                    }
                });
            }
            
            if (typeof showMessage === 'function') {
                const msgText = currentLang === 'ko' ? `🎮 ${mode === 'single' ? '싱글' : '멀티'} 플레이 시작!` :
                               currentLang === 'ja' ? `🎮 ${mode === 'single' ? 'シングル' : 'マルチ'}プレイ開始！` :
                               `🎮 ${mode === 'single' ? 'Single' : 'Multi'} Play Started!`;
                showMessage(msgText);
            }
        }
        
        // 전역으로 노출
        window.startGameMode = startGameMode;
        
        // ========== 드래그 가능 UI 시스템 ==========
        const draggableUISystem = {
            initialized: false,
            elements: [],
            activeElement: null,
            isDragging: false,
            pressTimer: null,
            startPos: { x: 0, y: 0 },
            elementStartPos: { x: 0, y: 0 },
            
            // 드래그 가능한 UI 요소 ID 목록
            draggableIds: [
                'pilot-eta-box',
                'pilot-warning-panel', 
                'pilot-right',
                'pilot-left-console',      // ★ THR/FUEL 게이지
                'pilot-center-console',    // ★ 속도 + 버튼들 (자동, 망원경 등)
                'pilot-right-console',     // ★ ▲▼ 버튼
                'ai-copilot-panel',
                'pilot-target-select',
                'cockpit-radio',
                'multiplayer-ui',
                'mobile-gauge-container',  // ★ 모바일 게이지
                'mobile-speed-container',  // ★ 모바일 속도
                'mobile-btns-container',   // ★ 모바일 버튼들
                'mobile-arrows-container'  // ★ 모바일 화살표
            ],
            
            init() {
                if (this.initialized) {
                    console.log('드래그 UI 이미 초기화됨');
                    return;
                }
                
                console.log('드래그 UI 시스템 초기화 시작...');
                
                // 드래그 가능한 요소 초기화
                this.draggableIds.forEach(id => {
                    const el = document.getElementById(id);
                    if (el) {
                        el.classList.add('draggable-ui');
                        el.dataset.draggable = 'true';
                        this.elements.push(el);
                        this.attachEvents(el);
                        console.log('드래그 등록:', id);
                    } else {
                        console.warn('요소 없음:', id);
                    }
                });
                
                // 저장된 위치 불러오기
                this.loadSavedPositions();
                
                // UI 설정 버튼 이벤트
                this.initSettingsPanel();
                
                this.initialized = true;
                console.log('드래그 UI 시스템 초기화 완료, 요소 수:', this.elements.length);
            },
            
            attachEvents(el) {
                // 터치 이벤트
                el.addEventListener('touchstart', (e) => {
                    if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') {
                        return;
                    }
                    this.onTouchStart(e, el);
                }, { passive: false });
                
                // 마우스 이벤트 (데스크톱)
                el.addEventListener('mousedown', (e) => {
                    if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') {
                        return;
                    }
                    this.onMouseDown(e, el);
                });
            },
            
            onMouseDown(e, el) {
                const startX = e.clientX;
                const startY = e.clientY;
                const rect = el.getBoundingClientRect();
                
                // Ctrl+클릭이면 즉시 드래그 모드
                if (e.ctrlKey || e.button === 2) {
                    e.preventDefault();
                    this.beginDrag(el, startX, startY, rect);
                    
                    const onMove = (ev) => this.doDrag(el, ev.clientX, ev.clientY);
                    const onUp = () => {
                        document.removeEventListener('mousemove', onMove);
                        document.removeEventListener('mouseup', onUp);
                        this.endDrag(el);
                    };
                    
                    document.addEventListener('mousemove', onMove);
                    document.addEventListener('mouseup', onUp);
                    return;
                }
                
                // 일반 클릭 - 길게 누르기
                let moved = false;
                
                const checkMove = (ev) => {
                    if (Math.abs(ev.clientX - startX) > 10 || Math.abs(ev.clientY - startY) > 10) {
                        moved = true;
                        clearTimeout(timer);
                        cleanup();
                    }
                };
                
                const cleanup = () => {
                    document.removeEventListener('mousemove', checkMove);
                    document.removeEventListener('mouseup', onMouseUp);
                };
                
                const onMouseUp = () => {
                    clearTimeout(timer);
                    cleanup();
                };
                
                const timer = setTimeout(() => {
                    if (moved) return;
                    cleanup();
                    
                    // 드래그 시작
                    const currentRect = el.getBoundingClientRect();
                    this.beginDrag(el, startX, startY, currentRect);
                    
                    const onMove = (ev) => this.doDrag(el, ev.clientX, ev.clientY);
                    const onUp = () => {
                        document.removeEventListener('mousemove', onMove);
                        document.removeEventListener('mouseup', onUp);
                        this.endDrag(el);
                    };
                    
                    document.addEventListener('mousemove', onMove);
                    document.addEventListener('mouseup', onUp);
                }, 600);
                
                document.addEventListener('mousemove', checkMove);
                document.addEventListener('mouseup', onMouseUp);
            },
            
            onTouchStart(e, el) {
                if (e.touches.length !== 1) return;
                
                const touch = e.touches[0];
                const startX = touch.clientX;
                const startY = touch.clientY;
                const rect = el.getBoundingClientRect();
                
                let lastX = startX;
                let lastY = startY;
                let moved = false;
                let dragStarted = false;
                
                const checkMove = (ev) => {
                    if (ev.touches.length !== 1) return;
                    const t = ev.touches[0];
                    lastX = t.clientX;
                    lastY = t.clientY;
                    
                    if (!dragStarted && (Math.abs(lastX - startX) > 15 || Math.abs(lastY - startY) > 15)) {
                        moved = true;
                        clearTimeout(timer);
                    }
                    
                    if (dragStarted) {
                        ev.preventDefault();
                        this.doDrag(el, lastX, lastY);
                    }
                };
                
                const onEnd = () => {
                    clearTimeout(timer);
                    document.removeEventListener('touchmove', checkMove);
                    document.removeEventListener('touchend', onEnd);
                    document.removeEventListener('touchcancel', onEnd);
                    if (dragStarted) {
                        this.endDrag(el);
                    }
                };
                
                const timer = setTimeout(() => {
                    if (moved) return;
                    
                    // 드래그 시작 - 현재 위치 기준
                    const currentRect = el.getBoundingClientRect();
                    this.beginDrag(el, lastX, lastY, currentRect);
                    dragStarted = true;
                }, 600);
                
                document.addEventListener('touchmove', checkMove, { passive: false });
                document.addEventListener('touchend', onEnd);
                document.addEventListener('touchcancel', onEnd);
            },
            
            // 드래그 시작
            beginDrag(el, touchX, touchY, rect) {
                this.isDragging = true;
                this.activeElement = el;
                
                // 진동 피드백
                if (navigator.vibrate) navigator.vibrate([50, 30, 50]);
                
                // position을 fixed로 변경
                el.style.position = 'fixed';
                el.style.left = rect.left + 'px';
                el.style.top = rect.top + 'px';
                el.style.right = 'auto';
                el.style.bottom = 'auto';
                el.style.transform = 'none';
                el.style.zIndex = '9999';
                el.style.transition = 'none';
                el.classList.add('dragging');
                
                // 드래그 기준점 저장 (현재 터치 위치와 요소 위치)
                this.dragStartTouch = { x: touchX, y: touchY };
                this.dragStartElement = { x: rect.left, y: rect.top };
                
                if (typeof showMessage === 'function') showMessage('🔄 UI 이동 모드 - 드래그하세요');
            },
            
            // 드래그 중
            doDrag(el, clientX, clientY) {
                if (!this.isDragging) return;
                
                const dx = clientX - this.dragStartTouch.x;
                const dy = clientY - this.dragStartTouch.y;
                
                let newX = this.dragStartElement.x + dx;
                let newY = this.dragStartElement.y + dy;
                
                // 화면 경계 제한
                newX = Math.max(0, Math.min(window.innerWidth - 50, newX));
                newY = Math.max(0, Math.min(window.innerHeight - 50, newY));
                
                el.style.left = newX + 'px';
                el.style.top = newY + 'px';
            },
            
            // 드래그 종료
            endDrag(el) {
                if (!this.isDragging) return;
                
                this.isDragging = false;
                this.activeElement = null;
                
                el.classList.remove('dragging');
                el.style.transition = '';
                el.style.zIndex = '';
                
                // 위치 저장
                this.savePositions();
                
                if (typeof showMessage === 'function') showMessage('✓ UI 위치 저장됨');
            },
            
            // 기존 함수들 (호환성)
            startDragging(el) { /* deprecated */ },
            moveElement(el, x, y) { /* deprecated */ },
            stopDragging(el) { /* deprecated */ },
            
            // 현재 위치 가져오기
            getCurrentPositions() {
                const positions = {};
                this.elements.forEach(el => {
                    if (el.style.left || el.style.top) {
                        positions[el.id] = {
                            left: el.style.left,
                            top: el.style.top,
                            position: 'fixed'
                        };
                    }
                });
                return positions;
            },
            
            // 슬롯에 저장
            saveToSlot(slotIndex) {
                const slots = this.getSlots();
                const positions = this.getCurrentPositions();
                
                slots[slotIndex] = {
                    positions: positions,
                    date: new Date().toLocaleString('ko-KR'),
                    name: 'UI 배치 ' + (slotIndex + 1)
                };
                
                localStorage.setItem('cockpitUISlots', JSON.stringify(slots));
                this.renderSlots();
                if (typeof showMessage === 'function') showMessage('💾 슬롯 ' + (slotIndex + 1) + '에 저장되었습니다');
            },
            
            // 슬롯에서 불러오기
            loadFromSlot(slotIndex) {
                const slots = this.getSlots();
                const slot = slots[slotIndex];
                
                if (!slot || !slot.positions) {
                    if (typeof showMessage === 'function') showMessage('⚠️ 빈 슬롯입니다');
                    return;
                }
                
                this.applyPositions(slot.positions);
                if (typeof showMessage === 'function') showMessage('📂 슬롯 ' + (slotIndex + 1) + '을 불러왔습니다');
            },
            
            // 슬롯 삭제
            deleteSlot(slotIndex) {
                const slots = this.getSlots();
                slots[slotIndex] = null;
                localStorage.setItem('cockpitUISlots', JSON.stringify(slots));
                this.renderSlots();
                if (typeof showMessage === 'function') showMessage('🗑️ 슬롯 ' + (slotIndex + 1) + '이 삭제되었습니다');
            },
            
            // 모든 슬롯 가져오기
            getSlots() {
                try {
                    const saved = localStorage.getItem('cockpitUISlots');
                    return saved ? JSON.parse(saved) : [null, null, null];
                } catch (e) {
                    return [null, null, null];
                }
            },
            
            // 위치 적용
            applyPositions(positions) {
                Object.keys(positions).forEach(id => {
                    const el = document.getElementById(id);
                    if (el && positions[id]) {
                        const pos = positions[id];
                        el.style.position = 'fixed';
                        el.style.left = pos.left;
                        el.style.top = pos.top;
                        el.style.right = 'auto';
                        el.style.bottom = 'auto';
                        el.style.transform = 'none';
                    }
                });
            },
            
            // 슬롯 UI 렌더링
            renderSlots() {
                const container = document.getElementById('ui-slots-list');
                if (!container) return;
                
                const slots = this.getSlots();
                container.innerHTML = '';
                
                for (let i = 0; i < 3; i++) {
                    const slot = slots[i];
                    const isEmpty = !slot || !slot.positions;
                    
                    const slotEl = document.createElement('div');
                    slotEl.className = 'ui-slot' + (isEmpty ? ' empty' : '');
                    
                    // 미리보기 생성
                    const preview = document.createElement('div');
                    preview.className = 'ui-slot-preview';
                    
                    if (!isEmpty && slot.positions) {
                        // 미리보기 점 생성
                        Object.keys(slot.positions).forEach(id => {
                            const pos = slot.positions[id];
                            if (pos.left && pos.top) {
                                const dot = document.createElement('div');
                                dot.className = 'preview-dot';
                                // 비율 계산 (화면 크기 기준으로 축소)
                                const leftPercent = (parseFloat(pos.left) / window.innerWidth) * 100;
                                const topPercent = (parseFloat(pos.top) / window.innerHeight) * 100;
                                dot.style.left = Math.min(90, Math.max(5, leftPercent)) + '%';
                                dot.style.top = Math.min(85, Math.max(5, topPercent)) + '%';
                                preview.appendChild(dot);
                            }
                        });
                    }
                    
                    // 슬롯 정보
                    const info = document.createElement('div');
                    info.className = 'ui-slot-info';
                    info.innerHTML = `
                        <div class="ui-slot-name">${isEmpty ? '빈 슬롯' : slot.name}</div>
                        <div class="ui-slot-date">${isEmpty ? '저장된 배치 없음' : slot.date}</div>
                    `;
                    
                    // 버튼들
                    const actions = document.createElement('div');
                    actions.className = 'ui-slot-actions';
                    
                    if (isEmpty) {
                        const saveBtn = document.createElement('button');
                        saveBtn.className = 'ui-slot-btn save';
                        saveBtn.textContent = t('save');
                        saveBtn.onclick = (e) => {
                            e.stopPropagation();
                            this.saveToSlot(i);
                        };
                        actions.appendChild(saveBtn);
                    } else {
                        const loadBtn = document.createElement('button');
                        loadBtn.className = 'ui-slot-btn load';
                        loadBtn.textContent = t('load');
                        loadBtn.onclick = (e) => {
                            e.stopPropagation();
                            this.loadFromSlot(i);
                        };
                        
                        const saveBtn = document.createElement('button');
                        saveBtn.className = 'ui-slot-btn save';
                        saveBtn.textContent = t('overwrite');
                        saveBtn.onclick = (e) => {
                            e.stopPropagation();
                            this.saveToSlot(i);
                        };
                        
                        const delBtn = document.createElement('button');
                        delBtn.className = 'ui-slot-btn delete';
                        delBtn.textContent = t('delete');
                        delBtn.onclick = (e) => {
                            e.stopPropagation();
                            this.deleteSlot(i);
                        };
                        
                        actions.appendChild(loadBtn);
                        actions.appendChild(saveBtn);
                        actions.appendChild(delBtn);
                    }
                    
                    slotEl.appendChild(preview);
                    slotEl.appendChild(info);
                    slotEl.appendChild(actions);
                    container.appendChild(slotEl);
                }
            },
            
            savePositions() {
                // 자동 저장용 (첫 번째 슬롯 사용하거나 마지막 사용 슬롯)
                const positions = this.getCurrentPositions();
                localStorage.setItem('cockpitUIPositions', JSON.stringify(positions));
            },
            
            loadSavedPositions() {
                const saved = localStorage.getItem('cockpitUIPositions');
                if (!saved) return;
                
                try {
                    const positions = JSON.parse(saved);
                    
                    // 각 요소별로 개별 적용 (다른 요소에 영향 없이)
                    Object.keys(positions).forEach(id => {
                        const el = document.getElementById(id);
                        if (!el || !positions[id]) return;
                        
                        const pos = positions[id];
                        const left = parseInt(pos.left) || 0;
                        const top = parseInt(pos.top) || 0;
                        
                        // 화면 범위 내인지 확인
                        if (left < 0 || left > window.innerWidth - 50 || 
                            top < 0 || top > window.innerHeight - 50) {
                            console.warn('UI 위치가 화면 밖:', id);
                            return; // 이 요소는 기본 위치 유지
                        }
                        
                        // 위치 적용
                        el.style.position = 'fixed';
                        el.style.left = pos.left;
                        el.style.top = pos.top;
                        el.style.right = 'auto';
                        el.style.bottom = 'auto';
                        el.style.transform = 'none';
                    });
                    
                    console.log('저장된 UI 위치 불러옴');
                } catch (e) {
                    console.warn('UI 위치 불러오기 실패:', e);
                    localStorage.removeItem('cockpitUIPositions');
                }
            },
            
            resetToDefault() {
                this.elements.forEach(el => {
                    el.style.position = '';
                    el.style.left = '';
                    el.style.top = '';
                    el.style.right = '';
                    el.style.bottom = '';
                    el.style.transform = '';
                    el.style.zIndex = '';
                });
                localStorage.removeItem('cockpitUIPositions');
                localStorage.removeItem('uiRearrangePositions');  // ★ 재배치 위치도 리셋
                
                // 재배치 시스템의 요소들도 리셋
                if (typeof uiRearrangeSystem !== 'undefined') {
                    uiRearrangeSystem.rearrangeableIds.forEach(id => {
                        const el = document.getElementById(id);
                        if (el) {
                            el.style.position = '';
                            el.style.left = '';
                            el.style.top = '';
                            el.style.right = '';
                            el.style.bottom = '';
                            el.style.transform = '';
                        }
                    });
                }
                
                if (typeof showMessage === 'function') showMessage('🔄 UI 배치가 기본값으로 리셋되었습니다');
            },
            
            initSettingsPanel() {
                const btn = document.getElementById('ui-settings-btn');
                const panel = document.getElementById('ui-settings-panel');
                const closeBtn = document.getElementById('ui-settings-close');
                
                if (btn) {
                    btn.onclick = () => {
                        panel?.classList.toggle('open');
                        if (panel?.classList.contains('open')) {
                            this.renderSlots();
                        }
                    };
                }
                
                if (closeBtn) {
                    closeBtn.onclick = () => panel?.classList.remove('open');
                }
                
                document.getElementById('ui-reset-default')?.addEventListener('click', () => {
                    this.resetToDefault();
                    panel?.classList.remove('open');
                });
                
                // ★ UI 재배치 모드 버튼
                document.getElementById('ui-rearrange-mode')?.addEventListener('click', () => {
                    panel?.classList.remove('open');
                    uiRearrangeSystem.start();
                });
                
                // ★ 재배치 완료 버튼
                document.getElementById('ui-rearrange-done')?.addEventListener('click', () => {
                    uiRearrangeSystem.stop();
                });
                
                // 초기 슬롯 렌더링
                this.renderSlots();
            }
        };
        
        // ========== UI 재배치 모드 시스템 ==========
        const uiRearrangeSystem = {
            isActive: false,
            elements: [],
            activeElement: null,
            isDragging: false,
            startPos: { x: 0, y: 0 },
            elementStartPos: { x: 0, y: 0 },
            
            // 재배치 가능한 UI 요소 ID 목록
            rearrangeableIds: [
                'unified-chat-panel',       // ★ 통합 채팅창 (ARIA + 멀티)
                'pilot-left-console',       // THR/FUEL 게이지
                'pilot-center-console',     // 속도 + 버튼들
                'pilot-right-console',      // ▲▼ 버튼
                'pilot-right',              // 레이더 + TARGET + AUTOPILOT
                'pilot-eta-box',            // ETA 박스
                'pilot-warning-panel',      // 경고 패널
                'pilot-target-select',      // 목표 선택 드롭다운
                'cockpit-radio',            // 📻 라디오
                'docking-center-btn',       // 도킹 버튼
                'crosshair',                // 조준선
                'ui-settings-btn'           // ⚙️ 설정 버튼
            ],
            
            start() {
                this.isActive = true;
                document.body.classList.add('ui-rearrange-mode');
                document.getElementById('ui-rearrange-overlay')?.classList.add('active');
                
                // 모든 재배치 가능 UI에 클래스 추가 및 이벤트 바인딩
                this.elements = [];
                const self = this;
                this.rearrangeableIds.forEach(id => {
                    const el = document.getElementById(id);
                    if (el) {  // 모든 요소 포함
                        el.classList.add('rearrangeable-ui');
                        el.style.zIndex = '9999';  // 재배치 중 높은 z-index
                        this.elements.push(el);
                        
                        // 터치/마우스 이벤트
                        el._rearrangeStart = function(e) { self.onDragStart(e, el); };
                        
                        el.addEventListener('mousedown', el._rearrangeStart);
                        el.addEventListener('touchstart', el._rearrangeStart, { passive: false });
                    }
                });
                
                this.boundDragMove = (e) => this.onDragMove(e);
                this.boundDragEnd = (e) => this.onDragEnd(e);
                
                document.addEventListener('mousemove', this.boundDragMove);
                document.addEventListener('mouseup', this.boundDragEnd);
                document.addEventListener('touchmove', this.boundDragMove, { passive: false });
                document.addEventListener('touchend', this.boundDragEnd);
                
                if (typeof showMessage === 'function') showMessage('🔧 UI 재배치 모드 - 드래그하여 이동');
            },
            
            stop() {
                this.isActive = false;
                document.body.classList.remove('ui-rearrange-mode');
                document.getElementById('ui-rearrange-overlay')?.classList.remove('active');
                
                // 이벤트 제거 및 클래스 제거
                this.elements.forEach(el => {
                    el.classList.remove('rearrangeable-ui', 'dragging');
                    el.style.zIndex = '';  // z-index 복원
                    if (el._rearrangeStart) {
                        el.removeEventListener('mousedown', el._rearrangeStart);
                        el.removeEventListener('touchstart', el._rearrangeStart);
                    }
                });
                
                document.removeEventListener('mousemove', this.boundDragMove);
                document.removeEventListener('mouseup', this.boundDragEnd);
                document.removeEventListener('touchmove', this.boundDragMove);
                document.removeEventListener('touchend', this.boundDragEnd);
                
                // 위치 저장
                this.savePositions();
                
                if (typeof showMessage === 'function') showMessage('✅ UI 배치가 저장되었습니다');
            },
            
            onDragStart(e, el) {
                if (!this.isActive) return;
                
                e.preventDefault();
                e.stopPropagation();
                
                this.isDragging = true;
                this.activeElement = el;
                el.classList.add('dragging');
                
                const touch = e.touches ? e.touches[0] : e;
                this.startPos = { x: touch.clientX, y: touch.clientY };
                
                const rect = el.getBoundingClientRect();
                this.elementStartPos = { x: rect.left, y: rect.top };
            },
            
            onDragMove(e) {
                if (!this.isDragging || !this.activeElement) return;
                
                e.preventDefault();
                
                const touch = e.touches ? e.touches[0] : e;
                const dx = touch.clientX - this.startPos.x;
                const dy = touch.clientY - this.startPos.y;
                
                let newX = this.elementStartPos.x + dx;
                let newY = this.elementStartPos.y + dy;
                
                // 화면 경계 체크
                const el = this.activeElement;
                const rect = el.getBoundingClientRect();
                newX = Math.max(0, Math.min(window.innerWidth - rect.width, newX));
                newY = Math.max(0, Math.min(window.innerHeight - rect.height, newY));
                
                el.style.position = 'fixed';
                el.style.left = newX + 'px';
                el.style.top = newY + 'px';
                el.style.right = 'auto';
                el.style.bottom = 'auto';
                el.style.transform = 'none';
            },
            
            onDragEnd(e) {
                if (!this.isDragging) return;
                
                this.isDragging = false;
                if (this.activeElement) {
                    this.activeElement.classList.remove('dragging');
                }
                this.activeElement = null;
            },
            
            savePositions() {
                const positions = {};
                this.rearrangeableIds.forEach(id => {
                    const el = document.getElementById(id);
                    if (el) {
                        const rect = el.getBoundingClientRect();
                        positions[id] = {
                            left: rect.left,
                            top: rect.top
                        };
                    }
                });
                localStorage.setItem('uiRearrangePositions', JSON.stringify(positions));
            },
            
            loadPositions() {
                try {
                    const saved = localStorage.getItem('uiRearrangePositions');
                    if (saved) {
                        const positions = JSON.parse(saved);
                        Object.keys(positions).forEach(id => {
                            const el = document.getElementById(id);
                            if (el && positions[id]) {
                                el.style.position = 'fixed';
                                el.style.left = positions[id].left + 'px';
                                el.style.top = positions[id].top + 'px';
                                el.style.right = 'auto';
                                el.style.bottom = 'auto';
                                el.style.transform = 'none';
                            }
                        });
                    }
                } catch (e) {
                    console.warn('UI 위치 로드 실패:', e);
                }
            }
        };
        
        window.uiRearrangeSystem = uiRearrangeSystem;
        
        // 전역으로 노출
        window.draggableUISystem = draggableUISystem;
        
        // 조종 모드 진입 시 초기화
        window.initDraggableUI = () => {
            // 약간의 지연 후 초기화 (DOM이 준비되도록)
            setTimeout(() => {
                draggableUISystem.initialized = false; // 재초기화 허용
                draggableUISystem.elements = [];
                draggableUISystem.init();
                
                // ★ 저장된 UI 위치 로드
                uiRearrangeSystem.loadPositions();
            }, 100);
        };
        
        // ========== 통합 채팅 시스템 ==========
        const unifiedChatSystem = {
            currentTab: 'aria',
            isCollapsed: false,
            transparentTimer: null,
            
            init() {
                const panel = document.getElementById('unified-chat-panel');
                if (!panel) return;
                
                // 탭 전환 이벤트
                panel.querySelectorAll('.chat-tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        this.switchTab(tab.dataset.tab);
                        this.showPanel();
                    });
                });
                
                // 접기/펼치기 버튼
                document.getElementById('chat-toggle-btn')?.addEventListener('click', () => {
                    this.toggleCollapse();
                });
                
                // ARIA 전송
                document.getElementById('aria-send-btn')?.addEventListener('click', () => {
                    this.sendAriaMessage();
                });
                document.getElementById('aria-input')?.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.sendAriaMessage();
                });
                
                // 멀티 채팅 전송
                document.getElementById('multi-send-btn')?.addEventListener('click', () => {
                    this.sendMultiMessage();
                });
                document.getElementById('multi-input')?.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.sendMultiMessage();
                });
                
                // 입력창 포커스 시 패널 표시
                panel.querySelectorAll('input').forEach(input => {
                    input.addEventListener('focus', () => this.showPanel());
                });
                
                // 초기 투명화 타이머 시작
                this.startTransparentTimer();
            },
            
            switchTab(tabName) {
                this.currentTab = tabName;
                
                // 탭 버튼 활성화
                document.querySelectorAll('.chat-tab').forEach(tab => {
                    tab.classList.toggle('active', tab.dataset.tab === tabName);
                });
                
                // 탭 콘텐츠 표시
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                document.getElementById(tabName + '-tab')?.classList.add('active');
            },
            
            toggleCollapse() {
                const panel = document.getElementById('unified-chat-panel');
                if (!panel) return;
                
                this.isCollapsed = !this.isCollapsed;
                panel.classList.toggle('collapsed', this.isCollapsed);
                
                if (!this.isCollapsed) {
                    this.showPanel();
                }
            },
            
            showPanel() {
                const panel = document.getElementById('unified-chat-panel');
                if (!panel) return;
                
                panel.classList.remove('transparent');
                this.startTransparentTimer();
            },
            
            startTransparentTimer() {
                if (this.transparentTimer) {
                    clearTimeout(this.transparentTimer);
                }
                this.transparentTimer = setTimeout(() => {
                    const panel = document.getElementById('unified-chat-panel');
                    if (panel && !panel.querySelector('input:focus')) {
                        panel.classList.add('transparent');
                    }
                }, 2000);
            },
            
            addAriaMessage(text, isUser = false) {
                const container = document.getElementById('aria-messages');
                if (!container) return;
                
                const msg = document.createElement('div');
                msg.className = 'aria-msg';
                if (isUser) {
                    msg.innerHTML = `<span class="aria-label" style="color:#0ff;">나: </span><span class="aria-text">${text}</span>`;
                } else {
                    msg.innerHTML = `<span class="aria-label">ARIA: </span><span class="aria-text">${text}</span>`;
                }
                container.appendChild(msg);
                container.scrollTop = container.scrollHeight;
                
                this.showPanel();
            },
            
            sendAriaMessage() {
                const input = document.getElementById('aria-input');
                const text = input?.value.trim();
                if (!text) return;
                
                this.addAriaMessage(text, true);
                input.value = '';
                
                // 기존 ARIA 시스템 호출
                if (typeof aiSendQuestionWithText === 'function') {
                    aiSendQuestionWithText(text);
                } else if (typeof aiSendQuestion === 'function') {
                    // 기존 방식 호출
                    const oldInput = document.getElementById('ai-input');
                    if (oldInput) {
                        oldInput.value = text;
                        aiSendQuestion();
                    }
                }
            },
            
            addMultiMessage(nick, text, time, isSystem = false) {
                const container = document.getElementById('multi-messages');
                if (!container) return;
                
                // 첫 메시지면 "Not connected" 제거
                const systemMsg = container.querySelector('.mp-msg.system');
                if (systemMsg && systemMsg.textContent.includes('Not connected')) {
                    systemMsg.remove();
                }
                
                const msg = document.createElement('div');
                msg.className = isSystem ? 'mp-msg system' : 'mp-msg';
                if (isSystem) {
                    msg.textContent = text;
                } else {
                    msg.innerHTML = `<span class="time">${time}</span><span class="nick">${nick}:</span><span class="text">${text}</span>`;
                }
                container.appendChild(msg);
                container.scrollTop = container.scrollHeight;
                
                // 최대 50개 메시지 유지
                while (container.children.length > 50) {
                    container.removeChild(container.firstChild);
                }
                
                this.showPanel();
            },
            
            sendMultiMessage() {
                const input = document.getElementById('multi-input');
                const text = input?.value.trim();
                if (!text) return;
                
                input.value = '';
                
                // 기존 멀티플레이어 채팅 전송
                if (typeof sendMultiChat === 'function') {
                    sendMultiChat(text);
                } else if (typeof window.supabaseClient !== 'undefined' && window.mpChannel) {
                    // 직접 Supabase 채널로 전송
                    window.mpChannel.send({
                        type: 'broadcast',
                        event: 'chat',
                        payload: {
                            userId: window.mpUserId || 'guest',
                            nick: window.mpNickname || '익명',
                            text: text,
                            time: new Date().toLocaleTimeString('ko-KR', {hour:'2-digit', minute:'2-digit'})
                        }
                    });
                }
            },
            
            setConnected(connected) {
                const container = document.getElementById('multi-messages');
                if (!container) return;
                
                if (connected) {
                    const systemMsg = container.querySelector('.mp-msg.system');
                    if (systemMsg && systemMsg.textContent.includes('Not connected')) {
                        systemMsg.textContent = t('chatConnected');
                    }
                }
            }
        };
        
        window.unifiedChatSystem = unifiedChatSystem;
        
        // ARIA 메시지 표시 함수 오버라이드
        window.aiShowMessage = function(text) {
            unifiedChatSystem.addAriaMessage(text, false);
        };
        
        // ARIA 질문 전송 (텍스트 직접 전달)
        window.aiSendQuestionWithText = function(text) {
            if (!text) return;
            
            // 로딩 표시
            unifiedChatSystem.addAriaMessage('Thinking...', false);
            
            // Gemini API 호출
            if (typeof callGeminiAPI === 'function') {
                callGeminiAPI(text)
                    .then(function(response) {
                        // 마지막 "Thinking..." 메시지 제거
                        var container = document.getElementById('aria-messages');
                        var lastMsg = container ? container.lastElementChild : null;
                        if (lastMsg && lastMsg.textContent.indexOf('Thinking...') >= 0) {
                            lastMsg.remove();
                        }
                        if (response) {
                            unifiedChatSystem.addAriaMessage(response, false);
                        } else {
                            showLocalAnswer(text);
                        }
                    })
                    .catch(function(e) {
                        console.warn('Gemini API 오류:', e);
                        showLocalAnswer(text);
                    });
            } else {
                showLocalAnswer(text);
            }
            
            function showLocalAnswer(text) {
                // 로컬 답변 폴백
                var localAnswers = {
                    '조작': '조종: WASD 또는 화살표키\n가속/감속: 화면 왼쪽 조이스틱\n시점 변경: 화면 오른쪽 드래그',
                    '연료': '연료는 정거장에 도킹하면 보충 가능합니다. 코인 1개당 연료 1이 충전됩니다.',
                    '자동항법': '목표를 선택하고 🤖자동 버튼을 누르면 자동으로 비행합니다.',
                    '도킹': '정거장 근처에서 🔗도킹 버튼이 나타나면 눌러주세요.'
                };
                
                var answer = '죄송합니다, 이해하지 못했습니다. 다시 질문해 주세요.';
                for (var key in localAnswers) {
                    if (text.indexOf(key) >= 0) {
                        answer = localAnswers[key];
                        break;
                    }
                }
                
                // 마지막 "Thinking..." 메시지 제거
                var container = document.getElementById('aria-messages');
                var lastMsg = container ? container.lastElementChild : null;
                if (lastMsg && lastMsg.textContent.indexOf('Thinking...') >= 0) {
                    lastMsg.remove();
                }
                unifiedChatSystem.addAriaMessage(answer, false);
            }
        };
        
        // 멀티플레이어 채팅 수신 처리 연결
        window.onMultiChatReceived = function(nick, text, time) {
            unifiedChatSystem.addMultiMessage(nick, text, time);
        };
        
        // 초기화
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(function() { unifiedChatSystem.init(); }, 500);
        });
        
        // ========== 조종실 라디오 시스템 ==========
        const cockpitRadio = {
            audio: null,
            isPlaying: false,
            currentStation: null,
            volume: 0.3,
            
            init() {
                this.audio = new Audio();
                // crossOrigin 제거 - CORS 문제 방지
                this.audio.volume = this.volume;
                
                // 토글 버튼
                const toggleBtn = document.getElementById('radio-toggle-btn');
                const radioPanel = document.getElementById('cockpit-radio');
                
                if (toggleBtn) {
                    toggleBtn.addEventListener('click', (e) => {
                        e.stopPropagation();  // 이벤트 전파 방지
                        if (radioPanel.classList.contains('collapsed')) {
                            radioPanel.classList.remove('collapsed');
                            toggleBtn.textContent = t('radio');
                        } else {
                            if (this.isPlaying) {
                                // 재생 중이면 멈춤
                                this.stop();
                            } else {
                                radioPanel.classList.add('collapsed');
                                toggleBtn.textContent = t('radioShort');
                            }
                        }
                    });
                }
                
                // 닫기 버튼 이벤트
                const closeBtn = document.getElementById('radio-close-btn');
                if (closeBtn) {
                    closeBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        radioPanel.classList.add('collapsed');
                        toggleBtn.textContent = this.isPlaying ? t('stop') : t('radioShort');
                    });
                }
                
                // 빈 곳 클릭 시 닫기
                document.addEventListener('click', (e) => {
                    if (!radioPanel.classList.contains('collapsed') && 
                        !radioPanel.contains(e.target)) {
                        radioPanel.classList.add('collapsed');
                        if (toggleBtn) {
                            toggleBtn.textContent = this.isPlaying ? t('stop') : t('radioShort');
                        }
                    }
                });
                
                // 라디오 패널 내부 클릭은 전파 방지
                radioPanel.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
                
                // 채널 선택
                document.querySelectorAll('.radio-station').forEach(station => {
                    station.addEventListener('click', () => {
                        const url = station.dataset.url;
                        const name = station.dataset.name;
                        this.play(url, name, station);
                    });
                });
                
                // 볼륨 조절
                const volSlider = document.getElementById('radio-volume');
                if (volSlider) {
                    volSlider.addEventListener('input', (e) => {
                        this.volume = e.target.value / 100;
                        this.audio.volume = this.volume;
                        document.getElementById('radio-vol-val').textContent = e.target.value + '%';
                    });
                }
                
                // 오류 처리 - 실제 네트워크 오류만 표시
                this.audio.addEventListener('error', (e) => {
                    // 빈 src 설정 시 발생하는 오류는 무시
                    if (!this.audio.src || this.audio.src === '' || this.audio.src === window.location.href) {
                        return;
                    }
                    console.error('라디오 스트림 오류:', e);
                    document.getElementById('radio-now-playing').textContent = t('radioConnectionFailed');
                    this.isPlaying = false;
                    this.updateUI();
                });
                
                // 재생 시작
                this.audio.addEventListener('playing', () => {
                    document.getElementById('radio-now-playing').textContent = '🎵 ' + (this.currentStation || t('playing'));
                });
                
                console.log('조종실 라디오 시스템 초기화 완료');
            },
            
            play(url, name, stationEl) {
                // 같은 채널이면 정지
                if (this.currentStation === name && this.isPlaying) {
                    this.stop();
                    return;
                }
                
                // 기존 재생 중지
                this.audio.pause();
                this.audio.src = '';  // 먼저 비우기
                
                // 잠시 대기 후 새 채널 재생
                this.currentStation = name;
                document.getElementById('radio-now-playing').textContent = t('radioConnecting');
                
                setTimeout(() => {
                    // 새 채널 재생
                    this.audio.src = url;
                    this.audio.load();
                    
                    this.audio.play().then(() => {
                        this.isPlaying = true;
                        this.updateUI();
                        
                        // 활성 채널 표시
                        document.querySelectorAll('.radio-station').forEach(s => s.classList.remove('active'));
                        if (stationEl) stationEl.classList.add('active');
                        
                        if (typeof showMessage === 'function') showMessage('📻 ' + name + ' 재생 중');
                    }).catch(err => {
                        console.error('라디오 재생 실패:', err);
                        document.getElementById('radio-now-playing').textContent = t('radioPlaybackFailed');
                        this.isPlaying = false;
                        this.updateUI();
                    });
                }, 100);
            },
            
            stop() {
                this.audio.pause();
                this.isPlaying = false;
                this.currentStation = null;
                
                // src 비우기 전에 상태 먼저 업데이트
                document.querySelectorAll('.radio-station').forEach(s => s.classList.remove('active'));
                document.getElementById('radio-now-playing').textContent = t('selectChannel');
                this.updateUI();
                
                // 나중에 src 비우기
                setTimeout(() => {
                    this.audio.src = '';
                }, 50);
                
                if (typeof showMessage === 'function') showMessage('📻 라디오 정지');
            },
            
            updateUI() {
                const toggleBtn = document.getElementById('radio-toggle-btn');
                if (toggleBtn) {
                    if (this.isPlaying) {
                        toggleBtn.classList.add('playing');
                        toggleBtn.textContent = t('stop');
                    } else {
                        toggleBtn.classList.remove('playing');
                        const radioPanel = document.getElementById('cockpit-radio');
                        toggleBtn.textContent = radioPanel.classList.contains('collapsed') ? t('radioShort') : t('radio');
                    }
                }
            }
        };
        
        // 전역으로 노출
        window.cockpitRadio = cockpitRadio;
        
        // 페이지 로드 시 라디오 초기화
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(() => cockpitRadio.init(), 1000);
        });
        
        // ========== 모바일 탭 바 시스템 ==========
        const mobileTabSystem = {
            currentTab: 'control',
            panelOpen: true,
            
            init() {
                // 탭 버튼 이벤트
                document.querySelectorAll('.mobile-tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        const tabName = tab.dataset.tab;
                        this.switchTab(tabName);
                    });
                });
                
                // 조종 버튼들 (속도 조절은 3인칭에서도 허용)
                document.getElementById('mobile-accel')?.addEventListener('touchstart', () => {
                    if (window.shipInputs) window.shipInputs.throttle = 1;
                });
                document.getElementById('mobile-accel')?.addEventListener('touchend', () => {
                    if (window.shipInputs) window.shipInputs.throttle = 0;
                });
                document.getElementById('mobile-decel')?.addEventListener('touchstart', () => {
                    if (window.shipInputs) window.shipInputs.throttle = -1;
                });
                document.getElementById('mobile-decel')?.addEventListener('touchend', () => {
                    if (window.shipInputs) window.shipInputs.throttle = 0;
                });
                
                // 기능 버튼들
                document.getElementById('mobile-autopilot')?.addEventListener('click', () => {
                    if (typeof toggleAutopilot === 'function') toggleAutopilot();
                });
                document.getElementById('mobile-telescope')?.addEventListener('click', () => {
                    if (typeof enterTelescopeMode === 'function') enterTelescopeMode();
                });
                document.getElementById('mobile-space-mode')?.addEventListener('click', () => {
                    if (typeof toggleSpaceView === 'function') toggleSpaceView();
                });
                
                // 모바일 라디오
                document.querySelectorAll('.mobile-radio-station').forEach(station => {
                    station.addEventListener('click', () => {
                        const url = station.dataset.url;
                        const name = station.dataset.name;
                        
                        // 기존 라디오 시스템 사용
                        if (window.cockpitRadio) {
                            window.cockpitRadio.play(url, name, station);
                        }
                        
                        // 모바일 UI 업데이트
                        document.querySelectorAll('.mobile-radio-station').forEach(s => s.classList.remove('active'));
                        station.classList.add('active');
                    });
                });
                
                // 모바일 라디오 볼륨
                document.getElementById('mobile-radio-vol')?.addEventListener('input', (e) => {
                    const vol = e.target.value / 100;
                    document.getElementById('mobile-radio-vol-val').textContent = e.target.value + '%';
                    if (window.cockpitRadio) {
                        window.cockpitRadio.volume = vol;
                        window.cockpitRadio.audio.volume = vol;
                    }
                });
                
                // 모바일 채팅
                document.getElementById('mobile-chat-send')?.addEventListener('click', () => {
                    this.sendMobileChat();
                });
                document.getElementById('mobile-chat-input')?.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.sendMobileChat();
                });
                
                // 모바일 ARIA
                document.getElementById('mobile-aria-send')?.addEventListener('click', () => {
                    this.sendMobileAria();
                });
                document.getElementById('mobile-aria-input')?.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.sendMobileAria();
                });
                
                // 업데이트 시작
                setInterval(() => this.updateMobileUI(), 100);
                
                console.log('모바일 탭 시스템 초기화 완료');
            },
            
            switchTab(tabName) {
                // 같은 탭 누르면 패널 토글
                if (this.currentTab === tabName) {
                    this.panelOpen = !this.panelOpen;
                    document.getElementById('mobile-tab-panel')?.classList.toggle('open', this.panelOpen);
                    return;
                }
                
                this.currentTab = tabName;
                this.panelOpen = true;
                
                // 탭 버튼 활성화
                document.querySelectorAll('.mobile-tab').forEach(t => {
                    t.classList.toggle('active', t.dataset.tab === tabName);
                });
                
                // 패널 표시
                document.querySelectorAll('.mobile-panel-content').forEach(p => {
                    p.classList.remove('active');
                });
                document.getElementById('mobile-tab-panel')?.classList.add('open');
                
                const panelMap = {
                    'control': 'mobile-control-panel',
                    'status': 'mobile-status-panel',
                    'radio': 'mobile-radio-panel',
                    'chat': 'mobile-chat-panel',
                    'aria': 'mobile-aria-panel'
                };
                
                document.getElementById(panelMap[tabName])?.classList.add('active');
            },
            
            updateMobileUI() {
                const ship = window.playerShip;
                if (!ship) return;
                
                const speed = Math.abs(ship.speed || 0);
                const fuel = ship.fuel || 100;
                const throttle = (ship.throttlePercent || 0);
                const maxFuel = SHIP_CONFIG.maxFuel;
                const fuelPercent = (fuel / maxFuel) * 100;
                
                // 미니 HUD
                const miniSpeed = document.getElementById('mini-speed');
                const miniFuel = document.getElementById('mini-fuel');
                const miniFuelBar = document.getElementById('mini-fuel-bar');
                const miniTarget = document.getElementById('mini-target');
                
                if (miniSpeed) miniSpeed.textContent = speed.toFixed(1);
                if (miniFuel) miniFuel.textContent = Math.round(fuel) + '/' + maxFuel;
                if (miniFuelBar) miniFuelBar.style.width = fuelPercent + '%';
                if (miniTarget) {
                    const targetName = window.autopilotTarget?.name || t('none');
                    miniTarget.textContent = targetName.substring(0, 6);
                }
                
                // 조종 패널
                const thrFill = document.getElementById('mobile-thr-fill');
                const thrValue = document.getElementById('mobile-thr-value');
                const fuelFill = document.getElementById('mobile-fuel-fill');
                const fuelValue = document.getElementById('mobile-fuel-value');
                const speedVal = document.getElementById('mobile-speed-val');
                const speedKmh = document.getElementById('mobile-speed-kmh');
                
                if (thrFill) thrFill.style.height = Math.abs(throttle) + '%';
                if (thrValue) thrValue.textContent = (throttle >= 0 ? '+' : '') + throttle.toFixed(0) + '%';
                if (fuelFill) fuelFill.style.height = fuelPercent + '%';
                if (fuelValue) fuelValue.textContent = Math.round(fuel) + '/' + maxFuel;
                if (speedVal) speedVal.textContent = speed.toFixed(1);
                if (speedKmh) speedKmh.textContent = '(' + (speed * 3600).toFixed(0) + ' km/h)';
                
                // ★ 모바일 내구도 게이지 업데이트
                const hullFill = document.getElementById('mobile-hull-fill');
                const hullValue = document.getElementById('mobile-hull-value');
                const maxHull = SHIP_CONFIG.maxHull || 100;
                const currentHull = playerShip ? playerShip.hull : maxHull;
                const hullPercent = (currentHull / maxHull) * 100;
                if (hullFill) hullFill.style.height = hullPercent + '%';
                if (hullValue) hullValue.textContent = Math.round(currentHull);
                const autopilotBtn = document.getElementById('mobile-autopilot');
                if (autopilotBtn && window.autopilotEngaged !== undefined) {
                    autopilotBtn.classList.toggle('engaged', window.autopilotEngaged);
                    autopilotBtn.textContent = window.autopilotEngaged ? '🤖 자동 ON' : '🤖 자동';
                }
                
                // 상태 패널
                document.getElementById('mobile-stat-speed')?.textContent && 
                    (document.getElementById('mobile-stat-speed').textContent = speed.toFixed(2) + ' km/s');
                document.getElementById('mobile-stat-fuel')?.textContent && 
                    (document.getElementById('mobile-stat-fuel').textContent = Math.round(fuel) + '/' + maxFuel);
                document.getElementById('mobile-stat-target')?.textContent && 
                    (document.getElementById('mobile-stat-target').textContent = window.autopilotTarget?.name || t('none'));
                document.getElementById('mobile-stat-autopilot')?.textContent && 
                    (document.getElementById('mobile-stat-autopilot').textContent = window.autopilotEngaged ? 'ON' : 'OFF');
            },
            
            sendMobileChat() {
                const input = document.getElementById('mobile-chat-input');
                if (!input || !input.value.trim()) return;
                
                const msg = input.value.trim();
                input.value = '';
                
                // 기존 채팅 시스템 사용
                if (typeof sendChat === 'function') {
                    // 임시로 mp-chat-input에 값 넣고 전송
                    const mpInput = document.getElementById('mp-chat-input');
                    if (mpInput) {
                        mpInput.value = msg;
                        sendChat();
                    }
                }
                
                // 모바일 채팅에도 표시
                this.addMobileChatMessage('나', msg);
            },
            
            addMobileChatMessage(nick, msg) {
                const container = document.getElementById('mobile-chat-messages');
                if (!container) return;
                
                const msgEl = document.createElement('div');
                msgEl.innerHTML = `<span style="color:#ff0;">${nick}:</span> ${msg}`;
                msgEl.style.marginBottom = '5px';
                container.appendChild(msgEl);
                container.scrollTop = container.scrollHeight;
            },
            
            sendMobileAria() {
                const input = document.getElementById('mobile-aria-input');
                if (!input || !input.value.trim()) return;
                
                const question = input.value.trim();
                input.value = '';
                
                // ARIA 메시지 영역에 질문 표시
                const msgArea = document.getElementById('mobile-aria-messages');
                if (msgArea) {
                    msgArea.innerHTML = `<div style="color:#888;margin-bottom:10px;">👤 ${question}</div><div style="color:#0ff;">🤖 Thinking...</div>`;
                }
                
                // 기존 ARIA 시스템 사용
                if (typeof aiSendQuestion === 'function') {
                    const aiInput = document.getElementById('ai-input');
                    if (aiInput) {
                        aiInput.value = question;
                        aiSendQuestion();
                        
                        // 응답 대기 후 표시
                        setTimeout(() => {
                            const aiMsgBox = document.getElementById('ai-message-box');
                            if (aiMsgBox && msgArea) {
                                msgArea.innerHTML = `<div style="color:#888;margin-bottom:10px;">👤 ${question}</div><div>🤖 ${aiMsgBox.textContent}</div>`;
                            }
                        }, 2000);
                    }
                }
            }
        };
        
        // 전역 노출
        window.mobileTabSystem = mobileTabSystem;
        
        // 조종 모드 진입 시 초기화
        const originalEnterPilotMode = window.enterPilotMode;
        window.enterPilotMode = function() {
            if (originalEnterPilotMode) originalEnterPilotMode.apply(this, arguments);
            
            // ★ 멀티모드 튜토리얼 가이드
            if (typeof MultiTutorial !== 'undefined') {
                setTimeout(() => MultiTutorial.showFeatureGuide('pilot-mode'), 500);
            }
            
            // 모바일에서 미니 HUD 표시
            if (window.innerWidth <= 768) {
                document.getElementById('mobile-mini-hud').style.display = 'flex';
            }
        };
        
        // DOM 로드 후 초기화
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(() => mobileTabSystem.init(), 1500);
        });
        
        // 버튼 이벤트 연결
        document.getElementById('btn-single').addEventListener('click', () => startGameMode('single'));
        document.getElementById('btn-multi').addEventListener('click', () => startGameMode('multi'));
        
        // ★★★ VOYAGER 메뉴 이벤트 ★★★
        // 로그인 버튼 (메인 메뉴)
        document.getElementById('btn-login-main').addEventListener('click', () => {
            // 로그인 UI 열기
            if (typeof createAuthUI === 'function') {
                createAuthUI();
            }
        });
        
        // 설정 버튼
        document.getElementById('btn-settings').addEventListener('click', () => {
            document.getElementById('settings-modal').classList.add('active');
        });
        
        // ★★★ 고정 헤더 버튼 이벤트 ★★★
        document.getElementById('global-settings-btn').addEventListener('click', () => {
            document.getElementById('settings-modal').classList.add('active');
        });
        
        document.getElementById('global-profile-btn').addEventListener('click', () => {
            // 로그인 상태 확인
            if (window.mpUser || window.currentUser) {
                // 로그인 됨 - 프로필 표시 (또는 로그아웃)
                const userName = window.mpUser?.user_metadata?.username || 
                                window.currentUser?.name || 
                                window.currentUser?.email || 'User';
                if (confirm(`${userName}\n\nLogout?`)) {
                    if (typeof logoutUser === 'function') logoutUser();
                    showMsg('Logged out');
                }
            } else {
                // 로그인 안됨 - 로그인 모달 열기
                const authOverlay = document.getElementById('auth-overlay');
                if (authOverlay) {
                    authOverlay.style.display = 'flex';
                } else {
                    document.getElementById('login-modal').classList.add('open');
                }
            }
        });
        
        // 설정 닫기
        document.getElementById('settings-close').addEventListener('click', () => {
            document.getElementById('settings-modal').classList.remove('active');
        });
        
        // ★★★ 설정 모달 언어 변경 이벤트 ★★★
        document.getElementById('settings-language').addEventListener('change', (e) => {
            const newLang = e.target.value;
            setLanguage(newLang);
            // 상단바 언어 선택도 동기화
            const topLangSelect = document.getElementById('lang-select');
            if (topLangSelect) topLangSelect.value = newLang;
        });
        
        // 미션 보드 닫기
        document.getElementById('mission-board-close').addEventListener('click', () => {
            document.getElementById('mission-board-modal').classList.remove('active');
        });
        
        // 설정 슬라이더 이벤트
        document.getElementById('settings-volume').addEventListener('input', (e) => {
            document.getElementById('settings-volume-val').textContent = e.target.value + '%';
            if (typeof SpaceAudio !== 'undefined') {
                SpaceAudio.setVolume(e.target.value / 100);
            }
        });
        
        // 미션 탭 전환
        document.querySelectorAll('.mission-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.mission-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                // 미션 시스템 렌더링
                if (typeof MissionSystem !== 'undefined') {
                    MissionSystem.render(tab.dataset.tab);
                }
            });
        });
        
        // 모달 배경 클릭 시 닫기
        document.querySelectorAll('.voyager-modal').forEach(modal => {
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.classList.remove('active');
                }
            });
        });
        
        // ★★★ 프로필 패널 이벤트 ★★★
        setTimeout(() => {
            // ★★★ 프로필 패널 이벤트 ★★★
            const profilePanel = document.getElementById('user-profile-panel');
            const profileMenuBtn = document.getElementById('profile-menu-btn');
            const profileDropdown = document.getElementById('profile-dropdown');
            
            if (profilePanel && profileDropdown) {
                // 드롭다운 토글
                profileMenuBtn?.addEventListener('click', (e) => {
                    e.stopPropagation();
                    profileDropdown.style.display = profileDropdown.style.display === 'none' ? 'block' : 'none';
                });
                
                profilePanel.addEventListener('click', (e) => {
                    if (e.target === profileMenuBtn) return;
                    profileDropdown.style.display = profileDropdown.style.display === 'none' ? 'block' : 'none';
                });
                
                // 드롭다운 항목 클릭
                document.getElementById('dropdown-profile')?.addEventListener('click', () => {
                    profileDropdown.style.display = 'none';
                    showMsg('👤 프로필 기능은 준비 중입니다');
                });
                
                // 미션 보드
                document.getElementById('dropdown-missions')?.addEventListener('click', () => {
                    profileDropdown.style.display = 'none';
                    if (typeof MissionSystem !== 'undefined') {
                        MissionSystem.init();
                    }
                    document.getElementById('mission-board-modal').classList.add('active');
                });
                
                document.getElementById('dropdown-settings')?.addEventListener('click', () => {
                    profileDropdown.style.display = 'none';
                    document.getElementById('settings-modal').classList.add('active');
                });
                
                document.getElementById('dropdown-logout')?.addEventListener('click', () => {
                    profileDropdown.style.display = 'none';
                    confirmLogout();
                });
                
                // 바깥 클릭 시 닫기
                document.addEventListener('click', (e) => {
                    if (!profilePanel.contains(e.target) && !profileDropdown.contains(e.target)) {
                        profileDropdown.style.display = 'none';
                    }
                });
            }
        }, 1000);
        
        // 미션 시스템 초기화
        setTimeout(() => {
            if (typeof MissionSystem !== 'undefined') {
                MissionSystem.init();
            }
        }, 2000);

        init();
    </script>

<script>
// ============================================================
// Solar Explorer 멀티플레이어 코드
// ============================================================

// ============ 우주 사운드 시스템 (자동 전환) ============
const SpaceAudio = {
    ctx: null,
    masterGain: null,
    isInitialized: false,
    isPlaying: false,
    currentMode: null,
    volume: 0.4,
    nodes: [],
    timers: [],
    
    // ★★★ 외부 BGM 설정 ★★★
    bgmConfig: null,
    bgmAudio: null,  // HTML Audio 요소
    bgmLoaded: false,
    
    init() {
        if (this.isInitialized) return;
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = this.volume;
        this.masterGain.connect(this.ctx.destination);
        this.isInitialized = true;
        
        // ★ BGM 설정 로드
        this.loadBgmConfig();
    },
    
    // ★★★ BGM 설정 파일 로드 ★★★
    async loadBgmConfig() {
        try {
            const res = await fetch('bgm_config.json');
            if (res.ok) {
                this.bgmConfig = await res.json();
                this.bgmLoaded = true;
                console.log('🎵 BGM 설정 로드됨:', this.bgmConfig);
            }
        } catch(e) {
            console.log('🎵 bgm_config.json 없음 - 기본 사운드 사용');
        }
    },
    
    // ★★★ 외부 BGM 재생 ★★★
    playBgm(category) {
        if (!this.bgmConfig || !this.bgmConfig.tracks) return false;
        
        // 해당 카테고리의 기본 BGM 찾기
        const defaultId = this.bgmConfig.defaults?.[category];
        let track = null;
        
        if (defaultId) {
            track = this.bgmConfig.tracks.find(t => t.id === defaultId);
        }
        
        // 기본 설정 없으면 해당 카테고리의 첫번째 트랙
        if (!track) {
            track = this.bgmConfig.tracks.find(t => t.category === category);
        }
        
        if (!track) return false;
        
        // 기존 BGM 정지
        this.stopBgm();
        
        // 새 BGM 재생
        console.log('🎵 BGM 재생:', track.name, track.url);
        this.bgmAudio = new Audio(track.url);
        this.bgmAudio.volume = (track.volume || 80) / 100 * this.volume;
        this.bgmAudio.loop = track.loop !== false;  // 기본값 true
        this.bgmAudio.play().catch(e => console.log('BGM 자동재생 차단됨'));
        
        return true;
    },
    
    // ★★★ 외부 BGM 정지 ★★★
    stopBgm() {
        if (this.bgmAudio) {
            this.bgmAudio.pause();
            this.bgmAudio.currentTime = 0;
            this.bgmAudio = null;
        }
    },
    
    stop() {
        this.stopBgm();  // ★ 외부 BGM도 정지
        this.timers.forEach(t => clearInterval(t));
        this.timers = [];
        this.nodes.forEach(n => { try { n.stop(); n.disconnect(); } catch(e) {} });
        this.nodes = [];
        this.isPlaying = false;
        this.currentMode = null;
    },
    
    // ===== 우주 공간 BGM =====
    playSpace() {
        if (this.currentMode === 'space') return;
        this.stop();
        this.init();
        this.currentMode = 'space';
        this.isPlaying = true;
        
        // ★ 외부 BGM 있으면 우선 재생
        if (this.playBgm('explore')) {
            return;  // 외부 BGM 재생 성공
        }
        
        // 외부 BGM 없으면 기본 사운드
        const ctx = this.ctx;
        
        // 1. 딥 드론 (40Hz)
        const drone = ctx.createOscillator();
        const droneGain = ctx.createGain();
        drone.type = 'sine';
        drone.frequency.value = 40;
        droneGain.gain.value = 0.25;
        drone.connect(droneGain);
        droneGain.connect(this.masterGain);
        drone.start();
        this.nodes.push(drone);
        
        // 2. 5도 위 드론 (60Hz)
        const drone2 = ctx.createOscillator();
        const drone2Gain = ctx.createGain();
        drone2.type = 'sine';
        drone2.frequency.value = 60;
        drone2Gain.gain.value = 0.12;
        drone2.connect(drone2Gain);
        drone2Gain.connect(this.masterGain);
        drone2.start();
        this.nodes.push(drone2);
        
        // 3. 우주 바람 노이즈
        const noiseLen = ctx.sampleRate * 3;
        const noiseBuf = ctx.createBuffer(1, noiseLen, ctx.sampleRate);
        const noiseData = noiseBuf.getChannelData(0);
        for (let i = 0; i < noiseLen; i++) noiseData[i] = Math.random() * 2 - 1;
        const noise = ctx.createBufferSource();
        noise.buffer = noiseBuf;
        noise.loop = true;
        const noiseFilt = ctx.createBiquadFilter();
        noiseFilt.type = 'lowpass';
        noiseFilt.frequency.value = 150;
        const noiseGain = ctx.createGain();
        noiseGain.gain.value = 0.06;
        noise.connect(noiseFilt);
        noiseFilt.connect(noiseGain);
        noiseGain.connect(this.masterGain);
        noise.start();
        this.nodes.push(noise);
        
        // 4. 신비로운 패드 (가끔)
        const padTimer = setInterval(() => {
            if (this.currentMode !== 'space') return;
            const pad = ctx.createOscillator();
            const padGain = ctx.createGain();
            pad.type = 'sine';
            pad.frequency.value = [220, 330, 440, 550][Math.floor(Math.random() * 4)];
            padGain.gain.setValueAtTime(0, ctx.currentTime);
            padGain.gain.linearRampToValueAtTime(0.04, ctx.currentTime + 2);
            padGain.gain.linearRampToValueAtTime(0, ctx.currentTime + 5);
            pad.connect(padGain);
            padGain.connect(this.masterGain);
            pad.start();
            pad.stop(ctx.currentTime + 5);
        }, 7000);
        this.timers.push(padTimer);
    },
    
    // ===== 정거장 BGM (우주 배경 + 보이저 스타일 신호음) =====
    playStation() {
        if (this.currentMode === 'station') return;
        this.stop();
        this.init();
        this.currentMode = 'station';
        this.isPlaying = true;
        
        // ★ 외부 BGM 있으면 우선 재생
        if (this.playBgm('station')) {
            return;  // 외부 BGM 재생 성공
        }
        
        const ctx = this.ctx;
        
        // 우주 배경음 (동일)
        const drone = ctx.createOscillator();
        const droneGain = ctx.createGain();
        drone.type = 'sine';
        drone.frequency.value = 40;
        droneGain.gain.value = 0.2;
        drone.connect(droneGain);
        droneGain.connect(this.masterGain);
        drone.start();
        this.nodes.push(drone);
        
        const drone2 = ctx.createOscillator();
        const drone2Gain = ctx.createGain();
        drone2.type = 'sine';
        drone2.frequency.value = 60;
        drone2Gain.gain.value = 0.1;
        drone2.connect(drone2Gain);
        drone2Gain.connect(this.masterGain);
        drone2.start();
        this.nodes.push(drone2);
        
        // 우주 바람
        const noiseLen = ctx.sampleRate * 3;
        const noiseBuf = ctx.createBuffer(1, noiseLen, ctx.sampleRate);
        const noiseData = noiseBuf.getChannelData(0);
        for (let i = 0; i < noiseLen; i++) noiseData[i] = Math.random() * 2 - 1;
        const noise = ctx.createBufferSource();
        noise.buffer = noiseBuf;
        noise.loop = true;
        const noiseFilt = ctx.createBiquadFilter();
        noiseFilt.type = 'lowpass';
        noiseFilt.frequency.value = 150;
        const noiseGain = ctx.createGain();
        noiseGain.gain.value = 0.05;
        noise.connect(noiseFilt);
        noiseFilt.connect(noiseGain);
        noiseGain.connect(this.masterGain);
        noise.start();
        this.nodes.push(noise);
        
        // 보이저 스타일 신호음 (3.7초마다 연속 펄스)
        const voyagerTimer = setInterval(() => {
            if (this.currentMode !== 'station') return;
            
            // 8개의 연속 펄스 (데이터 버스트)
            for (let i = 0; i < 8; i++) {
                const delay = i * 0.12;
                const pulse = ctx.createOscillator();
                const pulseGain = ctx.createGain();
                
                pulse.type = 'sine';
                pulse.frequency.value = 1500;  // 보이저 주파수 대역
                
                // 살짝 떨리는 효과
                const vibrato = ctx.createOscillator();
                vibrato.type = 'sine';
                vibrato.frequency.value = 30;
                const vibGain = ctx.createGain();
                vibGain.gain.value = 20;
                vibrato.connect(vibGain);
                vibGain.connect(pulse.frequency);
                vibrato.start(ctx.currentTime + delay);
                vibrato.stop(ctx.currentTime + delay + 0.08);
                
                pulseGain.gain.setValueAtTime(0, ctx.currentTime + delay);
                pulseGain.gain.linearRampToValueAtTime(0.12, ctx.currentTime + delay + 0.01);
                pulseGain.gain.setValueAtTime(0.12, ctx.currentTime + delay + 0.05);
                pulseGain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + delay + 0.08);
                
                pulse.connect(pulseGain);
                pulseGain.connect(this.masterGain);
                pulse.start(ctx.currentTime + delay);
                pulse.stop(ctx.currentTime + delay + 0.1);
            }
        }, 3700);
        this.timers.push(voyagerTimer);
        
        // 긴 캐리어 톤 (10초마다)
        const carrierTimer = setInterval(() => {
            if (this.currentMode !== 'station') return;
            
            const carrier = ctx.createOscillator();
            const carrierGain = ctx.createGain();
            carrier.type = 'sine';
            carrier.frequency.value = 2295;  // 보이저 실제 캐리어 주파수 대역
            
            carrierGain.gain.setValueAtTime(0, ctx.currentTime);
            carrierGain.gain.linearRampToValueAtTime(0.06, ctx.currentTime + 0.1);
            carrierGain.gain.setValueAtTime(0.06, ctx.currentTime + 0.8);
            carrierGain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 1.0);
            
            carrier.connect(carrierGain);
            carrierGain.connect(this.masterGain);
            carrier.start();
            carrier.stop(ctx.currentTime + 1.0);
        }, 10000);
        this.timers.push(carrierTimer);
    },
    
    // ===== 조종실 BGM (운항 중인 우주선) =====
    playCockpit() {
        if (this.currentMode === 'cockpit') return;
        this.stop();
        this.init();
        this.currentMode = 'cockpit';
        this.isPlaying = true;
        
        // ★ 외부 BGM 있으면 우선 재생 (battle 카테고리 사용)
        if (this.playBgm('battle')) {
            return;  // 외부 BGM 재생 성공
        }
        
        const ctx = this.ctx;
        
        // 1. 엔진 저음 웅웅 (35Hz 메인)
        const engine = ctx.createOscillator();
        const engineGain = ctx.createGain();
        engine.type = 'sine';
        engine.frequency.value = 35;
        engineGain.gain.value = 0.3;
        engine.connect(engineGain);
        engineGain.connect(this.masterGain);
        engine.start();
        this.nodes.push(engine);
        
        // 2. 엔진 하모닉 (70Hz)
        const engine2 = ctx.createOscillator();
        const engine2Gain = ctx.createGain();
        engine2.type = 'sine';
        engine2.frequency.value = 70;
        engine2Gain.gain.value = 0.15;
        engine2.connect(engine2Gain);
        engine2Gain.connect(this.masterGain);
        engine2.start();
        this.nodes.push(engine2);
        
        // 3. 엔진 진동 변화 (미세한 떨림)
        const vibrato = ctx.createOscillator();
        vibrato.type = 'sine';
        vibrato.frequency.value = 3;
        const vibGain = ctx.createGain();
        vibGain.gain.value = 2;
        vibrato.connect(vibGain);
        vibGain.connect(engine.frequency);
        vibrato.start();
        this.nodes.push(vibrato);
        
        // 4. 공기 순환 소리 (부드러운 쉬쉬)
        const airLen = ctx.sampleRate * 2;
        const airBuf = ctx.createBuffer(1, airLen, ctx.sampleRate);
        const airData = airBuf.getChannelData(0);
        for (let i = 0; i < airLen; i++) airData[i] = Math.random() * 2 - 1;
        const air = ctx.createBufferSource();
        air.buffer = airBuf;
        air.loop = true;
        const airFilt = ctx.createBiquadFilter();
        airFilt.type = 'bandpass';
        airFilt.frequency.value = 500;
        airFilt.Q.value = 1;
        const airGain = ctx.createGain();
        airGain.gain.value = 0.03;
        air.connect(airFilt);
        airFilt.connect(airGain);
        airGain.connect(this.masterGain);
        air.start();
        this.nodes.push(air);
        
        // 5. 가끔 계기판 삑 (랜덤)
        const beepTimer = setInterval(() => {
            if (this.currentMode !== 'cockpit') return;
            if (Math.random() > 0.5) return;
            const b = ctx.createOscillator();
            const g = ctx.createGain();
            b.type = 'sine';
            b.frequency.value = [600, 800, 1000, 1200][Math.floor(Math.random() * 4)];
            g.gain.setValueAtTime(0.06, ctx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.05);
            b.connect(g);
            g.connect(this.masterGain);
            b.start();
            b.stop(ctx.currentTime + 0.05);
        }, 1500);
        this.timers.push(beepTimer);
        
        // 6. 시스템 상태음 (5초마다)
        const sysTimer = setInterval(() => {
            if (this.currentMode !== 'cockpit') return;
            if (Math.random() > 0.4) return;
            const s = ctx.createOscillator();
            const g = ctx.createGain();
            s.type = 'triangle';
            s.frequency.setValueAtTime(500, ctx.currentTime);
            s.frequency.setValueAtTime(600, ctx.currentTime + 0.1);
            g.gain.setValueAtTime(0.05, ctx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.2);
            s.connect(g);
            g.connect(this.masterGain);
            s.start();
            s.stop(ctx.currentTime + 0.2);
        }, 5000);
        this.timers.push(sysTimer);
    },
    
    // 볼륨 설정
    setVolume(v) {
        this.volume = v;
        if (this.masterGain) this.masterGain.gain.value = v;
        // ★ 외부 BGM 볼륨도 조절
        if (this.bgmAudio) {
            this.bgmAudio.volume = v;
        }
    },
    
    // 효과음: 클릭
    playClick() {
        this.init();
        const ctx = this.ctx;
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = 'sine';
        o.frequency.setValueAtTime(700, ctx.currentTime);
        o.frequency.exponentialRampToValueAtTime(350, ctx.currentTime + 0.06);
        g.gain.setValueAtTime(0.15, ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.06);
        o.connect(g);
        g.connect(this.masterGain);
        o.start();
        o.stop(ctx.currentTime + 0.06);
    },
    
    // 효과음: 선택
    playSelect() {
        this.init();
        const ctx = this.ctx;
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = 'sine';
        o.frequency.setValueAtTime(400, ctx.currentTime);
        o.frequency.exponentialRampToValueAtTime(800, ctx.currentTime + 0.12);
        g.gain.setValueAtTime(0.12, ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.15);
        o.connect(g);
        g.connect(this.masterGain);
        o.start();
        o.stop(ctx.currentTime + 0.15);
    },
    
    // 효과음: 워프
    playWarp() {
        this.init();
        const ctx = this.ctx;
        // 차징
        const c = ctx.createOscillator();
        const cg = ctx.createGain();
        c.type = 'sawtooth';
        c.frequency.setValueAtTime(50, ctx.currentTime);
        c.frequency.exponentialRampToValueAtTime(200, ctx.currentTime + 0.4);
        cg.gain.setValueAtTime(0.2, ctx.currentTime);
        cg.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.5);
        c.connect(cg);
        cg.connect(this.masterGain);
        c.start();
        c.stop(ctx.currentTime + 0.5);
        // 스윕
        setTimeout(() => {
            const s = ctx.createOscillator();
            const sg = ctx.createGain();
            s.type = 'sine';
            s.frequency.setValueAtTime(500, ctx.currentTime);
            s.frequency.exponentialRampToValueAtTime(2500, ctx.currentTime + 0.3);
            sg.gain.setValueAtTime(0.12, ctx.currentTime);
            sg.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.35);
            s.connect(sg);
            sg.connect(this.masterGain);
            s.start();
            s.stop(ctx.currentTime + 0.35);
        }, 350);
    },
    
    // 효과음: 에러
    playError() {
        this.init();
        const ctx = this.ctx;
        [0, 0.1].forEach(d => {
            const o = ctx.createOscillator();
            const g = ctx.createGain();
            o.type = 'square';
            o.frequency.value = 180;
            g.gain.setValueAtTime(0.12, ctx.currentTime + d);
            g.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + d + 0.08);
            o.connect(g);
            g.connect(this.masterGain);
            o.start(ctx.currentTime + d);
            o.stop(ctx.currentTime + d + 0.08);
        });
    }
};

// 위치 기반 자동 사운드 전환
let lastSoundMode = null;
function updateSoundByLocation() {
    if (!SpaceAudio.isPlaying) return;
    
    let mode = 'space';
    
    // 조종실 모드 (우주선 탑승 중)
    if (typeof isPilotMode !== 'undefined' && isPilotMode) {
        mode = 'cockpit';
    }
    // 정거장 근처 (ISS 등)
    else if (typeof focusedBody !== 'undefined' && focusedBody && 
             focusedBody.name && focusedBody.name.includes('ISS')) {
        mode = 'station';
    }
    // 선내 모드
    else if (typeof isInsideShip !== 'undefined' && isInsideShip) {
        mode = 'cockpit';
    }
    
    if (mode !== lastSoundMode) {
        lastSoundMode = mode;
        switch(mode) {
            case 'space': SpaceAudio.playSpace(); break;
            case 'station': SpaceAudio.playStation(); break;
            case 'cockpit': SpaceAudio.playCockpit(); break;
        }
    }
}

// 초기화
document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => {
        // 1초마다 위치 체크하여 사운드 자동 전환
        setInterval(updateSoundByLocation, 1000);
    }, 2000);
    
    // 버튼 클릭 효과음
    document.addEventListener('click', (e) => {
        if (e.target.tagName === 'BUTTON' && e.target.id !== 'sound-btn') {
            SpaceAudio.playClick();
        }
    });
});

// ============ 멀티플레이어 설정 (Supabase) ============
const SUPABASE_URL = 'https://sfirzuqngdbpwvdoyero.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InNmaXJ6dXFuZ2RicHd2ZG95ZXJvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjU5MjU2MzYsImV4cCI6MjA4MTUwMTYzNn0.Si0i23yCuihJ4LOM-LXxZ8atl2YOytd1Cm2Ur6yj3fk';

// Supabase 클라이언트
let supabase = null;

// ★★★ 최적화된 멀티플레이어 설정 ★★★
const MP_UPDATE_INTERVAL = 100;      // 100ms (10fps) - 위치 변경 시에만 전송
const MP_SYNC_INTERVAL = 500;        // 500ms - Realtime 백업용 폴링
const MP_CHAT_INTERVAL = 1500;       // 1.5초 - 채팅 폴링
const MP_POSITION_THRESHOLD = 0.5;   // 이동 임계값 (이 이상 움직여야 전송)
const MP_ROTATION_THRESHOLD = 0.01;  // 회전 임계값
const MP_INACTIVE_TIMEOUT = 60000;   // 60초 후 비활성 판정

// 유저 정보
let mpUser = null;
let mpUserId = null;
let mpNickname = '익명';
let mpOtherPlayers = {};
let mpChatLastId = 0;
let mpIntervals = [];
let mpRealtimeChannel = null;

// ★★★ 중복 접속 감지용 세션 토큰 ★★★
let mpSessionToken = null;

function generateSessionToken() {
    return Date.now().toString(36) + Math.random().toString(36).substring(2);
}

// ★★★ 델타 압축용 마지막 전송 상태 ★★★
let mpLastSentPosition = { x: 0, y: 0, z: 0 };
let mpLastSentRotation = { x: 0, y: 0, z: 0 };
let mpLastSentTime = 0;
let mpForceUpdateCounter = 0;

// ★★★ 서버 시간 동기화 ★★★
let serverTimeOffset = 0;  // 서버시간 - 클라이언트시간 (밀리초)
let serverTimeSynced = false;

// 서버 시간 가져오기 (HTTP Date 헤더 사용)
async function syncServerTime() {
    if (!supabase) return;

    try {
        const clientTimeBefore = Date.now();

        // Supabase REST API 호출하여 Date 헤더에서 서버 시간 추출
        const response = await fetch(SUPABASE_URL + '/rest/v1/', {
            method: 'HEAD',
            headers: {
                'apikey': SUPABASE_ANON_KEY
            }
        });

        const clientTimeAfter = Date.now();
        const serverDateHeader = response.headers.get('date');

        if (serverDateHeader) {
            const serverTime = new Date(serverDateHeader).getTime();
            const roundTrip = clientTimeAfter - clientTimeBefore;
            serverTimeOffset = serverTime - clientTimeBefore - (roundTrip / 2);
            serverTimeSynced = true;
            console.log('⏱️ 서버 시간 동기화 완료:', serverTimeOffset, 'ms 오프셋');
        } else {
            // Date 헤더 없으면 오프셋 0으로 (로컬 시간 사용)
            serverTimeOffset = 0;
            serverTimeSynced = true;
            console.log('⏱️ 서버 시간 헤더 없음, 로컬 시간 사용');
        }
    } catch (e) {
        console.warn('서버 시간 동기화 실패:', e);
        serverTimeOffset = 0;
        serverTimeSynced = true;
    }
}

// 동기화된 현재 시간 반환
function getSyncedTime() {
    return Date.now() + serverTimeOffset;
}

// Supabase SDK 로드 및 초기화
function initSupabase() {
    return new Promise(function(resolve, reject) {
        console.log('🔄 Supabase 초기화 시작...');
        
        // head에서 이미 로드된 경우
        if (window.supabase && window.supabase.createClient) {
            console.log('✅ Supabase SDK 로드됨');
            supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
            window.supabaseClient = supabase;
            console.log('✅ Supabase 연결됨:', SUPABASE_URL);
            resolve(supabase);
            return;
        }
        
        // 아직 로드 안됐으면 잠시 대기 후 재시도
        console.log('⏳ Supabase SDK 로딩 대기...');
        var attempts = 0;
        var maxAttempts = 20;
        
        var checkInterval = setInterval(function() {
            attempts++;
            if (window.supabase && window.supabase.createClient) {
                clearInterval(checkInterval);
                supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                window.supabaseClient = supabase;
                console.log('✅ Supabase 연결됨 (대기 후)');
                resolve(supabase);
            } else if (attempts >= maxAttempts) {
                clearInterval(checkInterval);
                console.error('❌ Supabase SDK 로드 실패 - 타임아웃');
                reject(new Error('Supabase SDK load timeout'));
            }
        }, 200);
    });
}

// 페이지 로드 시 Supabase 초기화
document.addEventListener('DOMContentLoaded', function() {
    initSupabase().then(function() {
        loadSavedLogin();
    }).catch(function(e) {
        console.warn('Supabase 없이 진행:', e);
    });
});

// 로컬스토리지에서 로그인 정보 복원
function loadSavedLogin() {
    if (!supabase) return Promise.resolve(false);
    
    return supabase.auth.getSession().then(function(result) {
        var session = result.data.session;
        if (session && session.user) {
            // 프로필 정보 가져오기
            return supabase
                .from('profiles')
                .select('*')
                .eq('id', session.user.id)
                .single()
                .then(function(profileResult) {
                    var profile = profileResult.data;
                    if (profile) {
                        mpUser = {
                            id: session.user.id,
                            username: profile.username,
                            nickname: profile.nickname,
                            email: profile.email,
                            coins: profile.coins,
                            exp: profile.exp || 0,
                            currentShip: profile.current_ship,
                            unlockedShips: profile.unlocked_ships,
                            avatar_url: profile.avatar_url
                        };
                        mpUserId = session.user.id;
                        mpSessionToken = generateSessionToken();  // ★★★ 중복 접속 감지용 ★★★
                        mpNickname = profile.nickname;

                        // window 객체에도 설정
                        window.mpUser = mpUser;
                        window.mpUserId = mpUserId;
                        window.mpNickname = mpNickname;
                        window.currentUser = profile.username;
                        
                        // UI 업데이트
                        if (typeof updateUserUI === 'function') {
                            updateUserUI();
                        }
                        
                        // ★★★ 메인 메뉴 로그인 버튼 숨기기 ★★★
                        const loginMainBtn = document.getElementById('btn-login-main');
                        if (loginMainBtn) {
                            loginMainBtn.style.display = 'none';
                        }
                        
                        console.log('✅ 자동 로그인:', profile.nickname);
                        return true;
                    }
                    return false;
                });
        }
        return false;
    }).catch(function(e) {
        console.log('자동 로그인 실패:', e);
        return false;
    });
}

// ============ 로그인 창 열기 ============
function openAuthUI() {
    // ★ 이미 정식 로그인되어 있으면 열지 않음 (게스트는 재로그인 허용)
    const isGuest = window.mpUserId && window.mpUserId.indexOf('guest_') === 0;
    if (window.mpUser && !isGuest) {
        if (typeof showMsg === 'function') {
            showMsg('✅ Already logged in.');
        }
        return;
    }
    
    // auth-overlay가 없으면 생성
    if (!document.getElementById('auth-overlay')) {
        if (typeof createAuthUI === 'function') {
            createAuthUI();
        }
    }
    // 창 표시
    var ao = document.getElementById('auth-overlay');
    if (ao) {
        ao.style.display = 'flex';
    }
}

function closeAuthUI() {
    var ao = document.getElementById('auth-overlay');
    if (ao) {
        ao.style.display = 'none';
    }
}

// ============ 로그인/회원가입 UI ============
function createAuthUI() {
    // t() 함수가 없으면 기본 영어 반환
    const _t = (key) => {
        if (typeof t === 'function') return t(key);
        const defaults = {
            login: 'Login', register: 'Register', emailAddress: 'Email Address',
            password: 'Password', passwordConfirm: 'Confirm Password',
            nickname: 'Nickname', nicknameDesc: '(Displayed in game)',
            email: 'Email', emailRequired: '(Required)',
            emailVerifyNote: '※ Please enter a valid email. Verification email will be sent.',
            privacyPolicy: 'Privacy Policy', termsOfService: 'Terms of Service',
            agreeToTerms: ' - I agree', guestStart: 'Start as Guest (Not saved)'
        };
        return defaults[key] || key;
    };
    
    const authUI = document.createElement('div');
    authUI.id = 'auth-ui';
    authUI.innerHTML = `
        <style>
            #auth-overlay {
                position: fixed;
                top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0, 10, 30, 0.95);
                z-index: 99999;
                display: none;
                justify-content: center;
                align-items: center;
                overflow-y: auto;
                padding: 20px 0;
            }
            #auth-box {
                background: linear-gradient(180deg, #0a1628 0%, #162a4a 100%);
                border: 2px solid #0ff;
                border-radius: 20px;
                padding: 40px;
                width: 350px;
                max-width: 90vw;
                max-height: 90vh;
                overflow-y: auto;
                margin: auto;
                box-shadow: 0 0 50px rgba(0, 255, 255, 0.3);
            }
            #auth-box h2 {
                color: #0ff;
                text-align: center;
                margin-bottom: 30px;
                font-family: 'Orbitron', sans-serif;
                font-size: 24px;
            }
            #auth-box h2::before {
                content: "🚀 ";
            }
            .auth-input {
                width: 100%;
                padding: 12px 15px;
                margin-bottom: 15px;
                background: rgba(0, 50, 80, 0.6);
                border: 1px solid #0ff;
                border-radius: 8px;
                color: #fff;
                font-size: 14px;
                box-sizing: border-box;
            }
            .auth-input:focus {
                outline: none;
                box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            }
            .auth-input::placeholder {
                color: #68a;
            }
            .auth-btn {
                width: 100%;
                padding: 12px;
                margin-top: 10px;
                border: none;
                border-radius: 8px;
                font-size: 16px;
                font-weight: bold;
                cursor: pointer;
                font-family: 'Orbitron', sans-serif;
                transition: all 0.3s;
            }
            .auth-btn-primary {
                background: linear-gradient(90deg, #0ff, #00f);
                color: #000;
            }
            .auth-btn-primary:hover {
                transform: scale(1.02);
                box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            }
            .auth-btn-secondary {
                background: transparent;
                color: #0ff;
                border: 1px solid #0ff;
            }
            .auth-btn-secondary:hover {
                background: rgba(0, 255, 255, 0.1);
            }
            .auth-btn-guest {
                background: transparent;
                color: #888;
                border: 1px solid #444;
                margin-top: 20px;
            }
            .auth-switch {
                text-align: center;
                margin-top: 20px;
                color: #68a;
                font-size: 13px;
            }
            .auth-switch a {
                color: #0ff;
                cursor: pointer;
                text-decoration: underline;
            }
            .auth-error {
                color: #f55;
                text-align: center;
                margin-bottom: 15px;
                font-size: 13px;
            }
            .auth-tabs {
                display: flex;
                margin-bottom: 25px;
            }
            .auth-tab {
                flex: 1;
                padding: 10px;
                text-align: center;
                color: #68a;
                cursor: pointer;
                border-bottom: 2px solid #234;
                transition: all 0.3s;
            }
            .auth-tab.active {
                color: #0ff;
                border-bottom-color: #0ff;
            }
            #register-fields { display: none; }
            .auth-agree {
                margin: 10px 0;
                font-size: 12px;
                color: #8ab;
            }
            .auth-agree label {
                display: flex;
                align-items: center;
                gap: 8px;
                cursor: pointer;
            }
            .auth-agree input[type="checkbox"] {
                width: 18px;
                height: 18px;
                accent-color: #0ff;
                cursor: pointer;
            }
            .auth-agree a {
                color: #0ff;
                text-decoration: underline;
            }
            .auth-agree a:hover {
                color: #fff;
            }
            .auth-close-btn {
                position: absolute;
                top: 15px;
                right: 15px;
                background: none;
                border: 1px solid #0ff;
                color: #0ff;
                width: 30px;
                height: 30px;
                border-radius: 50%;
                cursor: pointer;
                font-size: 16px;
            }
            .auth-close-btn:hover {
                background: rgba(0,255,255,0.2);
            }
        </style>
        <div id="auth-overlay">
            <div id="auth-box" style="position:relative;">
                <button class="auth-close-btn" onclick="closeAuthUI()">✕</button>
                <h2>STAR·WALKER</h2>
                <div class="auth-tabs">
                    <div class="auth-tab active" onclick="showLoginTab()">${_t('login')}</div>
                    <div class="auth-tab" onclick="showRegisterTab()">${_t('register')}</div>
                </div>
                <div id="auth-error" class="auth-error"></div>
                
                <input type="text" id="auth-username" class="auth-input" placeholder="${_t('emailAddress')}" maxlength="100">
                <input type="password" id="auth-password" class="auth-input" placeholder="${_t('password')}" maxlength="30">
                
                <div id="register-fields">
                    <input type="password" id="auth-password2" class="auth-input" placeholder="${_t('passwordConfirm')}" maxlength="30">
                    <input type="text" id="auth-nickname" class="auth-input" placeholder="${_t('nickname')} ${_t('nicknameDesc')}" maxlength="15">
                    <input type="email" id="auth-email" class="auth-input" placeholder="${_t('email')} ${_t('emailRequired')}" maxlength="100" required>
                    <div style="font-size: 11px; color: #8ab; margin-bottom: 10px;">
                        ${_t('emailVerifyNote')}
                    </div>
                    <div class="auth-agree">
                        <label>
                            <input type="checkbox" id="auth-privacy-agree">
                            <span><a href="privacy.html" target="_blank">${_t('privacyPolicy')}</a>${_t('agreeToTerms')}</span>
                        </label>
                    </div>
                    <div class="auth-agree">
                        <label>
                            <input type="checkbox" id="auth-terms-agree">
                            <span><a href="terms.html" target="_blank">${_t('termsOfService')}</a>${_t('agreeToTerms')}</span>
                        </label>
                    </div>
                </div>
                
                <button id="auth-submit-btn" class="auth-btn auth-btn-primary" onclick="submitAuth()">${_t('login')}</button>
                <button class="auth-btn auth-btn-guest" onclick="guestLogin()">${_t('guestStart')}</button>
            </div>
        </div>
    `;
    
    // 이미 존재하면 제거 후 다시 추가
    const existingUI = document.getElementById('auth-ui');
    if (existingUI) {
        existingUI.remove();
    }
    
    document.body.appendChild(authUI);
    
    // ★★★ 오버레이 표시 ★★★
    setTimeout(() => {
        const overlay = document.getElementById('auth-overlay');
        if (overlay) {
            overlay.style.display = 'flex';
        }
    }, 50);
    
    // 엔터키 로그인
    document.getElementById('auth-password').addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && !isRegisterMode) submitAuth();
    });
}

let isRegisterMode = false;

function showLoginTab() {
    isRegisterMode = false;
    document.querySelectorAll('.auth-tab')[0].classList.add('active');
    document.querySelectorAll('.auth-tab')[1].classList.remove('active');
    document.getElementById('register-fields').style.display = 'none';
    document.getElementById('auth-submit-btn').textContent = t('login');
    document.getElementById('auth-error').textContent = '';
}

function showRegisterTab() {
    isRegisterMode = true;
    document.querySelectorAll('.auth-tab')[0].classList.remove('active');
    document.querySelectorAll('.auth-tab')[1].classList.add('active');
    document.getElementById('register-fields').style.display = 'block';
    document.getElementById('auth-submit-btn').textContent = t('register');
    document.getElementById('auth-error').textContent = '';
}

function submitAuth() {
    var username = document.getElementById('auth-username').value.trim();
    var password = document.getElementById('auth-password').value;
    var errorEl = document.getElementById('auth-error');
    
    if (!username || !password) {
        errorEl.textContent = t('enterEmailPassword');
        return;
    }
    
    if (isRegisterMode) {
        // 회원가입
        var password2 = document.getElementById('auth-password2').value;
        var nickname = document.getElementById('auth-nickname').value.trim();
        var email = document.getElementById('auth-email').value.trim();
        var privacyAgree = document.getElementById('auth-privacy-agree').checked;
        var termsAgree = document.getElementById('auth-terms-agree').checked;
        
        if (password !== password2) {
            errorEl.textContent = t('passwordsNotMatch');
            return;
        }
        if (!nickname) {
            errorEl.textContent = t('enterNickname');
            return;
        }
        // 이메일 필수 체크
        if (!email) {
            errorEl.textContent = t('enterEmailRequired');
            return;
        }
        if (!email.includes('@') || !email.includes('.')) {
            errorEl.textContent = t('invalidEmailFormat');
            return;
        }
        if (!privacyAgree) {
            errorEl.textContent = t('agreePrivacy');
            return;
        }
        if (!termsAgree) {
            errorEl.textContent = t('agreeTerms');
            return;
        }
        
        if (!supabase) {
            errorEl.textContent = t('connectingServer');
            return;
        }
        
        console.log('📝 Registration attempt:', email, nickname);
        
        // 인증 대기용 정보 저장
        window.pendingVerification = {
            email: email,
            password: password,
            username: username,
            nickname: nickname
        };
        
        // Supabase 회원가입
        supabase.auth.signUp({
            email: email,
            password: password,
            options: {
                data: {
                    username: username,
                    nickname: nickname
                }
            }
        }).then(function(result) {
            console.log('📝 Registration result:', result);
            
            if (result.error) {
                console.error('❌ Registration error:', result.error);
                if (result.error.message.includes('already registered')) {
                    errorEl.textContent = t('emailAlreadyRegistered');
                } else if (result.error.message.includes('valid email')) {
                    errorEl.textContent = t('enterValidEmail');
                } else {
                    errorEl.textContent = result.error.message;
                }
            } else {
                console.log('✅ Registration request success');
                
                // 이메일 인증이 필요한지 확인
                if (result.data.user && !result.data.session) {
                    // 이메일 인증 필요
                    console.log('📧 Email verification required');
                    showEmailVerifyPanel(email);
                } else if (result.data.session) {
                    // 인증 없이 바로 로그인됨 (이메일 확인 비활성화된 경우)
                    console.log('✅ Logged in directly');
                    processLogin(result.data.user, username, nickname);
                } else {
                    // 회원가입 성공, 로그인 화면으로
                    errorEl.style.color = '#0f0';
                    errorEl.textContent = t('registrationComplete');
                    showLoginTab();
                    document.getElementById('auth-username').value = email;
                    document.getElementById('auth-password').value = '';
                }
            }
        }).catch(function(e) {
            console.error('❌ Registration catch:', e);
            errorEl.textContent = t('serverConnectionFailed') + e.message;
        });
    } else {
        // 로그인
        if (!supabase) {
            errorEl.textContent = t('connectingServer');
            return;
        }
        
        // 이메일 형식 체크
        var loginEmail = username;
        if (!loginEmail.includes('@')) {
            errorEl.textContent = t('enterEmailExample');
            return;
        }
        
        console.log('🔐 Login attempt:', loginEmail);
        
        supabase.auth.signInWithPassword({
            email: loginEmail,
            password: password
        }).then(function(result) {
            console.log('🔐 Login result:', result);
            
            if (result.error) {
                console.error('❌ Login error:', result.error);
                
                // 에러 메시지 분기
                if (result.error.message.includes('Email not confirmed')) {
                    errorEl.style.color = '#fa0';
                    errorEl.innerHTML = t('emailVerificationRequired');
                    
                    // 인증 대기 정보 저장
                    window.pendingVerification = {
                        email: loginEmail,
                        password: password,
                        username: loginEmail.split('@')[0],
                        nickname: loginEmail.split('@')[0]
                    };
                } else if (result.error.message.includes('Invalid login')) {
                    errorEl.textContent = t('invalidEmailOrPassword');
                } else {
                    errorEl.textContent = t('loginFailed') + result.error.message;
                }
                return;
            }
            
            var user = result.data.user;
            console.log('✅ 인증 성공, 사용자:', user.id);
            
            // 기본 사용자 정보 설정 (profiles 테이블 없어도 동작)
            mpUser = {
                id: user.id,
                username: username,
                nickname: username,
                email: user.email,
                coins: 1000,
                currentShip: 'shuttle',
                unlockedShips: ['shuttle']
            };
            mpUserId = user.id;
            mpSessionToken = generateSessionToken();  // ★★★ 중복 접속 감지용 ★★★
            mpNickname = username;

            // window 객체에도 설정
            window.mpUser = mpUser;
            window.mpUserId = mpUserId;
            window.mpNickname = mpNickname;
            window.currentUser = mpUser.username;
            
            // 프로필 정보 가져오기 시도 (실패해도 계속 진행)
            supabase
                .from('profiles')
                .select('*')
                .eq('id', user.id)
                .single()
                .then(function(profileResult) {
                    console.log('📋 프로필 조회 결과:', profileResult);
                    
                    if (profileResult.data) {
                        var profile = profileResult.data;
                        mpUser.username = profile.username || username;
                        mpUser.nickname = profile.nickname || username;
                        mpUser.coins = profile.coins || 1000;
                        mpUser.exp = profile.exp || 0;
                        mpUser.avatar_url = profile.avatar_url || null;
                        mpUser.currentShip = profile.current_ship || 'shuttle';
                        mpUser.unlockedShips = profile.unlocked_ships || ['shuttle'];
                        mpNickname = mpUser.nickname;
                        
                        window.mpUser = mpUser;
                        window.mpNickname = mpNickname;
                    }
                    
                    finishLogin();
                })
                .catch(function(e) {
                    console.warn('⚠️ 프로필 조회 실패 (무시하고 진행):', e);
                    finishLogin();
                });
            
            function finishLogin() {
                // UI 업데이트
                if (typeof updateUserUI === 'function') {
                    updateUserUI();
                }
                
                console.log('✅ Supabase 로그인 성공:', mpUser.nickname);
                
                // 로그인 UI 닫기
                document.getElementById('auth-overlay').style.display = 'none';
                
                // 멀티플레이어 UI 준비
                if (!document.getElementById('multiplayer-ui')) {
                    createMultiplayerUI();
                }
                var mpUI = document.getElementById('multiplayer-ui');
                if (mpUI) mpUI.style.display = 'none';
                console.log('멀티플레이어 로그인 완료');
                
                // ★★★ 저장된 우주선 위치 확인 ★★★
                if (typeof checkSavedShipOnLogin === 'function') {
                    checkSavedShipOnLogin();
                }
            }
        }).catch(function(e) {
            console.error('❌ 로그인 catch:', e);
            errorEl.textContent = 'Server connection failed: ' + e.message;
        });
    }
}

// 이메일 인증 대기 화면 표시
function showEmailVerifyPanel(email) {
    // 폼 숨기기
    document.getElementById('auth-username').style.display = 'none';
    document.getElementById('auth-password').style.display = 'none';
    document.getElementById('register-fields').style.display = 'none';
    document.getElementById('auth-submit-btn').style.display = 'none';
    document.querySelector('.auth-btn-guest').style.display = 'none';
    document.querySelector('.auth-tabs').style.display = 'none';
    document.getElementById('auth-error').style.display = 'none';
    
    // 인증 대기 화면 표시
    document.getElementById('email-verify-panel').style.display = 'block';
    document.getElementById('verify-email-display').textContent = email + ' 으로 인증 메일을 보냈습니다';
}

// 로그인 화면으로 돌아가기
function backToLogin() {
    // 폼 다시 표시
    document.getElementById('auth-username').style.display = 'block';
    document.getElementById('auth-password').style.display = 'block';
    document.getElementById('auth-submit-btn').style.display = 'block';
    document.querySelector('.auth-btn-guest').style.display = 'block';
    document.querySelector('.auth-tabs').style.display = 'flex';
    document.getElementById('auth-error').style.display = 'block';
    
    // 인증 대기 화면 숨기기
    document.getElementById('email-verify-panel').style.display = 'none';
    
    // 로그인 탭으로
    showLoginTab();
    
    // 이메일로 아이디 필드 채우기
    if (window.pendingVerification && window.pendingVerification.email) {
        document.getElementById('auth-username').value = window.pendingVerification.email;
    }
}

// 이메일 인증 확인 후 로그인 시도
function checkEmailVerified() {
    var statusEl = document.getElementById('verify-status');
    
    if (!window.pendingVerification) {
        statusEl.style.color = '#f55';
        statusEl.textContent = t('noAuthInfo');
        return;
    }
    
    statusEl.style.color = '#0ff';
    statusEl.textContent = t('verifying');
    
    var email = window.pendingVerification.email;
    var password = window.pendingVerification.password;
    
    // 로그인 시도
    supabase.auth.signInWithPassword({
        email: email,
        password: password
    }).then(function(result) {
        console.log('🔐 인증 확인 로그인 결과:', result);
        
        if (result.error) {
            if (result.error.message.includes('Email not confirmed')) {
                statusEl.style.color = '#f55';
                statusEl.textContent = t('emailPending');
            } else {
                statusEl.style.color = '#f55';
                statusEl.textContent = t('loginFailedMsg') + result.error.message;
            }
        } else {
            statusEl.style.color = '#0f0';
            statusEl.textContent = t('verified');
            
            // 로그인 처리
            var user = result.data.user;
            var pending = window.pendingVerification;
            processLogin(user, pending.username, pending.nickname);
        }
    }).catch(function(e) {
        statusEl.style.color = '#f55';
        statusEl.textContent = t('serverError') + e.message;
    });
}

// 인증 메일 재발송
function resendVerificationEmail() {
    var statusEl = document.getElementById('verify-status');
    
    if (!window.pendingVerification || !window.pendingVerification.email) {
        statusEl.style.color = '#f55';
        statusEl.textContent = t('emailNotFound');
        return;
    }
    
    statusEl.style.color = '#0ff';
    statusEl.textContent = t('sendingEmail');
    
    supabase.auth.resend({
        type: 'signup',
        email: window.pendingVerification.email
    }).then(function(result) {
        console.log('📨 재발송 결과:', result);
        
        if (result.error) {
            statusEl.style.color = '#f55';
            statusEl.textContent = t('resendFailed') + result.error.message;
        } else {
            statusEl.style.color = '#0f0';
            statusEl.textContent = t('resendSuccess');
        }
    }).catch(function(e) {
        statusEl.style.color = '#f55';
        statusEl.textContent = t('serverError') + e.message;
    });
}

// 로그인 처리 공통 함수
function processLogin(user, username, nickname) {
    // 프로필 조회 및 설정
    mpUser = {
        id: user.id,
        username: username || user.email,
        nickname: nickname || username || user.email.split('@')[0],
        email: user.email,
        coins: 1000,
        currentShip: 'shuttle',
        unlockedShips: ['shuttle']
    };
    mpUserId = user.id;
    mpSessionToken = generateSessionToken();  // ★★★ 중복 접속 감지용 ★★★
    mpNickname = mpUser.nickname;

    window.mpUser = mpUser;
    window.mpUserId = mpUserId;
    window.mpNickname = mpNickname;
    window.currentUser = mpUser.username;

    // 프로필 조회 시도
    supabase
        .from('profiles')
        .select('*')
        .eq('id', user.id)
        .single()
        .then(function(profileResult) {
            if (profileResult.data) {
                var profile = profileResult.data;
                mpUser.username = profile.username || mpUser.username;
                mpUser.nickname = profile.nickname || mpUser.nickname;
                mpUser.coins = profile.coins || 1000;
                mpUser.currentShip = profile.current_ship || 'shuttle';
                mpUser.unlockedShips = profile.unlocked_ships || ['shuttle'];
                mpNickname = mpUser.nickname;
                
                window.mpUser = mpUser;
                window.mpNickname = mpNickname;
            }
            completeLogin();
        })
        .catch(function(e) {
            console.warn('프로필 조회 실패:', e);
            completeLogin();
        });
    
    function completeLogin() {
        if (typeof updateUserUI === 'function') {
            updateUserUI();
        }
        
        console.log('✅ 로그인 성공:', mpUser.nickname);
        
        document.getElementById('auth-overlay').style.display = 'none';
        
        if (!document.getElementById('multiplayer-ui')) {
            createMultiplayerUI();
        }
        var mpUI = document.getElementById('multiplayer-ui');
        if (mpUI) mpUI.style.display = 'none';
        
        window.pendingVerification = null;
    }
}

function guestLogin() {
    // ★★★ UUID 형식으로 생성 (테이블이 uuid 타입) ★★★
    mpUserId = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
    mpSessionToken = generateSessionToken();  // ★★★ 중복 접속 감지용 ★★★
    mpNickname = '탐험가' + Math.floor(Math.random() * 9999);
    mpUser = null;

    // ★ window 객체에도 설정
    window.mpUserId = mpUserId;
    window.mpNickname = mpNickname;
    window.mpUser = null;
    
    document.getElementById('auth-overlay').style.display = 'none';
    
    // ★ UI 업데이트 (게스트 로그인 상태 반영)
    if (typeof updateUserUI === 'function') {
        updateUserUI();
    }
    
    // 멀티플레이어 UI 준비 (게임 모드 선택 후 시작됨)
    if (!document.getElementById('multiplayer-ui')) {
        createMultiplayerUI();
    }
    const mpUI = document.getElementById('multiplayer-ui');
    if (mpUI) mpUI.style.display = 'none';
    console.log('게스트 로그인 완료 (게임 모드 선택 대기 중)');
}

function logout() {
    var doLogout = function() {
        localStorage.removeItem('solar_user');
        mpUser = null;
        mpUserId = null;
        mpSessionToken = null;
        window.mpUser = null;
        window.mpUserId = null;
        window.currentUser = null;
        location.reload();
    };
    
    if (supabase) {
        supabase.auth.signOut().then(doLogout).catch(doLogout);
    } else {
        doLogout();
    }
}

// ============ 멀티플레이어 UI ============
function createMultiplayerUI() {
    const mpUI = document.createElement('div');
    mpUI.id = 'multiplayer-ui';
    mpUI.innerHTML = `
        <style>
            #multiplayer-ui {
                position: fixed;
                top: 60px;
                right: 10px;
                z-index: 10000;
                font-family: 'Orbitron', sans-serif;
            }
            #mp-toggle {
                background: rgba(0, 20, 40, 0.9);
                border: 1px solid #0ff;
                color: #0ff;
                padding: 8px 15px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 12px;
                display: block;
                margin-bottom: 5px;
            }
            #mp-toggle:hover {
                background: rgba(0, 100, 150, 0.9);
            }
            #mp-panel {
                background: rgba(0, 20, 40, 0.9);
                border: 1px solid #0ff;
                border-radius: 10px;
                padding: 15px;
                color: #0ff;
                width: 250px;
                max-height: 60vh;
                overflow-y: auto;
                display: block;
            }
            #mp-panel.hidden {
                display: none;
            }
            #mp-user-info {
                font-size: 14px;
                margin-bottom: 10px;
                padding-bottom: 10px;
                border-bottom: 1px solid #234;
            }
            #mp-online {
                font-size: 12px;
                margin-bottom: 10px;
                color: #0f0;
            }
            #mp-chat-container {
                max-height: 150px;
                overflow-y: auto;
                font-size: 11px;
                background: rgba(0, 0, 0, 0.5);
                padding: 5px;
                border-radius: 5px;
                margin-bottom: 5px;
            }
            #mp-chat-container::-webkit-scrollbar { width: 5px; }
            #mp-chat-container::-webkit-scrollbar-thumb { background: #0ff; border-radius: 5px; }
            .mp-chat-msg { margin: 3px 0; word-break: break-word; display: flex; flex-wrap: wrap; align-items: baseline; gap: 5px; }
            .mp-chat-msg .nick { color: #ff0; }
            .mp-chat-msg .msg-text { flex: 1; }
            .mp-chat-msg .msg-time { color: #666; font-size: 8px; margin-left: auto; white-space: nowrap; }
            #mp-chat-input {
                width: calc(100% - 50px);
                padding: 5px;
                background: rgba(0, 50, 80, 0.8);
                border: 1px solid #0ff;
                border-radius: 3px;
                color: #fff;
                font-size: 11px;
            }
            #mp-chat-send {
                width: 45px;
                padding: 5px;
                background: #0ff;
                border: none;
                border-radius: 3px;
                color: #000;
                cursor: pointer;
                font-size: 11px;
            }
            #mp-logout {
                font-size: 10px;
                color: #f88;
                cursor: pointer;
                margin-left: 10px;
            }
            .mp-player-label {
                color: #0ff;
                font-size: 10px;
                background: rgba(0, 0, 0, 0.7);
                padding: 2px 5px;
                border-radius: 3px;
            }
        </style>
        <button id="mp-toggle">💬 채팅</button>
        <div id="mp-panel">
            <div id="mp-user-info">
                👤 <span id="mp-nickname-display">${mpNickname}</span>
                ${mpUser ? '' : ' (게스트)'}
            </div>
            <div id="mp-online"><span data-i18n="playersOnline">🟢 접속자</span>: 1<span data-i18n="playersCount">명</span></div>
            <div id="mp-chat-container"></div>
            <div>
                <input type="text" id="mp-chat-input" placeholder="채팅..." data-placeholder-i18n="chatTab" maxlength="100">
                <button id="mp-chat-send" onclick="sendChat()" data-i18n="send">전송</button>
            </div>
        </div>
    `;
    document.body.appendChild(mpUI);
    
    // 토글 버튼 이벤트
    document.getElementById('mp-toggle').addEventListener('click', toggleMpPanel);
    
    document.getElementById('mp-chat-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') sendChat();
    });
    
    // 드래그 시스템에 등록
    if (window.draggableUISystem && window.draggableUISystem.initialized) {
        const el = document.getElementById('multiplayer-ui');
        if (el) {
            el.classList.add('draggable-ui');
            el.dataset.draggable = 'true';
            window.draggableUISystem.elements.push(el);
            window.draggableUISystem.attachEvents(el);
            console.log('드래그 등록: multiplayer-ui');
        }
    }
}

let mpPanelVisible = true;
function toggleMpPanel() {
    mpPanelVisible = !mpPanelVisible;
    const panel = document.getElementById('mp-panel');
    const btn = document.getElementById('mp-toggle');
    if (panel) {
        panel.classList.toggle('hidden', !mpPanelVisible);
    }
    if (btn) {
        btn.textContent = mpPanelVisible ? '💬 채팅' : '💬 채팅 ▶';
    }
}

// ============ 서버 통신 ============

function mpSendMyPosition(forceUpdate = false) {
    var ship = window.playerShip;
    if (!ship || !ship.mesh) return;
    if (!supabase) return;
    if (!mpUserId) return;

    var pos = ship.mesh.position;
    var rot = ship.mesh.rotation;

    // ★★★ 델타 압축: 위치/회전 변경 확인 ★★★
    var posChanged = Math.abs(pos.x - mpLastSentPosition.x) > MP_POSITION_THRESHOLD ||
                     Math.abs(pos.y - mpLastSentPosition.y) > MP_POSITION_THRESHOLD ||
                     Math.abs(pos.z - mpLastSentPosition.z) > MP_POSITION_THRESHOLD;

    var rotChanged = Math.abs(rot.x - mpLastSentRotation.x) > MP_ROTATION_THRESHOLD ||
                     Math.abs(rot.y - mpLastSentRotation.y) > MP_ROTATION_THRESHOLD ||
                     Math.abs(rot.z - mpLastSentRotation.z) > MP_ROTATION_THRESHOLD;

    // 5초마다 강제 업데이트 (하트비트)
    mpForceUpdateCounter++;
    var heartbeat = mpForceUpdateCounter >= 50; // 100ms * 50 = 5초

    // 변경 없고 강제 업데이트도 아니면 스킵
    if (!posChanged && !rotChanged && !heartbeat && !forceUpdate) {
        return;
    }

    if (heartbeat) mpForceUpdateCounter = 0;

    // 마지막 상태 저장
    mpLastSentPosition = { x: pos.x, y: pos.y, z: pos.z };
    mpLastSentRotation = { x: rot.x, y: rot.y, z: rot.z };
    mpLastSentTime = Date.now();

    var shipType = 'shuttle';
    if (typeof SHIP_TYPES !== 'undefined' && window.selectedShipIndex !== undefined) {
        shipType = SHIP_TYPES[window.selectedShipIndex] ? SHIP_TYPES[window.selectedShipIndex].id : 'shuttle';
    }

    // 우주선 색상 가져오기
    var shipColor = '#00aaff';
    if (typeof SHIP_TYPES !== 'undefined' && window.selectedShipIndex !== undefined) {
        var shipData = SHIP_TYPES[window.selectedShipIndex];
        if (shipData && shipData.color) {
            shipColor = '#' + shipData.color;
        }
    }

    // 상태 결정
    var status = 'flying';
    if (window.autopilot && window.autopilot.engaged) {
        status = 'autopilot';
    } else if (ship.speed < 1) {
        status = 'idle';
    }

    // ★★★ 위치 데이터 ★★★
    var data = {
        user_id: mpUserId,
        nickname: mpNickname,
        x: pos.x,
        y: pos.y,
        z: pos.z,
        rot_x: rot.x,
        rot_y: rot.y,
        rot_z: rot.z,
        ship_type: shipType,
        ship_color: shipColor,
        status: status,
        current_body: window.focusedBody ? window.focusedBody.name : null
    };

    // ★★★ user_id가 PRIMARY KEY면 onConflict 불필요 ★★★
    supabase
        .from('player_positions')
        .upsert(data)
        .then(function(result) {
            if (result.error) {
                console.log('MP 위치 전송 에러:', result.error.message);
            }
        })
        .catch(function(e) {
            console.log('MP 위치 전송 실패:', e);
        });
}

function mpGetOtherPlayers() {
    if (!supabase) {
        console.log('⚠️ mpGetOtherPlayers: supabase 없음');
        return;
    }
    if (!mpUserId) {
        console.log('⚠️ mpGetOtherPlayers: mpUserId 없음');
        return;
    }

    // ★★★ 원래 user_id로 자기 자신 제외 ★★★
    supabase
        .from('player_positions')
        .select('*')
        .neq('user_id', mpUserId)
        .then(function(result) {
            var players = result.data;
            var error = result.error;

            console.log('📡 player_positions 조회 결과:', {
                players: players ? players.length : 0,
                error: error,
                myUserId: mpUserId
            });

            if (error) {
                console.log('MP 플레이어 조회 에러:', error.message);
                return;
            }

            // 플레이어가 없어도 updateOtherPlayers 호출 (기존 플레이어 제거용)
            var formattedPlayers = (players || []).map(function(p) {
                console.log('   - 플레이어 발견:', p.user_id, p.nickname, 'x:', p.x, 'y:', p.y, 'z:', p.z);
                return {
                    user_id: p.user_id,
                    nickname: p.nickname || '익명',
                    pos_x: p.x || 0,
                    pos_y: p.y || 0,
                    pos_z: p.z || 0,
                    rot_x: p.rot_x || 0,
                    rot_y: p.rot_y || 0,
                    rot_z: p.rot_z || 0,
                    ship_type: p.ship_type || 'shuttle',
                    ship_color: p.ship_color || '#00aaff',
                    status: p.status || 'flying',
                    current_location: p.current_body
                };
            });

            console.log('📡 다른 플레이어:', formattedPlayers.length, '명');
            updateOtherPlayers(formattedPlayers);

            var onlineEl = document.getElementById('mp-online');
            if (onlineEl) {
                onlineEl.textContent = t('playersOnline') + ': ' + (formattedPlayers.length + 1) + t('playersCount');
            }
        })
        .catch(function(e) {
            console.log('MP 플레이어 조회 실패:', e);
        });
}

function updateOtherPlayers(players) {
    const activeIds = new Set();

    players.forEach(player => {
        activeIds.add(player.user_id);

        // ★★★ 기존 메시 버전 체크 - 없으면 강제 재생성 ★★★
        const existing = mpOtherPlayers[player.user_id];
        if (existing && !existing._v2) {
            // 구버전 메시 제거
            console.log('🔄 구버전 메시 제거:', player.user_id);
            if (window.scene) window.scene.remove(existing.mesh);
            delete mpOtherPlayers[player.user_id];
        }

        if (!mpOtherPlayers[player.user_id]) {
            // 새 플레이어 생성
            createOtherPlayerShip(player);
        } else {
            // ★★★ 백업 스타일: 직접 lerp (단순하고 확실) ★★★
            const ship = mpOtherPlayers[player.user_id];
            ship.mesh.position.lerp(
                new THREE.Vector3(
                    parseFloat(player.pos_x),
                    parseFloat(player.pos_y),
                    parseFloat(player.pos_z)
                ), 0.3
            );
            ship.mesh.rotation.set(
                parseFloat(player.rot_x),
                parseFloat(player.rot_y),
                parseFloat(player.rot_z)
            );
            if (ship.label) {
                ship.label.element.textContent = player.nickname;
            }
        }
    });

    Object.keys(mpOtherPlayers).forEach(id => {
        if (!activeIds.has(id)) {
            removeOtherPlayer(id);
        }
    });
}

// ★★★ 백업 호환용 빈 함수 (animate에서 호출됨) ★★★
function mpInterpolateOtherPlayers(deltaTime) {
    // 위치 업데이트는 updateOtherPlayers에서 직접 처리
}
window.mpInterpolateOtherPlayers = mpInterpolateOtherPlayers;

function createOtherPlayerShip(player) {
    console.log('🚀 다른 플레이어 우주선 생성:', player.nickname, 'pos:', player.pos_x, player.pos_y, player.pos_z);

    if (!window.scene) {
        console.error('❌ scene 없음');
        return;
    }

    const shipGroup = new THREE.Group();
    shipGroup.position.set(
        parseFloat(player.pos_x) || 0,
        parseFloat(player.pos_y) || 0,
        parseFloat(player.pos_z) || 0
    );

    // ★★★ 다른 플레이어는 내 우주선보다 뒤에 렌더링 ★★★
    shipGroup.renderOrder = -100;

    // ★★★ 플레이어 우주선 색상 결정 ★★★
    const shipTypeId = player.ship_type || 'shuttle';
    const shipType = window.SHIP_TYPES
        ? window.SHIP_TYPES.find(s => s.id === shipTypeId) : null;

    // 우선순위: player.ship_color > shipType.color > 기본값
    let shipColorHex = 0x4fc3f7; // 기본 하늘색
    if (player.ship_color) {
        // ship_color가 문자열이면 파싱
        if (typeof player.ship_color === 'string') {
            shipColorHex = parseInt(player.ship_color.replace('#', ''), 16);
        } else {
            shipColorHex = player.ship_color;
        }
    } else if (shipType && shipType.color) {
        if (typeof shipType.color === 'string') {
            shipColorHex = parseInt(shipType.color.replace('#', ''), 16);
        } else {
            shipColorHex = shipType.color;
        }
    }
    const shipColor = new THREE.Color(shipColorHex);

    // ★★★ 백업 스타일: 기본 형태 먼저 추가 ★★★
    const geometry = new THREE.ConeGeometry(5, 15, 8);  // 0.5→5, 1.5→15 (10배 증가)
    geometry.rotateX(Math.PI / 2);
    const material = new THREE.MeshBasicMaterial({
        color: shipColor,
        transparent: true,
        opacity: 0.8,
        depthWrite: true,
        depthTest: true
    });
    const defaultMesh = new THREE.Mesh(geometry, material);
    shipGroup.add(defaultMesh);

    // ★★★ GLB 모델 로드 시도 ★★★
    if (shipType && shipType.model && window.GLTFLoader) {
        const loader = new window.GLTFLoader();
        loader.load(shipType.model, (gltf) => {
            const model = gltf.scene;
            model.scale.setScalar(0.4);  // 0.04→0.4 (10배 증가)
            model.rotation.y = Math.PI;

            // 플레이어 우주선 색상으로 틴트
            model.traverse((child) => {
                if (child.isMesh && child.material) {
                    child.material = child.material.clone();
                    child.material.emissive = shipColor;
                    child.material.emissiveIntensity = 0.3;
                }
            });

            // 기본 형태 제거
            shipGroup.remove(defaultMesh);
            shipGroup.add(model);
            console.log('✅ 모델 로드 완료:', player.nickname, '색상:', shipColorHex.toString(16));
        }, undefined, (err) => {
            console.log('⚠️ 모델 로드 실패, 기본 형태 유지');
        });
    }

    window.scene.add(shipGroup);

    // ★★★ 닉네임 라벨 ★★★
    let label = null;
    if (window.CSS2DObject) {
        const labelDiv = document.createElement('div');
        labelDiv.className = 'mp-player-label';
        labelDiv.textContent = player.nickname || 'Player';
        // 우주선 색상을 CSS hex로 변환
        const labelColorHex = '#' + shipColor.getHexString();
        labelDiv.style.cssText = `color:${labelColorHex}; font-size:12px; font-family:Orbitron,sans-serif; text-shadow:0 0 5px ${labelColorHex}; background:rgba(0,0,0,0.5); padding:2px 6px; border-radius:3px;`;
        label = new window.CSS2DObject(labelDiv);
        label.position.set(0, 20, 0);  // 2→20 (10배 증가)
        shipGroup.add(label);
    }

    mpOtherPlayers[player.user_id] = { mesh: shipGroup, label: label, _v2: true };
    console.log('✅ 다른 플레이어 생성 완료:', player.nickname, '위치:', shipGroup.position.x.toFixed(2), shipGroup.position.y.toFixed(2), shipGroup.position.z.toFixed(2));
}

// ★★★ GLB 없을 때 기본 형태 생성 ★★★
function addFallbackGeometry(group, shipType, sizeScale) {
    const color = shipType ? shipType.color : 0x00ffff;

    // 본체 (콘)
    const bodyGeo = new THREE.ConeGeometry(0.3, 1.0, 8);
    bodyGeo.rotateX(Math.PI / 2);
    const bodyMat = new THREE.MeshStandardMaterial({
        color: color,
        metalness: 0.7,
        roughness: 0.3
    });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.scale.setScalar(sizeScale);
    group.add(body);

    // 글로우
    const glowGeo = new THREE.SphereGeometry(0.4, 16, 16);
    const glowMat = new THREE.MeshBasicMaterial({
        color: color,
        transparent: true,
        opacity: 0.3
    });
    const glow = new THREE.Mesh(glowGeo, glowMat);
    group.add(glow);
}

function removeOtherPlayer(userId) {
    const player = mpOtherPlayers[userId];
    if (player) {
        if (window.scene) {
            window.scene.remove(player.mesh);
        }
        delete mpOtherPlayers[userId];
    }
}

// ============ 채팅 ============

function sendChat() {
    var input = document.getElementById('mp-chat-input');
    var message = input.value.trim();
    if (!message || !supabase) return;
    
    var isGuest = mpUserId && mpUserId.indexOf('guest_') === 0;
    
    supabase
        .from('chat_messages')
        .insert({
            user_id: isGuest ? null : mpUserId,
            nickname: mpNickname,
            message: message,
            message_type: 'chat'
        })
        .then(function() {
            input.value = '';
        })
        .catch(function(e) {
            console.log('채팅 전송 실패:', e);
        });
}

// 통합 채팅에서 호출하는 전역 함수
window.sendMultiChat = async function(message) {
    if (!message || !mpUserId || !supabase) return;
    
    var isGuest = mpUserId && mpUserId.indexOf('guest_') === 0;
    
    try {
        const { data, error } = await supabase
            .from('chat_messages')
            .insert({
                user_id: isGuest ? null : mpUserId,
                nickname: mpNickname,
                message: message,
                message_type: 'chat'
            })
            .select();
        
        if (error) {
            console.log('채팅 전송 실패:', error);
        }
    } catch (e) {
        console.log('채팅 전송 오류:', e);
    }
};

function getChat() {
    if (!supabase) return;
    
    supabase
        .from('chat_messages')
        .select('*')
        .gt('id', mpChatLastId)
        .order('id', { ascending: true })
        .limit(50)
        .then(function(result) {
            var messages = result.data;
            var error = result.error;
            
            if (!error && messages && messages.length > 0) {
                var container = document.getElementById('mp-chat-container');
                
                messages.forEach(function(msg) {
                    var div = document.createElement('div');
                    div.className = 'mp-chat-msg';
                    
                    // 시간 포맷팅
                    var timeStr = '';
                    if (msg.created_at) {
                        var date = new Date(msg.created_at);
                        var month = String(date.getMonth() + 1).padStart(2, '0');
                        var day = String(date.getDate()).padStart(2, '0');
                        var hours = String(date.getHours()).padStart(2, '0');
                        var minutes = String(date.getMinutes()).padStart(2, '0');
                        var seconds = String(date.getSeconds()).padStart(2, '0');
                        timeStr = month + '/' + day + ' ' + hours + ':' + minutes + ':' + seconds;
                    }
                    
                    div.innerHTML = '<span class="nick">' + msg.nickname + ':</span> <span class="msg-text">' + msg.message + '</span> <span class="msg-time">' + timeStr + '</span>';
                    container.appendChild(div);
                    mpChatLastId = Math.max(mpChatLastId, parseInt(msg.id));
                    
                    // 통합 채팅에도 표시
                    if (typeof unifiedChatSystem !== 'undefined') {
                        unifiedChatSystem.addMultiMessage(msg.nickname, msg.message, timeStr);
                    }
                });
                
                container.scrollTop = container.scrollHeight;
            }
        })
        .catch(function(e) {
            console.log('채팅 조회 실패:', e);
        });
}

// ============ 초기화 ============

function startMultiplayer() {
    // UI가 없으면 생성
    if (!document.getElementById('multiplayer-ui')) {
        createMultiplayerUI();
    }

    // UI 표시
    const mpUI = document.getElementById('multiplayer-ui');
    if (mpUI) mpUI.style.display = 'block';

    // 이미 시작된 경우 중복 방지
    if (window.mpStarted) {
        console.log('멀티플레이어 이미 실행 중');
        return;
    }

    // 서버에서 방문 기록 불러오기
    if (typeof loadVisitedStations === 'function') {
        loadVisitedStations().then(() => {
            console.log('방문 기록 로드 완료');
        });
    }

    // ★★★ 최적화된 인터벌 설정 ★★★
    // 100ms마다 체크하지만 델타 압축으로 변경 시에만 전송
    mpIntervals.push(setInterval(mpSendMyPosition, MP_UPDATE_INTERVAL));
    // 500ms마다 다른 플레이어 조회 (Realtime 백업)
    mpIntervals.push(setInterval(mpGetOtherPlayers, MP_SYNC_INTERVAL));
    // 1.5초마다 채팅 조회
    mpIntervals.push(setInterval(getChat, MP_CHAT_INTERVAL));

    // ★★★ Supabase Realtime 구독 (WebSocket) ★★★
    setupRealtimeSubscription();

    // 초기 위치 강제 전송
    setTimeout(() => mpSendMyPosition(true), 500);

    window.mpStarted = true;
    console.log('🚀 멀티플레이어 시작! ID:', mpUserId);
    console.log('📡 동기화 설정: 위치전송=' + MP_UPDATE_INTERVAL + 'ms, 조회=' + MP_SYNC_INTERVAL + 'ms');

    // UI 업데이트 (로그인 상태 반영)
    if (typeof updateUserUI === 'function') {
        updateUserUI();
    }
}

// ★★★ Supabase Realtime 구독 설정 ★★★
function setupRealtimeSubscription() {
    if (!supabase || mpRealtimeChannel) return;

    try {
        mpRealtimeChannel = supabase
            .channel('player_positions_realtime')
            .on('postgres_changes', {
                event: '*',
                schema: 'public',
                table: 'player_positions'
            }, (payload) => {
                // INSERT 또는 UPDATE 이벤트 처리
                if (payload.eventType === 'INSERT' || payload.eventType === 'UPDATE') {
                    const p = payload.new;
                    if (p.user_id !== mpUserId) {  // ★★★ 자기 자신 제외 ★★★
                        // ★★★ 테이블 구조에 맞게 수정 ★★★
                        const formattedPlayer = {
                            user_id: p.user_id,
                            nickname: p.nickname || '익명',
                            pos_x: p.x || 0,
                            pos_y: p.y || 0,
                            pos_z: p.z || 0,
                            rot_x: p.rot_x || 0,
                            rot_y: p.rot_y || 0,
                            rot_z: p.rot_z || 0,
                            ship_type: p.ship_type || 'shuttle',
                            ship_color: p.ship_color || '#00aaff',
                            status: p.status || 'flying',
                            current_location: p.current_body
                        };

                        if (mpOtherPlayers[p.user_id]) {
                            // 기존 플레이어 업데이트
                            const ship = mpOtherPlayers[p.user_id];
                            ship.targetPosition = new THREE.Vector3(p.x, p.y, p.z);
                            ship.targetRotation = new THREE.Euler(p.rot_x, p.rot_y, p.rot_z);
                            ship.status = p.status || 'flying';
                            // 레이블 업데이트
                            if (ship.label) {
                                const statusIcon = p.status === 'autopilot' ? '🚀' : '';
                                ship.label.element.textContent = statusIcon + (p.nickname || '익명');
                            }
                        } else {
                            // 새 플레이어 생성
                            createOtherPlayerShip(formattedPlayer);
                        }
                    }
                } else if (payload.eventType === 'DELETE') {
                    // 플레이어 퇴장
                    removeOtherPlayer(payload.old.user_id);
                }
            })
            .subscribe((status) => {
                console.log('📡 Realtime 상태:', status);
            });

        console.log('✅ Supabase Realtime 구독 시작');
    } catch (e) {
        console.log('⚠️ Realtime 구독 실패, 폴링 모드로 동작:', e);
    }
}

window.addEventListener('load', () => {
    setTimeout(() => {
        // 저장된 로그인 정보만 로드 (인증 UI는 멀티 모드 선택 시 표시)
        loadSavedLogin();
        console.log('로그인 정보 체크 완료');
    }, 2000);
});

window.addEventListener('beforeunload', function() {
    // ★★★ user_id로 플레이어 위치 삭제 ★★★
    if (supabase && mpUserId) {
        // REST API로 직접 DELETE 요청 (sendBeacon 호환)
        navigator.sendBeacon(
            SUPABASE_URL + '/rest/v1/player_positions?user_id=eq.' + encodeURIComponent(mpUserId),
            ''
        );
    }

    // 실시간 구독 해제
    if (mpRealtimeChannel && supabase) {
        supabase.removeChannel(mpRealtimeChannel);
    }
});
</script>

<script>
// ===== 광고 보상 시스템 =====
const adBooster = {
    active: false,
    multiplier: 2.0,
    endTime: 0,
    duration: 300000  // 5분
};

const emergencyEscapeCharge = {
    charged: false,
    chargeEndTime: 0  // 10분 유효
};

const spaceExplorer = {
    active: false,
    remainingTime: 0,
    duration: 180000  // 3분
};

// 광고 시청 시뮬레이션 (실제로는 광고 SDK 연동)
function simulateAdWatch(callback) {
    const adModal = document.createElement('div');
    adModal.id = 'ad-modal';
    adModal.innerHTML = `
        <div style="position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);display:flex;flex-direction:column;justify-content:center;align-items:center;z-index:100000;">
            <div style="color:#fff;font-size:2em;margin-bottom:20px;">📺 광고 시청 중...</div>
            <div id="ad-countdown" style="color:#0ff;font-size:3em;">3</div>
        </div>
    `;
    document.body.appendChild(adModal);
    
    let count = 3;
    const interval = setInterval(() => {
        count--;
        document.getElementById('ad-countdown').textContent = count;
        if (count <= 0) {
            clearInterval(interval);
            document.body.removeChild(adModal);
            callback();
        }
    }, 1000);
}

// 광고 보고 2배 부스터 얻기
function watchAdForBooster() {
    simulateAdWatch(() => {
        adBooster.active = true;
        adBooster.endTime = Date.now() + adBooster.duration;
        updateAdUI();
        if (typeof showMessage === 'function') {
            showMessage('🚀 2배 부스터 활성화! (5분)');
        }
    });
}

// 광고 보고 긴급탈출 충전
function watchAdForEscape() {
    simulateAdWatch(() => {
        emergencyEscapeCharge.charged = true;
        emergencyEscapeCharge.chargeEndTime = Date.now() + 600000; // 10분
        updateAdUI();
        if (typeof showMessage === 'function') {
            showMessage('⚡ 긴급탈출 충전 완료! (10분간 유효)');
        }
    });
}

// 광고 보고 둘러보기 (멀티 전용)
function watchAdForExplore() {
    if (window.gameMode !== 'multi') return;
    simulateAdWatch(() => {
        spaceExplorer.active = true;
        spaceExplorer.remainingTime += spaceExplorer.duration;
        updateAdUI();
        if (typeof showMessage === 'function') {
            showMessage('🔭 둘러보기 모드 +3분 추가!');
        }
    });
}

// 광고 UI 업데이트
function updateAdUI() {
    // 초기화 전에는 실행 안함
    if (typeof window.gameMode === 'undefined') return;
    
    const boosterBtn = document.getElementById('ad-booster-btn');
    const escapeBtn = document.getElementById('ad-escape-btn');
    const exploreBtn = document.getElementById('ad-explore-btn');
    const boosterStatus = document.getElementById('booster-status');
    const escapeStatus = document.getElementById('escape-status');
    const exploreStatus = document.getElementById('explore-status');
    const exploreItem = document.getElementById('ad-item-explore');
    
    if (boosterBtn && boosterStatus) {
        if (adBooster.active) {
            const remaining = Math.max(0, adBooster.endTime - Date.now());
            const mins = Math.floor(remaining / 60000);
            const secs = Math.floor((remaining % 60000) / 1000);
            boosterStatus.textContent = `${mins}:${secs.toString().padStart(2,'0')}`;
            boosterStatus.style.color = '#0f0';
            boosterBtn.textContent = t('activated');
            boosterBtn.disabled = true;
            boosterBtn.style.opacity = '0.6';
        } else {
            boosterStatus.textContent = '';
            boosterBtn.textContent = t('watchAdBtn');
            boosterBtn.disabled = false;
            boosterBtn.style.opacity = '1';
        }
    }
    
    if (escapeBtn && escapeStatus) {
        if (emergencyEscapeCharge.charged) {
            const remaining = Math.max(0, emergencyEscapeCharge.chargeEndTime - Date.now());
            const mins = Math.floor(remaining / 60000);
            escapeStatus.textContent = `${mins}${t('minutes')}`;
            escapeStatus.style.color = '#0f0';
            escapeBtn.textContent = t('chargeComplete');
            escapeBtn.disabled = true;
            escapeBtn.style.opacity = '0.6';
        } else {
            escapeStatus.textContent = '';
            escapeBtn.textContent = t('watchAdBtn');
            escapeBtn.disabled = false;
            escapeBtn.style.opacity = '1';
        }
    }
    
    if (exploreItem) {
        exploreItem.style.display = (window.gameMode === 'multi') ? 'block' : 'none';
    }
    
    if (exploreBtn && exploreStatus) {
        if (spaceExplorer.active && spaceExplorer.remainingTime > 0) {
            const mins = Math.floor(spaceExplorer.remainingTime / 60000);
            const secs = Math.floor((spaceExplorer.remainingTime % 60000) / 1000);
            exploreStatus.textContent = `${mins}:${secs.toString().padStart(2,'0')}`;
            exploreStatus.style.color = '#0f0';
        } else {
            exploreStatus.textContent = '';
        }
    }
}

// 타이머 체크 (매 프레임)
function checkAdTimers() {
    const now = Date.now();
    
    if (adBooster.active && now >= adBooster.endTime) {
        adBooster.active = false;
        if (typeof showMessage === 'function') {
            showMessage('⏰ 부스터 효과가 종료되었습니다');
        }
    }
    
    if (emergencyEscapeCharge.charged && now >= emergencyEscapeCharge.chargeEndTime) {
        emergencyEscapeCharge.charged = false;
        if (typeof showMessage === 'function') {
            showMessage('⏰ 긴급탈출 충전이 만료되었습니다');
        }
    }
    
    // 메뉴 버튼 상태 표시
    const menuToggle = document.getElementById('ad-menu-toggle');
    if (menuToggle) {
        if (adBooster.active || emergencyEscapeCharge.charged) {
            menuToggle.style.borderColor = '#0f0';
            menuToggle.style.boxShadow = '0 0 10px #0f0';
        } else {
            menuToggle.style.borderColor = '#0ff';
            menuToggle.style.boxShadow = 'none';
        }
    }
    
    // 긴급탈출 부스터 HUD 표시 (조종 중일 때만)
    const escapeHUD = document.getElementById('warn-escape-ready');
    if (escapeHUD && typeof isPilotMode !== 'undefined') {
        if (isPilotMode && emergencyEscapeCharge.charged) {
            escapeHUD.style.display = 'block';
            // 중력 위험 시 번쩍임
            if (typeof isGravityWarning !== 'undefined' && isGravityWarning) {
                escapeHUD.style.animation = 'escapeFlash 0.5s ease-in-out infinite alternate';
            } else {
                escapeHUD.style.animation = 'none';
            }
        } else {
            escapeHUD.style.display = 'none';
        }
    }
    
    updateAdUI();
}

// 1초마다 타이머 체크 (DOM 로드 후)
document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => {
        setInterval(checkAdTimers, 1000);
    }, 2000);
});

// ===== 천체 정보 표시 (멀티모드용) =====
const BODY_RESOURCES = {
    'SUN': ['수소', '헬륨', '플라즈마 에너지'],
    'MERCURY': ['철', '니켈', '규소', '황'],
    'VENUS': ['황산', '이산화탄소', '질소', '황'],
    'EARTH': ['물', '산소', '철', '금', '석유', '희토류'],
    'MARS': ['철', '마그네슘', '물(얼음)', '이산화탄소', '규소'],
    'JUPITER': ['수소', '헬륨', '메탄', '암모니아'],
    'SATURN': ['수소', '헬륨', '암모니아', '메탄'],
    'URANUS': ['메탄', '수소', '헬륨', '얼음', '암모니아'],
    'NEPTUNE': ['메탄', '수소', '헬륨', '다이아몬드', '얼음'],
    'MOON': ['헬륨-3', '티타늄', '철', '물(얼음)', '알루미늄'],
    'TITAN': ['메탄', '에탄', '질소', '물(얼음)', '유기물'],
    'EUROPA': ['물(얼음)', '산소', '소금', '황산마그네슘'],
    'GANYMEDE': ['물(얼음)', '철', '규소', '마그네슘'],
    'CALLISTO': ['물(얼음)', '암석', '이산화탄소'],
    'IO': ['황', '이산화황', '규소', '나트륨'],
    'ENCELADUS': ['물(얼음)', '유기물', '소금', '수소'],
    'TRITON': ['질소(얼음)', '메탄', '물(얼음)', '이산화탄소'],
    'PLUTO': ['질소(얼음)', '메탄(얼음)', '물(얼음)'],
    'CERES': ['물(얼음)', '암모니아', '탄산염'],
    'PHOBOS': ['철', '탄소', '규소'],
    'DEIMOS': ['탄소', '규소', '철']
};

// 테라포밍 상태 데이터
const BODY_TERRAFORMING = {
    'EARTH': { percent: 100, status: '완전 생태계', phase: '유지' },
    'MOON': { percent: 8, status: '돔 기지 건설 중', phase: '1단계' },
    'MARS': { percent: 3, status: '대기 증가 중', phase: '1단계' },
    'VENUS': { percent: 0.1, status: '대기 냉각 연구 중', phase: '계획' },
    'TITAN': { percent: 0.5, status: '메탄 호수 연구 중', phase: '탐사' },
    'EUROPA': { percent: 1, status: '얼음 아래 해양 탐사', phase: '탐사' },
    'GANYMEDE': { percent: 0.2, status: '자기장 연구 중', phase: '계획' },
    'ENCELADUS': { percent: 0.3, status: '열수구 탐사', phase: '탐사' },
    'default': { percent: 0, status: '미탐사', phase: '-' }
};

// 인프라 데이터
const BODY_INFRASTRUCTURE = {
    'EARTH': { 
        spaceport: true, refuel: true, repair: true, shop: true, research: true, mining: true,
        description: '완전한 문명 인프라'
    },
    'MOON': { 
        spaceport: true, refuel: true, repair: true, shop: false, research: true, mining: true,
        description: '달 기지 (아르테미스)'
    },
    'MARS': { 
        spaceport: true, refuel: true, repair: false, shop: false, research: true, mining: false,
        description: '화성 전초기지'
    },
    'ISS': { 
        spaceport: true, refuel: true, repair: true, shop: true, research: true, mining: false,
        description: '국제우주정거장'
    },
    'EUROPA': { 
        spaceport: false, refuel: false, repair: false, shop: false, research: true, mining: false,
        description: '유로파 탐사선'
    },
    'TITAN': { 
        spaceport: false, refuel: false, repair: false, shop: false, research: true, mining: false,
        description: '타이탄 착륙선'
    },
    'default': { 
        spaceport: false, refuel: false, repair: false, shop: false, research: false, mining: false,
        description: '인프라 없음'
    }
};

// 식민지 상태
const BODY_COLONY_STATUS = {
    'EARTH': { status: '모행성', population: '80억', level: '5' },
    'MOON': { status: '기지 건설 중', population: '1,200명', level: '2' },
    'MARS': { status: '초기 정착', population: '150명', level: '1' },
    'ISS': { status: '운영 중', population: '7명', level: '3' },
    'default': { status: '미개척', population: '0명', level: '0' }
};

// 천체 물리 데이터
const BODY_PHYSICS = {
    'SUN': { gravity: '274 m/s²', temp: '5,500°C (표면)' },
    'MERCURY': { gravity: '3.7 m/s²', temp: '-180~430°C' },
    'VENUS': { gravity: '8.87 m/s²', temp: '465°C' },
    'EARTH': { gravity: '9.8 m/s²', temp: '-89~57°C' },
    'MARS': { gravity: '3.72 m/s²', temp: '-140~20°C' },
    'JUPITER': { gravity: '24.79 m/s²', temp: '-145°C' },
    'SATURN': { gravity: '10.44 m/s²', temp: '-178°C' },
    'URANUS': { gravity: '8.69 m/s²', temp: '-224°C' },
    'NEPTUNE': { gravity: '11.15 m/s²', temp: '-218°C' },
    'MOON': { gravity: '1.62 m/s²', temp: '-173~127°C' },
    'TITAN': { gravity: '1.35 m/s²', temp: '-179°C' },
    'EUROPA': { gravity: '1.31 m/s²', temp: '-160°C' },
    'GANYMEDE': { gravity: '1.43 m/s²', temp: '-163°C' },
    'IO': { gravity: '1.79 m/s²', temp: '-143°C' },
    'ENCELADUS': { gravity: '0.11 m/s²', temp: '-198°C' },
    'TRITON': { gravity: '0.78 m/s²', temp: '-235°C' },
    'PLUTO': { gravity: '0.62 m/s²', temp: '-229°C' },
    'default': { gravity: '알 수 없음', temp: '알 수 없음' }
};

function showBodyInfo(bodyName, bodyData) {
    const modal = document.getElementById('body-info-modal');
    
    // 대소문자 통일 (대문자로)
    const keyName = bodyName.toUpperCase();
    
    // 한글 이름 매핑
    const KOREAN_NAMES = {
        'SUN': '태양', 'MERCURY': '수성', 'VENUS': '금성', 'EARTH': '지구', 'MARS': '화성',
        'JUPITER': '목성', 'SATURN': '토성', 'URANUS': '천왕성', 'NEPTUNE': '해왕성',
        'MOON': '달', 'PHOBOS': '포보스', 'DEIMOS': '데이모스',
        'IO': '이오', 'EUROPA': '유로파', 'GANYMEDE': '가니메데', 'CALLISTO': '칼리스토',
        'TITAN': '타이탄', 'ENCELADUS': '엔셀라두스', 'MIMAS': '미마스', 
        'RHEA': '레아', 'DIONE': '디오네', 'IAPETUS': '이아페투스',
        'TITANIA': '티타니아', 'OBERON': '오베론', 'MIRANDA': '미란다', 
        'ARIEL': '아리엘', 'UMBRIEL': '움브리엘',
        'TRITON': '트리톤', 'PLUTO': '명왕성', 'CHARON': '카론', 
        'CERES': '세레스', 'ERIS': '에리스', 'ISS': '국제우주정거장'
    };
    
    // 유형 한글 매핑
    const TYPE_NAMES = {
        'star': '항성', 'planet': '행성', 'moon': '위성', 
        'dwarf': '왜소행성', 'asteroid': '소행성', 'station': '우주정거장'
    };
    
    // 번역된 이름 가져오기
    const translatedName = translateBodyName(bodyName);
    
    // 기본 정보
    document.getElementById('body-info-name').textContent = translatedName;
    document.getElementById('info-type').textContent = TYPE_NAMES[bodyData.type] || bodyData.type || t('unknownValue');
    document.getElementById('info-radius').textContent = bodyData.radius ? (bodyData.radius * 1000).toLocaleString() : '-';
    document.getElementById('info-mass').textContent = bodyData.mass ? bodyData.mass.toExponential(2) + ' kg' : '-';
    document.getElementById('info-orbit').textContent = bodyData.orbitPeriod ? bodyData.orbitPeriod.toFixed(1) + ' ' + t('days') : '-';
    
    // 물리 데이터
    const physics = BODY_PHYSICS[keyName] || BODY_PHYSICS['default'];
    document.getElementById('info-gravity').textContent = physics.gravity === '알 수 없음' ? t('unknownValue') : physics.gravity;
    document.getElementById('info-temp').textContent = physics.temp === '알 수 없음' ? t('unknownValue') : physics.temp;
    
    // 테라포밍 상태
    const terraform = BODY_TERRAFORMING[keyName] || BODY_TERRAFORMING['default'];
    document.getElementById('info-terraform-bar').style.width = terraform.percent + '%';
    document.getElementById('info-terraform-percent').textContent = terraform.percent + '%';
    document.getElementById('info-terraform-status').textContent = `${terraform.status} (${terraform.phase})`;
    
    // 인프라
    const infra = BODY_INFRASTRUCTURE[keyName] || BODY_INFRASTRUCTURE['default'];
    const infraHTML = `
        <div style="color: ${infra.spaceport ? '#0f0' : '#555'};">🚀 ${t('infraSpaceport')}: ${infra.spaceport ? 'O' : 'X'}</div>
        <div style="color: ${infra.refuel ? '#0f0' : '#555'};">⛽ ${t('infraFuel')}: ${infra.refuel ? 'O' : 'X'}</div>
        <div style="color: ${infra.repair ? '#0f0' : '#555'};">🔧 ${t('infraRepair')}: ${infra.repair ? 'O' : 'X'}</div>
        <div style="color: ${infra.shop ? '#0f0' : '#555'};">🛒 ${t('infraShop')}: ${infra.shop ? 'O' : 'X'}</div>
        <div style="color: ${infra.research ? '#0f0' : '#555'};">🔬 ${t('infraResearch')}: ${infra.research ? 'O' : 'X'}</div>
        <div style="color: ${infra.mining ? '#0f0' : '#555'};">⛏️ ${t('infraMining')}: ${infra.mining ? 'O' : 'X'}</div>
    `;
    document.getElementById('info-infrastructure').innerHTML = infraHTML;
    
    // 자원 (태그 스타일로)
    const resources = BODY_RESOURCES[keyName] || ['정보 없음'];
    const resourceColors = ['#f0f', '#0ff', '#ff0', '#0f0', '#f90', '#f55'];
    const resourceHTML = resources.map((r, i) => 
        `<span style="background: ${resourceColors[i % resourceColors.length]}33; color: ${resourceColors[i % resourceColors.length]}; padding: 3px 8px; border-radius: 10px; font-size: 0.8em; border: 1px solid ${resourceColors[i % resourceColors.length]}55;">${r}</span>`
    ).join('');
    document.getElementById('info-resources').innerHTML = resourceHTML;
    
    // 식민지 정보
    const colony = BODY_COLONY_STATUS[keyName] || BODY_COLONY_STATUS['default'];
    document.getElementById('info-colony').textContent = colony.status;
    document.getElementById('info-population').textContent = colony.population;
    
    // 인공위성 수 계산
    let satelliteCount = 0;
    if (typeof bodies !== 'undefined') {
        bodies.forEach(b => {
            if (b.parent && (b.parent.name === bodyName || b.parent.name === koreanName)) satelliteCount++;
        });
    }
    document.getElementById('info-satellites').textContent = satelliteCount;
    
    // 이동 버튼 이벤트
    document.getElementById('body-info-goto').onclick = () => {
        modal.style.display = 'none';
        // 해당 천체로 포커스
        if (typeof bodies !== 'undefined') {
            const targetBody = bodies.find(b => 
                b.name === bodyName || 
                b.name === koreanName || 
                b.name.toUpperCase() === keyName
            );
            if (targetBody) {
                focusedBody = targetBody;
                if (typeof showMessage === 'function') showMessage(`🎯 ${koreanName}(으)로 이동합니다`);
            }
        }
    };
    
    modal.style.display = 'block';
}

// 멀티모드에서 도감 제목 변경
function updateCatalogTitle() {
    const title = document.getElementById('catalog-title');
    if (title) {
        if (window.gameMode === 'multi') {
            title.textContent = '🌌 태양계 천체 정보';
        } else {
            title.textContent = '🌌 천체 도감 (클릭하여 생성)';
        }
    }
}

// 광고 모달 이벤트 (DOM 로드 후)
document.addEventListener('DOMContentLoaded', function() {
    setTimeout(() => {
        // 광고 모달 토글
        const adMenuToggle = document.getElementById('ad-menu-toggle');
        const adModalMenu = document.getElementById('ad-modal-menu');
        const adModalClose = document.getElementById('ad-modal-close');
        const adBoosterBtn = document.getElementById('ad-booster-btn');
        const adEscapeBtn = document.getElementById('ad-escape-btn');
        const adExploreBtn = document.getElementById('ad-explore-btn');
        
        if (adMenuToggle) {
            adMenuToggle.addEventListener('click', function() {
                if (adModalMenu) {
                    adModalMenu.style.display = 'flex';
                    updateAdUI();
                }
            });
        }
        
        if (adModalClose) {
            adModalClose.addEventListener('click', function() {
                if (adModalMenu) adModalMenu.style.display = 'none';
            });
        }
        
        // 모달 배경 클릭 시 닫기
        if (adModalMenu) {
            adModalMenu.addEventListener('click', function(e) {
                if (e.target === this) {
                    this.style.display = 'none';
                }
            });
        }
        
        // 광고 버튼 이벤트
        if (adBoosterBtn) {
            adBoosterBtn.addEventListener('click', function() {
                if (!adBooster.active) {
                    if (adModalMenu) adModalMenu.style.display = 'none';
                    watchAdForBooster();
                }
            });
        }
        
        if (adEscapeBtn) {
            adEscapeBtn.addEventListener('click', function() {
                if (!emergencyEscapeCharge.charged) {
                    if (adModalMenu) adModalMenu.style.display = 'none';
                    watchAdForEscape();
                }
            });
        }
        
        if (adExploreBtn) {
            adExploreBtn.addEventListener('click', function() {
                if (adModalMenu) adModalMenu.style.display = 'none';
                watchAdForExplore();
            });
        }
        
        console.log('광고 시스템 이벤트 초기화 완료');
    }, 500);
});

// ===== 중력 위험 분석 시스템 =====
const G_CONST = 6.674e-11;  // 중력 상수

function analyzeGravityDanger() {
    if (!playerShip || !playerShip.mesh) return null;
    
    const shipPos = playerShip.mesh.position;
    let mostDangerous = null;
    let maxDanger = 0;
    
    // 모든 천체에 대해 위험도 계산
    if (typeof celestialBodies !== 'undefined') {
        celestialBodies.forEach(body => {
            if (!body.mesh) return;
            
            const bodyPos = body.mesh.position;
            const dist = shipPos.distanceTo(bodyPos);
            const mass = body.mass || 1e24;
            const dangerRadius = (body.radius || 1) * 50;  // 위험 반경
            
            if (dist < dangerRadius) {
                // 위험도 = 질량 / 거리^2 * (위험반경/거리)
                const danger = (mass / (dist * dist)) * (dangerRadius / dist);
                
                if (danger > maxDanger) {
                    maxDanger = danger;
                    mostDangerous = {
                        body: body,
                        dist: dist,
                        mass: mass,
                        radius: body.radius || 1
                    };
                }
            }
        });
    }
    
    return mostDangerous;
}

function calculateEscapeRecommendation(dangerInfo) {
    if (!dangerInfo || !playerShip || !playerShip.mesh) return null;
    
    const { body, dist, mass } = dangerInfo;
    const bodyPos = body.mesh.position;
    const shipPos = playerShip.mesh.position;
    
    // 탈출 속도 계산 (간소화된 버전)
    const escapeVelocity = Math.sqrt(2 * mass * G_CONST / (dist * 1000)) / 1000;  // km/s
    const scaledEscapeVel = Math.min(escapeVelocity * 0.001, 100);  // 스케일 조정
    
    const currentSpeed = Math.abs(playerShip.speed);
    const speedDeficit = Math.max(0, scaledEscapeVel - currentSpeed);
    
    // 탈출 방향 계산 (천체 반대 방향)
    const escapeDir = new window.THREE.Vector3().subVectors(shipPos, bodyPos).normalize();
    
    // 현재 우주선 방향
    const shipDir = new window.THREE.Vector3(0, 0, -1);
    shipDir.applyQuaternion(playerShip.mesh.quaternion);
    
    // 필요 회전 각도
    const angleToEscape = Math.acos(Math.max(-1, Math.min(1, shipDir.dot(escapeDir)))) * 180 / Math.PI;
    
    // 회전 방향 (좌/우)
    const cross = new window.THREE.Vector3().crossVectors(shipDir, escapeDir);
    const turnDirection = cross.y > 0 ? '좌측' : '우측';
    
    return {
        escapeVelocity: scaledEscapeVel,
        currentSpeed: currentSpeed,
        speedDeficit: speedDeficit,
        angleToEscape: angleToEscape,
        turnDirection: turnDirection,
        bodyName: body.name || '알 수 없는 천체'
    };
}

function updateGravityWarningHUD() {
    if (!window.isPilotMode) {
        const hud = document.getElementById('gravity-hud-warning');
        if (hud) hud.style.display = 'none';
        return;
    }
    
    const dangerInfo = analyzeGravityDanger();
    const hud = document.getElementById('gravity-hud-warning');
    
    if (!dangerInfo) {
        if (hud) hud.style.display = 'none';
        return;
    }
    
    const recommendation = calculateEscapeRecommendation(dangerInfo);
    if (!recommendation || recommendation.speedDeficit <= 0) {
        if (hud) hud.style.display = 'none';
        return;
    }
    
    // HUD 표시
    if (hud) {
        hud.style.display = 'block';
        document.getElementById('gravity-body-name').textContent = recommendation.bodyName;
        document.getElementById('gravity-escape-vel').textContent = recommendation.escapeVelocity.toFixed(1);
        document.getElementById('gravity-current-vel').textContent = recommendation.currentSpeed.toFixed(1);
        document.getElementById('gravity-deficit').textContent = recommendation.speedDeficit.toFixed(1);
        document.getElementById('gravity-turn-dir').textContent = recommendation.turnDirection;
        document.getElementById('gravity-turn-angle').textContent = Math.round(recommendation.angleToEscape);
    }
}

// 1초마다 중력 경고 업데이트
document.addEventListener('DOMContentLoaded', () => {
    setInterval(updateGravityWarningHUD, 1000);
});

// ★★★ 좌표 복사 기능 (멀티모드) ★★★
document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => {
        const coordsPanel = document.getElementById('pilot-coords-panel');
        if (coordsPanel) {
            coordsPanel.addEventListener('click', async () => {
                if (!playerShip || !playerShip.mesh) return;
                
                const pos = playerShip.mesh.position;
                const coordsText = `X: ${pos.x.toFixed(1)}, Y: ${pos.y.toFixed(1)}, Z: ${pos.z.toFixed(1)}`;
                
                try {
                    await navigator.clipboard.writeText(coordsText);
                    coordsPanel.classList.add('copied');
                    const label = coordsPanel.querySelector('.coords-label');
                    const originalText = label.textContent;
                    label.textContent = '✅ 복사됨!';
                    
                    setTimeout(() => {
                        coordsPanel.classList.remove('copied');
                        label.textContent = originalText;
                    }, 1500);
                    
                    showMsg('📋 좌표가 클립보드에 복사되었습니다!');
                } catch (err) {
                    showMsg('❌ 좌표 복사 실패');
                }
            });
        }
    }, 1000);
});

// ★★★ 우주선 마지막 위치 저장/로드 시스템 ★★★
const ShipPositionManager = {
    // ★ 게임 모드별 저장 키 반환
    getStorageKey: function() {
        const mode = window.gameMode || 'single';
        return `milkyway-ship-position-${mode}`;
    },
    
    // 현재 우주선 위치 저장
    save: function() {
        if (!playerShip || !playerShip.mesh || !window.currentUser) return;
        
        const data = {
            userId: window.currentUser.id || window.currentUser.email,
            gameMode: window.gameMode || 'single',  // ★ 게임 모드도 저장
            position: {
                x: playerShip.mesh.position.x,
                y: playerShip.mesh.position.y,
                z: playerShip.mesh.position.z
            },
            rotation: {
                x: playerShip.mesh.rotation.x,
                y: playerShip.mesh.rotation.y,
                z: playerShip.mesh.rotation.z
            },
            shipType: window.currentShipType ? window.currentShipType.id : 'shuttle',
            shipName: window.currentShipType ? window.currentShipType.name : '셔틀',
            fuel: playerShip.fuel,
            speed: playerShip.speed,
            timestamp: Date.now()
        };
        
        localStorage.setItem(this.getStorageKey(), JSON.stringify(data));
        console.log(`우주선 위치 저장됨 (${data.gameMode}):`, data.position);
    },
    
    // 저장된 우주선 위치 로드
    load: function() {
        const saved = localStorage.getItem(this.getStorageKey());
        if (!saved) return null;
        
        try {
            const data = JSON.parse(saved);
            // 24시간 이내 데이터만 유효
            if (Date.now() - data.timestamp > 24 * 60 * 60 * 1000) {
                localStorage.removeItem(this.getStorageKey());
                return null;
            }
            // ★ 게임 모드 확인 (혹시 잘못된 데이터 방지)
            const currentMode = window.gameMode || 'single';
            if (data.gameMode && data.gameMode !== currentMode) {
                return null;
            }
            return data;
        } catch (e) {
            return null;
        }
    },
    
    // 저장된 위치 삭제
    clear: function() {
        localStorage.removeItem(this.getStorageKey());
    },
    
    // 저장된 위치에서 탑승
    restoreShip: function(data) {
        if (!data || !playerShip || !playerShip.mesh) return false;
        
        playerShip.mesh.position.set(data.position.x, data.position.y, data.position.z);
        playerShip.mesh.rotation.set(data.rotation.x, data.rotation.y, data.rotation.z);
        playerShip.fuel = data.fuel || SHIP_CONFIG.maxFuel;
        playerShip.speed = 0;  // 속도는 0으로 시작
        
        showMsg(`🚀 ${data.shipName}에 탑승했습니다!`);
        console.log('우주선 위치 복원됨:', data.position);
        return true;
    }
};

// 우주선 위치 자동 저장 (10초마다)
setInterval(() => {
    if (window.isPilotMode && playerShip && playerShip.mesh && window.currentUser && !playerShip.isDocked) {
        ShipPositionManager.save();
    }
}, 10000);

// 페이지 종료 시 저장
window.addEventListener('beforeunload', () => {
    if (window.isPilotMode && playerShip && playerShip.mesh && window.currentUser) {
        ShipPositionManager.save();
    }
});

// ★★★ 저장된 우주선 위치 안내 모달 ★★★
function showSavedShipPrompt() {
    const savedData = ShipPositionManager.load();
    if (!savedData) return false;
    
    // 현재 로그인 사용자와 일치하는지 확인
    if (window.currentUser && (window.currentUser.id === savedData.userId || window.currentUser.email === savedData.userId)) {
        const pos = savedData.position;
        const coordsStr = `X: ${pos.x.toFixed(0)}, Y: ${pos.y.toFixed(0)}, Z: ${pos.z.toFixed(0)}`;
        
        // 안내 모달 표시
        const modal = document.createElement('div');
        modal.id = 'saved-ship-modal';
        modal.innerHTML = `
            <div class="saved-ship-content">
                <div class="saved-ship-icon">🚀</div>
                <div class="saved-ship-title">${t('savedShipFound')}</div>
                <div class="saved-ship-info">
                    <div class="ship-name">${savedData.shipName}</div>
                    <div class="ship-coords">📍 ${coordsStr}</div>
                    <div class="ship-fuel">${t('fuelPercent')}: ${Math.round(savedData.fuel)}%</div>
                </div>
                <div class="saved-ship-buttons">
                    <button id="btn-restore-ship" class="restore-btn">🚀 ${t('restoreShip')}</button>
                    <button id="btn-new-ship" class="new-btn">🛸 ${t('newShipStart')}</button>
                </div>
            </div>
        `;
        modal.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); display: flex; align-items: center;
            justify-content: center; z-index: 100000;
        `;
        document.body.appendChild(modal);
        
        // 스타일 추가
        const style = document.createElement('style');
        style.textContent = `
            .saved-ship-content {
                background: linear-gradient(135deg, rgba(0,40,80,0.95) 0%, rgba(0,20,50,0.98) 100%);
                border: 2px solid #00aaff; border-radius: 15px; padding: 30px;
                text-align: center; max-width: 350px;
                box-shadow: 0 0 30px rgba(0,170,255,0.4);
                animation: fadeIn 0.3s;
            }
            .saved-ship-icon { font-size: 50px; margin-bottom: 10px; }
            .saved-ship-title { font-size: 20px; color: #00aaff; font-family: 'Orbitron', sans-serif; margin-bottom: 15px; }
            .saved-ship-info { background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px; margin-bottom: 20px; }
            .ship-name { font-size: 16px; color: #fff; font-weight: bold; margin-bottom: 8px; }
            .ship-coords { font-size: 12px; color: #00ff88; font-family: monospace; margin-bottom: 5px; }
            .ship-fuel { font-size: 12px; color: #ffaa00; }
            .saved-ship-buttons { display: flex; flex-direction: column; gap: 10px; }
            .restore-btn { background: linear-gradient(135deg, #0088ff, #00aaff); color: #fff; border: none;
                padding: 12px 20px; border-radius: 8px; font-size: 14px; cursor: pointer; font-family: 'Orbitron', sans-serif; }
            .restore-btn:hover { background: linear-gradient(135deg, #00aaff, #00ccff); }
            .new-btn { background: transparent; color: #888; border: 1px solid #555;
                padding: 10px 20px; border-radius: 8px; font-size: 12px; cursor: pointer; }
            .new-btn:hover { border-color: #888; color: #aaa; }
            @keyframes fadeIn { from { opacity: 0; transform: scale(0.9); } to { opacity: 1; transform: scale(1); } }
        `;
        document.head.appendChild(style);
        
        // 버튼 이벤트
        document.getElementById('btn-restore-ship').onclick = () => {
            modal.remove();
            // 우주선 생성 후 위치 복원
            setTimeout(() => {
                if (ShipPositionManager.restoreShip(savedData)) {
                    isPilotMode = true;
                    enterCockpitView();
                }
            }, 500);
        };
        
        document.getElementById('btn-new-ship').onclick = () => {
            ShipPositionManager.clear();
            modal.remove();
            // 정상적인 로그인 흐름
        };
        
        return true;
    }
    return false;
}

// 로그인 시 저장된 우주선 확인
window.checkSavedShipOnLogin = function() {
    if (window.currentUser) {
        setTimeout(() => {
            showSavedShipPrompt();
        }, 1000);
    }
};

// ===== 사운드 슬라이드 컨트롤 (DOM 로드 후) =====
document.addEventListener('DOMContentLoaded', function() {
    setTimeout(() => {
        // ★★★ BGM 자동 재생 (첫 사용자 상호작용 후) ★★★
        const startBgmOnce = () => {
            if (typeof SpaceAudio !== 'undefined' && !SpaceAudio.isPlaying) {
                SpaceAudio.playSpace();
                const soundOnoff = document.getElementById('sound-onoff');
                if (soundOnoff) {
                    soundOnoff.textContent = '🔊';
                    soundOnoff.classList.add('on');
                }
                console.log('🎵 BGM 자동 재생 시작');
            }
            // 이벤트 제거 (한 번만 실행)
            document.removeEventListener('click', startBgmOnce);
            document.removeEventListener('touchstart', startBgmOnce);
            document.removeEventListener('keydown', startBgmOnce);
        };
        
        // 첫 상호작용 시 BGM 시작 (브라우저 자동재생 정책 우회)
        document.addEventListener('click', startBgmOnce);
        document.addEventListener('touchstart', startBgmOnce);
        document.addEventListener('keydown', startBgmOnce);
        
        // 천체 정보 모달 닫기
        const bodyInfoClose = document.getElementById('body-info-close');
        if (bodyInfoClose) {
            bodyInfoClose.addEventListener('click', () => {
                const modal = document.getElementById('body-info-modal');
                if (modal) modal.style.display = 'none';
            });
        }
        
        // 화살표 클릭: 슬라이드 열기/닫기
        const soundArrow = document.getElementById('sound-arrow');
        if (soundArrow) {
            soundArrow.addEventListener('click', function() {
                const slide = document.getElementById('sound-slide');
                if (!slide) return;
                const isCollapsed = slide.classList.contains('collapsed');
                
                if (isCollapsed) {
                    slide.classList.remove('collapsed');
                    slide.classList.add('expanded');
                    this.textContent = '▶';
                } else {
                    slide.classList.remove('expanded');
                    slide.classList.add('collapsed');
                    this.textContent = '◀';
                }
            });
        }
        
        // ON/OFF 버튼
        const soundOnoff = document.getElementById('sound-onoff');
        if (soundOnoff) {
            soundOnoff.addEventListener('click', function() {
                if (typeof SpaceAudio !== 'undefined') {
                    if (SpaceAudio.isPlaying) {
                        SpaceAudio.stop();
                        this.textContent = '🔇';
                        this.classList.remove('on');
                    } else {
                        SpaceAudio.playSpace();
                        this.textContent = '🔊';
                        this.classList.add('on');
                    }
                }
            });
        }
        
        // 볼륨 슬라이더
        const soundSlider = document.getElementById('sound-slider');
        if (soundSlider) {
            soundSlider.addEventListener('input', function() {
                const vol = this.value / 100;
                const valDisplay = document.getElementById('sound-val');
                if (valDisplay) valDisplay.textContent = this.value + '%';
                if (typeof SpaceAudio !== 'undefined') {
                    SpaceAudio.setVolume(vol);
                }
            });
        }
        
        console.log('사운드 컨트롤 초기화 완료');
    }, 500);
});

// ===== 망원경 모드 (완전 개선) =====
const telescopeMode = {
    active: false,
    zoom: 1,
    baseMaxZoom: 20,      // 기본 최대 줌
    maxZoom: 20,          // 현재 최대 줌 (업그레이드에 따라 변경)
    originalFOV: 75,
    equippedTelescope: 'basic',  // basic, advanced, professional
    fineControl: { x: 0, y: 0 },
    originalCameraParent: null,
    originalControlsEnabled: true
};

// 망원경 업그레이드 정보
const telescopeUpgrades = {
    basic: { name: '기본 망원경', maxZoom: 20, price: 0, owned: true, description: '기본 장착. 20배 줌.' },
    standard: { name: '표준 망원경', maxZoom: 30, price: 2000, owned: false, description: '30배 줌. 향상된 성능.' },
    advanced: { name: '고급 망원경', maxZoom: 50, price: 5000, owned: false, description: '50배 줌. 선명한 화질.' },
    professional: { name: '전문가 망원경', maxZoom: 100, price: 15000, owned: false, description: '100배 줌. 최고 성능.' }
};

function enterTelescopeMode() {
    // ★ 우주 모드(외부 뷰)에서만 망원경 사용 가능
    if (window.isPilotMode) {
        if (typeof showMsg === 'function') showMsg('🔭 우주 모드에서만 망원경을 사용할 수 있습니다. (V키로 전환)');
        return;
    }
    
    if (!playerShip) {
        if (typeof showMsg === 'function') showMsg('우주선에 탑승해야 망원경을 사용할 수 있습니다.');
        return;
    }
    
    // ★ camera 확인
    if (!window.camera) {
        if (typeof showMsg === 'function') showMsg('카메라 초기화 대기 중...');
        return;
    }
    
    telescopeMode.active = true;
    telescopeMode.originalFOV = window.camera.fov;
    telescopeMode.zoom = 1;
    
    // 현재 장착된 망원경에 따른 최대 줌 설정
    const equipped = telescopeUpgrades[telescopeMode.equippedTelescope];
    telescopeMode.maxZoom = equipped ? equipped.maxZoom : 20;
    
    // UI 업데이트
    updateTelescopeUI();
    
    // 오버레이 표시
    document.getElementById('telescope-overlay').style.display = 'flex';
    
    // 슬라이더 최대값 업데이트
    const slider = document.getElementById('telescope-zoom-slider');
    if (slider) {
        slider.max = telescopeMode.maxZoom;
        slider.value = 1;
    }
    
    // OrbitControls 비활성화 (망원경 전용 컨트롤 사용)
    if (window.controls) {
        telescopeMode.originalControlsEnabled = window.controls.enabled;
        window.controls.enabled = false;
    }
    
    if (typeof showMsg === 'function') showMsg('🔭 망원경 모드 - 드래그로 시점 이동, 휠로 줌');
}

function exitTelescopeMode() {
    telescopeMode.active = false;
    telescopeMode.zoom = 1;
    if (window.camera) {
        window.camera.fov = telescopeMode.originalFOV || 60;
        window.camera.updateProjectionMatrix();
    }
    document.getElementById('telescope-overlay').style.display = 'none';
    
    // OrbitControls 복원
    if (window.controls) {
        window.controls.enabled = telescopeMode.originalControlsEnabled !== false;
    }
    
    if (typeof showMsg === 'function') showMsg('망원경 모드 종료');
}

function updateTelescopeZoom(zoom) {
    if (!window.camera) return;
    telescopeMode.zoom = Math.max(1, Math.min(telescopeMode.maxZoom, zoom));
    window.camera.fov = telescopeMode.originalFOV / telescopeMode.zoom;
    window.camera.updateProjectionMatrix();
    
    // UI 업데이트
    const zoomValue = document.getElementById('telescope-zoom-value');
    const zoomDisplay = document.getElementById('telescope-zoom-display');
    const slider = document.getElementById('telescope-zoom-slider');
    
    if (zoomValue) zoomValue.textContent = telescopeMode.zoom.toFixed(1) + 'x';
    if (zoomDisplay) zoomDisplay.textContent = telescopeMode.zoom.toFixed(1);
    if (slider) slider.value = telescopeMode.zoom;
    
    // 줌에 따른 렌즈 효과 변경
    updateTelescopeLensEffect();
}

function updateTelescopeLensEffect() {
    const lens = document.getElementById('telescope-lens');
    if (!lens) return;
    
    // 줌이 높을수록 비네팅 범위 확대
    const vignetteSize = 25 + (telescopeMode.zoom / telescopeMode.maxZoom) * 15;
    lens.style.background = `radial-gradient(circle at center, 
        transparent 0%, 
        transparent ${vignetteSize}%, 
        rgba(0,0,0,0.3) ${vignetteSize + 10}%, 
        rgba(0,0,0,0.7) ${vignetteSize + 20}%, 
        rgba(0,0,0,0.95) ${vignetteSize + 30}%)`;
}

function updateTelescopeUI() {
    // 최대 줌 표시
    const maxZoomDisplay = document.getElementById('telescope-max-zoom-display');
    if (maxZoomDisplay) maxZoomDisplay.textContent = telescopeMode.maxZoom;
    
    // 장착된 망원경 정보
    const equipped = telescopeUpgrades[telescopeMode.equippedTelescope];
    const equippedName = document.getElementById('telescope-equipped-name');
    if (equippedName && equipped) {
        equippedName.textContent = `${equipped.name} (${equipped.maxZoom}x)`;
    }
    
    // 프리셋 버튼 업데이트
    document.querySelectorAll('.telescope-preset-btn').forEach(btn => {
        const zoom = parseInt(btn.dataset.zoom);
        if (zoom <= telescopeMode.maxZoom) {
            btn.classList.remove('locked');
            btn.style.background = '#1a3a5c';
            btn.style.color = '#fff';
            btn.style.border = '1px solid #00aaff';
            btn.style.cursor = 'pointer';
            btn.textContent = btn.textContent.replace('🔒 ', '');
        } else {
            btn.classList.add('locked');
            btn.style.background = '#333';
            btn.style.color = '#888';
            btn.style.border = '1px solid #555';
            btn.style.cursor = 'not-allowed';
            if (!btn.textContent.startsWith('🔒')) {
                btn.textContent = '🔒 ' + btn.textContent;
            }
        }
    });
}

// 망원경 구매 함수
function buyTelescopeUpgrade(type) {
    const upgrade = telescopeUpgrades[type];
    if (!upgrade) return false;
    
    if (upgrade.owned) {
        showMsg('이미 보유한 망원경입니다.');
        return false;
    }
    
    const userCoins = getUserCoins();
    if (userCoins < upgrade.price) {
        showMsg(`코인이 부족합니다. (필요: ${upgrade.price}, 보유: ${userCoins})`);
        return false;
    }
    
    // 코인 차감
    if (typeof addCoins === 'function') {
        addCoins(-upgrade.price);
    }
    
    // 구매 완료
    upgrade.owned = true;
    telescopeMode.equippedTelescope = type;
    telescopeMode.maxZoom = upgrade.maxZoom;
    
    // 서버에 저장 (프로필 업데이트)
    if (window.supabaseClient && window.mpUserId) {
        window.supabaseClient
            .from('profiles')
            .update({ 
                telescope_level: type,
                telescope_owned: Object.keys(telescopeUpgrades).filter(k => telescopeUpgrades[k].owned)
            })
            .eq('id', window.mpUserId)
            .then(() => console.log('망원경 업그레이드 저장됨'))
            .catch(e => console.warn('망원경 저장 실패:', e));
    }
    
    showMsg(`🔭 ${upgrade.name} 구매 완료! (최대 ${upgrade.maxZoom}배 줌)`);
    return true;
}

// 망원경 장착 함수
function equipTelescope(type) {
    const upgrade = telescopeUpgrades[type];
    if (!upgrade || !upgrade.owned) {
        showMsg('먼저 구매해야 합니다.');
        return false;
    }
    
    telescopeMode.equippedTelescope = type;
    telescopeMode.maxZoom = upgrade.maxZoom;
    
    if (telescopeMode.active) {
        updateTelescopeUI();
        const slider = document.getElementById('telescope-zoom-slider');
        if (slider) slider.max = telescopeMode.maxZoom;
    }
    
    showMsg(`🔭 ${upgrade.name} 장착 완료!`);
    return true;
}

// 타겟 정보 업데이트 (레이캐스트로 바라보는 천체 확인)
function updateTelescopeTarget() {
    if (!telescopeMode.active) return;
    if (!window.THREE || !window.camera) return;  // ★ 방어 코드
    
    const targetInfo = document.getElementById('telescope-target-info');
    if (!targetInfo) return;
    
    // 화면 중앙에서 레이캐스트
    const raycaster = new window.THREE.Raycaster();
    raycaster.setFromCamera(new window.THREE.Vector2(0, 0), window.camera);
    
    // 모든 천체 메시 수집
    const meshes = [];
    if (window.bodies) {
        window.bodies.forEach(b => {
            if (b.mesh) meshes.push({ mesh: b.mesh, name: b.name, body: b });
        });
    }
    if (window.satellites) {
        window.satellites.forEach(s => {
            if (s.mesh) meshes.push({ mesh: s.mesh, name: s.name, body: s });
        });
    }
    
    if (meshes.length === 0) return;  // ★ 메시 없으면 리턴
    
    const intersects = raycaster.intersectObjects(meshes.map(m => m.mesh), true);
    
    if (intersects.length > 0) {
        // 가장 가까운 교차점의 부모 찾기
        let targetMesh = intersects[0].object;
        while (targetMesh.parent && !meshes.find(m => m.mesh === targetMesh)) {
            targetMesh = targetMesh.parent;
        }
        
        const found = meshes.find(m => m.mesh === targetMesh || m.mesh.children.includes(targetMesh));
        if (found) {
            const dist = intersects[0].distance.toFixed(0);
            targetInfo.innerHTML = `타겟: <strong style="color:#ffff00;">${found.name}</strong> (${dist} km)`;
            return;
        }
    }
    
    targetInfo.textContent = t('targetNone');
}

// 망원경 이벤트 리스너 (DOM 로드 후)
document.addEventListener('DOMContentLoaded', function() {
    setTimeout(() => {
        const zoomSlider = document.getElementById('telescope-zoom-slider');
        const closeBtn = document.getElementById('btn-telescope-close');
        
        // 슬라이더 이벤트
        if (zoomSlider) {
            zoomSlider.addEventListener('input', function() {
                updateTelescopeZoom(parseFloat(this.value));
            });
        }
        
        // 닫기 버튼
        if (closeBtn) {
            closeBtn.addEventListener('click', exitTelescopeMode);
        }
        
        // 프리셋 버튼 이벤트
        document.querySelectorAll('.telescope-preset-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                if (this.classList.contains('locked')) {
                    showMsg('이 줌 레벨은 고급 망원경이 필요합니다. 우주정거장에서 구매하세요.');
                    return;
                }
                const zoom = parseFloat(this.dataset.zoom);
                updateTelescopeZoom(zoom);
            });
        });
        
        // 휠 줌 이벤트
        document.getElementById('telescope-overlay')?.addEventListener('wheel', function(e) {
            if (!telescopeMode.active) return;
            e.preventDefault();
            
            const delta = e.deltaY > 0 ? -1 : 1;
            const step = telescopeMode.maxZoom > 50 ? 2 : 1;
            updateTelescopeZoom(telescopeMode.zoom + delta * step);
        }, { passive: false });
        
        // ★★★ 망원경 마우스 드래그 카메라 회전 ★★★
        let telescopeDragging = false;
        let telescopeLastMouse = { x: 0, y: 0 };
        
        document.getElementById('telescope-overlay')?.addEventListener('mousedown', function(e) {
            if (!telescopeMode.active) return;
            telescopeDragging = true;
            telescopeLastMouse = { x: e.clientX, y: e.clientY };
            e.preventDefault();
        });
        
        document.addEventListener('mouseup', function() {
            telescopeDragging = false;
        });
        
        document.addEventListener('mousemove', function(e) {
            if (!telescopeMode.active || !telescopeDragging) return;
            if (!window.THREE || !window.camera || !window.controls) return;
            
            const deltaX = e.clientX - telescopeLastMouse.x;
            const deltaY = e.clientY - telescopeLastMouse.y;
            
            // ★ 줌 레벨에 따라 감도 크게 조절 (줌이 높을수록 훨씬 느리게)
            // 기본 감도 0.003, 줌 배율의 제곱에 반비례
            const baseSensitivity = 0.003;
            const sensitivity = baseSensitivity / (telescopeMode.zoom * telescopeMode.zoom * 0.1 + 1);
            
            // 카메라 회전 (OrbitControls와 유사하게)
            if (window.controls.target) {
                // spherical 좌표로 회전
                const offset = new window.THREE.Vector3().copy(window.camera.position).sub(window.controls.target);
                const spherical = new window.THREE.Spherical().setFromVector3(offset);
                
                spherical.theta -= deltaX * sensitivity;
                spherical.phi -= deltaY * sensitivity;
                
                // phi 제한 (0.1 ~ PI - 0.1)
                spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                
                offset.setFromSpherical(spherical);
                window.camera.position.copy(window.controls.target).add(offset);
                window.camera.lookAt(window.controls.target);
            }
            
            telescopeLastMouse = { x: e.clientX, y: e.clientY };
        });
        
        // ★★★ 모바일 터치 드래그 ★★★
        let telescopeTouchStart = { x: 0, y: 0 };
        
        document.getElementById('telescope-overlay')?.addEventListener('touchstart', function(e) {
            if (!telescopeMode.active) return;
            if (e.touches.length === 1) {
                telescopeTouchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }
        }, { passive: true });
        
        document.getElementById('telescope-overlay')?.addEventListener('touchmove', function(e) {
            if (!telescopeMode.active || e.touches.length !== 1) return;
            if (!window.THREE || !window.camera || !window.controls) return;
            
            const deltaX = e.touches[0].clientX - telescopeTouchStart.x;
            const deltaY = e.touches[0].clientY - telescopeTouchStart.y;
            
            // ★ 줌 레벨에 따라 감도 크게 조절 (줌이 높을수록 훨씬 느리게)
            const baseSensitivity = 0.004;
            const sensitivity = baseSensitivity / (telescopeMode.zoom * telescopeMode.zoom * 0.1 + 1);
            
            if (window.controls.target) {
                const offset = new window.THREE.Vector3().copy(window.camera.position).sub(window.controls.target);
                const spherical = new window.THREE.Spherical().setFromVector3(offset);
                
                spherical.theta -= deltaX * sensitivity;
                spherical.phi -= deltaY * sensitivity;
                spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                
                offset.setFromSpherical(spherical);
                window.camera.position.copy(window.controls.target).add(offset);
                window.camera.lookAt(window.controls.target);
            }
            
            telescopeTouchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }, { passive: true });
        
        // 핀치 줌
        let telescopeLastPinchDist = 0;
        
        document.getElementById('telescope-overlay')?.addEventListener('touchstart', function(e) {
            if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                telescopeLastPinchDist = Math.sqrt(dx * dx + dy * dy);
            }
        }, { passive: true });
        
        document.getElementById('telescope-overlay')?.addEventListener('touchmove', function(e) {
            if (!telescopeMode.active || e.touches.length !== 2) return;
            
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (telescopeLastPinchDist > 0) {
                const delta = (dist - telescopeLastPinchDist) * 0.05;
                updateTelescopeZoom(telescopeMode.zoom + delta);
            }
            
            telescopeLastPinchDist = dist;
        }, { passive: true });
        
        // ESC 키로 종료
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && telescopeMode.active) {
                exitTelescopeMode();
            }
        });
        
        // 주기적으로 타겟 정보 업데이트
        setInterval(updateTelescopeTarget, 500);
    }, 500);
});

// ★★★ 멀티모드 튜토리얼 시스템 ★★★
const MultiTutorial = {
    STORAGE_KEY: 'starwalker_tutorial',
    currentStep: 0,
    overlay: null,
    highlightedElement: null,
    savedPosition: '',
    savedZIndex: '',
    
    // 안전하게 현재 언어 가져오기
    getLang() {
        return window.currentLang || (typeof currentLang !== 'undefined' ? currentLang : 'en');
    },
    
    // 다국어 튜토리얼 단계 정의
    getSteps() {
        const lang = this.getLang();
        const isKo = lang === 'ko';
        const isJa = lang === 'ja';
        
        if (isKo) {
            return [
                {
                    id: 'welcome',
                    title: '🌌 STAR·WALKER에 오신 것을 환영합니다!',
                    content: `
                        <p>우주 탐험의 세계에 오신 것을 환영합니다!</p>
                        <p>이 가이드가 기본적인 조작법과 기능을 안내해 드릴게요.</p>
                        <div style="margin-top:15px;padding:10px;background:rgba(0,255,255,0.1);border-radius:8px;">
                            <p style="margin:0;color:#00ffff;">💡 팁: 언제든지 <b>ESC</b> 키를 눌러 가이드를 건너뛸 수 있습니다.</p>
                        </div>
                    `,
                    target: null,
                    position: 'center'
                },
                {
                    id: 'nav-panel',
                    title: '🪐 천체 목록',
                    content: `
                        <p>좌측에서 태양계의 모든 천체를 확인할 수 있습니다.</p>
                        <ul style="margin:10px 0;padding-left:20px;">
                            <li><b>태양</b> - 우리 태양계의 중심</li>
                            <li><b>행성들</b> - 수성, 금성, 지구, 화성 등</li>
                            <li><b>정거장</b> - 연료 보급 및 탐험 거점</li>
                        </ul>
                        <p style="color:#00ff88;">클릭하면 해당 천체로 카메라가 이동합니다.</p>
                    `,
                    target: '#nav-panel',
                    position: 'right'
                },
                {
                    id: 'top-bar',
                    title: '🎛️ 상단 메뉴',
                    content: `
                        <div style="display:grid;gap:10px;">
                            <div><b style="color:#00ff88;">⛽ 정거장</b> - 우주 정거장 목록 보기</div>
                            <div><b style="color:#a855f7;">📚 도감</b> - 발견한 천체 도감 확인</div>
                            <div><b style="color:#00ffff;">🖥️ 전체화면</b> - 몰입감 있는 플레이</div>
                            <div><b style="color:#ff9500;">⏱️ 0.1x</b> - 시간 배속 표시</div>
                        </div>
                    `,
                    target: '#top-bar',
                    position: 'bottom'
                },
                {
                    id: 'login',
                    title: '👤 로그인',
                    content: `
                        <p>우측 상단의 <b style="color:#00ff88;">로그인</b> 버튼을 눌러 계정을 만들거나 로그인하세요.</p>
                        <p style="margin-top:10px;">로그인하면:</p>
                        <ul style="margin:10px 0;padding-left:20px;">
                            <li>다른 플레이어와 함께 탐험</li>
                            <li>진행 상황 저장</li>
                            <li>우주선 소유 및 업그레이드</li>
                        </ul>
                        <p style="margin-top:10px;color:#00ffff;font-size:13px;">💡 이미 로그인되어 있다면 이 단계는 건너뛰세요!</p>
                    `,
                    target: '#btn-login',
                    position: 'left'
                },
                {
                    id: 'boarding',
                    title: '🚀 우주선 탑승',
                    content: `
                        <p>우주선은 <b style="color:#00ffff;">우주 정거장</b>에서 탑승할 수 있습니다.</p>
                        <div style="margin:15px 0;padding:12px;background:rgba(0,255,136,0.15);border:1px solid #00ff88;border-radius:8px;">
                            <p style="margin:0;color:#00ff88;"><b>🌍 첫 우주선 받기</b></p>
                            <p style="margin:8px 0 0 0;">지구 근처의 <b>ISS 우주정거장</b>으로 이동하면<br>첫 우주선을 지급받을 수 있습니다!</p>
                        </div>
                        <div style="margin-top:15px;padding:10px;background:rgba(0,255,255,0.1);border-radius:8px;">
                            <p style="margin:0;"><b>조종 방법:</b></p>
                            <p style="margin:5px 0 0 0;">• <b>W/S</b> 또는 <b>↑/↓</b> - 가속/감속</p>
                            <p style="margin:5px 0 0 0;">• 마우스 드래그 - 방향 전환</p>
                            <p style="margin:5px 0 0 0;">• <b>자동항법</b> - 목적지 자동 비행</p>
                        </div>
                    `,
                    target: null,
                    position: 'center'
                },
                {
                    id: 'complete',
                    title: '🎉 준비 완료!',
                    content: `
                        <p>이제 우주 탐험을 시작할 준비가 되었습니다!</p>
                        <div style="margin-top:15px;display:grid;gap:8px;">
                            <div style="padding:10px;background:rgba(0,255,255,0.1);border-radius:8px;">
                                🎯 <b>미션</b>: 천체를 방문하면 ✓ 표시가 됩니다
                            </div>
                            <div style="padding:10px;background:rgba(255,149,0,0.1);border-radius:8px;">
                                ⛽ <b>연료</b>: 정거장에서 연료를 보급하세요
                            </div>
                            <div style="padding:10px;background:rgba(168,85,247,0.1);border-radius:8px;">
                                👥 <b>멀티플레이</b>: 다른 플레이어와 실시간 탐험!
                            </div>
                        </div>
                        <p style="margin-top:15px;color:#00ff88;text-align:center;">즐거운 우주 탐험 되세요! 🚀</p>
                    `,
                    target: null,
                    position: 'center'
                }
            ];
        } else if (isJa) {
            return [
                {
                    id: 'welcome',
                    title: '🌌 STAR·WALKERへようこそ！',
                    content: `
                        <p>宇宙探検の世界へようこそ！</p>
                        <p>このガイドが基本的な操作方法と機能をご案内します。</p>
                        <div style="margin-top:15px;padding:10px;background:rgba(0,255,255,0.1);border-radius:8px;">
                            <p style="margin:0;color:#00ffff;">💡 ヒント: いつでも<b>ESC</b>キーでガイドをスキップできます。</p>
                        </div>
                    `,
                    target: null,
                    position: 'center'
                },
                {
                    id: 'nav-panel',
                    title: '🪐 天体リスト',
                    content: `
                        <p>左側で太陽系のすべての天体を確認できます。</p>
                        <ul style="margin:10px 0;padding-left:20px;">
                            <li><b>太陽</b> - 太陽系の中心</li>
                            <li><b>惑星</b> - 水星、金星、地球、火星など</li>
                            <li><b>ステーション</b> - 燃料補給と探検拠点</li>
                        </ul>
                        <p style="color:#00ff88;">クリックするとカメラがその天体に移動します。</p>
                    `,
                    target: '#nav-panel',
                    position: 'right'
                },
                {
                    id: 'top-bar',
                    title: '🎛️ 上部メニュー',
                    content: `
                        <div style="display:grid;gap:10px;">
                            <div><b style="color:#00ff88;">⛽ ステーション</b> - 宇宙ステーションリスト</div>
                            <div><b style="color:#a855f7;">📚 図鑑</b> - 発見した天体の情報</div>
                            <div><b style="color:#00ffff;">🖥️ 全画面</b> - 没入感のあるプレイ</div>
                            <div><b style="color:#ff9500;">⏱️ 0.1x</b> - 時間倍速表示</div>
                        </div>
                    `,
                    target: '#top-bar',
                    position: 'bottom'
                },
                {
                    id: 'login',
                    title: '👤 ログイン',
                    content: `
                        <p>右上の<b style="color:#00ff88;">ログイン</b>ボタンでアカウントを作成またはログインしてください。</p>
                        <p style="margin-top:10px;">ログインすると:</p>
                        <ul style="margin:10px 0;padding-left:20px;">
                            <li>他のプレイヤーと一緒に探検</li>
                            <li>進行状況の保存</li>
                            <li>宇宙船の所有とアップグレード</li>
                        </ul>
                    `,
                    target: '#btn-login',
                    position: 'left'
                },
                {
                    id: 'boarding',
                    title: '🚀 宇宙船に乗る',
                    content: `
                        <p>宇宙船は<b style="color:#00ffff;">宇宙ステーション</b>で搭乗できます。</p>
                        <div style="margin:15px 0;padding:12px;background:rgba(0,255,136,0.15);border:1px solid #00ff88;border-radius:8px;">
                            <p style="margin:0;color:#00ff88;"><b>🌍 最初の宇宙船を入手</b></p>
                            <p style="margin:8px 0 0 0;">地球近くの<b>ISS宇宙ステーション</b>に移動すると<br>最初の宇宙船がもらえます！</p>
                        </div>
                        <div style="margin-top:15px;padding:10px;background:rgba(0,255,255,0.1);border-radius:8px;">
                            <p style="margin:0;"><b>操縦方法:</b></p>
                            <p style="margin:5px 0 0 0;">• <b>W/S</b>または<b>↑/↓</b> - 加速/減速</p>
                            <p style="margin:5px 0 0 0;">• マウスドラッグ - 方向転換</p>
                            <p style="margin:5px 0 0 0;">• <b>自動航法</b> - 目的地まで自動飛行</p>
                        </div>
                    `,
                    target: null,
                    position: 'center'
                },
                {
                    id: 'complete',
                    title: '🎉 準備完了！',
                    content: `
                        <p>宇宙探検を始める準備ができました！</p>
                        <div style="margin-top:15px;display:grid;gap:8px;">
                            <div style="padding:10px;background:rgba(0,255,255,0.1);border-radius:8px;">
                                🎯 <b>ミッション</b>: 天体を訪問すると✓がつきます
                            </div>
                            <div style="padding:10px;background:rgba(255,149,0,0.1);border-radius:8px;">
                                ⛽ <b>燃料</b>: ステーションで燃料を補給
                            </div>
                            <div style="padding:10px;background:rgba(168,85,247,0.1);border-radius:8px;">
                                👥 <b>マルチプレイ</b>: 他のプレイヤーとリアルタイム探検！
                            </div>
                        </div>
                        <p style="margin-top:15px;color:#00ff88;text-align:center;">楽しい宇宙探検を！ 🚀</p>
                    `,
                    target: null,
                    position: 'center'
                }
            ];
        } else {
            // English (default)
            return [
                {
                    id: 'welcome',
                    title: '🌌 Welcome to STAR·WALKER!',
                    content: `
                        <p>Welcome to the world of space exploration!</p>
                        <p>This guide will walk you through the basic controls and features.</p>
                        <div style="margin-top:15px;padding:10px;background:rgba(0,255,255,0.1);border-radius:8px;">
                            <p style="margin:0;color:#00ffff;">💡 Tip: Press <b>ESC</b> anytime to skip this guide.</p>
                        </div>
                    `,
                    target: null,
                    position: 'center'
                },
                {
                    id: 'nav-panel',
                    title: '🪐 Celestial Bodies',
                    content: `
                        <p>View all celestial bodies in our solar system on the left panel.</p>
                        <ul style="margin:10px 0;padding-left:20px;">
                            <li><b>Sun</b> - Center of our solar system</li>
                            <li><b>Planets</b> - Mercury, Venus, Earth, Mars, etc.</li>
                            <li><b>Stations</b> - Refuel and exploration hubs</li>
                        </ul>
                        <p style="color:#00ff88;">Click to move the camera to that body.</p>
                    `,
                    target: '#nav-panel',
                    position: 'right'
                },
                {
                    id: 'top-bar',
                    title: '🎛️ Top Menu',
                    content: `
                        <div style="display:grid;gap:10px;">
                            <div><b style="color:#00ff88;">⛽ Station</b> - View space station list</div>
                            <div><b style="color:#a855f7;">📚 Catalog</b> - Check discovered bodies</div>
                            <div><b style="color:#00ffff;">🖥️ Fullscreen</b> - Immersive gameplay</div>
                            <div><b style="color:#ff9500;">⏱️ 0.1x</b> - Time speed display</div>
                        </div>
                    `,
                    target: '#top-bar',
                    position: 'bottom'
                },
                {
                    id: 'login',
                    title: '👤 Login',
                    content: `
                        <p>Click the <b style="color:#00ff88;">Login</b> button in the top right to create an account or sign in.</p>
                        <p style="margin-top:10px;">With login you can:</p>
                        <ul style="margin:10px 0;padding-left:20px;">
                            <li>Explore with other players</li>
                            <li>Save your progress</li>
                            <li>Own and upgrade ships</li>
                        </ul>
                        <p style="margin-top:10px;color:#00ffff;font-size:13px;">💡 Skip this step if already logged in!</p>
                    `,
                    target: '#btn-login',
                    position: 'left'
                },
                {
                    id: 'boarding',
                    title: '🚀 Board a Ship',
                    content: `
                        <p>Ships can be boarded at <b style="color:#00ffff;">Space Stations</b>.</p>
                        <div style="margin:15px 0;padding:12px;background:rgba(0,255,136,0.15);border:1px solid #00ff88;border-radius:8px;">
                            <p style="margin:0;color:#00ff88;"><b>🌍 Get Your First Ship</b></p>
                            <p style="margin:8px 0 0 0;">Travel to <b>ISS Space Station</b> near Earth<br>to receive your first ship!</p>
                        </div>
                        <div style="margin-top:15px;padding:10px;background:rgba(0,255,255,0.1);border-radius:8px;">
                            <p style="margin:0;"><b>Controls:</b></p>
                            <p style="margin:5px 0 0 0;">• <b>W/S</b> or <b>↑/↓</b> - Accelerate/Decelerate</p>
                            <p style="margin:5px 0 0 0;">• Mouse drag - Turn direction</p>
                            <p style="margin:5px 0 0 0;">• <b>Autopilot</b> - Auto-fly to destination</p>
                        </div>
                    `,
                    target: null,
                    position: 'center'
                },
                {
                    id: 'complete',
                    title: '🎉 Ready to Go!',
                    content: `
                        <p>You're all set to begin your space adventure!</p>
                        <div style="margin-top:15px;display:grid;gap:8px;">
                            <div style="padding:10px;background:rgba(0,255,255,0.1);border-radius:8px;">
                                🎯 <b>Missions</b>: Visit bodies to mark them ✓
                            </div>
                            <div style="padding:10px;background:rgba(255,149,0,0.1);border-radius:8px;">
                                ⛽ <b>Fuel</b>: Refuel at stations
                            </div>
                            <div style="padding:10px;background:rgba(168,85,247,0.1);border-radius:8px;">
                                👥 <b>Multiplayer</b>: Real-time exploration with others!
                            </div>
                        </div>
                        <p style="margin-top:15px;color:#00ff88;text-align:center;">Enjoy your space journey! 🚀</p>
                    `,
                    target: null,
                    position: 'center'
                }
            ];
        }
    },
    
    // 다국어 버튼 텍스트
    getButtonText() {
        const lang = this.getLang();
        const isKo = lang === 'ko';
        const isJa = lang === 'ja';
        return {
            skip: isKo ? '건너뛰기' : isJa ? 'スキップ' : 'Skip',
            next: isKo ? '다음' : isJa ? '次へ' : 'Next',
            start: isKo ? '시작하기' : isJa ? '始める' : 'Start'
        };
    },
    
    // 기능별 가이드 (첫 사용 시)
    getFeatureGuides() {
        const lang = this.getLang();
        const isKo = lang === 'ko';
        const isJa = lang === 'ja';
        
        if (isKo) {
            return {
                'station-modal': { title: '⛽ 우주 정거장', content: '여기서 연료 정거장 목록을 확인하고 빠르게 이동할 수 있습니다.', shown: false },
                'catalog-modal': { title: '📚 천체 도감', content: '발견한 천체들의 정보를 확인할 수 있습니다. 모든 천체를 방문해보세요!', shown: false },
                'ship-select': { title: '🚀 우주선 선택', content: '다양한 우주선 중 원하는 것을 선택하세요. 각 우주선마다 특성이 다릅니다.', shown: false },
                'pilot-mode': { title: '🎮 조종 모드', content: 'W/S로 가속/감속, 마우스로 방향 전환! 자동항법으로 편하게 이동할 수도 있습니다.', shown: false },
                'autopilot': { title: '🤖 자동항법', content: '목적지를 선택하면 자동으로 비행합니다. 도착하면 자동 정지!', shown: false }
            };
        } else if (isJa) {
            return {
                'station-modal': { title: '⛽ 宇宙ステーション', content: 'ここで燃料ステーションリストを確認し、素早く移動できます。', shown: false },
                'catalog-modal': { title: '📚 天体図鑑', content: '発見した天体の情報を確認できます。すべての天体を訪問してみてください！', shown: false },
                'ship-select': { title: '🚀 宇宙船選択', content: '様々な宇宙船から選んでください。それぞれ特性が異なります。', shown: false },
                'pilot-mode': { title: '🎮 操縦モード', content: 'W/Sで加速/減速、マウスで方向転換！自動航法で楽に移動もできます。', shown: false },
                'autopilot': { title: '🤖 自動航法', content: '目的地を選ぶと自動で飛行します。到着すると自動停止！', shown: false }
            };
        } else {
            return {
                'station-modal': { title: '⛽ Space Station', content: 'View fuel station list and quickly travel here.', shown: false },
                'catalog-modal': { title: '📚 Celestial Catalog', content: 'Check info on discovered bodies. Visit them all!', shown: false },
                'ship-select': { title: '🚀 Ship Selection', content: 'Choose from various ships. Each has unique characteristics.', shown: false },
                'pilot-mode': { title: '🎮 Pilot Mode', content: 'W/S to accelerate/decelerate, mouse to turn! Autopilot available too.', shown: false },
                'autopilot': { title: '🤖 Autopilot', content: 'Select a destination and fly automatically. Auto-stop on arrival!', shown: false }
            };
        }
    },
    
    featureGuidesShown: {},
    
    // 저장된 상태 불러오기
    loadState() {
        try {
            const saved = localStorage.getItem(this.STORAGE_KEY);
            if (saved) {
                const state = JSON.parse(saved);
                this.featureGuidesShown = state.featureGuidesShown || {};
                return state.completed;
            }
        } catch (e) {}
        return false;
    },
    
    // 상태 저장
    saveState(completed = false) {
        try {
            localStorage.setItem(this.STORAGE_KEY, JSON.stringify({
                completed,
                featureGuidesShown: this.featureGuidesShown,
                timestamp: Date.now()
            }));
        } catch (e) {}
    },
    
    // 튜토리얼 시작 체크
    checkAndStart() {
        if (!this.loadState()) {
            this.start();
        }
    },
    
    // 튜토리얼 시작
    start() {
        this.currentStep = 0;
        document.body.classList.add('tutorial-active');
        this.createOverlay();
        this.showStep(0);
        
        // ESC 키로 건너뛰기
        document.addEventListener('keydown', this.handleKeydown.bind(this));
    },
    
    handleKeydown(e) {
        if (e.key === 'Escape') {
            this.complete();
        }
    },
    
    // 오버레이 생성
    createOverlay() {
        if (this.overlay) return;
        
        this.overlay = document.createElement('div');
        this.overlay.id = 'tutorial-overlay';
        this.overlay.innerHTML = `
            <style>
                #tutorial-overlay {
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.6);
                    z-index: 99990;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }
                /* 튜토리얼 중 UI 요소들 위로 올리기 */
                body.tutorial-active #top-bar,
                body.tutorial-active #nav-container,
                body.tutorial-active #btn-login,
                body.tutorial-active .login-status {
                    position: relative;
                    z-index: 99995 !important;
                }
                #tutorial-box {
                    background: linear-gradient(135deg, rgba(10, 15, 25, 0.98) 0%, rgba(15, 20, 35, 0.95) 100%);
                    border: 2px solid #00ffff;
                    border-radius: 0;
                    clip-path: polygon(20px 0, 100% 0, 100% calc(100% - 20px), calc(100% - 20px) 100%, 0 100%, 0 20px);
                    padding: 30px;
                    max-width: 450px;
                    width: 90%;
                    color: #fff;
                    font-family: 'Rajdhani', sans-serif;
                    box-shadow: 0 0 50px rgba(0, 255, 255, 0.3), inset 0 0 30px rgba(0, 255, 255, 0.05);
                    position: relative;
                    z-index: 100001;
                }
                #tutorial-box::before {
                    content: '';
                    position: absolute;
                    top: 0;
                    left: 0;
                    right: 0;
                    height: 3px;
                    background: linear-gradient(90deg, transparent, #00ffff, transparent);
                }
                #tutorial-step {
                    position: absolute;
                    top: 10px;
                    right: 15px;
                    font-family: 'Orbitron', sans-serif;
                    font-size: 11px;
                    color: #00ffff;
                    opacity: 0.7;
                }
                #tutorial-title {
                    font-family: 'Orbitron', sans-serif;
                    font-size: 20px;
                    font-weight: 700;
                    color: #00ffff;
                    margin-bottom: 20px;
                    text-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
                }
                #tutorial-content {
                    font-size: 15px;
                    line-height: 1.7;
                    color: #c8d6e5;
                }
                #tutorial-content p { margin: 10px 0; }
                #tutorial-content ul { margin: 10px 0; }
                #tutorial-content li { margin: 5px 0; }
                #tutorial-content b { color: #fff; }
                #tutorial-buttons {
                    display: flex;
                    justify-content: space-between;
                    margin-top: 25px;
                    gap: 15px;
                }
                .tutorial-btn {
                    flex: 1;
                    padding: 12px 20px;
                    border: 1px solid;
                    background: transparent;
                    font-family: 'Orbitron', sans-serif;
                    font-size: 12px;
                    font-weight: 600;
                    text-transform: uppercase;
                    letter-spacing: 1px;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    clip-path: polygon(8px 0, 100% 0, 100% calc(100% - 8px), calc(100% - 8px) 100%, 0 100%, 0 8px);
                }
                .tutorial-btn.skip {
                    border-color: #6b7c93;
                    color: #6b7c93;
                }
                .tutorial-btn.skip:hover {
                    background: rgba(107, 124, 147, 0.2);
                    color: #fff;
                }
                .tutorial-btn.next {
                    border-color: #00ffff;
                    color: #00ffff;
                    background: linear-gradient(135deg, rgba(0, 255, 255, 0.1) 0%, rgba(0, 255, 255, 0.02) 100%);
                }
                .tutorial-btn.next:hover {
                    background: linear-gradient(135deg, rgba(0, 255, 255, 0.3) 0%, rgba(0, 255, 255, 0.1) 100%);
                    box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
                }
                .tutorial-btn.complete {
                    border-color: #00ff88;
                    color: #00ff88;
                    background: linear-gradient(135deg, rgba(0, 255, 136, 0.1) 0%, rgba(0, 255, 136, 0.02) 100%);
                }
                .tutorial-btn.complete:hover {
                    background: linear-gradient(135deg, rgba(0, 255, 136, 0.3) 0%, rgba(0, 255, 136, 0.1) 100%);
                    box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
                }
                #tutorial-highlight {
                    position: fixed;
                    border: 3px solid #00ffff;
                    border-radius: 8px;
                    box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
                    pointer-events: none;
                    z-index: 99999;
                    animation: tutorialPulse 2s infinite;
                    display: none;
                }
                @keyframes tutorialPulse {
                    0%, 100% { box-shadow: 0 0 20px rgba(0, 255, 255, 0.5); }
                    50% { box-shadow: 0 0 40px rgba(0, 255, 255, 0.8); }
                }
                #tutorial-progress {
                    display: flex;
                    justify-content: center;
                    gap: 8px;
                    margin-top: 20px;
                }
                .progress-dot {
                    width: 10px;
                    height: 10px;
                    border-radius: 50%;
                    background: rgba(0, 255, 255, 0.2);
                    border: 1px solid rgba(0, 255, 255, 0.5);
                    transition: all 0.3s ease;
                }
                .progress-dot.active {
                    background: #00ffff;
                    box-shadow: 0 0 10px #00ffff;
                }
                .progress-dot.completed {
                    background: #00ff88;
                    border-color: #00ff88;
                }
            </style>
            <div id="tutorial-highlight"></div>
            <div id="tutorial-box">
                <div id="tutorial-step"></div>
                <div id="tutorial-title"></div>
                <div id="tutorial-content"></div>
                <div id="tutorial-buttons">
                    <button class="tutorial-btn skip" id="tutorial-skip-btn">${this.getButtonText().skip}</button>
                    <button class="tutorial-btn next" id="tutorial-next-btn">${this.getButtonText().next}</button>
                </div>
                <div id="tutorial-progress"></div>
            </div>
        `;
        document.body.appendChild(this.overlay);
        
        // 이벤트 리스너 추가
        document.getElementById('tutorial-skip-btn').onclick = () => this.complete();
        document.getElementById('tutorial-next-btn').onclick = () => this.nextStep();
    },
    
    // 단계 표시
    showStep(index) {
        const steps = this.getSteps();
        if (index >= steps.length) {
            this.complete();
            return;
        }
        
        const step = steps[index];
        this.currentStep = index;
        
        // ★ 이전 하이라이트 대상 스타일 복원
        if (this.highlightedElement) {
            this.highlightedElement.style.position = this.savedPosition || '';
            this.highlightedElement.style.zIndex = this.savedZIndex || '';
            this.highlightedElement = null;
        }
        
        document.getElementById('tutorial-step').textContent = `${index + 1} / ${steps.length}`;
        document.getElementById('tutorial-title').textContent = step.title;
        document.getElementById('tutorial-content').innerHTML = step.content;
        
        // 버튼 업데이트
        const nextBtn = document.getElementById('tutorial-next-btn');
        const btnText = this.getButtonText();
        if (index === steps.length - 1) {
            nextBtn.textContent = btnText.start;
            nextBtn.className = 'tutorial-btn complete';
            nextBtn.onclick = () => this.complete();
        } else {
            nextBtn.textContent = btnText.next;
            nextBtn.className = 'tutorial-btn next';
            nextBtn.onclick = () => this.nextStep();
        }
        
        // 진행 표시 업데이트
        let progressHtml = '';
        for (let i = 0; i < steps.length; i++) {
            const cls = i < index ? 'completed' : (i === index ? 'active' : '');
            progressHtml += `<div class="progress-dot ${cls}"></div>`;
        }
        document.getElementById('tutorial-progress').innerHTML = progressHtml;
        
        // 하이라이트
        const highlight = document.getElementById('tutorial-highlight');
        if (step.target) {
            const target = document.querySelector(step.target);
            if (target) {
                const rect = target.getBoundingClientRect();
                highlight.style.display = 'block';
                highlight.style.left = (rect.left - 5) + 'px';
                highlight.style.top = (rect.top - 5) + 'px';
                highlight.style.width = (rect.width + 10) + 'px';
                highlight.style.height = (rect.height + 10) + 'px';
                
                // ★ 하이라이트 대상을 오버레이 위로 올리기
                this.savedPosition = target.style.position;
                this.savedZIndex = target.style.zIndex;
                target.style.position = 'relative';
                target.style.zIndex = '100001';
                this.highlightedElement = target;
            }
        } else {
            highlight.style.display = 'none';
        }
    },
    
    // 다음 단계
    nextStep() {
        this.showStep(this.currentStep + 1);
    },
    
    // 완료
    complete() {
        this.saveState(true);
        document.removeEventListener('keydown', this.handleKeydown);
        document.body.classList.remove('tutorial-active');  // ★ UI 스타일 복원
        
        // ★ 하이라이트 대상 스타일 복원
        if (this.highlightedElement) {
            this.highlightedElement.style.position = this.savedPosition || '';
            this.highlightedElement.style.zIndex = this.savedZIndex || '';
            this.highlightedElement = null;
        }
        
        if (this.overlay) {
            this.overlay.style.opacity = '0';
            this.overlay.style.transition = 'opacity 0.3s';
            setTimeout(() => {
                this.overlay.remove();
                this.overlay = null;
            }, 300);
        }
    },
    
    // 기능 가이드 표시 (첫 사용 시)
    showFeatureGuide(featureId) {
        // 이미 표시한 가이드인지 확인
        if (this.featureGuidesShown[featureId]) return;
        
        const guides = this.getFeatureGuides();
        const guide = guides[featureId];
        if (!guide) return;
        
        this.featureGuidesShown[featureId] = true;
        this.saveState();
        
        const lang = this.getLang();
        const isKo = lang === 'ko';
        const isJa = lang === 'ja';
        const okText = isKo ? '확인' : isJa ? 'OK' : 'OK';
        
        // 작은 팝업 표시
        const popup = document.createElement('div');
        popup.className = 'feature-guide-popup';
        popup.innerHTML = `
            <style>
                .feature-guide-popup {
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: linear-gradient(135deg, rgba(10, 15, 25, 0.98) 0%, rgba(15, 20, 35, 0.95) 100%);
                    border: 2px solid #00ffff;
                    padding: 25px 30px;
                    z-index: 100001;
                    font-family: 'Rajdhani', sans-serif;
                    max-width: 350px;
                    clip-path: polygon(15px 0, 100% 0, 100% calc(100% - 15px), calc(100% - 15px) 100%, 0 100%, 0 15px);
                    box-shadow: 0 0 40px rgba(0, 255, 255, 0.4);
                    animation: featurePopIn 0.3s ease;
                }
                @keyframes featurePopIn {
                    from { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
                    to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
                }
                .feature-guide-popup h3 {
                    font-family: 'Orbitron', sans-serif;
                    color: #00ffff;
                    margin: 0 0 15px 0;
                    font-size: 16px;
                }
                .feature-guide-popup p {
                    color: #c8d6e5;
                    margin: 0;
                    line-height: 1.6;
                }
                .feature-guide-popup button {
                    margin-top: 15px;
                    width: 100%;
                    padding: 10px;
                    background: linear-gradient(135deg, rgba(0, 255, 255, 0.2) 0%, rgba(0, 255, 255, 0.05) 100%);
                    border: 1px solid #00ffff;
                    color: #00ffff;
                    font-family: 'Orbitron', sans-serif;
                    font-size: 11px;
                    cursor: pointer;
                    transition: all 0.3s;
                }
                .feature-guide-popup button:hover {
                    background: rgba(0, 255, 255, 0.3);
                }
            </style>
            <h3>${guide.title}</h3>
            <p>${guide.content}</p>
            <button onclick="this.parentElement.remove()">${okText}</button>
        `;
        document.body.appendChild(popup);
        
        // 5초 후 자동 닫기
        setTimeout(() => {
            if (popup.parentElement) {
                popup.style.opacity = '0';
                popup.style.transition = 'opacity 0.3s';
                setTimeout(() => popup.remove(), 300);
            }
        }, 5000);
    },
    
    // 튜토리얼 리셋 (디버그용)
    reset() {
        localStorage.removeItem(this.STORAGE_KEY);
        console.log('Tutorial reset');
    }
};

// 전역 노출
window.MultiTutorial = MultiTutorial;
</script>

<!-- Service Worker 등록 (PWA) -->
<script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('sw.js')
      .then(reg => console.log('✅ Service Worker 등록 성공:', reg.scope))
      .catch(err => console.log('❌ Service Worker 등록 실패:', err));
  });
}

// PWA 설치 프롬프트
let deferredPrompt;
window.addEventListener('beforeinstallprompt', (e) => {
  e.preventDefault();
  deferredPrompt = e;
  console.log('📱 PWA 설치 가능');
});
</script>

</body>
</html>
