<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Spherical Floating Cockpit - Final Yoke</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; touch-action: none; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #instruction {
            position: absolute;
            top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: rgba(0, 255, 255, 0.5); font-family: 'Segoe UI', sans-serif;
            pointer-events: none; opacity: 1; transition: opacity 1s; letter-spacing: 2px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="instruction">DRAG TO LOOK AROUND<br>Detailed Yoke System</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- 1. 씬 설정 ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x010103);
        scene.fog = new THREE.FogExp2(0x010103, 0.01);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 100);
        camera.position.set(0, 0, 0); 
        camera.rotation.order = 'YXZ'; 

        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.physicallyCorrectLights = true; 
        document.body.appendChild(renderer.domElement);

        // --- 2. 컨트롤 ---
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let targetRotY = 0; let targetRotX = 0; 
        let currentRotY = 0; let currentRotX = 0;
        const LOOK_SPEED = 0.0025; const DAMPING = 0.08; 

        function handleInputStart(x, y) {
            isDragging = true; previousMousePosition = { x, y };
            const inst = document.getElementById('instruction'); if(inst) inst.style.opacity = 0;
        }
        function handleInputMove(x, y) {
            if (isDragging) {
                const deltaX = x - previousMousePosition.x;
                const deltaY = y - previousMousePosition.y;
                targetRotY -= deltaX * LOOK_SPEED;
                targetRotX -= deltaY * LOOK_SPEED;
                targetRotY = Math.max(-Math.PI / 1.5, Math.min(Math.PI / 1.5, targetRotY));
                targetRotX = Math.max(-Math.PI / 2.5, Math.min(Math.PI / 2.5, targetRotX));
                previousMousePosition = { x, y };
            }
        }
        document.addEventListener('mousedown', e => handleInputStart(e.clientX, e.clientY));
        document.addEventListener('mouseup', () => isDragging = false);
        document.addEventListener('mousemove', e => handleInputMove(e.clientX, e.clientY));
        document.addEventListener('touchstart', e => handleInputStart(e.touches[0].clientX, e.touches[0].clientY), {passive: false});
        document.addEventListener('touchend', () => isDragging = false);
        document.addEventListener('touchmove', e => { e.preventDefault(); handleInputMove(e.touches[0].clientX, e.touches[0].clientY); }, {passive: false});


        // --- 3. 텍스처 & 재질 ---
        function createHexTexture() {
            const c = document.createElement('canvas'); c.width=512; c.height=512;
            const ctx = c.getContext('2d');
            ctx.fillStyle = '#050505'; ctx.fillRect(0,0,512,512);
            ctx.strokeStyle = '#333'; ctx.lineWidth = 3; 
            for(let y=0; y<512; y+=40) {
                for(let x=0; x<512; x+=35) {
                    if((Math.floor(y/40))%2==0) ctx.strokeRect(x,y,30,30);
                    else ctx.strokeRect(x+17,y,30,30);
                }
            }
            const t = new THREE.CanvasTexture(c);
            t.wrapS = t.wrapT = THREE.RepeatWrapping; t.repeat.set(6,4);
            return t;
        }
        const hexTex = createHexTexture();

        const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(256, {
            format: THREE.RGBFormat, generateMipmaps: true, minFilter: THREE.LinearMipmapLinearFilter
        });
        const cubeCamera = new THREE.CubeCamera(0.1, 100, cubeRenderTarget);
        scene.add(cubeCamera);

        const mats = {
            hullInterior: new THREE.MeshStandardMaterial({ 
                map: hexTex, color: 0x444444, roughness: 0.5, metalness: 0.7, side: THREE.BackSide 
            }),
            glass: new THREE.MeshPhysicalMaterial({ 
                color: 0x88ccff, metalness: 0.1, roughness: 0.0, 
                transmission: 0.95, transparent: true, opacity: 0.1, side: THREE.DoubleSide,
                envMap: cubeRenderTarget.texture, envMapIntensity: 1.0 
            }),
            frame: new THREE.MeshStandardMaterial({ 
                color: 0x222222, roughness: 0.2, metalness: 0.9, 
                envMap: cubeRenderTarget.texture, envMapIntensity: 1.5 
            }),
            seat: new THREE.MeshStandardMaterial({ 
                color: 0x333333, roughness: 0.4, metalness: 0.6,
                envMap: cubeRenderTarget.texture, envMapIntensity: 0.8
            }),
            glowBlue: new THREE.MeshBasicMaterial({ color: 0x00ffff }),
            glowOrange: new THREE.MeshBasicMaterial({ color: 0xffaa00 }),
            hologram: new THREE.MeshBasicMaterial({ 
                color: 0x00ffff, transparent: true, opacity: 0.3, 
                side: THREE.DoubleSide, blending: THREE.AdditiveBlending, depthWrite: false 
            })
        };

        const world = new THREE.Group();
        scene.add(world);

        const sun = new THREE.DirectionalLight(0xffffff, 3.0);
        sun.position.set(5, 5, -5); scene.add(sun);
        const innerLight = new THREE.PointLight(0x00aaff, 1.0, 10);
        innerLight.position.set(0, 1, 0); scene.add(innerLight);
        const ambient = new THREE.AmbientLight(0xffffff, 0.2); scene.add(ambient);


        // --- 4. 구형 쉘 ---
        const rearGeo = new THREE.SphereGeometry(4, 64, 64, 0, Math.PI * 2, 0, Math.PI * 0.55);
        const rearShell = new THREE.Mesh(rearGeo, mats.hullInterior);
        rearShell.rotation.x = Math.PI / 2; 
        world.add(rearShell);

        const ringGeo = new THREE.TorusGeometry(3.8, 0.1, 16, 64);
        const ring = new THREE.Mesh(ringGeo, mats.frame);
        ring.position.z = 0.5; 
        world.add(ring);

        const glassGeo = new THREE.SphereGeometry(3.9, 64, 64, 0, Math.PI * 2, 0, Math.PI * 0.48);
        const glassShell = new THREE.Mesh(glassGeo, mats.glass);
        glassShell.rotation.x = -Math.PI / 2; 
        world.add(glassShell);

        const borderGeo = new THREE.TorusGeometry(3.9, 0.15, 16, 100);
        const border = new THREE.Mesh(borderGeo, mats.frame);
        world.add(border);


        // --- 5. 플로팅 플랫폼 ---
        const floatGroup = new THREE.Group();
        world.add(floatGroup);

        const baseGeo = new THREE.CylinderGeometry(0.6, 0.4, 0.2, 32);
        const base = new THREE.Mesh(baseGeo, mats.frame);
        base.position.set(0, -0.8, 0);
        floatGroup.add(base);

        const emitter = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.05, 0.3, 16), new THREE.MeshBasicMaterial({color: 0x00ffff, transparent:true, opacity:0.5}));
        emitter.position.set(0, -1.0, 0);
        floatGroup.add(emitter);

        const seatGroup = new THREE.Group();
        seatGroup.position.set(0, -0.6, 0.2);
        floatGroup.add(seatGroup);
        seatGroup.add(new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.15, 0.6), mats.seat));
        const back = new THREE.Mesh(new THREE.BoxGeometry(0.55, 0.8, 0.1), mats.seat);
        back.position.set(0, 0.4, 0.25); back.rotation.x = -0.15;
        seatGroup.add(back);
        const head = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.25, 0.1), mats.seat);
        head.position.set(0, 0.9, 0.35); 
        seatGroup.add(head);
        const armL = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.05, 0.4), mats.seat);
        armL.position.set(-0.45, 0.3, 0); seatGroup.add(armL);
        const armR = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.05, 0.4), mats.seat);
        armR.position.set(0.45, 0.3, 0); seatGroup.add(armR);

        // --- [NEW] 고해상도 대칭형 조종간 (Detailed Symmetrical Yoke) ---
        const yokeGroup = new THREE.Group();
        yokeGroup.position.set(0, -0.4, -0.55); // 위치: 다리 사이, 조금 앞쪽
        
        // 1. 메인 컬럼 (기둥) - 운전자 쪽으로 기울어짐
        const colGeo = new THREE.CylinderGeometry(0.04, 0.05, 0.4, 16);
        const column = new THREE.Mesh(colGeo, mats.frame);
        column.position.y = -0.15;
        column.rotation.x = -0.3; 
        yokeGroup.add(column);

        // 2. 중앙 허브 (Hub)
        const hubGeo = new THREE.BoxGeometry(0.12, 0.08, 0.08);
        const hub = new THREE.Mesh(hubGeo, mats.frame);
        hub.rotation.x = -0.3;
        yokeGroup.add(hub);

        // 중앙 미니 스크린 (데이터 표시)
        const hubScreen = new THREE.Mesh(new THREE.PlaneGeometry(0.1, 0.06), mats.hologram);
        hubScreen.position.set(0, 0.01, 0.045);
        hubScreen.rotation.x = -0.3;
        yokeGroup.add(hubScreen);

        // 3. 핸들 생성 함수 (대칭형)
        function createYokeHandle(side) { // side: 1(Right), -1(Left)
            const handleGrp = new THREE.Group();
            handleGrp.position.set(side * 0.22, 0, 0);
            handleGrp.rotation.x = -0.3; // 허브와 각도 일치

            // 가로바 (Wing)
            const bar = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.025, 0.15, 8), mats.frame);
            bar.rotation.z = Math.PI / 2;
            bar.position.set(-side * 0.075, 0, 0);
            handleGrp.add(bar);

            // 그립 (Grip) - 인체공학적 곡선
            const grip = new THREE.Mesh(new THREE.CylinderGeometry(0.035, 0.03, 0.18, 12), mats.seat);
            grip.rotation.z = side * 0.15; // 손 모양에 맞춰 휨
            handleGrp.add(grip);

            // 상단 헤드 (Thumb Rest)
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.06, 0.06), mats.frame);
            head.position.set(side * 0.01, 0.1, 0.01);
            head.rotation.z = side * 0.15;
            handleGrp.add(head);

            // 엄지 버튼 (Red)
            const btn1 = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.012, 0.01, 8), mats.glowOrange);
            btn1.position.set(side * 0.01, 0.135, 0.02);
            btn1.rotation.x = 0.5;
            handleGrp.add(btn1);

            // 보조 버튼 (Blue)
            const btn2 = new THREE.Mesh(new THREE.BoxGeometry(0.01, 0.02, 0.01), mats.glowBlue);
            btn2.position.set(-side * 0.02, 0.11, 0.02);
            handleGrp.add(btn2);

            // 전면 트리거 (Trigger)
            const trigger = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.05, 0.02), mats.glowOrange);
            trigger.position.set(side * 0.01, 0.02, -0.035);
            trigger.rotation.x = 0.2;
            handleGrp.add(trigger);

            return handleGrp;
        }

        const leftHandle = createYokeHandle(-1);
        const rightHandle = createYokeHandle(1);
        yokeGroup.add(leftHandle);
        yokeGroup.add(rightHandle);

        floatGroup.add(yokeGroup);


        // --- 6. 홀로그램 인터페이스 ---
        function createCurvedHUD(w, h, r, y) {
            const geometry = new THREE.CylinderGeometry(r, r, h, 32, 1, true, Math.PI * 1.2, Math.PI * 0.6); 
            geometry.scale(-1, 1, 1);
            const canvas = document.createElement('canvas'); canvas.width=512; canvas.height=256;
            const ctx = canvas.getContext('2d');
            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.MeshBasicMaterial({ 
                map: tex, transparent: true, opacity: 0.6, 
                side: THREE.DoubleSide, blending: THREE.AdditiveBlending, depthWrite: false
            });
            const mesh = new THREE.Mesh(geometry, mat);
            mesh.position.y = y;
            mesh.rotation.y = Math.PI / 2;
            return { ctx, tex, mesh };
        }

        const mainHUD = createCurvedHUD(2, 0.8, 1.5, 0);
        floatGroup.add(mainHUD.mesh);

        const subHUD = createCurvedHUD(1, 0.4, 0.8, -0.4);
        subHUD.mesh.rotation.x = -0.3; 
        floatGroup.add(subHUD.mesh);


        // --- 7. 배경 ---
        const starGeo = new THREE.BufferGeometry();
        const starPos = []; 
        for(let i=0; i<4000; i++) starPos.push((Math.random()-0.5)*300, (Math.random()-0.5)*300, (Math.random()-0.5)*300);
        starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
        const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({color: 0xffffff, size: 0.2}));
        scene.add(stars);

        cubeCamera.update(renderer, scene);

        // --- 8. 애니메이션 ---
        const clock = new THREE.Clock();

        function drawMainHUD(hud, t) {
            const ctx = hud.ctx;
            ctx.clearRect(0,0,512,256);
            ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 2;
            
            ctx.beginPath(); ctx.arc(256, 128, 40, 0, Math.PI*2); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(216, 128); ctx.lineTo(180, 128); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(296, 128); ctx.lineTo(332, 128); ctx.stroke();
            
            ctx.fillStyle = 'rgba(0, 255, 255, 0.5)'; ctx.font = '20px Arial';
            ctx.fillText("ALT: " + (12000 + Math.floor(Math.sin(t)*500)), 100, 130);
            ctx.fillText("SPD: " + (4500 + Math.floor(Math.cos(t)*100)), 350, 130);
            
            const pitch = Math.sin(t*0.5) * 50;
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
            ctx.beginPath(); ctx.moveTo(100, 128+pitch); ctx.lineTo(412, 128+pitch); ctx.stroke();
            hud.tex.needsUpdate = true;
        }

        function drawSubHUD(hud, t) {
            const ctx = hud.ctx;
            ctx.clearRect(0,0,512,256);
            ctx.strokeStyle = '#ffaa00'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(256, 128, 80, 0, Math.PI*2); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(256, 128); 
            ctx.lineTo(256 + Math.cos(t*3)*80, 128 + Math.sin(t*3)*80); ctx.stroke();
            ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
            ctx.beginPath(); ctx.arc(256 + Math.cos(t)*40, 128 + Math.sin(t)*40, 5, 0, Math.PI*2); ctx.fill();
            hud.tex.needsUpdate = true;
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            currentRotY += (targetRotY - currentRotY) * DAMPING; 
            currentRotX += (targetRotX - currentRotX) * DAMPING;
            camera.rotation.y = currentRotY; camera.rotation.x = currentRotX;

            floatGroup.position.y = Math.sin(time * 0.5) * 0.05;
            floatGroup.rotation.z = Math.sin(time * 0.2) * 0.02;

            yokeGroup.rotation.x = Math.sin(time * 10) * 0.002;

            drawMainHUD(mainHUD, time);
            drawSubHUD(subHUD, time);

            renderer.render(scene, camera);
        }
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
        animate();
    </script>
</body>
</html>